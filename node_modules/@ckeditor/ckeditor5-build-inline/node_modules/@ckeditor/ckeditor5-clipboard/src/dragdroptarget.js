/**
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
/**
 * @module clipboard/dragdroptarget
 */
import { Plugin } from '@ckeditor/ckeditor5-core';
import { global, Rect, DomEmitterMixin, delay, ResizeObserver } from '@ckeditor/ckeditor5-utils';
import LineView from './lineview.js';
import { throttle } from 'lodash-es';
/**
 * Part of the Drag and Drop handling. Responsible for finding and displaying the drop target.
 *
 * @internal
 */
export default class DragDropTarget extends Plugin {
    constructor() {
        super(...arguments);
        /**
         * A delayed callback removing the drop marker.
         *
         * @internal
         */
        this.removeDropMarkerDelayed = delay(() => this.removeDropMarker(), 40);
        /**
         * A throttled callback updating the drop marker.
         */
        this._updateDropMarkerThrottled = throttle(targetRange => this._updateDropMarker(targetRange), 40);
        /**
         * A throttled callback reconverting the drop parker.
         */
        this._reconvertMarkerThrottled = throttle(() => {
            if (this.editor.model.markers.has('drop-target')) {
                this.editor.editing.reconvertMarker('drop-target');
            }
        }, 0);
        /**
         * The horizontal drop target line view.
         */
        this._dropTargetLineView = new LineView();
        /**
         * DOM Emitter.
         */
        this._domEmitter = new (DomEmitterMixin())();
        /**
         * Map of document scrollable elements.
         */
        this._scrollables = new Map();
    }
    /**
     * @inheritDoc
     */
    static get pluginName() {
        return 'DragDropTarget';
    }
    /**
     * @inheritDoc
     */
    init() {
        this._setupDropMarker();
    }
    /**
     * @inheritDoc
     */
    destroy() {
        this._domEmitter.stopListening();
        for (const { resizeObserver } of this._scrollables.values()) {
            resizeObserver.destroy();
        }
        this._updateDropMarkerThrottled.cancel();
        this.removeDropMarkerDelayed.cancel();
        this._reconvertMarkerThrottled.cancel();
        return super.destroy();
    }
    /**
     * Finds the drop target range and updates the drop marker.
     *
     * @internal
     */
    updateDropMarker(targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange) {
        this.removeDropMarkerDelayed.cancel();
        const targetRange = findDropTargetRange(this.editor, targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange);
        /* istanbul ignore next -- @preserve */
        if (!targetRange) {
            return;
        }
        if (draggedRange && draggedRange.containsRange(targetRange)) {
            // Target range is inside the dragged range.
            return this.removeDropMarker();
        }
        this._updateDropMarkerThrottled(targetRange);
    }
    /**
     * Finds the final drop target range.
     *
     * @internal
     */
    getFinalDropRange(targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange) {
        const targetRange = findDropTargetRange(this.editor, targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange);
        // The dragging markers must be removed after searching for the target range because sometimes
        // the target lands on the marker itself.
        this.removeDropMarker();
        return targetRange;
    }
    /**
     * Removes the drop target marker.
     *
     * @internal
     */
    removeDropMarker() {
        const model = this.editor.model;
        this.removeDropMarkerDelayed.cancel();
        this._updateDropMarkerThrottled.cancel();
        this._dropTargetLineView.isVisible = false;
        if (model.markers.has('drop-target')) {
            model.change(writer => {
                writer.removeMarker('drop-target');
            });
        }
    }
    /**
     * Creates downcast conversion for the drop target marker.
     */
    _setupDropMarker() {
        const editor = this.editor;
        editor.ui.view.body.add(this._dropTargetLineView);
        // Drop marker conversion for hovering over widgets.
        editor.conversion.for('editingDowncast').markerToHighlight({
            model: 'drop-target',
            view: {
                classes: ['ck-clipboard-drop-target-range']
            }
        });
        // Drop marker conversion for in text and block drop target.
        editor.conversion.for('editingDowncast').markerToElement({
            model: 'drop-target',
            view: (data, { writer }) => {
                // Inline drop.
                if (editor.model.schema.checkChild(data.markerRange.start, '$text')) {
                    this._dropTargetLineView.isVisible = false;
                    return this._createDropTargetPosition(writer);
                }
                // Block drop.
                else {
                    if (data.markerRange.isCollapsed) {
                        this._updateDropTargetLine(data.markerRange);
                    }
                    else {
                        this._dropTargetLineView.isVisible = false;
                    }
                }
            }
        });
    }
    /**
     * Updates the drop target marker to the provided range.
     *
     * @param targetRange The range to set the marker to.
     */
    _updateDropMarker(targetRange) {
        const editor = this.editor;
        const markers = editor.model.markers;
        edit