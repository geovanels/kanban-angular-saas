/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
import { Command, Plugin } from '@ckeditor/ckeditor5-core/dist/index.js';
import { Delete } from '@ckeditor/ckeditor5-typing/dist/index.js';
import { Enter } from '@ckeditor/ckeditor5-enter/dist/index.js';
import { toArray, first, uid, env, CKEditorError, FocusTracker, KeystrokeHandler, global, getCode, parseKeystroke, getLocalizedArrowKeyCodeDirection, createElement } from '@ckeditor/ckeditor5-utils/dist/index.js';
import { _normalizeFontSizeOptions } from '@ckeditor/ckeditor5-font/dist/index.js';
import { ClipboardPipeline } from '@ckeditor/ckeditor5-clipboard/dist/index.js';
import { ButtonView, MenuBarMenuListItemButtonView, View, ViewCollection, FocusCycler, addKeyboardHandlingForGrid, CollapsibleView, LabeledFieldView, createLabeledInputNumber, SwitchButtonView, createDropdown, SplitButtonView, MenuBarMenuView, focusChildOnDropdownOpen } from '@ckeditor/ckeditor5-ui/dist/index.js';
import { IconNumberedList, IconBulletedList, IconListStyleDisc, IconListStyleCircle, IconListStyleSquare, IconListStyleDecimal, IconListStyleDecimalLeadingZero, IconListStyleLowerRoman, IconListStyleUpperRoman, IconListStyleLowerLatin, IconListStyleUpperLatin, IconTodoList } from '@ckeditor/ckeditor5-icons/dist/index.js';
import { DomEventObserver, Matcher, ModelTreeWalker, getViewFillerOffset } from '@ckeditor/ckeditor5-engine/dist/index.js';

/**
 * Document list blocks iterator.
 *
 * @internal
 */ class ListWalker {
    /**
	 * The start list item block element.
	 */ _startElement;
    /**
	 * The reference indent. Initialized by the indent of the start block.
	 */ _referenceIndent;
    /**
	 * The iterating direction.
	 */ _isForward;
    /**
	 * Whether start block should be included in the result (if it's matching other criteria).
	 */ _includeSelf;
    /**
	 * Additional attributes that must be the same for each block.
	 */ _sameAttributes;
    /**
	 * Whether blocks with the same indent level as the start block should be included in the result.
	 */ _sameIndent;
    /**
	 * Whether blocks with a lower indent level than the start block should be included in the result.
	 */ _lowerIndent;
    /**
	 * Whether blocks with a higher indent level than the start block should be included in the result.
	 */ _higherIndent;
    /**
	 * Creates a document list iterator.
	 *
	 * @param startElement The start list item block element.
	 * @param options.direction The iterating direction.
	 * @param options.includeSelf Whether start block should be included in the result (if it's matching other criteria).
	 * @param options.sameAttributes Additional attributes that must be the same for each block.
	 * @param options.sameIndent Whether blocks with the same indent level as the start block should be included
	 * in the result.
	 * @param options.lowerIndent Whether blocks with a lower indent level than the start block should be included
	 * in the result.
	 * @param options.higherIndent Whether blocks with a higher indent level than the start block should be included
	 * in the result.
	 */ constructor(startElement, options){
        this._startElement = startElement;
        this._referenceIndent = startElement.getAttribute('listIndent');
        this._isForward = options.direction == 'forward';
        this._includeSelf = !!options.includeSelf;
        this._sameAttributes = toArray(options.sameAttributes || []);
        this._sameIndent = !!options.sameIndent;
        this._lowerIndent = !!options.lowerIndent;
        this._higherIndent = !!options.higherIndent;
    }
    /**
	 * Performs only first step of iteration and returns the result.
	 *
	 * @param startElement The start list item block element.
	 * @param options.direction The iterating direction.
	 * @param options.includeSelf Whether start block should be included in the result (if it's matching other criteria).
	 * @param options.sameAttributes Additional attributes that must be the same for each block.
	 * @param options.sameIndent Whether blocks with the same indent level as the start block should be included
	 * in the result.
	 * @param options.lowerIndent Whether blocks with a lower indent level than the start block should be included
	 * in the result.
	 * @param options.higherIndent Whether blocks with a higher indent level than the start block should be included
	 * in the result.
	 */ static first(startElement, options) {
        const walker = new this(startElement, options);
        const iterator = walker[Symbol.iterator]();
        return first(iterator);
    }
    /**
	 * Iterable interface.
	 */ *[Symbol.iterator]() {
        const nestedItems = [];
        for (const { node } of new SiblingListBlocksIterator(this._getStartNode(), this._isForward ? 'forward' : 'backward')){
            const indent = node.getAttribute('listIndent');
            // Leaving a nested list.
            if (indent < this._referenceIndent) {
                // Abort searching blocks.
                if (!this._lowerIndent) {
                    break;
                }
                // While searching for lower indents, update the reference indent to find another parent in the next step.
                this._referenceIndent = indent;
            } else if (indent > this._referenceIndent) {
                // Ignore nested blocks.
                if (!this._higherIndent) {
                    continue;
                }
                // Collect nested blocks to verify if they are really nested, or it's a different item.
                if (!this._isForward) {
                    nestedItems.push(node);
                    continue;
                }
            } else {
                // Ignore same indent block.
                if (!this._sameIndent) {
                    // While looking for nested blocks, stop iterating while encountering first same indent block.
                    if (this._higherIndent) {
                        // No more nested blocks so yield nested items.
                        if (nestedItems.length) {
                            yield* nestedItems;
                            nestedItems.length = 0;
                        }
                        break;
                    }
                    continue;
                }
                // Abort if item has any additionally specified attribute different.
                if (this._sameAttributes.some((attr)=>node.getAttribute(attr) !== this._startElement.getAttribute(attr))) {
                    break;
                }
            }
            // There is another block for the same list item so the nested items were in the same list item.
            if (nestedItems.length) {
                yield* nestedItems;
                nestedItems.length = 0;
            }
            yield node;
        }
    }
    /**
	 * Returns the model element to start iterating.
	 */ _getStartNode() {
        if (this._includeSelf) {
            return this._startElement;
        }
        return this._isForward ? this._startElement.nextSibling : this._startElement.previousSibling;
    }
}
/**
 * Iterates sibling list blocks starting from the given node.
 *
 * @internal
 */ class SiblingListBlocksIterator {
    _node;
    _isForward;
    _previousNodesByIndent = [];
    _previous = null;
    _previousNodeIndent = null;
    /**
	 * @param node The model node.
	 * @param direction Iteration direction.
	 */ constructor(node, direction = 'forward'){
        this._node = node;
        this._isForward = direction === 'forward';
    }
    [Symbol.iterator]() {
        return this;
    }
    next() {
        if (!isListItemBlock(this._node)) {
            return {
                done: true,
                value: undefined
            };
        }
        const nodeIndent = this._node.getAttribute('listIndent');
        let previousNodeInList = null;
        if (this._previous) {
            const previousNodeIndent = this._previousNodeIndent;
            // Let's find previous node for the same indent.
            // We're going to need that when we get back to previous indent.
            if (nodeIndent > previousNodeIndent) {
                this._previousNodesByIndent[previousNodeIndent] = this._previous;
            } else if (nodeIndent < previousNodeIndent) {
                previousNodeInList = this._previousNodesByIndent[nodeIndent] || null;
                this._previousNodesByIndent.length = nodeIndent;
            } else {
                previousNodeInList = this._previous;
            }
        }
        const value = {
            node: this._node,
            previous: this._previous,
            previousNodeInList
        };
        this._previous = this._node;
        this._previousNodeIndent = nodeIndent;
        this._node = this._isForward ? this._node.nextSibling : this._node.previousSibling;
        return {
            value,
            done: false
        };
    }
}
/**
 * The iterable protocol over the list elements.
 *
 * @internal
 */ class ListBlocksIterable {
    _listHead;
    /**
	 * @param listHead The head element of a list.
	 */ constructor(listHead){
        this._listHead = listHead;
    }
    /**
	 * List blocks iterator.
	 *
	 * Iterates over all blocks of a list.
	 */ [Symbol.iterator]() {
        return new SiblingListBlocksIterator(this._listHead);
    }
}

/**
 * The list item ID generator.
 *
 * @internal
 */ class ListItemUid {
    /**
	 * Returns the next ID.
	 *
	 * @internal
	 */ /* istanbul ignore next: static function definition -- @preserve */ static next() {
        return uid();
    }
}
/**
 * Returns true if the given model node is a list item block.
 *
 * @internal
 */ function isListItemBlock(node) {
    return !!node && node.is('element') && node.hasAttribute('listItemId');
}
/**
 * Returns an array with all elements that represents the same list item.
 *
 * It means that values for `listIndent`, and `listItemId` for all items are equal.
 *
 * @internal
 * @param listItem Starting list item element.
 * @param options.higherIndent Whether blocks with a higher indent level than the start block should be included
 * in the result.
 */ function getAllListItemBlocks(listItem, options = {}) {
    return [
        ...getListItemBlocks(listItem, {
            ...options,
            direction: 'backward'
        }),
        ...getListItemBlocks(listItem, {
            ...options,
            direction: 'forward'
        })
    ];
}
/**
 * Returns an array with elements that represents the same list item in the specified direction.
 *
 * It means that values for `listIndent` and `listItemId` for all items are equal.
 *
 * **Note**: For backward search the provided item is not included, but for forward search it is included in the result.
 *
 * @internal
 * @param listItem Starting list item element.
 * @param options.direction Walking direction.
 * @param options.higherIndent Whether blocks with a higher indent level than the start block should be included in the result.
 */ function getListItemBlocks(listItem, options = {}) {
    const isForward = options.direction == 'forward';
    const items = Array.from(new ListWalker(listItem, {
        ...options,
        includeSelf: isForward,
        sameIndent: true,
        sameAttributes: 'listItemId'
    }));
    return isForward ? items : items.reverse();
}
/**
 * Returns a list items nested inside the given list item.
 *
 * @internal
 */ function getNestedListBlocks(listItem) {
    return Array.from(new ListWalker(listItem, {
        direction: 'forward',
        higherIndent: true
    }));
}
/**
 * Returns array of all blocks/items of the same list as given block (same indent, same type and properties).
 *
 * @internal
 * @param listItem Starting list item element.
 * @param options Additional list walker options to modify the range of returned list items.
 */ function getListItems(listItem, options) {
    const backwardBlocks = new ListWalker(listItem, {
        sameIndent: true,
        sameAttributes: 'listType',
        ...options
    });
    const forwardBlocks = new ListWalker(listItem, {
        sameIndent: true,
        sameAttributes: 'listType',
        includeSelf: true,
        direction: 'forward',
        ...options
    });
    return [
        ...Array.from(backwardBlocks).reverse(),
        ...forwardBlocks
    ];
}
/**
 * Check if the given block is the first in the list item.
 *
 * @internal
 * @param listBlock The list block element.
 */ function isFirstBlockOfListItem(listBlock) {
    const previousSibling = ListWalker.first(listBlock, {
        sameIndent: true,
        sameAttributes: 'listItemId'
    });
    if (!previousSibling) {
        return true;
    }
    return false;
}
/**
 * Check if the given block is the last in the list item.
 *
 * @internal
 */ function isLastBlockOfListItem(listBlock) {
    const nextSibling = ListWalker.first(listBlock, {
        direction: 'forward',
        sameIndent: true,
        sameAttributes: 'listItemId'
    });
    if (!nextSibling) {
        return true;
    }
    return false;
}
/**
 * Expands the given list of selected blocks to include the leading and tailing blocks of partially selected list items.
 *
 * @internal
 * @param blocks The list of selected blocks.
 * @param options.withNested Whether should include nested list items.
 */ function expandListBlocksToCompleteItems(blocks, options = {}) {
    blocks = toArray(blocks);
    const higherIndent = options.withNested !== false;
    const allBlocks = new Set();
    for (const block of blocks){
        for (const itemBlock of getAllListItemBlocks(block, {
            higherIndent
        })){
            allBlocks.add(itemBlock);
        }
    }
    return sortBlocks(allBlocks);
}
/**
 * Expands the given list of selected blocks to include all the items of the lists they're in.
 *
 * @internal
 * @param blocks The list of selected blocks.
 */ function expandListBlocksToCompleteList(blocks) {
    blocks = toArray(blocks);
    const allBlocks = new Set();
    for (const block of blocks){
        for (const itemBlock of getListItems(block)){
            allBlocks.add(itemBlock);
        }
    }
    return sortBlocks(allBlocks);
}
/**
 * Splits the list item just before the provided list block.
 *
 * @internal
 * @param listBlock The list block element.
 * @param writer The model writer.
 * @returns The array of updated blocks.
 */ function splitListItemBefore(listBlock, writer) {
    const blocks = getListItemBlocks(listBlock, {
        direction: 'forward'
    });
    const id = ListItemUid.next();
    for (const block of blocks){
        writer.setAttribute('listItemId', id, block);
    }
    return blocks;
}
/**
 * Merges the list item with the parent list item.
 *
 * @internal
 * @param listBlock The list block element.
 * @param parentBlock The list block element to merge with.
 * @param writer The model writer.
 * @returns The array of updated blocks.
 */ function mergeListItemBefore(listBlock, parentBlock, writer) {
    const attributes = {};
    for (const [key, value] of parentBlock.getAttributes()){
        if (key.startsWith('list')) {
            attributes[key] = value;
        }
    }
    const blocks = getListItemBlocks(listBlock, {
        direction: 'forward'
    });
    for (const block of blocks){
        writer.setAttributes(attributes, block);
    }
    return blocks;
}
/**
 * Increases indentation of given list blocks.
 *
 * @internal
 * @param blocks The block or iterable of blocks.
 * @param writer The model writer.
 * @param options Additional options.
 * @param options.expand Whether should expand the list of blocks to include complete list items.
 * @param options.indentBy The number of levels the indentation should change (could be negative).
 */ function indentBlocks(blocks, writer, { expand, indentBy = 1 } = {}) {
    blocks = toArray(blocks);
    // Expand the selected blocks to contain the whole list items.
    const allBlocks = expand ? expandListBlocksToCompleteItems(blocks) : blocks;
    for (const block of allBlocks){
        const blockIndent = block.getAttribute('listIndent') + indentBy;
        if (blockIndent < 0) {
            removeListAttributes(block, writer);
        } else {
            writer.setAttribute('listIndent', blockIndent, block);
        }
    }
    return allBlocks;
}
/**
 * Decreases indentation of given list of blocks. If the indentation of some blocks matches the indentation
 * of surrounding blocks, they get merged together.
 *
 * @internal
 * @param blocks The block or iterable of blocks.
 * @param writer The model writer.
 */ function outdentBlocksWithMerge(blocks, writer) {
    blocks = toArray(blocks);
    // Expand the selected blocks to contain the whole list items.
    const allBlocks = expandListBlocksToCompleteItems(blocks);
    const visited = new Set();
    const referenceIndent = Math.min(...allBlocks.map((block)=>block.getAttribute('listIndent')));
    const parentBlocks = new Map();
    // Collect parent blocks before the list structure gets altered.
    for (const block of allBlocks){
        parentBlocks.set(block, ListWalker.first(block, {
            lowerIndent: true
        }));
    }
    for (const block of allBlocks){
        if (visited.has(block)) {
            continue;
        }
        visited.add(block);
        const blockIndent = block.getAttribute('listIndent') - 1;
        if (blockIndent < 0) {
            removeListAttributes(block, writer);
            continue;
        }
        // Merge with parent list item while outdenting and indent matches reference indent.
        if (block.getAttribute('listIndent') == referenceIndent) {
            const mergedBlocks = mergeListItemIfNotLast(block, parentBlocks.get(block), writer);
            // All list item blocks are updated while merging so add those to visited set.
            for (const mergedBlock of mergedBlocks){
                visited.add(mergedBlock);
            }
            // The indent level was updated while merging so continue to next block.
            if (mergedBlocks.length) {
                continue;
            }
        }
        writer.setAttribute('listIndent', blockIndent, block);
    }
    return sortBlocks(visited);
}
/**
 * Removes all list attributes from the given blocks.
 *
 * @internal
 * @param blocks The block or iterable of blocks.
 * @param writer The model writer.
 * @returns Array of altered blocks.
 */ function removeListAttributes(blocks, writer) {
    blocks = toArray(blocks);
    // Convert simple list items to plain paragraphs.
    for (const block of blocks){
        if (block.is('element', 'listItem')) {
            writer.rename(block, 'paragraph');
        }
    }
    // Remove list attributes.
    for (const block of blocks){
        for (const attributeKey of block.getAttributeKeys()){
            if (attributeKey.startsWith('list')) {
                writer.removeAttribute(attributeKey, block);
            }
        }
    }
    return blocks;
}
/**
 * Checks whether the given blocks are related to a single list item.
 *
 * @internal
 * @param blocks The list block elements.
 */ function isSingleListItem(blocks) {
    if (!blocks.length) {
        return false;
    }
    const firstItemId = blocks[0].getAttribute('listItemId');
    if (!firstItemId) {
        return false;
    }
    return !blocks.some((item)=>item.getAttribute('listItemId') != firstItemId);
}
/**
 * Modifies the indents of list blocks following the given list block so the indentation is valid after
 * the given block is no longer a list item.
 *
 * @internal
 * @param lastBlock The last list block that has become a non-list element.
 * @param writer The model writer.
 * @returns Array of altered blocks.
 */ function outdentFollowingItems(lastBlock, writer) {
    const changedBlocks = [];
    // Start from the model item that is just after the last turned-off item.
    let currentIndent = Number.POSITIVE_INFINITY;
    // Correct indent of all items after the last turned off item.
    // Rules that should be followed:
    // 1. All direct sub-items of turned-off item should become indent 0, because the first item after it
    //    will be the first item of a new list. Other items are at the same level, so should have same 0 index.
    // 2. All items with indent lower than indent of turned-off item should become indent 0, because they
    //    should not end up as a child of any of list items that they were not children of before.
    // 3. All other items should have their indent changed relatively to it's parent.
    //
    // For example:
    // 1  * --------
    // 2     * --------
    // 3        * --------			<-- this is turned off.
    // 4           * --------		<-- this has to become indent = 0, because it will be first item on a new list.
    // 5              * --------	<-- this should be still be a child of item above, so indent = 1.
    // 6        * --------			<-- this has to become indent = 0, because it should not be a child of any of items above.
    // 7           * --------		<-- this should be still be a child of item above, so indent = 1.
    // 8     * --------				<-- this has to become indent = 0.
    // 9        * --------			<-- this should still be a child of item above, so indent = 1.
    // 10          * --------		<-- this should still be a child of item above, so indent = 2.
    // 11          * --------		<-- this should still be at the same level as item above, so indent = 2.
    // 12 * --------				<-- this and all below are left unchanged.
    // 13    * --------
    // 14       * --------
    //
    // After turning off 3 the list becomes:
    //
    // 1  * --------
    // 2     * --------
    //
    // 3  --------
    //
    // 4  * --------
    // 5     * --------
    // 6  * --------
    // 7     * --------
    // 8  * --------
    // 9     * --------
    // 10       * --------
    // 11       * --------
    // 12 * --------
    // 13    * --------
    // 14       * --------
    //
    // Thanks to this algorithm no lists are mismatched and no items get unexpected children/parent, while
    // those parent-child connection which are possible to maintain are still maintained. It's worth noting
    // that this is the same effect that we would be get by multiple use of outdent command. However doing
    // it like this is much more efficient because it's less operation (less memory usage, easier OT) and
    // less conversion (faster).
    for (const { node } of new SiblingListBlocksIterator(lastBlock.nextSibling)){
        // Check each next list item, as long as its indent is higher than 0.
        const indent = node.getAttribute('listIndent');
        // If the indent is 0 we are not going to change anything anyway.
        if (indent == 0) {
            break;
        }
        // We check if that's item indent is lower than current relative indent.
        if (indent < currentIndent) {
            // If it is, current relative indent becomes that indent.
            currentIndent = indent;
        }
        // Fix indent relatively to current relative indent.
        // Note, that if we just changed the current relative indent, the newIndent will be equal to 0.
        const newIndent = indent - currentIndent;
        writer.setAttribute('listIndent', newIndent, node);
        changedBlocks.push(node);
    }
    return changedBlocks;
}
/**
 * Returns the array of given blocks sorted by model indexes (document order).
 *
 * @internal
 */ function sortBlocks(blocks) {
    return Array.from(blocks).filter((block)=>block.root.rootName !== '$graveyard').sort((a, b)=>a.index - b.index);
}
/**
 * Returns a selected block object. If a selected object is inline or when there is no selected
 * object, `null` is returned.
 *
 * @internal
 * @param model The instance of editor model.
 * @returns Selected block object or `null`.
 */ function getSelectedBlockObject(model) {
    const selectedElement = model.document.selection.getSelectedElement();
    if (!selectedElement) {
        return null;
    }
    if (model.schema.isObject(selectedElement) && model.schema.isBlock(selectedElement)) {
        return selectedElement;
    }
    return null;
}
/**
 * Checks whether the given block can be replaced by a listItem.
 *
 * Note that this is possible only when multiBlock = false option is set in feature config.
 *
 * @param block A block to be tested.
 * @param schema The schema of the document.
 * @internal
 */ function canBecomeSimpleListItem(block, schema) {
    return schema.checkChild(block.parent, 'listItem') && schema.checkChild(block, '$text') && !schema.isObject(block);
}
/**
 * Returns true if listType is of type `numbered` or `customNumbered`.
 *
 * @internal
 */ function isNumberedListType(listType) {
    return listType == 'numbered' || listType == 'customNumbered';
}
/**
 * Merges a given block to the given parent block if parent is a list item and there is no more blocks in the same item.
 */ function mergeListItemIfNotLast(block, parentBlock, writer) {
    const parentItemBlocks = getListItemBlocks(parentBlock, {
        direction: 'forward'
    });
    // Merge with parent only if outdented item wasn't the last one in its parent.
    // Merge:
    // * a			->		* a
    //   * [b]		->		  b
    //   c			->		  c
    // Don't merge:
    // * a			->		* a
    //   * [b]		-> 		* b
    // * c			->		* c
    if (parentItemBlocks.pop().index > block.index) {
        return mergeListItemBefore(block, parentBlock, writer);
    }
    return [];
}

/**
 * The document list indent command. It is used by the {@link module:list/list~List list feature}.
 */ class ListIndentCommand extends Command {
    /**
	 * Determines by how much the command will change the list item's indent attribute.
	 */ _direction;
    /**
	 * Creates an instance of the command.
	 *
	 * @param editor The editor instance.
	 * @param indentDirection The direction of indent. If it is equal to `backward`, the command
	 * will outdent a list item.
	 */ constructor(editor, indentDirection){
        super(editor);
        this._direction = indentDirection;
    }
    /**
	 * @inheritDoc
	 */ refresh() {
        this.isEnabled = this._checkEnabled();
    }
    /**
	 * Indents or outdents (depending on the {@link #constructor}'s `indentDirection` parameter) selected list items.
	 *
	 * @fires execute
	 * @fires afterExecute
	 */ execute() {
        const model = this.editor.model;
        const blocks = getSelectedListBlocks(model.document.selection);
        model.change((writer)=>{
            const changedBlocks = [];
            // Handle selection contained in the single list item and starting in the following blocks.
            if (isSingleListItem(blocks) && !isFirstBlockOfListItem(blocks[0])) {
                // Allow increasing indent of following list item blocks.
                if (this._direction == 'forward') {
                    changedBlocks.push(...indentBlocks(blocks, writer));
                }
                // For indent make sure that indented blocks have a new ID.
                // For outdent just split blocks from the list item (give them a new IDs).
                changedBlocks.push(...splitListItemBefore(blocks[0], writer));
            } else {
                // Now just update the attributes of blocks.
                if (this._direction == 'forward') {
                    changedBlocks.push(...indentBlocks(blocks, writer, {
                        expand: true
                    }));
                } else {
                    changedBlocks.push(...outdentBlocksWithMerge(blocks, writer));
                }
            }
            // Align the list item type to match the previous list item (from the same list).
            for (const block of changedBlocks){
                // This block become a plain block (for example a paragraph).
                if (!block.hasAttribute('listType')) {
                    continue;
                }
                const previousItemBlock = ListWalker.first(block, {
                    sameIndent: true
                });
                if (previousItemBlock) {
                    writer.setAttribute('listType', previousItemBlock.getAttribute('listType'), block);
                }
            }
            this._fireAfterExecute(changedBlocks);
        });
    }
    /**
	 * Fires the `afterExecute` event.
	 *
	 * @param changedBlocks The changed list elements.
	 */ _fireAfterExecute(changedBlocks) {
        this.fire('afterExecute', sortBlocks(new Set(changedBlocks)));
    }
    /**
	 * Checks whether the command can be enabled in the current context.
	 *
	 * @returns Whether the command should be enabled.
	 */ _checkEnabled() {
        // Check whether any of position's ancestor is a list item.
        let blocks = getSelectedListBlocks(this.editor.model.document.selection);
        let firstBlock = blocks[0];
        // If selection is not in a list item, the command is disabled.
        if (!firstBlock) {
            return false;
        }
        // If we are outdenting it is enough to be in list item. Every list item can always be outdented.
        if (this._direction == 'backward') {
            return true;
        }
        // A single block of a list item is selected, so it could be indented as a sublist.
        if (isSingleListItem(blocks) && !isFirstBlockOfListItem(blocks[0])) {
            return true;
        }
        blocks = expandListBlocksToCompleteItems(blocks);
        firstBlock = blocks[0];
        // Check if there is any list item before selected items that could become a parent of selected items.
        const siblingItem = ListWalker.first(firstBlock, {
            sameIndent: true
        });
        if (!siblingItem) {
            return false;
        }
        if (siblingItem.getAttribute('listType') == firstBlock.getAttribute('listType')) {
            return true;
        }
        return false;
    }
}
/**
 * Returns an array of selected blocks truncated to the first non list block element.
 */ function getSelectedListBlocks(selection) {
    const blocks = Array.from(selection.getSelectedBlocks());
    const firstNonListBlockIndex = blocks.findIndex((block)=>!isListItemBlock(block));
    if (firstNonListBlockIndex != -1) {
        blocks.length = firstNonListBlockIndex;
    }
    return blocks;
}

/**
 * The list command. It is used by the {@link module:list/list~List list feature}.
 */ class ListCommand extends Command {
    /**
	 * The type of the list created by the command.
	 */ type;
    /**
	 * List Walker options that change the range of the list items to be changed when the selection is collapsed within a list item.
	 *
	 * In a multi-level list, when the selection is collapsed within a list item, instead of changing only the list items of the same list
	 * type and current indent level, the entire list structure is changed (all list items at all indent levels of any list type).
	 */ _listWalkerOptions;
    /**
	 * Creates an instance of the command.
	 *
	 * @param editor The editor instance.
	 * @param type List type that will be handled by this command.
	 */ constructor(editor, type, options = {}){
        super(editor);
        this.type = type;
        this._listWalkerOptions = options.multiLevel ? {
            higherIndent: true,
            lowerIndent: true,
            sameAttributes: []
        } : undefined;
    }
    /**
	 * @inheritDoc
	 */ refresh() {
        this.value = this._getValue();
        this.isEnabled = this._checkEnabled();
    }
    /**
	 * Executes the list command.
	 *
	 * @fires execute
	 * @fires afterExecute
	 * @param options Command options.
	 * @param options.forceValue If set, it will force the command behavior. If `true`, the command will try to convert the
	 * selected items and potentially the neighbor elements to the proper list items. If set to `false` it will convert selected elements
	 * to paragraphs. If not set, the command will toggle selected elements to list items or paragraphs, depending on the selection.
	 * @param options.additionalAttributes Additional attributes that are set for list items when the command is executed.
	 */ execute(options = {}) {
        const model = this.editor.model;
        const document = model.document;
        const selectedBlockObject = getSelectedBlockObject(model);
        const blocks = Array.from(document.selection.getSelectedBlocks()).filter((block)=>model.schema.checkAttribute(block, 'listType') || canBecomeSimpleListItem(block, model.schema));
        // Whether we are turning off some items.
        const turnOff = options.forceValue !== undefined ? !options.forceValue : this.value;
        model.change((writer)=>{
            if (turnOff) {
                const lastBlock = blocks[blocks.length - 1];
                // Split the first block from the list item.
                const itemBlocks = getListItemBlocks(lastBlock, {
                    direction: 'forward'
                });
                const changedBlocks = [];
                if (itemBlocks.length > 1) {
                    changedBlocks.push(...splitListItemBefore(itemBlocks[1], writer));
                }
                // Strip list attributes.
                changedBlocks.push(...removeListAttributes(blocks, writer));
                // Outdent items following the selected list item.
                changedBlocks.push(...outdentFollowingItems(lastBlock, writer));
                this._fireAfterExecute(changedBlocks);
            } else if ((selectedBlockObject || document.selection.isCollapsed) && isListItemBlock(blocks[0])) {
                const changedBlocks = getListItems(selectedBlockObject || blocks[0], this._listWalkerOptions);
                for (const block of changedBlocks){
                    writer.setAttributes({
                        ...options.additionalAttributes,
                        listType: this.type
                    }, block);
                }
                this._fireAfterExecute(changedBlocks);
            } else {
                const changedBlocks = [];
                for (const block of blocks){
                    // Promote the given block to the list item.
                    if (!block.hasAttribute('listType')) {
                        // Rename block to a simple list item if this option is enabled.
                        if (!block.is('element', 'listItem') && canBecomeSimpleListItem(block, model.schema)) {
                            writer.rename(block, 'listItem');
                        }
                        writer.setAttributes({
                            ...options.additionalAttributes,
                            listIndent: 0,
                            listItemId: ListItemUid.next(),
                            listType: this.type
                        }, block);
                        changedBlocks.push(block);
                    } else {
                        for (const node of expandListBlocksToCompleteItems(block, {
                            withNested: false
                        })){
                            if (node.getAttribute('listType') != this.type) {
                                writer.setAttributes({
                                    ...options.additionalAttributes,
                                    listType: this.type
                                }, node);
                                changedBlocks.push(node);
                            }
                        }
                    }
                }
                this._fireAfterExecute(changedBlocks);
            }
        });
    }
    /**
	 * Fires the `afterExecute` event.
	 *
	 * @param changedBlocks The changed list elements.
	 */ _fireAfterExecute(changedBlocks) {
        this.fire('afterExecute', sortBlocks(new Set(changedBlocks)));
    }
    /**
	 * Checks the command's {@link #value}.
	 *
	 * @returns The current value.
	 */ _getValue() {
        const selection = this.editor.model.document.selection;
        const blocks = Array.from(selection.getSelectedBlocks());
        if (!blocks.length) {
            return false;
        }
        for (const block of blocks){
            if (block.getAttribute('listType') != this.type) {
                return false;
            }
        }
        return true;
    }
    /**
	 * Checks whether the command can be enabled in the current context.
	 *
	 * @returns Whether the command should be enabled.
	 */ _checkEnabled() {
        const model = this.editor.model;
        const schema = model.schema;
        const selection = model.document.selection;
        const blocks = Array.from(selection.getSelectedBlocks());
        if (!blocks.length) {
            return false;
        }
        // If command value is true it means that we are in list item, so the command should be enabled.
        if (this.value) {
            return true;
        }
        for (const block of blocks){
            if (schema.checkAttribute(block, 'listType') || canBecomeSimpleListItem(block, schema)) {
                return true;
            }
        }
        return false;
    }
}

/**
 * The document list merge command. It is used by the {@link module:list/list~List list feature}.
 */ class ListMergeCommand extends Command {
    /**
	 * Whether list item should be merged before or after the selected block.
	 */ _direction;
    /**
	 * Creates an instance of the command.
	 *
	 * @param editor The editor instance.
	 * @param direction Whether list item should be merged before or after the selected block.
	 */ constructor(editor, direction){
        super(editor);
        this._direction = direction;
    }
    /**
	 * @inheritDoc
	 */ refresh() {
        this.isEnabled = this._checkEnabled();
    }
    /**
	 * Merges list blocks together (depending on the {@link #constructor}'s `direction` parameter).
	 *
	 * @fires execute
	 * @fires afterExecute
	 * @param options Command options.
	 * @param options.shouldMergeOnBlocksContentLevel When set `true`, merging will be performed together
	 * with {@link module:engine/model/model~Model#deleteContent} to get rid of the inline content in the selection or take advantage
	 * of the heuristics in `deleteContent()` that helps convert lists into paragraphs in certain cases.
	 */ execute({ shouldMergeOnBlocksContentLevel = false } = {}) {
        const model = this.editor.model;
        const selection = model.document.selection;
        const changedBlocks = [];
        model.change((writer)=>{
            const { firstElement, lastElement } = this._getMergeSubjectElements(selection, shouldMergeOnBlocksContentLevel);
            const firstIndent = firstElement.getAttribute('listIndent') || 0;
            const lastIndent = lastElement.getAttribute('listIndent');
            const lastElementId = lastElement.getAttribute('listItemId');
            if (firstIndent != lastIndent) {
                const nestedLastElementBlocks = getNestedListBlocks(lastElement);
                changedBlocks.push(...indentBlocks([
                    lastElement,
                    ...nestedLastElementBlocks
                ], writer, {
                    indentBy: firstIndent - lastIndent,
                    // If outdenting, the entire sub-tree that follows must be included.
                    expand: firstIndent < lastIndent
                }));
            }
            if (shouldMergeOnBlocksContentLevel) {
                let sel = selection;
                if (selection.isCollapsed) {
                    sel = writer.createSelection(writer.createRange(writer.createPositionAt(firstElement, 'end'), writer.createPositionAt(lastElement, 0)));
                }
                // Delete selected content. Replace entire content only for non-collapsed selection.
                model.deleteContent(sel, {
                    doNotResetEntireContent: selection.isCollapsed
                });
                // Get the last "touched" element after deleteContent call (can't use the lastElement because
                // it could get merged into the firstElement while deleting content).
                const lastElementAfterDelete = sel.getLastPosition().parent;
                // Check if the element after it was in the same list item and adjust it if needed.
                const nextSibling = lastElementAfterDelete.nextSibling;
                changedBlocks.push(lastElementAfterDelete);
                if (nextSibling && nextSibling !== lastElement && nextSibling.getAttribute('listItemId') == lastElementId) {
                    changedBlocks.push(...mergeListItemBefore(nextSibling, lastElementAfterDelete, writer));
                }
            } else {
                changedBlocks.push(...mergeListItemBefore(lastElement, firstElement, writer));
            }
            this._fireAfterExecute(changedBlocks);
        });
    }
    /**
	 * Fires the `afterExecute` event.
	 *
	 * @param changedBlocks The changed list elements.
	 */ _fireAfterExecute(changedBlocks) {
        this.fire('afterExecute', sortBlocks(new Set(changedBlocks)));
    }
    /**
	 * Checks whether the command can be enabled in the current context.
	 *
	 * @returns Whether the command should be enabled.
	 */ _checkEnabled() {
        const model = this.editor.model;
        const selection = model.document.selection;
        const selectedBlockObject = getSelectedBlockObject(model);
        if (selection.isCollapsed || selectedBlockObject) {
            const positionParent = selectedBlockObject || selection.getFirstPosition().parent;
            if (!isListItemBlock(positionParent)) {
                return false;
            }
            const siblingNode = this._direction == 'backward' ? positionParent.previousSibling : positionParent.nextSibling;
            if (!siblingNode) {
                return false;
            }
            if (isSingleListItem([
                positionParent,
                siblingNode
            ])) {
                return false;
            }
        } else {
            const lastPosition = selection.getLastPosition();
            const firstPosition = selection.getFirstPosition();
            // If deleting within a single block of a list item, there's no need to merge anything.
            // The default delete should be executed instead.
            if (lastPosition.parent === firstPosition.parent) {
                return false;
            }
            if (!isListItemBlock(lastPosition.parent)) {
                return false;
            }
        }
        return true;
    }
    /**
	 * Returns the boundary elements the merge should be executed for. These are not necessarily selection's first
	 * and last position parents but sometimes sibling or even further blocks depending on the context.
	 *
	 * @param selection The selection the merge is executed for.
	 * @param shouldMergeOnBlocksContentLevel When `true`, merge is performed together with
	 * {@link module:engine/model/model~Model#deleteContent} to remove the inline content within the selection.
	 */ _getMergeSubjectElements(selection, shouldMergeOnBlocksContentLevel) {
        const model = this.editor.model;
        const selectedBlockObject = getSelectedBlockObject(model);
        let firstElement, lastElement;
        if (selection.isCollapsed || selectedBlockObject) {
            const positionParent = selectedBlockObject || selection.getFirstPosition().parent;
            const isFirstBlock = isFirstBlockOfListItem(positionParent);
            if (this._direction == 'backward') {
                lastElement = positionParent;
                if (isFirstBlock && !shouldMergeOnBlocksContentLevel) {
                    // For the "c" as an anchorElement:
                    //  * a
                    //    * b
                    //  * [c]  <-- this block should be merged with "a"
                    // It should find "a" element to merge with:
                    //  * a
                    //    * b
                    //    c
                    firstElement = ListWalker.first(positionParent, {
                        sameIndent: true,
                        lowerIndent: true
                    });
                } else {
                    firstElement = positionParent.previousSibling;
                }
            } else {
                // In case of the forward merge there is no case as above, just merge with next sibling.
                firstElement = positionParent;
                lastElement = positionParent.nextSibling;
            }
        } else {
            firstElement = selection.getFirstPosition().parent;
            lastElement = selection.getLastPosition().parent;
        }
        return {
            firstElement: firstElement,
            lastElement: lastElement
        };
    }
}

/**
 * The document list split command that splits the list item at the selection.
 *
 * It is used by the {@link module:list/list~List list feature}.
 */ class ListSplitCommand extends Command {
    /**
	 * Whether list item should be split before or after the selected block.
	 */ _direction;
    /**
	 * Creates an instance of the command.
	 *
	 * @param editor The editor instance.
	 * @param direction Whether list item should be split before or after the selected block.
	 */ constructor(editor, direction){
        super(editor);
        this._direction = direction;
    }
    /**
	 * @inheritDoc
	 */ refresh() {
        this.isEnabled = this._checkEnabled();
    }
    /**
	 * Splits the list item at the selection.
	 *
	 * @fires execute
	 * @fires afterExecute
	 */ execute() {
        const editor = this.editor;
        editor.model.change((writer)=>{
            const changedBlocks = splitListItemBefore(this._getStartBlock(), writer);
            this._fireAfterExecute(changedBlocks);
        });
    }
    /**
	 * Fires the `afterExecute` event.
	 *
	 * @param changedBlocks The changed list elements.
	 */ _fireAfterExecute(changedBlocks) {
        this.fire('afterExecute', sortBlocks(new Set(changedBlocks)));
    }
    /**
	 * Checks whether the command can be enabled in the current context.
	 *
	 * @returns Whether the command should be enabled.
	 */ _checkEnabled() {
        const selection = this.editor.model.document.selection;
        const block = this._getStartBlock();
        return selection.isCollapsed && isListItemBlock(block) && !isFirstBlockOfListItem(block);
    }
    /**
	 * Returns the model element that is the main focus of the command (according to the current selection and command direction).
	 */ _getStartBlock() {
        const doc = this.editor.model.document;
        const positionParent = doc.selection.getFirstPosition().parent;
        return this._direction == 'before' ? positionParent : positionParent.nextSibling;
    }
}

/**
 * The list item bold integration plugin.
 */ class ListItemBoldIntegration extends Plugin {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'ListItemBoldIntegration';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            ListEditing
        ];
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const ListFormatting = editor.plugins.get('ListFormatting');
        const listEditing = editor.plugins.get(ListEditing);
        if (!editor.plugins.has('BoldEditing') || !this.editor.config.get('list.enableListItemMarkerFormatting')) {
            return;
        }
        ListFormatting.registerFormatAttribute('bold', 'listItemBold');
        // Register the downcast strategy in init() so that the attribute name is registered before the list editing
        // registers its converters.
        // This ensures that the attribute is recognized by downcast strategies and bogus paragraphs are handled correctly.
        listEditing.registerDowncastStrategy({
            scope: 'item',
            attributeName: 'listItemBold',
            setAttributeOnDowncast (writer, value, viewElement, options) {
                if (value) {
                    writer.addClass('ck-list-marker-bold', viewElement);
                    // See: https://github.com/ckeditor/ckeditor5/issues/18790.
                    if (env.isSafari && !(options && options.dataPipeline)) {
                        writer.setStyle('--ck-content-list-marker-dummy-bold', '0', viewElement);
                    }
                }
            }
        });
    }
    /**
	 * @inheritDoc
	 */ afterInit() {
        const editor = this.editor;
        const model = editor.model;
        if (!editor.plugins.has('BoldEditing') || !this.editor.config.get('list.enableListItemMarkerFormatting')) {
            return;
        }
        model.schema.extend('$listItem', {
            allowAttributes: 'listItemBold'
        });
        model.schema.setAttributeProperties('listItemBold', {
            isFormatting: true
        });
        model.schema.addAttributeCheck((context)=>{
            const item = context.last;
            if (!item.getAttribute('listItemId')) {
                return false;
            }
        }, 'listItemBold');
        editor.conversion.for('upcast').attributeToAttribute({
            model: 'listItemBold',
            view: {
                name: 'li',
                classes: 'ck-list-marker-bold'
            }
        });
    }
}

/**
 * The list item italic integration plugin.
 */ class ListItemItalicIntegration extends Plugin {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'ListItemItalicIntegration';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            ListEditing
        ];
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const ListFormatting = editor.plugins.get('ListFormatting');
        const listEditing = editor.plugins.get(ListEditing);
        if (!editor.plugins.has('ItalicEditing') || !this.editor.config.get('list.enableListItemMarkerFormatting')) {
            return;
        }
        ListFormatting.registerFormatAttribute('italic', 'listItemItalic');
        // Register the downcast strategy in init() so that the attribute name is registered before the list editing
        // registers its converters.
        // This ensures that the attribute is recognized by downcast strategies and bogus paragraphs are handled correctly.
        listEditing.registerDowncastStrategy({
            scope: 'item',
            attributeName: 'listItemItalic',
            setAttributeOnDowncast (writer, value, viewElement, options) {
                if (value) {
                    writer.addClass('ck-list-marker-italic', viewElement);
                    // See: https://github.com/ckeditor/ckeditor5/issues/18790.
                    if (env.isSafari && !(options && options.dataPipeline)) {
                        writer.setStyle('--ck-content-list-marker-dummy-italic', '0', viewElement);
                    }
                }
            }
        });
    }
    /**
	 * @inheritDoc
	 */ afterInit() {
        const editor = this.editor;
        const model = editor.model;
        if (!editor.plugins.has('ItalicEditing') || !this.editor.config.get('list.enableListItemMarkerFormatting')) {
            return;
        }
        model.schema.extend('$listItem', {
            allowAttributes: 'listItemItalic'
        });
        model.schema.setAttributeProperties('listItemItalic', {
            isFormatting: true
        });
        model.schema.addAttributeCheck((context)=>{
            const item = context.last;
            if (!item.getAttribute('listItemId')) {
                return false;
            }
        }, 'listItemItalic');
        editor.conversion.for('upcast').attributeToAttribute({
            model: 'listItemItalic',
            view: {
                name: 'li',
                classes: 'ck-list-marker-italic'
            }
        });
    }
}

/**
 * The list item font size integration plugin.
 */ class ListItemFontSizeIntegration extends Plugin {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'ListItemFontSizeIntegration';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            ListEditing
        ];
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const ListFormatting = editor.plugins.get('ListFormatting');
        const listEditing = editor.plugins.get(ListEditing);
        if (!editor.plugins.has('FontSizeEditing') || !this.editor.config.get('list.enableListItemMarkerFormatting')) {
            return;
        }
        const normalizedFontSizeOptions = _normalizeFontSizeOptions(editor.config.get('fontSize.options'));
        ListFormatting.registerFormatAttribute('fontSize', 'listItemFontSize');
        // Register the downcast strategy in init() so that the attribute name is registered before the list editing
        // registers its converters.
        // This ensures that the attribute is recognized by downcast strategies and bogus paragraphs are handled correctly.
        listEditing.registerDowncastStrategy({
            scope: 'item',
            attributeName: 'listItemFontSize',
            setAttributeOnDowncast (writer, value, viewElement, options) {
                if (value) {
                    const fontSizeOption = normalizedFontSizeOptions.find((option)=>option.model == value);
                    if (fontSizeOption && fontSizeOption.view && typeof fontSizeOption.view != 'string') {
                        if (fontSizeOption.view.styles) {
                            writer.addClass('ck-list-marker-font-size', viewElement);
                            writer.setStyle('--ck-content-list-marker-font-size', fontSizeOption.view.styles['font-size'], viewElement);
                        } else if (fontSizeOption.view.classes) {
                            writer.addClass(`ck-list-marker-font-size-${value}`, viewElement);
                            // See: https://github.com/ckeditor/ckeditor5/issues/18790.
                            if (env.isSafari && !(options && options.dataPipeline)) {
                                writer.setStyle('--ck-content-list-marker-dummy-font-size', '0', viewElement);
                            }
                        }
                    } else {
                        writer.addClass('ck-list-marker-font-size', viewElement);
                        writer.setStyle('--ck-content-list-marker-font-size', value, viewElement);
                    }
                }
            }
        });
    }
    /**
	 * @inheritDoc
	 */ afterInit() {
        const editor = this.editor;
        const model = editor.model;
        if (!editor.plugins.has('FontSizeEditing') || !this.editor.config.get('list.enableListItemMarkerFormatting')) {
            return;
        }
        model.schema.extend('$listItem', {
            allowAttributes: 'listItemFontSize'
        });
        model.schema.setAttributeProperties('listItemFontSize', {
            isFormatting: true
        });
        model.schema.addAttributeCheck((context)=>{
            const item = context.last;
            if (!item.getAttribute('listItemId')) {
                return false;
            }
        }, 'listItemFontSize');
        editor.conversion.for('upcast').elementToAttribute({
            model: {
                key: 'listItemFontSize',
                value: (viewElement)=>viewElement.getStyle('--ck-content-list-marker-font-size')
            },
            view: {
                name: 'li',
                classes: 'ck-list-marker-font-size',
                styles: {
                    '--ck-content-list-marker-font-size': /.*/
                }
            }
        });
        const fontSizeOptions = _normalizeFontSizeOptions(editor.config.get('fontSize.options'));
        for (const option of fontSizeOptions){
            if (option.model && option.view) {
                editor.conversion.for('upcast').elementToAttribute({
                    model: {
                        key: 'listItemFontSize',
                        value: option.model
                    },
                    view: {
                        name: 'li',
                        classes: `ck-list-marker-font-size-${option.model}`
                    }
                });
            }
        }
    }
}

/**
 * The list item font color integration plugin.
 */ class ListItemFontColorIntegration extends Plugin {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'ListItemFontColorIntegration';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            ListEditing
        ];
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const ListFormatting = editor.plugins.get('ListFormatting');
        const listEditing = editor.plugins.get(ListEditing);
        if (!editor.plugins.has('FontColorEditing') || !this.editor.config.get('list.enableListItemMarkerFormatting')) {
            return;
        }
        ListFormatting.registerFormatAttribute('fontColor', 'listItemFontColor');
        // Register the downcast strategy in init() so that the attribute name is registered before the list editing
        // registers its converters.
        // This ensures that the attribute is recognized by downcast strategies and bogus paragraphs are handled correctly.
        listEditing.registerDowncastStrategy({
            scope: 'item',
            attributeName: 'listItemFontColor',
            setAttributeOnDowncast (writer, value, viewElement) {
                if (value) {
                    writer.addClass('ck-list-marker-color', viewElement);
                    writer.setStyle('--ck-content-list-marker-color', value, viewElement);
                }
            }
        });
    }
    /**
	 * @inheritDoc
	 */ afterInit() {
        const editor = this.editor;
        const model = editor.model;
        if (!editor.plugins.has('FontColorEditing') || !this.editor.config.get('list.enableListItemMarkerFormatting')) {
            return;
        }
        model.schema.extend('$listItem', {
            allowAttributes: 'listItemFontColor'
        });
        model.schema.setAttributeProperties('listItemFontColor', {
            isFormatting: true
        });
        model.schema.addAttributeCheck((context)=>{
            const item = context.last;
            if (!item.getAttribute('listItemId')) {
                return false;
            }
        }, 'listItemFontColor');
        editor.conversion.for('upcast').attributeToAttribute({
            model: {
                key: 'listItemFontColor',
                value: (viewElement)=>{
                    return viewElement.getStyle('--ck-content-list-marker-color');
                }
            },
            view: {
                name: 'li',
                classes: 'ck-list-marker-color',
                styles: {
                    '--ck-content-list-marker-color': /.*/
                }
            }
        });
    }
}

/**
 * The list item font family integration plugin.
 */ class ListItemFontFamilyIntegration extends Plugin {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'ListItemFontFamilyIntegration';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            ListEditing
        ];
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const ListFormatting = editor.plugins.get('ListFormatting');
        const listEditing = editor.plugins.get(ListEditing);
        if (!editor.plugins.has('FontFamilyEditing') || !this.editor.config.get('list.enableListItemMarkerFormatting')) {
            return;
        }
        ListFormatting.registerFormatAttribute('fontFamily', 'listItemFontFamily');
        // Register the downcast strategy in init() so that the attribute name is registered before the list editing
        // registers its converters.
        // This ensures that the attribute is recognized by downcast strategies and bogus paragraphs are handled correctly.
        listEditing.registerDowncastStrategy({
            scope: 'item',
            attributeName: 'listItemFontFamily',
            setAttributeOnDowncast (writer, value, viewElement) {
                // There is no need of removing the style because downcast strategies handles it automatically.
                if (value) {
                    writer.addClass('ck-list-marker-font-family', viewElement);
                    writer.setStyle('--ck-content-list-marker-font-family', value, viewElement);
                }
            }
        });
    }
    /**
	 * @inheritDoc
	 */ afterInit() {
        const editor = this.editor;
        const model = editor.model;
        if (!editor.plugins.has('FontFamilyEditing') || !this.editor.config.get('list.enableListItemMarkerFormatting')) {
            return;
        }
        model.schema.extend('$listItem', {
            allowAttributes: 'listItemFontFamily'
        });
        model.schema.setAttributeProperties('listItemFontFamily', {
            isFormatting: true
        });
        model.schema.addAttributeCheck((context)=>{
            const item = context.last;
            if (!item.getAttribute('listItemId')) {
                return false;
            }
        }, 'listItemFontFamily');
        editor.conversion.for('upcast').attributeToAttribute({
            model: {
                key: 'listItemFontFamily',
                value: (viewElement)=>{
                    return viewElement.getStyle('--ck-content-list-marker-font-family');
                }
            },
            view: {
                name: 'li',
                classes: 'ck-list-marker-font-family',
                styles: {
                    '--ck-content-list-marker-font-family': /.*/
                }
            }
        });
    }
}

/**
 * The list formatting plugin.
 *
 * It enables integration with formatting plugins to style the list marker.
 * The list marker is styled based on the consistent formatting applied to the content of the list item.
 *
 * The list of supported formatting plugins includes:
 * * Font color.
 * * Font size.
 * * Font family.
 * * Bold.
 * * Italic.
 */ class ListFormatting extends Plugin {
    /**
	 * The list of loaded formatting.
	 */ _loadedFormatting = {};
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'ListFormatting';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            ListItemBoldIntegration,
            ListItemItalicIntegration,
            ListItemFontSizeIntegration,
            ListItemFontColorIntegration,
            ListItemFontFamilyIntegration
        ];
    }
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        editor.config.define('list.enableListItemMarkerFormatting', true);
    }
    /**
	 * @inheritDoc
	 */ afterInit() {
        if (!this.editor.config.get('list.enableListItemMarkerFormatting')) {
            return;
        }
        this._registerPostfixerForListItemFormatting();
    }
    /**
	 * Registers a postfixer that ensures that the list item formatting attribute is consistent with the formatting
	 * applied to the content of the list item.
	 */ _registerPostfixerForListItemFormatting() {
        const model = this.editor.model;
        model.document.registerPostFixer((writer)=>{
            const changes = model.document.differ.getChanges();
            const modifiedListItems = new Set();
            let returnValue = false;
            for (const entry of changes){
                if (entry.type === 'attribute') {
                    if (entry.attributeKey == 'listItemId' || entry.attributeKey == 'listType' || this._isInlineOrSelectionFormatting(entry.attributeKey) || Object.values(this._loadedFormatting).includes(entry.attributeKey)) {
                        if (isListItemBlock(entry.range.start.nodeAfter)) {
                            modifiedListItems.add(entry.range.start.nodeAfter);
                        } else if (isListItemBlock(entry.range.start.parent)) {
                            modifiedListItems.add(entry.range.start.parent);
                        }
                    }
                } else {
                    if (isListItemBlock(entry.position.nodeAfter)) {
                        modifiedListItems.add(entry.position.nodeAfter);
                    }
                    if (isListItemBlock(entry.position.nodeBefore)) {
                        modifiedListItems.add(entry.position.nodeBefore);
                    }
                    if (isListItemBlock(entry.position.parent)) {
                        modifiedListItems.add(entry.position.parent);
                    }
                    if (entry.type == 'insert' && entry.name != '$text') {
                        const range = writer.createRangeIn(entry.position.nodeAfter);
                        for (const item of range.getItems()){
                            if (isListItemBlock(item)) {
                                modifiedListItems.add(item);
                            }
                        }
                    }
                }
            }
            for (const listItem of modifiedListItems){
                const formats = getListItemConsistentFormat(model, listItem, Object.keys(this._loadedFormatting));
                for (const [formatAttributeName, formatValue] of Object.entries(formats)){
                    const listItemFormatAttributeName = this._loadedFormatting[formatAttributeName];
                    if (formatValue && setFormattingToListItem(writer, listItem, listItemFormatAttributeName, formatValue)) {
                        returnValue = true;
                    } else if (!formatValue && removeFormattingFromListItem(writer, listItem, listItemFormatAttributeName)) {
                        returnValue = true;
                    }
                }
            }
            return returnValue;
        });
    }
    /**
	 * Registers an integration between a default attribute (e.g., `fontFamily`) and a new attribute
	 * intended specifically for list item elements (e.g., `listItemFontFamily`).
	 *
	 * These attributes are later used by the postfixer logic to determine whether to add the new attribute
	 * to the list item element, based on whether there is a consistent default formatting attribute
	 * applied within its content.
	 */ registerFormatAttribute(formatAttribute, listItemFormatAttribute) {
        this._loadedFormatting[formatAttribute] = listItemFormatAttribute;
    }
    /**
	 * Returns true if the given model attribute name is a supported inline formatting attribute.
	 */ _isInlineOrSelectionFormatting(attributeKey) {
        return attributeKey.replace(/^selection:/, '') in this._loadedFormatting;
    }
}
/**
 * Returns the consistent format of the list item element.
 * If the list item contains multiple blocks, it checks only the first block.
 */ function getListItemConsistentFormat(model, listItem, attributeKeys) {
    if (isFirstBlockOfListItem(listItem)) {
        return getSingleListItemConsistentFormat(model, listItem, attributeKeys);
    }
    // Always the first block of the list item should be checked for consistent formatting.
    const listItemBlocks = getAllListItemBlocks(listItem);
    return getSingleListItemConsistentFormat(model, listItemBlocks[0], attributeKeys);
}
/**
 * Returns the consistent format of a single list item element.
 */ function getSingleListItemConsistentFormat(model, listItem, attributeKeys) {
    // Only bulleted and numbered lists can have formatting (to-do lists are not supported).
    // Do not check internals of limit elements (for example, do not check table cells).
    if (!isNumberedOrBulletedList(listItem) || model.schema.isLimit(listItem)) {
        return Object.fromEntries(attributeKeys.map((attributeKey)=>[
                attributeKey
            ]));
    }
    if (listItem.isEmpty) {
        return Object.fromEntries(attributeKeys.map((attributeKey)=>[
                attributeKey,
                listItem.getAttribute(`selection:${attributeKey}`)
            ]));
    }
    const attributesToCheck = new Set(attributeKeys);
    const valuesMap = {};
    const range = model.createRangeIn(listItem);
    const walker = range.getWalker({
        ignoreElementEnd: true
    });
    for (const { item } of walker){
        for (const attributeKey of attributesToCheck){
            if (model.schema.checkAttribute(item, attributeKey)) {
                const formatAttribute = item.getAttribute(attributeKey);
                if (formatAttribute === undefined) {
                    attributesToCheck.delete(attributeKey);
                    valuesMap[attributeKey] = undefined;
                } else if (valuesMap[attributeKey] === undefined) {
                    // First item inside a list item block.
                    valuesMap[attributeKey] = formatAttribute;
                } else if (valuesMap[attributeKey] !== formatAttribute) {
                    // Following items in the same block of a list item.
                    attributesToCheck.delete(attributeKey);
                    valuesMap[attributeKey] = undefined;
                }
            } else if (!(attributeKey in valuesMap)) {
                // Store it so a format would be removed when all items in the given list item does not allow that formatting.
                valuesMap[attributeKey] = undefined;
            }
        }
        // End early if all attributes have been checked and are inconsistent.
        if (!attributesToCheck.size) {
            break;
        }
        // Jump over inline limit elements as we expect only outside them to be the same formatting.
        if (model.schema.isLimit(item)) {
            walker.jumpTo(model.createPositionAfter(item));
        }
    }
    return valuesMap;
}
/**
 * Adds the specified formatting attribute to the list item element.
 */ function setFormattingToListItem(writer, listItem, attributeKey, attributeValue) {
    // Multi-block items should have consistent formatting.
    const listItemBlocks = getAllListItemBlocks(listItem);
    let wasChanged = false;
    for (const listItem of listItemBlocks){
        if (!listItem.hasAttribute(attributeKey) || listItem.getAttribute(attributeKey) !== attributeValue) {
            writer.setAttribute(attributeKey, attributeValue, listItem);
            wasChanged = true;
        }
    }
    return wasChanged;
}
/**
 * Removes the specified formatting attribute from the list item element.
 */ function removeFormattingFromListItem(writer, listItem, attributeKey) {
    // Multi-block items should have consistent formatting.
    const listItemBlocks = getAllListItemBlocks(listItem);
    let wasChanged = false;
    for (const listItem of listItemBlocks){
        if (listItem.hasAttribute(attributeKey)) {
            writer.removeAttribute(attributeKey, listItem);
            wasChanged = true;
        }
    }
    return wasChanged;
}
/**
 * Checks if the given list type is a numbered or bulleted list.
 */ function isNumberedOrBulletedList(listItem) {
    return [
        'numbered',
        'bulleted',
        'customNumbered',
        'customBulleted'
    ].includes(listItem.getAttribute('listType'));
}

/**
 * A set of helpers related to document lists.
 */ class ListUtils extends Plugin {
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'ListUtils';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * Expands the given list of selected blocks to include all the items of the lists they're in.
	 *
	 * @param blocks The list of selected blocks.
	 */ expandListBlocksToCompleteList(blocks) {
        return expandListBlocksToCompleteList(blocks);
    }
    /**
	 * Check if the given block is the first in the list item.
	 *
	 * @param listBlock The list block element.
	 */ isFirstBlockOfListItem(listBlock) {
        return isFirstBlockOfListItem(listBlock);
    }
    /**
	 * Returns true if the given model node is a list item block.
	 *
	 * @param node A model node.
	 */ isListItemBlock(node) {
        return isListItemBlock(node);
    }
    /**
	 * Expands the given list of selected blocks to include the leading and tailing blocks of partially selected list items.
	 *
	 * @param blocks The list of selected blocks.
	 * @param options.withNested Whether should include nested list items.
	 */ expandListBlocksToCompleteItems(blocks, options = {}) {
        return expandListBlocksToCompleteItems(blocks, options);
    }
    /**
	 * Returns true if listType is of type `numbered` or `customNumbered`.
	 */ isNumberedListType(listType) {
        return isNumberedListType(listType);
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /**
 * @module list/list/utils/view
 */ /**
 * Checks if view element is a list type (ul or ol).
 *
 * @internal
 */ function isListView(viewElement) {
    return viewElement.is('element', 'ol') || viewElement.is('element', 'ul');
}
/**
 * Checks if view element is a list item (li).
 *
 * @internal
 */ function isListItemView(viewElement) {
    return viewElement.is('element', 'li');
}
/**
 * Calculates the indent value for a list item. Handles HTML compliant and non-compliant lists.
 *
 * Also, fixes non HTML compliant lists indents:
 *
 * ```
 * before:                                     fixed list:
 * OL                                          OL
 * |-> LI (parent LIs: 0)                      |-> LI     (indent: 0)
 *     |-> OL                                  |-> OL
 *         |-> OL                                  |
 *         |   |-> OL                              |
 *         |       |-> OL                          |
 *         |           |-> LI (parent LIs: 1)      |-> LI (indent: 1)
 *         |-> LI (parent LIs: 1)                  |-> LI (indent: 1)
 *
 * before:                                     fixed list:
 * OL                                          OL
 * |-> OL                                      |
 *     |-> OL                                  |
 *          |-> OL                             |
 *              |-> LI (parent LIs: 0)         |-> LI        (indent: 0)
 *
 * before:                                     fixed list:
 * OL                                          OL
 * |-> LI (parent LIs: 0)                      |-> LI         (indent: 0)
 * |-> OL                                          |-> OL
 *     |-> LI (parent LIs: 0)                          |-> LI (indent: 1)
 * ```
 *
 * @internal
 */ function getIndent$1(listItem) {
    let indent = 0;
    let parent = listItem.parent;
    while(parent){
        // Each LI in the tree will result in an increased indent for HTML compliant lists.
        if (isListItemView(parent)) {
            indent++;
        } else {
            // If however the list is nested in other list we should check previous sibling of any of the list elements...
            const previousSibling = parent.previousSibling;
            // ...because the we might need increase its indent:
            //		before:                           fixed list:
            //		OL                                OL
            //		|-> LI (parent LIs: 0)            |-> LI         (indent: 0)
            //		|-> OL                                |-> OL
            //		    |-> LI (parent LIs: 0)                |-> LI (indent: 1)
            if (previousSibling && isListItemView(previousSibling)) {
                indent++;
            }
        }
        parent = parent.parent;
    }
    return indent;
}
/**
 * Creates a list attribute element (ol or ul).
 *
 * @internal
 */ function createListElement(writer, indent, type, id = getViewElementIdForListType(type, indent)) {
    // Negative priorities so that restricted editing attribute won't wrap lists.
    return writer.createAttributeElement(getViewElementNameForListType(type), null, {
        priority: 2 * indent / 100 - 100,
        id
    });
}
/**
 * Creates a list item attribute element (li).
 *
 * @internal
 */ function createListItemElement(writer, indent, id) {
    // Negative priorities so that restricted editing attribute won't wrap list items.
    return writer.createAttributeElement('li', null, {
        priority: (2 * indent + 1) / 100 - 100,
        id
    });
}
/**
 * Returns a view element name for the given list type.
 *
 * @internal
 */ function getViewElementNameForListType(type) {
    return type == 'numbered' || type == 'customNumbered' ? 'ol' : 'ul';
}
/**
 * Returns a view element ID for the given list type and indent.
 *
 * @internal
 */ function getViewElementIdForListType(type, indent) {
    return `list-${type}-${indent}`;
}

/**
 * Based on the provided positions looks for the list head and stores it in the provided map.
 *
 * @internal
 * @param position The search starting position.
 * @param itemToListHead The map from list item element to the list head element.
 * @param visited A set of elements that were already visited.
 */ function findAndAddListHeadToMap(position, itemToListHead, visited) {
    const previousNode = position.nodeBefore;
    if (!isListItemBlock(previousNode)) {
        const item = position.nodeAfter;
        if (isListItemBlock(item)) {
            itemToListHead.add(item);
        }
    } else {
        let listHead = previousNode;
        // Previously, the loop below was defined like this:
        //
        // 		for ( { node: listHead } of new SiblingListBlocksIterator( listHead, 'backward' ) )
        //
        // Unfortunately, such a destructuring is incorrectly transpiled by Babel and the loop never ends.
        // See: https://github.com/ckeditor/ckeditor5-react/issues/345.
        for (const { node } of new SiblingListBlocksIterator(listHead, 'backward')){
            listHead = node;
            if (visited.has(listHead)) {
                return;
            }
            visited.add(listHead);
            if (itemToListHead.has(previousNode)) {
                return;
            }
        }
        itemToListHead.add(listHead);
    }
}
/**
 * Scans the list starting from the given list head element and fixes items' indentation.
 *
 * @internal
 * @param listNodes The iterable of list nodes.
 * @param writer The model writer.
 * @returns Whether the model was modified.
 */ function fixListIndents(listNodes, writer) {
    let maxIndent = 0; // Guards local sublist max indents that need fixing.
    let prevIndent = -1; // Previous item indent.
    let fixBy = null;
    let applied = false;
    for (const { node } of listNodes){
        const itemIndent = node.getAttribute('listIndent');
        if (itemIndent > maxIndent) {
            let newIndent;
            if (fixBy === null) {
                fixBy = itemIndent - maxIndent;
                newIndent = maxIndent;
            } else {
                if (fixBy > itemIndent) {
                    fixBy = itemIndent;
                }
                newIndent = itemIndent - fixBy;
            }
            if (newIndent > prevIndent + 1) {
                newIndent = prevIndent + 1;
            }
            writer.setAttribute('listIndent', newIndent, node);
            applied = true;
            prevIndent = newIndent;
        } else {
            fixBy = null;
            maxIndent = itemIndent + 1;
            prevIndent = itemIndent;
        }
    }
    return applied;
}
/**
 * Scans the list starting from the given list head element and fixes items' types.
 *
 * @internal
 * @param listNodes The iterable of list nodes.
 * @param seenIds The set of already known IDs.
 * @param writer The model writer.
 * @returns Whether the model was modified.
 */ function fixListItemIds(listNodes, seenIds, writer) {
    const visited = new Set();
    let applied = false;
    for (const { node } of listNodes){
        if (visited.has(node)) {
            continue;
        }
        let listType = node.getAttribute('listType');
        let listItemId = node.getAttribute('listItemId');
        // Use a new ID if this one was spot earlier (even in other list).
        if (seenIds.has(listItemId)) {
            listItemId = ListItemUid.next();
        }
        seenIds.add(listItemId);
        // Make sure that all items in a simple list have unique IDs.
        if (node.is('element', 'listItem')) {
            if (node.getAttribute('listItemId') != listItemId) {
                writer.setAttribute('listItemId', listItemId, node);
                applied = true;
            }
            continue;
        }
        for (const block of getListItemBlocks(node, {
            direction: 'forward'
        })){
            visited.add(block);
            // Use a new ID if a block of a bigger list item has different type.
            if (block.getAttribute('listType') != listType) {
                listItemId = ListItemUid.next();
                listType = block.getAttribute('listType');
            }
            if (block.getAttribute('listItemId') != listItemId) {
                writer.setAttribute('listItemId', listItemId, block);
                applied = true;
            }
        }
    }
    return applied;
}

/**
 * Returns the upcast converter for list items. It's supposed to work after the block converters (content inside list items) are converted.
 *
 * @internal
 */ function listItemUpcastConverter() {
    return (evt, data, conversionApi)=>{
        const { writer, schema } = conversionApi;
        if (!data.modelRange) {
            return;
        }
        const items = Array.from(data.modelRange.getItems({
            shallow: true
        })).filter((item)=>schema.checkAttribute(item, 'listItemId'));
        if (!items.length) {
            return;
        }
        const listItemId = data.viewItem.getAttribute('data-list-item-id') || ListItemUid.next();
        conversionApi.consumable.consume(data.viewItem, {
            attributes: 'data-list-item-id'
        });
        const listIndent = getIndent$1(data.viewItem);
        let listType = data.viewItem.parent && data.viewItem.parent.is('element', 'ol') ? 'numbered' : 'bulleted';
        // Preserve list type if was already set (for example by to-do list feature).
        const firstItemListType = items[0].getAttribute('listType');
        if (firstItemListType) {
            listType = firstItemListType;
        }
        const attributes = {
            listItemId,
            listIndent,
            listType
        };
        for (const item of items){
            // Set list attributes only on same level items, those nested deeper are already handled by the recursive conversion.
            if (!item.hasAttribute('listItemId')) {
                writer.setAttributes(attributes, item);
            }
        }
        if (items.length > 1) {
            // Make sure that list item that contain only nested list will preserve paragraph for itself:
            //	<ul>
            //		<li>
            //			<p></p>  <-- this one must be kept
            //			<ul>
            //				<li></li>
            //			</ul>
            //		</li>
            //	</ul>
            if (items[1].getAttribute('listItemId') != attributes.listItemId) {
                conversionApi.keepEmptyElement(items[0]);
            }
        }
    };
}
/**
 * Returns a model document change:data event listener that triggers conversion of related items if needed.
 *
 * @internal
 * @param model The editor model.
 * @param editing The editing controller.
 * @param attributeNames The list of all model list attributes (including registered strategies).
 * @param listEditing The document list editing plugin.
 */ function reconvertItemsOnDataChange(model, editing, attributeNames, listEditing) {
    return ()=>{
        const changes = model.document.differ.getChanges();
        const itemsToRefresh = [];
        const itemToListHead = new Set();
        const changedItems = new Set();
        const visited = new Set();
        for (const entry of changes){
            if (entry.type == 'insert' && entry.name != '$text') {
                findAndAddListHeadToMap(entry.position, itemToListHead, visited);
                // Insert of a non-list item.
                if (!entry.attributes.has('listItemId')) {
                    findAndAddListHeadToMap(entry.position.getShiftedBy(entry.length), itemToListHead, visited);
                } else {
                    changedItems.add(entry.position.nodeAfter);
                }
            } else if (entry.type == 'remove' && entry.attributes.has('listItemId')) {
                findAndAddListHeadToMap(entry.position, itemToListHead, visited);
            } else if (entry.type == 'attribute') {
                const item = entry.range.start.nodeAfter;
                if (attributeNames.includes(entry.attributeKey)) {
                    findAndAddListHeadToMap(entry.range.start, itemToListHead, visited);
                    if (entry.attributeNewValue === null) {
                        findAndAddListHeadToMap(entry.range.start.getShiftedBy(1), itemToListHead, visited);
                        // Check if paragraph should be converted from bogus to plain paragraph.
                        if (doesItemBlockRequiresRefresh(item)) {
                            itemsToRefresh.push(item);
                        }
                    } else {
                        changedItems.add(item);
                    }
                } else if (isListItemBlock(item)) {
                    // Some other attribute was changed on the list item,
                    // check if paragraph does not need to be converted to bogus or back.
                    if (doesItemBlockRequiresRefresh(item)) {
                        itemsToRefresh.push(item);
                    }
                }
            }
        }
        for (const listHead of itemToListHead.values()){
            itemsToRefresh.push(...collectListItemsToRefresh(listHead, changedItems));
        }
        for (const item of new Set(itemsToRefresh)){
            editing.reconvertItem(item);
        }
    };
    function collectListItemsToRefresh(listHead, changedItems) {
        const itemsToRefresh = [];
        const visited = new Set();
        const stack = [];
        for (const { node, previous } of new SiblingListBlocksIterator(listHead)){
            if (visited.has(node)) {
                continue;
            }
            const itemIndent = node.getAttribute('listIndent');
            // Current node is at the lower indent so trim the stack.
            if (previous && itemIndent < previous.getAttribute('listIndent')) {
                stack.length = itemIndent + 1;
            }
            // Update the stack for the current indent level.
            stack[itemIndent] = {
                modelAttributes: Object.fromEntries(Array.from(node.getAttributes()).filter(([key])=>attributeNames.includes(key))),
                modelElement: node
            };
            // Find all blocks of the current node.
            const blocks = getListItemBlocks(node, {
                direction: 'forward'
            });
            for (const block of blocks){
                visited.add(block);
                // Check if bogus vs plain paragraph needs refresh.
                if (doesItemBlockRequiresRefresh(block, blocks)) {
                    itemsToRefresh.push(block);
                } else if (doesItemWrappingRequiresRefresh(block, stack, changedItems)) {
                    itemsToRefresh.push(block);
                }
            }
        }
        return itemsToRefresh;
    }
    function doesItemBlockRequiresRefresh(item, blocks) {
        const viewElement = editing.mapper.toViewElement(item);
        if (!viewElement) {
            return false;
        }
        const needsRefresh = listEditing.fire('checkElement', {
            modelElement: item,
            viewElement
        });
        if (needsRefresh) {
            return true;
        }
        if (!item.is('element', 'paragraph') && !item.is('element', 'listItem')) {
            return false;
        }
        const useBogus = shouldUseBogusParagraph(item, attributeNames, blocks);
        if (useBogus && viewElement.is('element', 'p')) {
            return true;
        } else if (!useBogus && viewElement.is('element', 'span')) {
            return true;
        }
        return false;
    }
    function doesItemWrappingRequiresRefresh(item, stack, changedItems) {
        // Items directly affected by some "change" don't need a refresh, they will be converted by their own changes.
        if (changedItems.has(item)) {
            return false;
        }
        const viewElement = editing.mapper.toViewElement(item);
        let indent = stack.length - 1;
        // Traverse down the stack to the root to verify if all ULs, OLs, and LIs are as expected.
        for(let element = viewElement.parent; !element.is('editableElement'); element = element.parent){
            const isListItemElement = isListItemView(element);
            const isListElement = isListView(element);
            if (!isListElement && !isListItemElement) {
                continue;
            }
            const eventName = `checkAttributes:${isListItemElement ? 'item' : 'list'}`;
            const needsRefresh = listEditing.fire(eventName, {
                viewElement: element,
                modelAttributes: stack[indent].modelAttributes,
                modelReferenceElement: stack[indent].modelElement
            });
            if (needsRefresh) {
                break;
            }
            if (isListElement) {
                indent--;
                // Don't need to iterate further if we already know that the item is wrapped appropriately.
                if (indent < 0) {
                    return false;
                }
            }
        }
        return true;
    }
}
/**
 * Returns the list item downcast converter.
 *
 * @internal
 * @param attributeNames A list of attribute names that should be converted if they are set.
 * @param strategies The strategies.
 * @param model The model.
 */ function listItemDowncastConverter(attributeNames, strategies, model, { dataPipeline } = {}) {
    const consumer = createAttributesConsumer(attributeNames);
    return (evt, data, conversionApi)=>{
        const { writer, mapper, consumable } = conversionApi;
        const listItem = data.item;
        if (!attributeNames.includes(data.attributeKey)) {
            return;
        }
        // Test if attributes on the converted items are not consumed.
        if (!consumer(listItem, consumable)) {
            return;
        }
        const options = {
            ...conversionApi.options,
            dataPipeline
        };
        // Use positions mapping instead of mapper.toViewElement( listItem ) to find outermost view element.
        // This is for cases when mapping is using inner view element like in the code blocks (pre > code).
        const viewElement = findMappedViewElement(listItem, mapper, model);
        // Remove custom item marker.
        removeCustomMarkerElements(viewElement, writer, mapper);
        // Unwrap element from current list wrappers.
        unwrapListItemBlock(viewElement, writer);
        // Insert custom item marker.
        const viewRange = insertCustomMarkerElements(listItem, viewElement, strategies, writer, options);
        // Then wrap them with the new list wrappers (UL, OL, LI).
        wrapListItemBlock(listItem, viewRange, strategies, writer, options);
    };
}
/**
 * The 'remove' downcast converter for custom markers.
 *
 * @internal
 */ function listItemDowncastRemoveConverter(schema) {
    return (evt, data, conversionApi)=>{
        const { writer, mapper } = conversionApi;
        const elementName = evt.name.split(':')[1];
        // Do not remove marker if the deleted element is some inline object inside paragraph.
        // See https://github.com/ckeditor/ckeditor5-internal/issues/3680.
        if (!schema.checkAttribute(elementName, 'listItemId')) {
            return;
        }
        // Find the view range start position by mapping the model position at which the remove happened.
        const viewStart = mapper.toViewPosition(data.position);
        const modelEnd = data.position.getShiftedBy(data.length);
        const viewEnd = mapper.toViewPosition(modelEnd, {
            isPhantom: true
        });
        // Trim the range to remove in case some UI elements are on the view range boundaries.
        const viewRange = writer.createRange(viewStart, viewEnd).getTrimmed();
        // Use positions mapping instead of mapper.toViewElement( listItem ) to find outermost view element.
        // This is for cases when mapping is using inner view element like in the code blocks (pre > code).
        const viewElement = viewRange.end.nodeBefore;
        /* istanbul ignore next -- @preserve */ if (!viewElement) {
            return;
        }
        // Remove custom item marker.
        removeCustomMarkerElements(viewElement, writer, mapper);
    };
}
/**
 * Returns the bogus paragraph view element creator. A bogus paragraph is used if a list item contains only a single block or nested list.
 *
 * @internal
 * @param attributeNames The list of all model list attributes (including registered strategies).
 */ function bogusParagraphCreator(attributeNames, { dataPipeline } = {}) {
    return (modelElement, { writer })=>{
        // Convert only if a bogus paragraph should be used.
        if (!shouldUseBogusParagraph(modelElement, attributeNames)) {
            return null;
        }
        if (!dataPipeline) {
            return writer.createContainerElement('span', {
                class: 'ck-list-bogus-paragraph'
            });
        }
        // Using `<p>` in case there are some markers on it and transparentRendering will render it anyway.
        const viewElement = writer.createContainerElement('p');
        writer.setCustomProperty('dataPipeline:transparentRendering', true, viewElement);
        return viewElement;
    };
}
/**
 * Helper for mapping mode to view elements. It's using positions mapping instead of mapper.toViewElement( element )
 * to find outermost view element. This is for cases when mapping is using inner view element like in the code blocks (pre > code).
 *
 * @internal
 * @param element The model element.
 * @param mapper The mapper instance.
 * @param model The model.
 */ function findMappedViewElement(element, mapper, model) {
    const modelRange = model.createRangeOn(element);
    const viewRange = mapper.toViewRange(modelRange).getTrimmed();
    return viewRange.end.nodeBefore;
}
/**
 * The model to view custom position mapping for cases when marker is injected at the beginning of a block.
 *
 * @internal
 */ function createModelToViewPositionMapper(strategies, view) {
    return (evt, data)=>{
        if (data.modelPosition.offset > 0) {
            return;
        }
        const positionParent = data.modelPosition.parent;
        if (!isListItemBlock(positionParent)) {
            return;
        }
        if (!strategies.some((strategy)=>strategy.scope == 'itemMarker' && strategy.canInjectMarkerIntoElement && strategy.canInjectMarkerIntoElement(positionParent))) {
            return;
        }
        const viewElement = data.mapper.toViewElement(positionParent);
        const viewRange = view.createRangeIn(viewElement);
        const viewWalker = viewRange.getWalker();
        let positionAfterLastMarker = viewRange.start;
        for (const { item } of viewWalker){
            // Walk only over the non-mapped elements (UIElements, ViewAttributeElements, $text, or any other element without mapping).
            if (item.is('element') && data.mapper.toModelElement(item) || item.is('$textProxy')) {
                break;
            }
            if (item.is('element') && item.getCustomProperty('listItemMarker')) {
                positionAfterLastMarker = view.createPositionAfter(item);
                // Jump over the content of the marker (this is not needed for UIElement but required for other element types).
                viewWalker.skip(({ previousPosition })=>!previousPosition.isEqual(positionAfterLastMarker));
            }
        }
        data.viewPosition = positionAfterLastMarker;
    };
}
/**
 * Removes a custom marker elements and item wrappers related to that marker.
 */ function removeCustomMarkerElements(viewElement, viewWriter, mapper) {
    // Remove item wrapper.
    while(viewElement.parent.is('attributeElement') && viewElement.parent.getCustomProperty('listItemWrapper')){
        viewWriter.unwrap(viewWriter.createRangeOn(viewElement), viewElement.parent);
    }
    // Remove custom item markers.
    const markersToRemove = [];
    // Markers before a block.
    collectMarkersToRemove(viewWriter.createPositionBefore(viewElement).getWalker({
        direction: 'backward'
    }));
    // Markers inside a block.
    collectMarkersToRemove(viewWriter.createRangeIn(viewElement).getWalker());
    for (const marker of markersToRemove){
        viewWriter.remove(marker);
    }
    function collectMarkersToRemove(viewWalker) {
        for (const { item } of viewWalker){
            // Walk only over the non-mapped elements (UIElements, ViewAttributeElements, $text, or any other element without mapping).
            if (item.is('element') && mapper.toModelElement(item)) {
                break;
            }
            if (item.is('element') && item.getCustomProperty('listItemMarker')) {
                markersToRemove.push(item);
            }
        }
    }
}
/**
 * Inserts a custom marker elements and wraps first block of a list item if marker requires it.
 */ function insertCustomMarkerElements(listItem, viewElement, strategies, writer, { dataPipeline }) {
    let viewRange = writer.createRangeOn(viewElement);
    // Marker can be inserted only before the first block of a list item.
    if (!isFirstBlockOfListItem(listItem)) {
        return viewRange;
    }
    for (const strategy of strategies){
        if (strategy.scope != 'itemMarker') {
            continue;
        }
        // Create the custom marker element and inject it before the first block of the list item.
        const markerElement = strategy.createElement(writer, listItem, {
            dataPipeline
        });
        if (!markerElement) {
            continue;
        }
        writer.setCustomProperty('listItemMarker', true, markerElement);
        if (strategy.canInjectMarkerIntoElement && strategy.canInjectMarkerIntoElement(listItem)) {
            writer.insert(writer.createPositionAt(viewElement, 0), markerElement);
        } else {
            writer.insert(viewRange.start, markerElement);
            viewRange = writer.createRange(writer.createPositionBefore(markerElement), writer.createPositionAfter(viewElement));
        }
        // Wrap the marker and optionally the first block with an attribute element (label for to-do lists).
        if (!strategy.createWrapperElement || !strategy.canWrapElement) {
            continue;
        }
        const wrapper = strategy.createWrapperElement(writer, listItem, {
            dataPipeline
        });
        writer.setCustomProperty('listItemWrapper', true, wrapper);
        // The whole block can be wrapped...
        if (strategy.canWrapElement(listItem)) {
            viewRange = writer.wrap(viewRange, wrapper);
        } else {
            // ... or only the marker element (if the block is downcasted to heading or block widget).
            viewRange = writer.wrap(writer.createRangeOn(markerElement), wrapper);
            viewRange = writer.createRange(viewRange.start, writer.createPositionAfter(viewElement));
        }
    }
    return viewRange;
}
/**
 * Unwraps all ol, ul, and li attribute elements that are wrapping the provided view element.
 */ function unwrapListItemBlock(viewElement, viewWriter) {
    let attributeElement = viewElement.parent;
    while(attributeElement.is('attributeElement') && [
        'ul',
        'ol',
        'li'
    ].includes(attributeElement.name)){
        const parentElement = attributeElement.parent;
        viewWriter.unwrap(viewWriter.createRangeOn(viewElement), attributeElement);
        attributeElement = parentElement;
    }
}
/**
 * Wraps the given list item with appropriate attribute elements for ul, ol, and li.
 */ function wrapListItemBlock(listItem, viewRange, strategies, writer, options) {
    if (!listItem.hasAttribute('listIndent')) {
        return;
    }
    const listItemIndent = listItem.getAttribute('listIndent');
    let currentListItem = listItem;
    for(let indent = listItemIndent; indent >= 0; indent--){
        const listItemViewElement = createListItemElement(writer, indent, currentListItem.getAttribute('listItemId'));
        const listViewElement = createListElement(writer, indent, currentListItem.getAttribute('listType'));
        for (const strategy of strategies){
            if ((strategy.scope == 'list' || strategy.scope == 'item') && currentListItem.hasAttribute(strategy.attributeName)) {
                strategy.setAttributeOnDowncast(writer, currentListItem.getAttribute(strategy.attributeName), strategy.scope == 'list' ? listViewElement : listItemViewElement, options);
            }
        }
        viewRange = writer.wrap(viewRange, listItemViewElement);
        viewRange = writer.wrap(viewRange, listViewElement);
        if (indent == 0) {
            break;
        }
        currentListItem = ListWalker.first(currentListItem, {
            lowerIndent: true
        });
        // There is no list item with lower indent, this means this is a document fragment containing
        // only a part of nested list (like copy to clipboard) so we don't need to try to wrap it further.
        if (!currentListItem) {
            break;
        }
    }
}
// Returns the function that is responsible for consuming attributes that are set on the model node.
function createAttributesConsumer(attributeNames) {
    return (node, consumable)=>{
        const events = [];
        // Collect all set attributes that are triggering conversion.
        for (const attributeName of attributeNames){
            if (node.hasAttribute(attributeName)) {
                events.push(`attribute:${attributeName}`);
            }
        }
        if (!events.every((event)=>consumable.test(node, event) !== false)) {
            return false;
        }
        events.forEach((event)=>consumable.consume(node, event));
        return true;
    };
}
// Whether the given item should be rendered as a bogus paragraph.
function shouldUseBogusParagraph(item, attributeNames, blocks = getAllListItemBlocks(item)) {
    if (!isListItemBlock(item)) {
        return false;
    }
    for (const attributeKey of item.getAttributeKeys()){
        // Ignore selection attributes stored on block elements.
        if (attributeKey.startsWith('selection:') || attributeKey == 'htmlEmptyBlock') {
            continue;
        }
        // Don't use bogus paragraph if there are attributes from other features.
        if (!attributeNames.includes(attributeKey)) {
            return false;
        }
    }
    return blocks.length < 2;
}

/**
 * A list of base list model attributes.
 */ const LIST_BASE_ATTRIBUTES = [
    'listType',
    'listIndent',
    'listItemId'
];
/**
 * The editing part of the document-list feature. It handles creating, editing and removing lists and list items.
 */ class ListEditing extends Plugin {
    /**
	 * The list of registered downcast strategies.
	 */ _downcastStrategies = [];
    /**
	 * @inheritDoc
	 */ static get pluginName() {
        return 'ListEditing';
    }
    /**
	 * @inheritDoc
	 */ static get isOfficialPlugin() {
        return true;
    }
    /**
	 * @inheritDoc
	 */ static get requires() {
        return [
            Enter,
            Delete,
            ListUtils,
            ClipboardPipeline,
            ListFormatting
        ];
    }
    /**
	 * @inheritDoc
	 */ constructor(editor){
        super(editor);
        editor.config.define('list.multiBlock', true);
    }
    /**
	 * @inheritDoc
	 */ init() {
        const editor = this.editor;
        const model = editor.model;
        const multiBlock = editor.config.get('list.multiBlock');
        if (editor.plugins.has('LegacyListEditing')) {
            /**
			 * The `List` feature cannot be loaded together with the `LegacyList` plugin.
			 *
			 * @error list-feature-conflict
			 * @param {string} conflictPlugin Name of the plugin.
			 */ throw new CKEditorError('list-feature-conflict', this, {
                conflictPlugin: 'LegacyListEditing'
            });
        }
        model.schema.register('$listItem', {
            allowAttributes: LIST_BASE_ATTRIBUTES
        });
        if (multiBlock) {
            model.schema.extend('$container', {
                allowAttributesOf: '$listItem'
            });
            model.schema.extend('$block', {
                allowAttributesOf: '$listItem'
            });
            model.schema.extend('$blockObject', {
                allowAttributesOf: '$listItem'
            });
        } else {
            model.schema.register('listItem', {
                inheritAllFrom: '$block',
                allowAttributesOf: '$listItem'
            });
        }
        for (const attribute of LIST_BASE_ATTRIBUTES){
            model.schema.setAttributeProperties(attribute, {
                copyOnReplace: true
            });
        }
        // Register commands.
        editor.commands.add('numberedList', new ListCommand(editor, 'numbered'));
        editor.commands.add('bulletedList', new ListCommand(editor, 'bulleted'));
        editor.commands.add('customNumberedList', new ListCommand(editor, 'customNumbered', {
            multiLevel: true
        }));
        editor.commands.add('customBulletedList', new ListCommand(editor, 'customBulleted', {
            multiLevel: true
        }));
        editor.commands.add('indentList', new ListIndentCommand(editor, 'forward'));
        editor.commands.add('outdentList', new ListIndentCommand(editor, 'backward'));
        editor.commands.add('splitListItemBefore', new ListSplitCommand(editor, 'before'));
        editor.commands.add('splitListItemAfter', new ListSplitCommand(editor, 'after'));
        if (multiBlock) {
            editor.commands.add('mergeListItemBackward', new ListMergeCommand(editor, 'backward'));
            editor.commands.add('mergeListItemForward', new ListMergeCommand(editor, 'forward'));
        }
        this._setupDeleteIntegration();
        this._setupEnterIntegration();
        this._setupTabIntegration();
        this._setupClipboardIntegration();
        this._setupAccessibilityIntegration();
        this._setupListItemIdConversionStrategy();
    }
    /**
	 * @inheritDoc
	 */ afterInit() {
        const editor = this.editor;
        const commands = editor.commands;
        const indent = commands.get('indent');
        const outdent = commands.get('outdent');
        if (indent) {
            // Priority is high due to integration with `IndentBlock` plugin. We want to indent list first and if it's not possible
            // user can indent content with `IndentBlock` plugin.
            indent.registerChildCommand(commands.get('indentList'), {
                priority: 'high'
            });
        }
        if (outdent) {
            // Priority is lowest due to integration with `IndentBlock` and `IndentCode` plugins.
            // First we want to allow user to outdent all indendations from other features then he can oudent list item.
            outdent.registerChildCommand(commands.get('outdentList'), {
                priority: 'lowest'
            });
        }
        // Register conversion and model post-fixer after other plugins had a chance to register their attribute strategies.
        this._setupModelPostFixing();
        this._setupConversion();
    }
    /**
	 * Registers a downcast strategy.
	 *
	 * **Note**: Strategies must be registered in the `Plugin#init()` phase so that it can be applied
	 * in the `ListEditing#afterInit()`.
	 *
	 * @param strategy The downcast strategy to register.
	 */ registerDowncastStrategy(strategy) {
        this._downcastStrategies.push(strategy);
    }
    /**
	 * Returns list of model attribute names that should affect downcast conversion.
	 */ getListAttributeNames() {
        return [
            ...LIST_BASE_ATTRIBUTES,
            ...this._downcastStrategies.map((strategy)=>strategy.attributeName)
        ];
    }
    /**
	 * Attaches the listener to the {@link module:engine/view/document~ViewDocument#event:delete} event and handles backspace/delete
	 * keys in and around document lists.
	 */ _setupDeleteIntegration() {
        const editor = this.editor;
        const mergeBackwardCommand = editor.commands.get('mergeListItemBackward');
        const mergeForwardCommand = editor.commands.get('mergeListItemForward');
        this.listenTo(editor.editing.view.document, 'delete', (evt, data)=>{
            const selection = editor.model.document.selection;
            // Let the Widget plugin take care of block widgets while deleting (https://github.com/ckeditor/ckeditor5/issues/11346).
            if (getSelectedBlockObject(editor.model)) {
                return;
            }
            editor.model.change(()=>{
                const firstPosition = selection.getFirstPosition();
                if (selection.isCollapsed && data.direction == 'backward') {
                    if (!firstPosition.isAtStart) {
                        return;
                    }
                    const positionParent = firstPosition.parent;
                    if (!isListItemBlock(positionParent)) {
                        return;
                    }
                    const previousBlock = ListWalker.first(positionParent, {
                        sameAttributes: 'listType',
                        sameIndent: true
                    });
                    // Outdent the first block of a first list item.
                    if (!previousBlock && positionParent.getAttribute('listIndent') === 0) {
                        if (!isLastBlockOfListItem(positionParent)) {
                            editor.execute('splitListItemAfter');
                        }
                        editor.execute('outdentList');
                    } else {
                        if (!mergeBackwardCommand || !mergeBackwardCommand.isEnabled) {
                            return;
                        }
                        mergeBackwardCommand.execute({
                            shouldMergeOnBlocksContentLevel: shouldMergeOnBlocksContentLevel(editor.model, 'backward')
                        });
                    }
                    data.preventDefault();
                    evt.stop();
                } else {
                    // Collapsed selection should trigger forward merging only if at the end of a block.
                    if (selection.isCollapsed && !selection.getLastPosition().isAtEnd) {
                        return;
                    }
                    if (!mergeForwardCommand || !mergeForwardCommand.isEnabled) {
                        return;
                    }
                    mergeForwardCommand.execute({
                        shouldMergeOnBlocksContentLevel: shouldMergeOnBlocksContentLevel(editor.model, 'forward')
                    });
                    data.preventDefault();
                    evt.stop();
                }
            });
        }, {
            context: 'li'
        });
    }
    /**
	 * Attaches a listener to the {@link module:engine/view/document~ViewDocument#event:enter} event and handles enter key press
	 * in document lists.
	 */ _setupEnterIntegration() {
        const editor = this.editor;
        const model = editor.model;
        const commands = editor.commands;
        const enterCommand = commands.get('enter');
        // Overwrite the default Enter key behavior: outdent or split the list in certain cases.
        this.listenTo(editor.editing.view.document, 'enter', (evt, data)=>{
            const doc = model.document;
            const positionParent = doc.selection.getFirstPosition().parent;
            if (doc.selection.isCollapsed && isListItemBlock(positionParent) && positionParent.isEmpty && !data.isSoft) {
                const isFirstBlock = isFirstBlockOfListItem(positionParent);
                const isLastBlock = isLastBlockOfListItem(positionParent);
                // * a            * a
                // * []           []
                if (isFirstBlock && isLastBlock) {
                    editor.execute('outdentList');
                    data.preventDefault();
                    evt.stop();
                } else if (isFirstBlock && !isLastBlock) {
                    editor.execute('splitListItemAfter');
                    data.preventDefault();
                    evt.stop();
                } else if (isLastBlock) {
                    editor.execute('splitListItemBefore');
                    data.preventDefault();
                    evt.stop();
                }
            }
        }, {
            context: 'li'
        });
        // In some cases, after the default block splitting, we want to modify the new block to become a new list item
        // instead of an additional block in the same list item.
        this.listenTo(enterCommand, 'afterExecute', ()=>{
            const splitCommand = commands.get('splitListItemBefore');
            // The command has not refreshed because the change block related to EnterCommand#execute() is not over yet.
            // Let's keep it up to date and take advantage of ListSplitCommand#isEnabled.
            splitCommand.refresh();
            if (!splitCommand.isEnabled) {
                return;
            }
            const doc = editor.model.document;
            const positionParent = doc.selection.getLastPosition().parent;
            const listItemBlocks = getAllListItemBlocks(positionParent);
            // Keep in mind this split happens after the default enter handler was executed. For instance:
            //
            //        Initial state           After default enter       Here in #afterExecute   
            // 
            //           * a[]                       * a                        * a             
            //                                         []                       * []            
            if (listItemBlocks.length === 2) {
                splitCommand.execute();
            }
        });
    }
    /**
	 * Attaches a listener to the {@link module:engine/view/document~ViewDocument#event:tab} event and handles tab key and tab+shift keys
	 * presses in document lists.
	 */ _setupTabIntegration() {
        const editor = this.editor;
        this.listenTo(editor.editing.view.document, 'tab', (evt, data)=>{
            const commandName = data.shiftKey ? 'outdentList' : 'indentList';
            const command = this.editor.commands.get(commandName);
            if (command.isEnabled) {
                editor.execute(commandName);
                data.stopPropagation();
                data.preventDefault();
                evt.stop();
            }
        }, {
            context: 'li'
        });
    }
    /**
	 * Registers the conversion helpers for the document-list feature.
	 */ _setupConversion() {
        const editor = this.editor;
        const model = editor.model;
        const attributeNames = this.getListAttributeNames();
        const multiBlock = editor.config.get('list.multiBlock');
        const elementName = multiBlock ? 'paragraph' : 'listItem';
        editor.conversion.for('upcast')// Convert <li> to a generic paragraph (or listItem element) so the content of <li> is always inside a block.
        // Setting the listType attribute to let other features (to-do list) know that this is part of a list item.
        // This is also important to properly handle simple lists so that paragraphs inside a list item won't break the list item.
        // <li>  <-- converted to listItem
        //   <p></p> <-- should be also converted to listItem, so it won't split and replace the listItem generated from the above li.
        .elementToElement({
            view: 'li',
            model: (viewElement, { writer })=>writer.createElement(elementName, {
                    listType: ''
                })
        })// Convert paragraph to the list block (without list type defined yet).
        // This is important to properly handle bogus paragraph and to-do lists.
        // Most of the time the bogus paragraph should not appear in the data of to-do list,
        // but if there is any marker or an attribute on the paragraph then the bogus paragraph
        // is preserved in the data, and we need to be able to detect this case.
        .elementToElement({
            view: 'p',
            model: (viewElement, { writer })=>{
                if (viewElement.parent && viewElement.parent.is('element', 'li')) {
                    return writer.createElement(elementName, {
                        listType: ''
                    });
                }
                return null;
            },
            converterPriority: 'high'
        }).add((dispatcher)=>{
            dispatcher.on('element:li', listItemUpcastConverter());
        });
        if (!multiBlock) {
            editor.conversion.for('downcast').elementToElement({
                model: 'listItem',
                view: 'p'
            });
        }
        editor.conversion.for('editingDowncast').elementToElement({
            model: elementName,
            view: bogusParagraphCreator(attributeNames),
            converterPriority: 'high'
        }).add((dispatcher)=>{
            dispatcher.on('attribute', listItemDowncastConverter(attributeNames, this._downcastStrategies, model));
            dispatcher.on('remove', listItemDowncastRemoveConverter(model.schema));
        });
        editor.conversion.for('dataDowncast').elementToElement({
            model: elementName,
            view: bogusParagraphCreator(attributeNames, {
                dataPipeline: true
            }),
            converterPriority: 'high'
        }).add((dispatcher)=>{
            dispatcher.on('attribute', listItemDowncastConverter(attributeNames, this._downcastStrategies, model, {
                dataPipeline: true
            }));
        });
        const modelToViewPositionMapper = createModelToViewPositionMapper(this._downcastStrategies, editor.editing.view);
        editor.editing.mapper.on('modelToViewPosition', modelToViewPositionMapper);
        editor.data.