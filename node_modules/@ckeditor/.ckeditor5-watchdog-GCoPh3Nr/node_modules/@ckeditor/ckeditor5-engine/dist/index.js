/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
import { logWarning, EmitterMixin, CKEditorError, compareArrays, toArray, toMap, isIterable, ObservableMixin, count, EventInfo, Collection, keyCodes, isText, env, remove as remove$1, insertAt, diff, fastDiff, isNode, isComment, indexOf, global, isValidAttributeName, first, getAncestors, DomEmitterMixin, getCode, isArrowKeyCode, scrollViewportToShowTarget, uid, spliceArray, priorities, isInsideSurrogatePair, isInsideCombinedSymbol, isInsideEmojiSequence } from '@ckeditor/ckeditor5-utils/dist/index.js';
import { clone, isObject, get, merge, set, isPlainObject, extend, debounce, isEqualWith, cloneDeep, isEqual } from 'es-toolkit/compat';

// Each document stores information about its placeholder elements and check functions.
const documentPlaceholders = new WeakMap();
let hasDisplayedPlaceholderDeprecationWarning = false;
/**
 * A helper that enables a placeholder on the provided view element (also updates its visibility).
 * The placeholder is a CSS pseudo–element (with a text content) attached to the element.
 *
 * To change the placeholder text, change value of the `placeholder` property in the provided `element`.
 *
 * To disable the placeholder, use {@link module:engine/view/placeholder~disableViewPlaceholder `disableViewPlaceholder()`} helper.
 *
 * @param options Configuration options of the placeholder.
 * @param options.view Editing view instance.
 * @param options.element Element that will gain a placeholder. See `options.isDirectHost` to learn more.
 * @param options.isDirectHost If set `false`, the placeholder will not be enabled directly
 * in the passed `element` but in one of its children (selected automatically, i.e. a first empty child element).
 * Useful when attaching placeholders to elements that can host other elements (not just text), for instance,
 * editable root elements.
 * @param options.text Placeholder text. It's **deprecated** and will be removed soon. Use
 * {@link module:engine/view/placeholder~PlaceholderableViewElement#placeholder `options.element.placeholder`} instead.
 * @param options.keepOnFocus If set `true`, the placeholder stay visible when the host element is focused.
 */ function enableViewPlaceholder({ view, element, text, isDirectHost = true, keepOnFocus = false }) {
    const doc = view.document;
    // Use a single post fixer per—document to update all placeholders.
    if (!documentPlaceholders.has(doc)) {
        documentPlaceholders.set(doc, new Map());
        // If a post-fixer callback makes a change, it should return `true` so other post–fixers
        // can re–evaluate the document again.
        doc.registerPostFixer((writer)=>updateDocumentPlaceholders(documentPlaceholders.get(doc), writer));
        // Update placeholders on isComposing state change since rendering is disabled while in composition mode.
        doc.on('change:isComposing', ()=>{
            view.change((writer)=>updateDocumentPlaceholders(documentPlaceholders.get(doc), writer));
        }, {
            priority: 'high'
        });
    }
    if (element.is('editableElement')) {
        element.on('change:placeholder', (evtInfo, evt, text)=>setPlaceholder(text));
    }
    if (element.placeholder) {
        setPlaceholder(element.placeholder);
    } else if (text) {
        setPlaceholder(text);
    }
    if (text) {
        showViewPlaceholderTextDeprecationWarning();
    }
    function setPlaceholder(text) {
        const config = {
            text,
            isDirectHost,
            keepOnFocus,
            hostElement: isDirectHost ? element : null
        };
        // Store information about the element placeholder under its document.
        documentPlaceholders.get(doc).set(element, config);
        // Update the placeholders right away.
        view.change((writer)=>updateDocumentPlaceholders([
                [
                    element,
                    config
                ]
            ], writer));
    }
}
/**
 * Disables the placeholder functionality from a given element.
 *
 * See {@link module:engine/view/placeholder~enableViewPlaceholder `enableViewPlaceholder()`} to learn more.
 */ function disableViewPlaceholder(view, element) {
    const doc = element.document;
    if (!documentPlaceholders.has(doc)) {
        return;
    }
    view.change((writer)=>{
        const placeholders = documentPlaceholders.get(doc);
        const config = placeholders.get(element);
        writer.removeAttribute('data-placeholder', config.hostElement);
        hideViewPlaceholder(writer, config.hostElement);
        placeholders.delete(element);
    });
}
/**
 * Shows a placeholder in the provided element by changing related attributes and CSS classes.
 *
 * **Note**: This helper will not update the placeholder visibility nor manage the
 * it in any way in the future. What it does is a one–time state change of an element. Use
 * {@link module:engine/view/placeholder~enableViewPlaceholder `enableViewPlaceholder()`} and
 * {@link module:engine/view/placeholder~disableViewPlaceholder `disableViewPlaceholder()`} for full
 * placeholder functionality.
 *
 * **Note**: This helper will blindly show the placeholder directly in the root editable element if
 * one is passed, which could result in a visual clash if the editable element has some children
 * (for instance, an empty paragraph). Use {@link module:engine/view/placeholder~enableViewPlaceholder `enableViewPlaceholder()`}
 * in that case or make sure the correct element is passed to the helper.
 *
 * @returns `true`, if any changes were made to the `element`.
 */ function showViewPlaceholder(writer, element) {
    if (!element.hasClass('ck-placeholder')) {
        writer.addClass('ck-placeholder', element);
        return true;
    }
    return false;
}
/**
 * Hides a placeholder in the element by changing related attributes and CSS classes.
 *
 * **Note**: This helper will not update the placeholder visibility nor manage the
 * it in any way in the future. What it does is a one–time state change of an element. Use
 * {@link module:engine/view/placeholder~enableViewPlaceholder `enableViewPlaceholder()`} and
 * {@link module:engine/view/placeholder~disableViewPlaceholder `disableViewPlaceholder()`} for full
 * placeholder functionality.
 *
 * @returns `true`, if any changes were made to the `element`.
 */ function hideViewPlaceholder(writer, element) {
    if (element.hasClass('ck-placeholder')) {
        writer.removeClass('ck-placeholder', element);
        return true;
    }
    return false;
}
/**
 * Checks if a placeholder should be displayed in the element.
 *
 * **Note**: This helper will blindly check the possibility of showing a placeholder directly in the
 * root editable element if one is passed, which may not be the expected result. If an element can
 * host other elements (not just text), most likely one of its children should be checked instead
 * because it will be the final host for the placeholder. Use
 * {@link module:engine/view/placeholder~enableViewPlaceholder `enableViewPlaceholder()`} in that case or make
 * sure the correct element is passed to the helper.
 *
 * @param element Element that holds the placeholder.
 * @param keepOnFocus Focusing the element will keep the placeholder visible.
 */ function needsViewPlaceholder(element, keepOnFocus) {
    if (!element.isAttached()) {
        return false;
    }
    if (hasContent(element)) {
        return false;
    }
    const doc = element.document;
    const viewSelection = doc.selection;
    const selectionAnchor = viewSelection.anchor;
    if (doc.isComposing && selectionAnchor && selectionAnchor.parent === element) {
        return false;
    }
    // Skip the focus check and make the placeholder visible already regardless of document focus state.
    if (keepOnFocus) {
        return true;
    }
    // If the document is blurred.
    if (!doc.isFocused) {
        return true;
    }
    // If document is focused and the element is empty but the selection is not anchored inside it.
    return !!selectionAnchor && selectionAnchor.parent !== element;
}
/**
 * Anything but uiElement(s) counts as content.
 */ function hasContent(element) {
    for (const child of element.getChildren()){
        if (!child.is('uiElement')) {
            return true;
        }
    }
    return false;
}
/**
 * Updates all placeholders associated with a document in a post–fixer callback.
 *
 * @returns True if any changes were made to the view document.
 */ function updateDocumentPlaceholders(placeholders, writer) {
    const directHostElements = [];
    let wasViewModified = false;
    // First set placeholders on the direct hosts.
    for (const [element, config] of placeholders){
        if (config.isDirectHost) {
            directHostElements.push(element);
            if (updatePlaceholder(writer, element, config)) {
                wasViewModified = true;
            }
        }
    }
    // Then set placeholders on the indirect hosts but only on those that does not already have an direct host placeholder.
    for (const [element, config] of placeholders){
        if (config.isDirectHost) {
            continue;
        }
        const hostElement = getChildPlaceholderHostSubstitute(element);
        // When not a direct host, it could happen that there is no child element
        // capable of displaying a placeholder.
        if (!hostElement) {
            continue;
        }
        // Don't override placeholder if the host element already has some direct placeholder.
        if (directHostElements.includes(hostElement)) {
            continue;
        }
        // Update the host element (used for setting and removing the placeholder).
        config.hostElement = hostElement;
        if (updatePlaceholder(writer, element, config)) {
            wasViewModified = true;
        }
    }
    return wasViewModified;
}
/**
 * Updates a single placeholder in a post–fixer callback.
 *
 * @returns True if any changes were made to the view document.
 */ function updatePlaceholder(writer, element, config) {
    const { text, isDirectHost, hostElement } = config;
    let wasViewModified = false;
    // This may be necessary when updating the placeholder text to something else.
    if (hostElement.getAttribute('data-placeholder') !== text) {
        writer.setAttribute('data-placeholder', text, hostElement);
        wasViewModified = true;
    }
    // If the host element is not a direct host then placeholder is needed only when there is only one element.
    const isOnlyChild = isDirectHost || element.childCount == 1;
    if (isOnlyChild && needsViewPlaceholder(hostElement, config.keepOnFocus)) {
        if (showViewPlaceholder(writer, hostElement)) {
            wasViewModified = true;
        }
    } else if (hideViewPlaceholder(writer, hostElement)) {
        wasViewModified = true;
    }
    return wasViewModified;
}
/**
 * Gets a child element capable of displaying a placeholder if a parent element can host more
 * than just text (for instance, when it is a root editable element). The child element
 * can then be used in other placeholder helpers as a substitute of its parent.
 */ function getChildPlaceholderHostSubstitute(parent) {
    if (parent.childCount) {
        const firstChild = parent.getChild(0);
        if (firstChild.is('element') && !firstChild.is('uiElement') && !firstChild.is('attributeElement')) {
            return firstChild;
        }
    }
    return null;
}
/**
 * Displays a deprecation warning message in the console, but only once per page load.
 */ function showViewPlaceholderTextDeprecationWarning() {
    if (!hasDisplayedPlaceholderDeprecationWarning) {
        /**
		 * The "text" option in the {@link module:engine/view/placeholder~enableViewPlaceholder `enableViewPlaceholder()`}
		 * function is deprecated and will be removed soon.
		 *
		 * See the {@glink updating/guides/update-to-39#view-element-placeholder Migration to v39} guide for
		 * more information on how to apply this change.
		 *
		 * @error enableViewPlaceholder-deprecated-text-option
		 */ logWarning('enableViewPlaceholder-deprecated-text-option');
    }
    hasDisplayedPlaceholderDeprecationWarning = true;
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */ /**
 * @module engine/view/typecheckable
 */ class ViewTypeCheckable {
    /* istanbul ignore next -- @preserve */ is() {
        // There are a lot of overloads above.
        // Overriding method in derived classes remove them and only `is( type: string ): boolean` is visible which we don't want.
        // One option would be to copy them all to all classes, but that's ugly.
        // It's best when TypeScript compiler doesn't see those overloads, except the one in the top base class.
        // To overload a method, but not let the compiler see it, do after class definition:
        // `MyClass.prototype.is = function( type: string ) {...}`
        throw new Error('is() method is abstract');
    }
}

/**
 * Abstract view node class.
 *
 * This is an abstract class. Its constructor should not be used directly.
 * Use the {@link module:engine/view/downcastwriter~ViewDowncastWriter} or {@link module:engine/view/upcastwriter~ViewUpcastWriter}
 * to create new instances of view nodes.
 */ class ViewNode extends /* #__PURE__ */ EmitterMixin(ViewTypeCheckable) {
    /**
	 * The document instance to which this node belongs.
	 */ document;
    /**
	 * Parent element. Null by default. Set by {@link module:engine/view/element~ViewElement#_insertChild}.
	 */ parent;
    /**
	 * Creates a tree view node.
	 *
	 * @param document The document instance to which this node belongs.
	 */ constructor(document){
        super();
        this.document = document;
        this.parent = null;
    }
    /**
	 * Index of the node in the parent element or null if the node has no parent.
	 *
	 * Accessing this property throws an error if this node's parent element does not contain it.
	 * This means that view tree got broken.
	 */ get index() {
        let pos;
        if (!this.parent) {
            return null;
        }
        // No parent or child doesn't exist in parent's children.
        if ((pos = this.parent.getChildIndex(this)) == -1) {
            /**
			 * The node's parent does not contain this node. It means that the document tree is corrupted.
			 *
			 * @error view-node-not-found-in-parent
			 */ throw new CKEditorError('view-node-not-found-in-parent', this);
        }
        return pos;
    }
    /**
	 * Node's next sibling, or `null` if it is the last child.
	 */ get nextSibling() {
        const index = this.index;
        return index !== null && this.parent.getChild(index + 1) || null;
    }
    /**
	 * Node's previous sibling, or `null` if it is the first child.
	 */ get previousSibling() {
        const index = this.index;
        return index !== null && this.parent.getChild(index - 1) || null;
    }
    /**
	 * Top-most ancestor of the node. If the node has no parent it is the root itself.
	 */ get root() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this
        let root = this;
        while(root.parent){
            root = root.parent;
        }
        return root;
    }
    /**
	 * Returns true if the node is in a tree rooted in the document (is a descendant of one of its roots).
	 */ isAttached() {
        return this.root.is('rootElement');
    }
    /**
	 * Gets a path to the node. The path is an array containing indices of consecutive ancestors of this node,
	 * beginning from {@link module:engine/view/node~ViewNode#root root}, down to this node's index.
	 *
	 * ```ts
	 * const abc = downcastWriter.createText( 'abc' );
	 * const foo = downcastWriter.createText( 'foo' );
	 * const h1 = downcastWriter.createElement( 'h1', null, downcastWriter.createText( 'header' ) );
	 * const p = downcastWriter.createElement( 'p', null, [ abc, foo ] );
	 * const div = downcastWriter.createElement( 'div', null, [ h1, p ] );
	 * foo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.
	 * h1.getPath(); // Returns [ 0 ].
	 * div.getPath(); // Returns [].
	 * ```
	 *
	 * @returns The path.
	 */ getPath() {
        const path = [];
        // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this
        let node = this;
        while(node.parent){
            path.unshift(node.index);
            node = node.parent;
        }
        return path;
    }
    /**
	 * Returns ancestors array of this node.
	 *
	 * @param options Options object.
	 * @param options.includeSelf When set to `true` this node will be also included in parent's array.
	 * @param options.parentFirst When set to `true`, array will be sorted from node's parent to root element,
	 * otherwise root element will be the first item in the array.
	 * @returns Array with ancestors.
	 */ getAncestors(options = {}) {
        const ancestors = [];
        let parent = options.includeSelf ? this : this.parent;
        while(parent){
            ancestors[options.parentFirst ? 'push' : 'unshift'](parent);
            parent = parent.parent;
        }
        return ancestors;
    }
    /**
	 * Returns a {@link module:engine/view/element~ViewElement} or {@link module:engine/view/documentfragment~ViewDocumentFragment}
	 * which is a common ancestor of both nodes.
	 *
	 * @param node The second node.
	 * @param options Options object.
	 * @param options.includeSelf When set to `true` both nodes will be considered "ancestors" too.
	 * Which means that if e.g. node A is inside B, then their common ancestor will be B.
	 */ getCommonAncestor(node, options = {}) {
        const ancestorsA = this.getAncestors(options);
        const ancestorsB = node.getAncestors(options);
        let i = 0;
        while(ancestorsA[i] == ancestorsB[i] && ancestorsA[i]){
            i++;
        }
        return i === 0 ? null : ancestorsA[i - 1];
    }
    /**
	 * Returns whether this node is before given node. `false` is returned if nodes are in different trees (for example,
	 * in different {@link module:engine/view/documentfragment~ViewDocumentFragment}s).
	 *
	 * @param node Node to compare with.
	 */ isBefore(node) {
        // Given node is not before this node if they are same.
        if (this == node) {
            return false;
        }
        // Return `false` if it is impossible to compare nodes.
        if (this.root !== node.root) {
            return false;
        }
        const thisPath = this.getPath();
        const nodePath = node.getPath();
        const result = compareArrays(thisPath, nodePath);
        switch(result){
            case 'prefix':
                return true;
            case 'extension':
                return false;
            default:
                return thisPath[result] < nodePath[result];
        }
    }
    /**
	 * Returns whether this node is after given node. `false` is returned if nodes are in different trees (for example,
	 * in different {@link module:engine/view/documentfragment~ViewDocumentFragment}s).
	 *
	 * @param node Node to compare with.
	 */ isAfter(node) {
        // Given node is not before this node if they are same.
        if (this == node) {
            return false;
        }
        // Return `false` if it is impossible to compare nodes.
        if (this.root !== node.root) {
            return false;
        }
        // In other cases, just check if the `node` is before, and return the opposite.
        return !this.isBefore(node);
    }
    /**
	 * Removes node from parent.
	 *
	 * @internal
	 */ _remove() {
        this.parent._removeChildren(this.index);
    }
    /**
	 * @internal
	 * @param type Type of the change.
	 * @param node Changed node.
	 * @param data Additional data.
	 * @fires change
	 */ _fireChange(type, node, data) {
        this.fire(`change:${type}`, node, data);
        if (this.parent) {
            this.parent._fireChange(type, node, data);
        }
    }
    /**
	 * Custom toJSON method to solve child-parent circular dependencies.
	 *
	 * @returns Clone of this object with the parent property removed.
	 */ toJSON() {
        const json = clone(this);
        // Due to circular references we need to remove parent reference.
        delete json.parent;
        return json;
    }
}
// The magic of type inference using `is` method is centralized in `TypeCheckable` class.
// Proper overload would interfere with that.
ViewNode.prototype.is = function(type) {
    return type === 'node' || type === 'view:node';
};

/**
 * Tree view text node.
 *
 * The constructor of this class should not be used directly. To create a new text node instance
 * use the {@link module:engine/view/downcastwriter~ViewDowncastWriter#createText `ViewDowncastWriter#createText()`}
 * method when working on data downcasted from the model or the
 * {@link module:engine/view/upcastwriter~ViewUpcastWriter#createText `ViewUpcastWriter#createText()`}
 * method when working on non-semantic views.
 */ class ViewText extends ViewNode {
    /**
	 * The text content.
	 *
	 * Setting the data fires the {@link module:engine/view/node~ViewNode#event:change:text change event}.
	 */ _textData;
    /**
	 * Creates a tree view text node.
	 *
	 * @see module:engine/view/downcastwriter~ViewDowncastWriter#createText
	 * @internal
	 * @param document The document instance to which this text node belongs.
	 * @param data The text's data.
	 */ constructor(document, data){
        super(document);
        this._textData = data;
    }
    /**
	 * The text content.
	 */ get data() {
        return this._textData;
    }
    /**
	 * The `_data` property is controlled by a getter and a setter.
	 *
	 * The getter is required when using the addition assignment operator on protected property:
	 *
	 * ```ts
	 * const foo = downcastWriter.createText( 'foo' );
	 * const bar = downcastWriter.createText( 'bar' );
	 *
	 * foo._data += bar.data;   // executes: `foo._data = foo._data + bar.data`
	 * console.log( foo.data ); // prints: 'foobar'
	 * ```
	 *
	 * If the protected getter didn't exist, `foo._data` will return `undefined` and result of the merge will be invalid.
	 *
	 * The setter sets data and fires the {@link module:engine/view/node~ViewNode#event:change:text change event}.
	 *
	 * @internal
	 */ get _data() {
        return this.data;
    }
    set _data(data) {
        this._fireChange('text', this);
        this._textData = data;
    }
    /**
	 * Checks if this text node is similar to other text node.
	 * Both nodes should have the same data to be considered as similar.
	 *
	 * @param otherNode Node to check if it is same as this node.
	 */ isSimilar(otherNode) {
        if (!(otherNode instanceof ViewText)) {
            return false;
        }
        return this === otherNode || this.data === otherNode.data;
    }
    /**
	 * Clones this node.
	 *
	 * @internal
	 * @returns Text node that is a clone of this node.
	 */ _clone() {
        return new ViewText(this.document, this.data);
    }
}
// The magic of type inference using `is` method is centralized in `TypeCheckable` class.
// Proper overload would interfere with that.
ViewText.prototype.is = function(type) {
    return type === '$text' || type === 'view:$text' || // This are legacy values kept for backward compatibility.
    type === 'text' || type === 'view:text' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === 'node' || type === 'view:node';
};

/**
 * ViewTextProxy is a wrapper for substring of {@link module:engine/view/text~ViewText}. Instance of this class is created by
 * {@link module:engine/view/treewalker~ViewTreeWalker} when only a part of {@link module:engine/view/text~ViewText} needs to be returned.
 *
 * `ViewTextProxy` has an API similar to {@link module:engine/view/text~ViewText Text} and allows to do most of the common tasks performed
 * on view nodes.
 *
 * **Note:** Some `ViewTextProxy` instances may represent whole text node, not just a part of it.
 * See {@link module:engine/view/textproxy~ViewTextProxy#isPartial}.
 *
 * **Note:** `ViewTextProxy` is a readonly interface.
 *
 * **Note:** `ViewTextProxy` instances are created on the fly basing
 * on the current state of parent {@link module:engine/view/text~ViewText}.
 * Because of this it is highly unrecommended to store references to `TextProxy instances because they might get
 * invalidated due to operations on Document. Also ViewTextProxy is not a {@link module:engine/view/node~ViewNode} so it cannot be
 * inserted as a child of {@link module:engine/view/element~ViewElement}.
 *
 * `ViewTextProxy` instances are created by {@link module:engine/view/treewalker~ViewTreeWalker view tree walker}.
 * You should not need to create an instance of this class by your own.
 */ class ViewTextProxy extends ViewTypeCheckable {
    /**
	 * Reference to the {@link module:engine/view/text~ViewText} element which ViewTextProxy is a substring.
	 */ textNode;
    /**
	 * Text data represented by this text proxy.
	 */ data;
    /**
	 * Offset in the `textNode` where this `ViewTextProxy` instance starts.
	 */ offsetInText;
    /**
	 * Creates a text proxy.
	 *
	 * @internal
	 * @param textNode Text node which part is represented by this text proxy.
	 * @param offsetInText Offset in {@link module:engine/view/textproxy~ViewTextProxy#textNode text node}
	 * from which the text proxy starts.
	 * @param length Text proxy length, that is how many text node's characters, starting from `offsetInText` it represents.
	 */ constructor(textNode, offsetInText, length){
        super();
        this.textNode = textNode;
        if (offsetInText < 0 || offsetInText > textNode.data.length) {
            /**
			 * Given offsetInText value is incorrect.
			 *
			 * @error view-textproxy-wrong-offsetintext
			 */ throw new CKEditorError('view-textproxy-wrong-offsetintext', this);
        }
        if (length < 0 || offsetInText + length > textNode.data.length) {
            /**
			 * Given length value is incorrect.
			 *
			 * @error view-textproxy-wrong-length
			 */ throw new CKEditorError('view-textproxy-wrong-length', this);
        }
        this.data = textNode.data.substring(offsetInText, offsetInText + length);
        this.offsetInText = offsetInText;
    }
    /**
	 * Offset size of this node.
	 */ get offsetSize() {
        return this.data.length;
    }
    /**
	 * Flag indicating whether `ViewTextProxy` instance covers only part of the original {@link module:engine/view/text~ViewText text node}
	 * (`true`) or the whole text node (`false`).
	 *
	 * This is `false` when text proxy starts at the very beginning of {@link module:engine/view/textproxy~ViewTextProxy#textNode textNode}
	 * ({@link module:engine/view/textproxy~ViewTextProxy#offsetInText offsetInText} equals `0`) and text proxy sizes is equal to
	 * text node size.
	 */ get isPartial() {
        return this.data.length !== this.textNode.data.length;
    }
    /**
	 * Parent of this text proxy, which is same as parent of text node represented by this text proxy.
	 */ get parent() {
        return this.textNode.parent;
    }
    /**
	 * Root of this text proxy, which is same as root of text node represented by this text proxy.
	 */ get root() {
        return this.textNode.root;
    }
    /**
	 * {@link module:engine/view/document~ViewDocument View document} that owns this text proxy, or `null` if the text proxy is inside
	 * {@link module:engine/view/documentfragment~ViewDocumentFragment document fragment}.
	 */ get document() {
        return this.textNode.document;
    }
    /**
	 * Returns ancestors array of this text proxy.
	 *
	 * @param options Options object.
	 * @param options.includeSelf When set to `true`, textNode will be also included in parent's array.
	 * @param options.parentFirst When set to `true`, array will be sorted from text proxy parent to
	 * root element, otherwise root element will be the first item in the array.
	 * @returns Array with ancestors.
	 */ getAncestors(options = {}) {
        const ancestors = [];
        let parent = options.includeSelf ? this.textNode : this.parent;
        while(parent !== null){
            ancestors[options.parentFirst ? 'push' : 'unshift'](parent);
            parent = parent.parent;
        }
        return ancestors;
    }
}
// The magic of type inference using `is` method is centralized in `TypeCheckable` class.
// Proper overload would interfere with that.
ViewTextProxy.prototype.is = function(type) {
    return type === '$textProxy' || type === 'view:$textProxy' || // This are legacy values kept for backward compatibility.
    type === 'textProxy' || type === 'view:textProxy';
};

/**
 * Class used for handling consumption of view {@link module:engine/view/element~ViewElement elements},
 * {@link module:engine/view/text~ViewText text nodes} and
 * {@link module:engine/view/documentfragment~ViewDocumentFragment document fragments}.
 * Element's name and its parts (attributes, classes and styles) can be consumed separately. Consuming an element's name
 * does not consume its attributes, classes and styles.
 * To add items for consumption use {@link module:engine/conversion/viewconsumable~ViewConsumable#add add method}.
 * To test items use {@link module:engine/conversion/viewconsumable~ViewConsumable#test test method}.
 * To consume items use {@link module:engine/conversion/viewconsumable~ViewConsumable#consume consume method}.
 * To revert already consumed items use {@link module:engine/conversion/viewconsumable~ViewConsumable#revert revert method}.
 *
 * ```ts
 * viewConsumable.add( element, { name: true } ); // Adds element's name as ready to be consumed.
 * viewConsumable.add( textNode ); // Adds text node for consumption.
 * viewConsumable.add( docFragment ); // Adds document fragment for consumption.
 * viewConsumable.test( element, { name: true }  ); // Tests if element's name can be consumed.
 * viewConsumable.test( textNode ); // Tests if text node can be consumed.
 * viewConsumable.test( docFragment ); // Tests if document fragment can be consumed.
 * viewConsumable.consume( element, { name: true }  ); // Consume element's name.
 * viewConsumable.consume( textNode ); // Consume text node.
 * viewConsumable.consume( docFragment ); // Consume document fragment.
 * viewConsumable.revert( element, { name: true }  ); // Revert already consumed element's name.
 * viewConsumable.revert( textNode ); // Revert already consumed text node.
 * viewConsumable.revert( docFragment ); // Revert already consumed document fragment.
 * ```
 */ class ViewConsumable {
    /**
	 * Map of consumable elements. If {@link module:engine/view/element~ViewElement element} is used as a key,
	 * {@link module:engine/conversion/viewconsumable~ViewElementConsumables ViewElementConsumables} instance is stored as value.
	 * For {@link module:engine/view/text~ViewText text nodes} and
	 * {@link module:engine/view/documentfragment~ViewDocumentFragment document fragments} boolean value is stored as value.
	 */ _consumables = new Map();
    /**
	 * Adds view {@link module:engine/view/element~ViewElement element}, {@link module:engine/view/text~ViewText text node} or
	 * {@link module:engine/view/documentfragment~ViewDocumentFragment document fragment} as ready to be consumed.
	 *
	 * ```ts
	 * viewConsumable.add( p, { name: true } ); // Adds element's name to consume.
	 * viewConsumable.add( p, { attributes: 'name' } ); // Adds element's attribute.
	 * viewConsumable.add( p, { classes: 'foobar' } ); // Adds element's class.
	 * viewConsumable.add( p, { styles: 'color' } ); // Adds element's style
	 * viewConsumable.add( p, { attributes: 'name', styles: 'color' } ); // Adds attribute and style.
	 * viewConsumable.add( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be provided.
	 * viewConsumable.add( textNode ); // Adds text node to consume.
	 * viewConsumable.add( docFragment ); // Adds document fragment to consume.
	 * ```
	 *
	 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`
	 * attribute is provided - it should be handled separately by providing actual style/class.
	 *
	 * ```ts
	 * viewConsumable.add( p, { attributes: 'style' } ); // This call will throw an exception.
	 * viewConsumable.add( p, { styles: 'color' } ); // This is properly handled style.
	 * ```
	 *
	 * @param consumables Used only if first parameter is {@link module:engine/view/element~ViewElement view element} instance.
	 * @param consumables.name If set to true element's name will be included.
	 * @param consumables.attributes Attribute name or array of attribute names.
	 * @param consumables.classes Class name or array of class names.
	 * @param consumables.styles Style name or array of style names.
	 */ add(element, consumables) {
        let elementConsumables;
        // For text nodes and document fragments just mark them as consumable.
        if (element.is('$text') || element.is('documentFragment')) {
            this._consumables.set(element, true);
            return;
        }
        // For elements create new ViewElementConsumables or update already existing one.
        if (!this._consumables.has(element)) {
            elementConsumables = new ViewElementConsumables(element);
            this._consumables.set(element, elementConsumables);
        } else {
            elementConsumables = this._consumables.get(element);
        }
        elementConsumables.add(consumables ? normalizeConsumables(consumables) : element._getConsumables());
    }
    /**
	 * Tests if {@link module:engine/view/element~ViewElement view element}, {@link module:engine/view/text~ViewText text node} or
	 * {@link module:engine/view/documentfragment~ViewDocumentFragment document fragment} can be consumed.
	 * It returns `true` when all items included in method's call can be consumed. Returns `false` when
	 * first already consumed item is found and `null` when first non-consumable item is found.
	 *
	 * ```ts
	 * viewConsumable.test( p, { name: true } ); // Tests element's name.
	 * viewConsumable.test( p, { attributes: 'name' } ); // Tests attribute.
	 * viewConsumable.test( p, { classes: 'foobar' } ); // Tests class.
	 * viewConsumable.test( p, { styles: 'color' } ); // Tests style.
	 * viewConsumable.test( p, { attributes: 'name', styles: 'color' } ); // Tests attribute and style.
	 * viewConsumable.test( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be tested.
	 * viewConsumable.test( textNode ); // Tests text node.
	 * viewConsumable.test( docFragment ); // Tests document fragment.
	 * ```
	 *
	 * Testing classes and styles as attribute will test if all added classes/styles can be consumed.
	 *
	 * ```ts
	 * viewConsumable.test( p, { attributes: 'class' } ); // Tests if all added classes can be consumed.
	 * viewConsumable.test( p, { attributes: 'style' } ); // Tests if all added styles can be consumed.
	 * ```
	 *
	 * @param consumables Used only if first parameter is {@link module:engine/view/element~ViewElement view element} instance.
	 * @param consumables.name If set to true element's name will be included.
	 * @param consumables.attributes Attribute name or array of attribute names.
	 * @param consumables.classes Class name or array of class names.
	 * @param consumables.styles Style name or array of style names.
	 * @returns Returns `true` when all items included in method's call can be consumed. Returns `false`
	 * when first already consumed item is found and `null` when first non-consumable item is found.
	 */ test(element, consumables) {
        const elementConsumables = this._consumables.get(element);
        if (elementConsumables === undefined) {
            return null;
        }
        // For text nodes and document fragments return stored boolean value.
        if (element.is('$text') || element.is('documentFragment')) {
            return elementConsumables;
        }
        // For elements test consumables object.
        return elementConsumables.test(normalizeConsumables(consumables));
    }
    /**
	 * Consumes {@link module:engine/view/element~ViewElement view element}, {@link module:engine/view/text~ViewText text node} or
	 * {@link module:engine/view/documentfragment~ViewDocumentFragment document fragment}.
	 * It returns `true` when all items included in method's call can be consumed, otherwise returns `false`.
	 *
	 * ```ts
	 * viewConsumable.consume( p, { name: true } ); // Consumes element's name.
	 * viewConsumable.consume( p, { attributes: 'name' } ); // Consumes element's attribute.
	 * viewConsumable.consume( p, { classes: 'foobar' } ); // Consumes element's class.
	 * viewConsumable.consume( p, { styles: 'color' } ); // Consumes element's style.
	 * viewConsumable.consume( p, { attributes: 'name', styles: 'color' } ); // Consumes attribute and style.
	 * viewConsumable.consume( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be consumed.
	 * viewConsumable.consume( textNode ); // Consumes text node.
	 * viewConsumable.consume( docFragment ); // Consumes document fragment.
	 * ```
	 *
	 * Consuming classes and styles as attribute will test if all added classes/styles can be consumed.
	 *
	 * ```ts
	 * viewConsumable.consume( p, { attributes: 'class' } ); // Consume only if all added classes can be consumed.
	 * viewConsumable.consume( p, { attributes: 'style' } ); // Consume only if all added styles can be consumed.
	 * ```
	 *
	 * @param consumables Used only if first parameter is {@link module:engine/view/element~ViewElement view element} instance.
	 * @param consumables.name If set to true element's name will be included.
	 * @param consumables.attributes Attribute name or array of attribute names.
	 * @param consumables.classes Class name or array of class names.
	 * @param consumables.styles Style name or array of style names.
	 * @returns Returns `true` when all items included in method's call can be consumed,
	 * otherwise returns `false`.
	 */ consume(element, consumables) {
        if (element.is('$text') || element.is('documentFragment')) {
            if (!this.test(element, consumables)) {
                return false;
            }
            // For text nodes and document fragments set value to false.
            this._consumables.set(element, false);
            return true;
        }
        // For elements - consume consumables object.
        const elementConsumables = this._consumables.get(element);
        if (elementConsumables === undefined) {
            return false;
        }
        return elementConsumables.consume(normalizeConsumables(consumables));
    }
    /**
	 * Reverts {@link module:engine/view/element~ViewElement view element}, {@link module:engine/view/text~ViewText text node} or
	 * {@link module:engine/view/documentfragment~ViewDocumentFragment document fragment} so they can be consumed once again.
	 * Method does not revert items that were never previously added for consumption, even if they are included in
	 * method's call.
	 *
	 * ```ts
	 * viewConsumable.revert( p, { name: true } ); // Reverts element's name.
	 * viewConsumable.revert( p, { attributes: 'name' } ); // Reverts element's attribute.
	 * viewConsumable.revert( p, { classes: 'foobar' } ); // Reverts element's class.
	 * viewConsumable.revert( p, { styles: 'color' } ); // Reverts element's style.
	 * viewConsumable.revert( p, { attributes: 'name', styles: 'color' } ); // Reverts attribute and style.
	 * viewConsumable.revert( p, { classes: [ 'baz', 'bar' ] } ); // Multiple names can be reverted.
	 * viewConsumable.revert( textNode ); // Reverts text node.
	 * viewConsumable.revert( docFragment ); // Reverts document fragment.
	 * ```
	 *
	 * Reverting classes and styles as attribute will revert all classes/styles that were previously added for
	 * consumption.
	 *
	 * ```ts
	 * viewConsumable.revert( p, { attributes: 'class' } ); // Reverts all classes added for consumption.
	 * viewConsumable.revert( p, { attributes: 'style' } ); // Reverts all styles added for consumption.
	 * ```
	 *
	 * @param consumables Used only if first parameter is {@link module:engine/view/element~ViewElement view element} instance.
	 * @param consumables.name If set to true element's name will be included.
	 * @param consumables.attributes Attribute name or array of attribute names.
	 * @param consumables.classes Class name or array of class names.
	 * @param consumables.styles Style name or array of style names.
	 */ revert(element, consumables) {
        const elementConsumables = this._consumables.get(element);
        if (elementConsumables !== undefined) {
            if (element.is('$text') || element.is('documentFragment')) {
                // For text nodes and document fragments - set consumable to true.
                this._consumables.set(element, true);
            } else {
                // For elements - revert items from consumables object.
                elementConsumables.revert(normalizeConsumables(consumables));
            }
        }
    }
    /**
	 * Creates {@link module:engine/conversion/viewconsumable~ViewConsumable ViewConsumable} instance from
	 * {@link module:engine/view/node~ViewNode node} or {@link module:engine/view/documentfragment~ViewDocumentFragment document fragment}.
	 * Instance will contain all elements, child nodes, attributes, styles and classes added for consumption.
	 *
	 * @param from View node or document fragment from which `ViewConsumable` will be created.
	 * @param instance If provided, given `ViewConsumable` instance will be used
	 * to add all consumables. It will be returned instead of a new instance.
	 */ static createFrom(from, instance) {
        if (!instance) {
            instance = new ViewConsumable();
        }
        if (from.is('$text')) {
            instance.add(from);
        } else if (from.is('element') || from.is('documentFragment')) {
            instance.add(from);
            for (const child of from.getChildren()){
                ViewConsumable.createFrom(child, instance);
            }
        }
        return instance;
    }
}
/**
 * This is a private helper-class for {@link module:engine/conversion/viewconsumable~ViewConsumable}.
 * It represents and manipulates consumable parts of a single {@link module:engine/view/element~ViewElement}.
 *
 * @internal
 */ class ViewElementConsumables {
    element;
    /**
	 * Flag indicating if name of the element can be consumed.
	 */ _canConsumeName = null;
    /**
	 * A map of element's consumables.
	 * * For plain attributes the value is a boolean indicating whether the attribute is available to consume.
	 * * For token based attributes (like class list and style) the value is a map of tokens to booleans
	 * indicating whether the token is available to consume on the given attribute.
	 */ _attributes = new Map();
    /**
	 * Creates ViewElementConsumables instance.
	 *
	 * @param from View element from which `ViewElementConsumables` is being created.
	 */ constructor(from){
        this.element = from;
    }
    /**
	 * Adds consumable parts of the {@link module:engine/view/element~ViewElement view element}.
	 * Element's name itself can be marked to be consumed (when element's name is consumed its attributes, classes and
	 * styles still could be consumed):
	 *
	 * ```ts
	 * consumables.add( { name: true } );
	 * ```
	 *
	 * Attributes classes and styles:
	 *
	 * ```ts
	 * consumables.add( { attributes: [ [ 'title' ], [ 'class', 'foo' ], [ 'style', 'color'] ] } );
	 * consumables.add( { attributes: [ [ 'title' ], [ 'name' ], [ 'class', 'foo' ], [ 'class', 'bar' ] ] } );
	 * ```
	 *
	 * Note: This method accepts only {@link module:engine/view/element~ViewNormalizedConsumables}.
	 * You can use {@link module:engine/conversion/viewconsumable~normalizeConsumables} helper to convert from
	 * {@link module:engine/conversion/viewconsumable~Consumables} to `ViewNormalizedConsumables`.
	 *
	 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`
	 * attribute is provided - it should be handled separately by providing `style` and `class` in consumables object.
	 *
	 * @param consumables Object describing which parts of the element can be consumed.
	 */ add(consumables) {
        if (consumables.name) {
            this._canConsumeName = true;
        }
        for (const [name, token] of consumables.attributes){
            if (token) {
                let attributeTokens = this._attributes.get(name);
                if (!attributeTokens || typeof attributeTokens == 'boolean') {
                    attributeTokens = new Map();
                    this._attributes.set(name, attributeTokens);
                }
                attributeTokens.set(token, true);
            } else if (name == 'style' || name == 'class') {
                /**
				 * Class and style attributes should be handled separately in
				 * {@link module:engine/conversion/viewconsumable~ViewConsumable#add `ViewConsumable#add()`}.
				 *
				 * What you have done is trying to use:
				 *
				 * ```ts
				 * consumables.add( { attributes: [ 'class', 'style' ] } );
				 * ```
				 *
				 * While each class and style should be registered separately:
				 *
				 * ```ts
				 * consumables.add( { classes: 'some-class', styles: 'font-weight' } );
				 * ```
				 *
				 * @error viewconsumable-invalid-attribute
				 */ throw new CKEditorError('viewconsumable-invalid-attribute', this);
            } else {
                this._attributes.set(name, true);
            }
        }
    }
    /**
	 * Tests if parts of the {@link module:engine/view/element~ViewElement view element} can be consumed.
	 *
	 * Element's name can be tested:
	 *
	 * ```ts
	 * consumables.test( { name: true } );
	 * ```
	 *
	 * Attributes classes and styles:
	 *
	 * ```ts
	 * consumables.test( { attributes: [ [ 'title' ], [ 'class', 'foo' ], [ 'style', 'color' ] ] } );
	 * consumables.test( { attributes: [ [ 'title' ], [ 'name' ], [ 'class', 'foo' ], [ 'class', 'bar' ] ] } );
	 * ```
	 *
	 * @param consumables Object describing which parts of the element should be tested.
	 * @returns `true` when all tested items can be consumed, `null` when even one of the items
	 * was never marked for consumption and `false` when even one of the items was already consumed.
	 */ test(consumables) {
        // Check if name can be consumed.
        if (consumables.name && !this._canConsumeName) {
            return this._canConsumeName;
        }
        for (const [name, token] of consumables.attributes){
            const value = this._attributes.get(name);
            // Return null if attribute is not found.
            if (value === undefined) {
                return null;
            }
            // Already consumed.
            if (value === false) {
                return false;
            }
            // Simple attribute is not consumed so continue to next attribute.
            if (value === true) {
                continue;
            }
            if (!token) {
                // Tokenized attribute but token is not specified so check if all tokens are not consumed.
                for (const tokenValue of value.values()){
                    // Already consumed token.
                    if (!tokenValue) {
                        return false;
                    }
                }
            } else {
                const tokenValue = value.get(token);
                // Return null if token is not found.
                if (tokenValue === undefined) {
                    return null;
                }
                // Already consumed.
                if (!tokenValue) {
                    return false;
                }
            }
        }
        // Return true only if all can be consumed.
        return true;
    }
    /**
	 * Tests if parts of the {@link module:engine/view/element~ViewElement view element} can be consumed and consumes them if available.
	 * It returns `true` when all items included in method's call can be consumed, otherwise returns `false`.
	 *
	 * Element's name can be consumed:
	 *
	 * ```ts
	 * consumables.consume( { name: true } );
	 * ```
	 *
	 * Attributes classes and styles:
	 *
	 * ```ts
	 * consumables.consume( { attributes: [ [ 'title' ], [ 'class', 'foo' ], [ 'style', 'color' ] ] } );
	 * consumables.consume( { attributes: [ [ 'title' ], [ 'name' ], [ 'class', 'foo' ], [ 'class', 'bar' ] ] } );
	 * ```
	 *
	 * @param consumables Object describing which parts of the element should be consumed.
	 * @returns `true` when all tested items can be consumed and `false` when even one of the items could not be consumed.
	 */ consume(consumables) {
        if (!this.test(consumables)) {
            return false;
        }
        if (consumables.name) {
            this._canConsumeName = false;
        }
        for (const [name, token] of consumables.attributes){
            // `value` must be set, because `this.test()` returned `true`.
            const value = this._attributes.get(name);
            // Plain (not tokenized) not-consumed attribute.
            if (typeof value == 'boolean') {
                // Use Element API to collect related attributes.
                for (const [toConsume] of this.element._getConsumables(name, token).attributes){
                    this._attributes.set(toConsume, false);
                }
            } else if (!token) {
                // Tokenized attribute but token is not specified so consume all tokens.
                for (const token of value.keys()){
                    value.set(token, false);
                }
            } else {
                // Use Element API to collect related attribute tokens.
                for (const [, toConsume] of this.element._getConsumables(name, token).attributes){
                    value.set(toConsume, false);
                }
            }
        }
        return true;
    }
    /**
	 * Revert already consumed parts of {@link module:engine/view/element~ViewElement view Element}, so they can be consumed once again.
	 * Element's name can be reverted:
	 *
	 * ```ts
	 * consumables.revert( { name: true } );
	 * ```
	 *
	 * Attributes classes and styles:
	 *
	 * ```ts
	 * consumables.revert( { attributes: [ [ 'title' ], [ 'class', 'foo' ], [ 'style', 'color' ] ] } );
	 * consumables.revert( { attributes: [ [ 'title' ], [ 'name' ], [ 'class', 'foo' ], [ 'class', 'bar' ] ] } );
	 * ```
	 *
	 * @param consumables Object describing which parts of the element should be reverted.
	 */ revert(consumables) {
        if (consumables.name) {
            this._canConsumeName = true;
        }
        for (const [name, token] of consumables.attributes){
            const value = this._attributes.get(name);
            // Plain consumed attribute.
            if (value === false) {
                this._attributes.set(name, true);
                continue;
            }
            // Unknown attribute or not consumed.
            if (value === undefined || value === true) {
                continue;
            }
            if (!token) {
                // Tokenized attribute but token is not specified so revert all tokens.
                for (const token of value.keys()){
                    value.set(token, true);
                }
            } else {
                const tokenValue = value.get(token);
                if (tokenValue === false) {
                    value.set(token, true);
                }
            // Note that revert of consumed related styles is not handled.
            }
        }
    }
}
/**
 * Normalizes a {@link module:engine/conversion/viewconsumable~Consumables} or {@link module:engine/view/matcher~Match}
 * to a {@link module:engine/view/element~ViewNormalizedConsumables}.
 *
 * @internal
 */ function normalizeConsumables(consumables) {
    const attributes = [];
    if ('attributes' in consumables && consumables.attributes) {
        normalizeConsumablePart(attributes, consumables.attributes);
    }
    if ('classes' in consumables && consumables.classes) {
        normalizeConsumablePart(attributes, consumables.classes, 'class');
    }
    if ('styles' in consumables && consumables.styles) {
        normalizeConsumablePart(attributes, consumables.styles, 'style');
    }
    return {
        name: consumables.name || false,
        attributes
    };
}
/**
 * Normalizes a list of consumable attributes to a common tuple format.
 */ function normalizeConsumablePart(attributes, items, prefix) {
    if (typeof items == 'string') {
        attributes.push(prefix ? [
            prefix,
            items
        ] : [
            items
        ]);
        return;
    }
    for (const item of items){
        if (Array.isArray(item)) {
            attributes.push(item);
        } else {
            attributes.push(prefix ? [
                prefix,
                item
            ] : [
                item
            ]);
        }
    }
}

/**
 * View matcher class.
 * Instance of this class can be used to find {@link module:engine/view/element~ViewElement elements} that match given pattern.
 */ class Matcher {
    _patterns = [];
    /**
	 * Creates new instance of Matcher.
	 *
	 * @param pattern Match patterns. See {@link module:engine/view/matcher~Matcher#add add method} for more information.
	 */ constructor(...pattern){
        this.add(...pattern);
    }
    /**
	 * Adds pattern or patterns to matcher instance.
	 *
	 * ```ts
	 * // String.
	 * matcher.add( 'div' );
	 *
	 * // Regular expression.
	 * matcher.add( /^\w/ );
	 *
	 * // Single class.
	 * matcher.add( {
	 * 	classes: 'foobar'
	 * } );
	 * ```
	 *
	 * See {@link module:engine/view/matcher~MatcherPattern} for more examples.
	 *
	 * Multiple patterns can be added in one call:
	 *
	 * ```ts
	 * matcher.add( 'div', { classes: 'foobar' } );
	 * ```
	 *
	 * @param pattern Object describing pattern details. If string or regular expression
	 * is provided it will be used to match element's name. Pattern can be also provided in a form
	 * of a function - then this function will be called with each {@link module:engine/view/element~ViewElement element} as a parameter.
	 * Function's return value will be stored under `match` key of the object returned from
	 * {@link module:engine/view/matcher~Matcher#match match} or {@link module:engine/view/matcher~Matcher#matchAll matchAll} methods.
	 */ add(...pattern) {
        for (let item of pattern){
            // String or RegExp pattern is used as element's name.
            if (typeof item == 'string' || item instanceof RegExp) {
                item = {
                    name: item
                };
            }
            this._patterns.push(item);
        }
    }
    /**
	 * Matches elements for currently stored patterns. Returns match information about first found
	 * {@link module:engine/view/element~ViewElement element}, otherwise returns `null`.
	 *
	 * Example of returned object:
	 *
	 * ```ts
	 * {
	 * 	element: <instance of found element>,
	 * 	pattern: <pattern used to match found element>,
	 * 	match: {
	 * 		name: true,
	 * 		attributes: [
	 * 			[ 'title' ],
	 * 			[ 'href' ],
	 * 			[ 'class', 'foo' ],
	 * 			[ 'style', 'color' ],
	 * 			[ 'style', 'position' ]
	 * 		]
	 * 	}
	 * }
	 * ```
	 *
	 * You could use the `match` field from the above returned object as an input for the
	 * {@link module:engine/conversion/viewconsumable~ViewConsumable#test `ViewConsumable#test()`} and
	 * {@link module:engine/conversion/viewconsumable~ViewConsumable#consume `ViewConsumable#consume()`} methods.
	 *
	 * @see module:engine/view/matcher~Matcher#add
	 * @see module:engine/view/matcher~Matcher#matchAll
	 * @param element View element to match against stored patterns.
	 * @returns The match information about found element or `null`.
	 */ match(...element) {
        for (const singleElement of element){
            for (const pattern of this._patterns){
                const match = this._isElementMatching(singleElement, pattern);
                if (match) {
                    return {
                        element: singleElement,
                        pattern,
                        match
                    };
                }
            }
        }
        return null;
    }
    /**
	 * Matches elements for currently stored patterns. Returns array of match information with all found
	 * {@link module:engine/view/element~ViewElement elements}. If no element is found - returns `null`.
	 *
	 * @see module:engine/view/matcher~Matcher#add
	 * @see module:engine/view/matcher~Matcher#match
	 * @param element View element to match against stored patterns.
	 * @returns Array with match information about found elements or `null`. For more information
	 * see {@link module:engine/view/matcher~Matcher#match match method} description.
	 */ matchAll(...element) {
        const results = [];
        for (const singleElement of element){
            for (const pattern of this._patterns){
                const match = this._isElementMatching(singleElement, pattern);
                if (match) {
                    results.push({
                        element: singleElement,
                        pattern,
                        match
                    });
                }
            }
        }
        return results.length > 0 ? results : null;
    }
    /**
	 * Returns the name of the element to match if there is exactly one pattern added to the matcher instance
	 * and it matches element name defined by `string` (not `RegExp`). Otherwise, returns `null`.
	 *
	 * @returns Element name trying to match.
	 */ getElementName() {
        if (this._patterns.length !== 1) {
            return null;
        }
        const pattern = this._patterns[0];
        const name = pattern.name;
        return typeof pattern != 'function' && name && !(name instanceof RegExp) ? name : null;
    }
    /**
	 * Returns match information if {@link module:engine/view/element~ViewElement element} is matching provided pattern.
	 * If element cannot be matched to provided pattern - returns `null`.
	 *
	 * @returns Returns object with match information or null if element is not matching.
	 */ _isElementMatching(element, pattern) {
        // If pattern is provided as function - return result of that function;
        if (typeof pattern == 'function') {
            const match = pattern(element);
            // In some places we use Matcher with callback pattern that returns boolean.
            if (!match || typeof match != 'object') {
                return match;
            }
            return normalizeConsumables(match);
        }
        const match = {};
        // Check element's name.
        if (pattern.name) {
            match.name = matchName(pattern.name, element.name);
            if (!match.name) {
                return null;
            }
        }
        const attributesMatch = [];
        // Check element's attributes.
        if (pattern.attributes && !matchAttributes(pattern.attributes, element, attributesMatch)) {
            return null;
        }
        // Check element's classes.
        if (pattern.classes && !matchClasses(pattern.classes, element, attributesMatch)) {
            return null;
        }
        // Check element's styles.
        if (pattern.styles && !matchStyles(pattern.styles, element, attributesMatch)) {
            return null;
        }
        // Note the `attributesMatch` array is populated by the above calls.
        if (attributesMatch.length) {
            match.attributes = attributesMatch;
        }
        return match;
    }
}
/**
 * Returns true if the given `item` matches the pattern.
 *
 * @internal
 * @param pattern A pattern representing a key/value we want to match.
 * @param item An actual item key/value (e.g. `'src'`, `'background-color'`, `'ck-widget'`) we're testing against pattern.
 */ function isPatternMatched(pattern, item) {
    return pattern === true || pattern === item || pattern instanceof RegExp && !!String(item).match(pattern);
}
/**
 * Checks if name can be matched by provided pattern.
 *
 * @returns Returns `true` if name can be matched, `false` otherwise.
 */ function matchName(pattern, name) {
    // If pattern is provided as RegExp - test against this regexp.
    if (pattern instanceof RegExp) {
        return !!name.match(pattern);
    }
    return pattern === name;
}
/**
 * Bring all the possible pattern forms to an array of tuples where first item is a key, second is a value,
 * and third optional is a token value.
 *
 * Examples:
 *
 * Boolean pattern value:
 *
 * ```ts
 * true
 * ```
 *
 * to
 *
 * ```ts
 * [ [ true, true ] ]
 * ```
 *
 * Textual pattern value:
 *
 * ```ts
 * 'attribute-name-or-class-or-style'
 * ```
 *
 * to
 *
 * ```ts
 * [ [ 'attribute-name-or-class-or-style', true ] ]
 * ```
 *
 * Regular expression:
 *
 * ```ts
 * /^data-.*$/
 * ```
 *
 * to
 *
 * ```ts
 * [ [ /^data-.*$/, true ] ]
 * ```
 *
 * Objects (plain or with `key` and `value` specified explicitly):
 *
 * ```ts
 * {
 * 	src: /^https:.*$/
 * }
 * ```
 *
 * or
 *
 * ```ts
 * [ {
 * 	key: 'src',
 * 	value: /^https:.*$/
 * } ]
 * ```
 *
 * to:
 *
 * ```ts
 * [ [ 'src', /^https:.*$/ ] ]
 * ```
 *
 * @returns Returns an array of objects or null if provided patterns were not in an expected form.
 */ function normalizePatterns(patterns, prefix) {
    if (Array.isArray(patterns)) {
        return patterns.map((pattern)=>{
            if (typeof pattern !== 'object' || pattern instanceof RegExp) {
                return prefix ? [
                    prefix,
                    pattern,
                    true
                ] : [
                    pattern,
                    true
                ];
            }
            if (pattern.key === undefined || pattern.value === undefined) {
                // Documented at the end of matcher.js.
                logWarning('matcher-pattern-missing-key-or-value', pattern);
            }
            return prefix ? [
                prefix,
                pattern.key,
                pattern.value
            ] : [
                pattern.key,
                pattern.value
            ];
        });
    }
    if (typeof patterns !== 'object' || patterns instanceof RegExp) {
        return [
            prefix ? [
                prefix,
                patterns,
                true
            ] : [
                patterns,
                true
            ]
        ];
    }
    // Below we do what Object.entries() does, but faster
    const normalizedPatterns = [];
    for(const key in patterns){
        // Replace with Object.hasOwn() when we upgrade to es2022.
        if (Object.prototype.hasOwnProperty.call(patterns, key)) {
            normalizedPatterns.push(prefix ? [
                prefix,
                key,
                patterns[key]
            ] : [
                key,
                patterns[key]
            ]);
        }
    }
    return normalizedPatterns;
}
/**
 * Checks if attributes of provided element can be matched against provided patterns.
 *
 * @param patterns Object with information about attributes to match. Each key of the object will be
 * used as attribute name. Value of each key can be a string or regular expression to match against attribute value.
 * @param  element Element which attributes will be tested.
 * @param match An array to populate with matching tuples.
 * @returns Returns array with matched attribute names or `null` if no attributes were matched.
 */ function matchAttributes(patterns, element, match) {
    let excludeAttributes;
    // `style` and `class` attribute keys are deprecated. Only allow them in object pattern
    // for backward compatibility.
    if (typeof patterns === 'object' && !(patterns instanceof RegExp) && !Array.isArray(patterns)) {
        if (patterns.style !== undefined) {
            // Documented at the end of matcher.js.
            logWarning('matcher-pattern-deprecated-attributes-style-key', patterns);
        }
        if (patterns.class !== undefined) {
            // Documented at the end of matcher.js.
            logWarning('matcher-pattern-deprecated-attributes-class-key', patterns);
        }
    } else {
        excludeAttributes = [
            'class',
            'style'
        ];
    }
    return element._collectAttributesMatch(normalizePatterns(patterns), match, excludeAttributes);
}
/**
 * Checks if classes of provided element can be matched against provided patterns.
 *
 * @param patterns Array of strings or regular expressions to match against element's classes.
 * @param element Element which classes will be tested.
 * @param match An array to populate with matching tuples.
 * @returns Returns array with matched class names or `null` if no classes were matched.
 */ function matchClasses(patterns, element, match) {
    return element._collectAttributesMatch(normalizePatterns(patterns, 'class'), match);
}
/**
 * Checks if styles of provided element can be matched against provided patterns.
 *
 * @param patterns Object with information about styles to match. Each key of the object will be
 * used as style name. Value of each key can be a string or regular expression to match against style value.
 * @param element Element which styles will be tested.
 * @param match An array to populate with matching tuples.
 * @returns Returns array with matched style names or `null` if no styles were matched.
 */ function matchStyles(patterns, element, match) {
    return element._collectAttributesMatch(normalizePatterns(patterns, 'style'), match);
}
 /**
 * The key-value matcher pattern is missing key or value. Both must be present.
 * Refer the documentation: {@link module:engine/view/matcher~MatcherPattern}.
 *
 * @param pattern Pattern with missing properties.
 * @error matcher-pattern-missing-key-or-value
 */  /**
 * The key-value matcher pattern for `attributes` option is using deprecated `style` key.
 *
 * Use `styles` matcher pattern option instead:
 *
 * ```ts
 * // Instead of:
 * const pattern = {
 * 	attributes: {
 * 		key1: 'value1',
 * 		key2: 'value2',
 * 		style: /^border.*$/
 * 	}
 * }
 *
 * // Use:
 * const pattern = {
 * 	attributes: {
 * 		key1: 'value1',
 * 		key2: 'value2'
 * 	},
 * 	styles: /^border.*$/
 * }
 * ```
 *
 * Refer to the {@glink updating/guides/update-to-29##update-to-ckeditor-5-v2910 Migration to v29.1.0} guide
 * and {@link module:engine/view/matcher~MatcherPattern} documentation.
 *
 * @param pattern Pattern with missing properties.
 * @error matcher-pattern-deprecated-attributes-style-key
 */  /**
 * The key-value matcher pattern for `attributes` option is using deprecated `class` key.
 *
 * Use `classes` matcher pattern option instead:
 *
 * ```ts
 * // Instead of:
 * const pattern = {
 * 	attributes: {
 * 		key1: 'value1',
 * 		key2: 'value2',
 * 		class: 'foobar'
 * 	}
 * }
 *
 * // Use:
 * const pattern = {
 * 	attributes: {
 * 		key1: 'value1',
 * 		key2: 'value2'
 * 	},
 * 	classes: 'foobar'
 * }
 * ```
 *
 * Refer to the {@glink updating/guides/update-to-29##update-to-ckeditor-5-v2910 Migration to v29.1.0} guide
 * and the {@link module:engine/view/matcher~MatcherPattern} documentation.
 *
 * @param pattern Pattern with missing properties.
 * @error matcher-pattern-deprecated-attributes-class-key
 */

/**
 * Styles map. Allows handling (adding, removing, retrieving) a set of style rules (usually, of an element).
 */ class StylesMap {
    /**
	 * Keeps an internal representation of styles map. Normalized styles are kept as object tree to allow unified modification and
	 * value access model using lodash's get, set, unset, etc methods.
	 *
	 * When no style processor rules are defined it acts as simple key-value storage.
	 */ _styles;
    /**
	 * Cached list of style names for faster access.
	 */ _cachedStyleNames = null;
    /**
	 * Cached list of expanded style names for faster access.
	 */ _cachedExpandedStyleNames = null;
    /**
	 * An instance of the {@link module:engine/view/stylesmap~StylesProcessor}.
	 */ _styleProcessor;
    /**
	 * Creates Styles instance.
	 */ constructor(styleProcessor){
        this._styles = {};
        this._styleProcessor = styleProcessor;
    }
    /**
	 * Returns true if style map has no styles set.
	 */ get isEmpty() {
        const entries = Object.entries(this._styles);
        return !entries.length;
    }
    /**
	 * Number of styles defined.
	 */ get size() {
        if (this.isEmpty) {
            return 0;
        }
        return this.getStyleNames().length;
    }
    /**
	 * Set styles map to a new value.
	 *
	 * ```ts
	 * styles.setTo( 'border:1px solid blue;margin-top:1px;' );
	 * ```
	 */ setTo(inlineStyle) {
        this.clear();
        const parsedStyles = parseInlineStyles(inlineStyle);
        for (const [key, value] of parsedStyles){
            this._styleProcessor.toNormalizedForm(key, value, this._styles);
        }
        return this;
    }
    /**
	 * Checks if a given style is set.
	 *
	 * ```ts
	 * styles.setTo( 'margin-left:1px;' );
	 *
	 * styles.has( 'margin-left' );    // -> true
	 * styles.has( 'padding' );        // -> false
	 * ```
	 *
	 * **Note**: This check supports normalized style names.
	 *
	 * ```ts
	 * // Enable 'margin' shorthand processing:
	 * editor.data.addStyleProcessorRules( addMarginStylesRules );
	 *
	 * styles.setTo( 'margin:2px;' );
	 *
	 * styles.has( 'margin' );         // -> true
	 * styles.has( 'margin-top' );     // -> true
	 * styles.has( 'margin-left' );    // -> true
	 *
	 * styles.remove( 'margin-top' );
	 *
	 * styles.has( 'margin' );         // -> false
	 * styles.has( 'margin-top' );     // -> false
	 * styles.has( 'margin-left' );    // -> true
	 * ```
	 *
	 * @param name Style name.
	 */ has(name) {
        if (this.isEmpty) {
            return false;
        }
        const styles = this._styleProcessor.getReducedForm(name, this._styles);
        const propertyDescriptor = styles.find(([property])=>property === name);
        // Only return a value if it is set;
        return Array.isArray(propertyDescriptor);
    }
    set(nameOrObject, valueOrObject) {
        this._cachedStyleNames = null;
        this._cachedExpandedStyleNames = null;
        if (isObject(nameOrObject)) {
            for (const [key, value] of Object.entries(nameOrObject)){
                this._styleProcessor.toNormalizedForm(key, value, this._styles);
            }
        } else {
            this._styleProcessor.toNormalizedForm(nameOrObject, valueOrObject, this._styles);
        }
    }
    /**
	 * Removes given style.
	 *
	 * ```ts
	 * styles.setTo( 'background:#f00;margin-right:2px;' );
	 *
	 * styles.remove( 'background' );
	 *
	 * styles.toString();   // -> 'margin-right:2px;'
	 * ```
	 *
	 * ***Note**:* This method uses {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules
	 * enabled style processor rules} to normalize passed values.
	 *
	 * ```ts
	 * // Enable 'margin' shorthand processing:
	 * editor.data.addStyleProcessorRules( addMarginStylesRules );
	 *
	 * styles.setTo( 'margin:1px' );
	 *
	 * styles.remove( 'margin-top' );
	 * styles.remove( 'margin-right' );
	 *
	 * styles.toString(); // -> 'margin-bottom:1px;margin-left:1px;'
	 * ```
	 *
	 * @param names Style name or an array of names.
	 */ remove(names) {
        const normalizedStylesToRemove = {};
        for (const name of toArray(names)){
            // First, try the easy path, when the path reflects normalized styles structure.
            const path = toPath(name);
            const pathValue = get(this._styles, path);
            if (pathValue) {
                appendStyleValue(normalizedStylesToRemove, path, pathValue);
            } else {
                // Easy path did not work, so try to get the value from the styles map.
                const value = this.getAsString(name);
                if (value !== undefined) {
                    this._styleProcessor.toNormalizedForm(name, value, normalizedStylesToRemove);
                }
            }
        }
        if (Object.keys(normalizedStylesToRemove).length) {
            removeStyles(this._styles, normalizedStylesToRemove);
            this._cachedStyleNames = null;
            this._cachedExpandedStyleNames = null;
        }
    }
    /**
	 * Returns a normalized style object or a single value.
	 *
	 * ```ts
	 * // Enable 'margin' shorthand processing:
	 * editor.data.addStyleProcessorRules( addMarginStylesRules );
	 *
	 * const styles = new Styles();
	 * styles.setTo( 'margin:1px 2px 3em;' );
	 *
	 * styles.getNormalized( 'margin' );
	 * // will log:
	 * // {
	 * //     top: '1px',
	 * //     right: '2px',
	 * //     bottom: '3em',
	 * //     left: '2px'     // normalized value from margin shorthand
	 * // }
	 *
	 * styles.getNormalized( 'margin-left' ); // -> '2px'
	 * ```
	 *
	 * **Note**: This method will only return normalized styles if a style processor was defined.
	 *
	 * @param name Style name.
	 */ getNormalized(name) {
        return this._styleProcessor.getNormalized(name, this._styles);
    }
    /**
	 * Returns a normalized style string. Styles are sorted by name.
	 *
	 * ```ts
	 * styles.set( 'margin' , '1px' );
	 * styles.set( 'background', '#f00' );
	 *
	 * styles.toString(); // -> 'background:#f00;margin:1px;'
	 * ```
	 *
	 * **Note**: This method supports normalized styles if defined.
	 *
	 * ```ts
	 * // Enable 'margin' shorthand processing:
	 * editor.data.addStyleProcessorRules( addMarginStylesRules );
	 *
	 * styles.set( 'margin' , '1px' );
	 * styles.set( 'background', '#f00' );
	 * styles.remove( 'margin-top' );
	 * styles.remove( 'margin-right' );
	 *
	 * styles.toString(); // -> 'background:#f00;margin-bottom:1px;margin-left:1px;'
	 * ```
	 */ toString() {
        if (this.isEmpty) {
            return '';
        }
        return this.getStylesEntries().map((arr)=>arr.join(':')).sort().join(';') + ';';
    }
    /**
	 * Returns property as a value string or undefined if property is not set.
	 *
	 * ```ts
	 * // Enable 'margin' shorthand processing:
	 * editor.data.addStyleProcessorRules( addMarginStylesRules );
	 *
	 * const styles = new Styles();
	 * styles.setTo( 'margin:1px;' );
	 * styles.set( 'margin-bottom', '3em' );
	 *
	 * styles.getAsString( 'margin' ); // -> 'margin: 1px 1px 3em;'
	 * ```
	 *
	 * Note, however, that all sub-values must be set for the longhand property name to return a value:
	 *
	 * ```ts
	 * const styles = new Styles();
	 * styles.setTo( 'margin:1px;' );
	 * styles.remove( 'margin-bottom' );
	 *
	 * styles.getAsString( 'margin' ); // -> undefined
	 * ```
	 *
	 * In the above scenario, it is not possible to return a `margin` value, so `undefined` is returned.
	 * Instead, you should use:
	 *
	 * ```ts
	 * const styles = new Styles();
	 * styles.setTo( 'margin:1px;' );
	 * styles.remove( 'margin-bottom' );
	 *
	 * for ( const styleName of styles.getStyleNames() ) {
	 * 	console.log( styleName, styles.getAsString( styleName ) );
	 * }
	 * // 'margin-top', '1px'
	 * // 'margin-right', '1px'
	 * // 'margin-left', '1px'
	 * ```
	 *
	 * In general, it is recommend to iterate over style names like in the example above. This way, you will always get all
	 * the currently set style values. So, if all the 4 margin values would be set
	 * the for-of loop above would yield only `'margin'`, `'1px'`:
	 *
	 * ```ts
	 * const styles = new Styles();
	 * styles.setTo( 'margin:1px;' );
	 *
	 * for ( const styleName of styles.getStyleNames() ) {
	 * 	console.log( styleName, styles.getAsString( styleName ) );
	 * }
	 * // 'margin', '1px'
	 * ```
	 *
	 * **Note**: To get a normalized version of a longhand property use the {@link #getNormalized `#getNormalized()`} method.
	 */ getAsString(propertyName) {
        if (this.isEmpty) {
            return;
        }
        if (this._styles[propertyName] && !isObject(this._styles[propertyName])) {
            // Try return styles set directly - values that are not parsed.
            return this._styles[propertyName];
        }
        const styles = this._styleProcessor.getReducedForm(propertyName, this._styles);
        const propertyDescriptor = styles.find(([property])=>property === propertyName);
        // Only return a value if it is set;
        if (Array.isArray(propertyDescriptor)) {
            return propertyDescriptor[1];
        }
    }
    /**
	 * Returns all style properties names as they would appear when using {@link #toString `#toString()`}.
	 *
	 * When `expand` is set to true and there's a shorthand style property set, it will also return all equivalent styles:
	 *
	 * ```ts
	 * stylesMap.setTo( 'margin: 1em' )
	 * ```
	 *
	 * will be expanded to:
	 *
	 * ```ts
	 * [ 'margin', 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ]
	 * ```
	 *
	 * @param expand Expand shorthand style properties and all return equivalent style representations.
	 */ getStyleNames(expand = false) {
        if (this.isEmpty) {
            return [];
        }
        if (expand) {
            this._cachedExpandedStyleNames ||= this._styleProcessor.getStyleNames(this._styles);
            return this._cachedExpandedStyleNames;
        }
        this._cachedStyleNames ||= this.getStylesEntries().map(([key])=>key);
        return this._cachedStyleNames;
    }
    /**
	 * Alias for {@link #getStyleNames}.
	 */ keys() {
        return this.getStyleNames();
    }
    /**
	 * Removes all styles.
	 */ clear() {
        this._styles = {};
        this._cachedStyleNames = null;
        this._cachedExpandedStyleNames = null;
    }
    /**
	 * Returns `true` if both attributes have the same styles.
	 */ isSimilar(other) {
        if (this.size !== other.size) {
            return false;
        }
        for (const property of this.getStyleNames()){
            if (!other.has(property) || other.getAsString(property) !== this.getAsString(property)) {
                return false;
            }
        }
        return true;
    }
    /**
	 * Returns normalized styles entries for further processing.
	 */ getStylesEntries() {
        const parsed = [];
        const keys = Object.keys(this._styles);
        for (const key of keys){
            parsed.push(...this._styleProcessor.getReducedForm(key, this._styles));
        }
        return parsed;
    }
    /**
	 * Clones the attribute value.
	 *
	 * @internal
	 */ _clone() {
        const clone = new this.constructor(this._styleProcessor);
        clone.set(this.getNormalized());
        return clone;
    }
    /**
	 * Used by the {@link module:engine/view/matcher~Matcher Matcher} to collect matching styles.
	 *
	 * @internal
	 * @param tokenPattern The matched style name pattern.
	 * @param valuePattern The matched style value pattern.
	 * @returns An array of matching tokens (style names).
	 */ _getTokensMatch(tokenPattern, valuePattern) {
        const match = [];
        for (const styleName of this.getStyleNames(true)){
            if (isPatternMatched(tokenPattern, styleName)) {
                if (valuePattern === true) {
                    match.push(styleName);
                    continue;
                }
                // For now, the reducers are not returning the full tree of properties.
                // Casting to string preserves the old behavior until the root cause is fixed.
                // More can be found in https://github.com/ckeditor/ckeditor5/issues/10399.
                const value = this.getAsString(styleName);
                if (isPatternMatched(valuePattern, value)) {
                    match.push(styleName);
                }
            }
        }
        return match.length ? match : undefined;
    }
    /**
	 * Returns a list of consumables for the attribute. This includes related styles.
	 *
	 * Could be filtered by the given style name.
	 *
	 * @internal
	 */ _getConsumables(name) {
        const result = [];
        if (name) {
            result.push(name);
            for (const relatedName of this._styleProcessor.getRelatedStyles(name)){
                result.push(relatedName);
            }
        } else {
            for (const name of this.getStyleNames()){
                for (const relatedName of this._styleProcessor.getRelatedStyles(name)){
                    result.push(relatedName);
                }
                result.push(name);
            }
        }
        return result;
    }
    /**
	 * Used by {@link module:engine/view/element~ViewElement#_canMergeAttributesFrom} to verify if the given attribute can be merged without
	 * conflicts into the attribute.
	 *
	 * This method is indirectly used by the {@link module:engine/view/downcastwriter~ViewDowncastWriter} while down-casting
	 * an {@link module:engine/view/attributeelement~ViewAttributeElement} to merge it with other ViewAttributeElement.
	 *
	 * @internal
	 */ _canMergeFrom(other) {
        for (const key of other.getStyleNames()){
            if (this.has(key) && this.getAsString(key) !== other.getAsString(key)) {
                return false;
            }
        }
        return true;
    }
    /**
	 * Used by {@link module:engine/view/element~ViewElement#_mergeAttributesFrom} to merge a given attribute into the attribute.
	 *
	 * This method is indirectly used by the {@link module:engine/view/downcastwriter~ViewDowncastWriter} while down-casting
	 * an {@link module:engine/view/attributeelement~ViewAttributeElement} to merge it with other ViewAttributeElement.
	 *
	 * @internal
	 */ _mergeFrom(other) {
        for (const prop of other.getStyleNames()){
            if (!this.has(prop)) {
                this.set(prop, other.getAsString(prop));
            }
        }
    }
    /**
	 * Used by {@link module:engine/view/element~ViewElement#_canSubtractAttributesOf} to verify if the given attribute can be fully
	 * subtracted from the attribute.
	 *
	 * This method is indirectly used by the {@link module:engine/view/downcastwriter~ViewDowncastWriter} while down-casting
	 * an {@link module:engine/view/attributeelement~ViewAttributeElement} to unwrap the ViewAttributeElement.
	 *
	 * @internal
	 */ _isMatching(other) {
        for (const key of other.getStyleNames()){
            if (!this.has(key) || this.getAsString(key) !== other.getAsString(key)) {
                return false;
            }
        }
        return true;
    }
}
/**
 * Style processor is responsible for writing and reading a normalized styles object.
 */ class StylesProcessor {
    _normalizers;
    _extractors;
    _reducers;
    _consumables;
    /**
	 * Creates StylesProcessor instance.
	 *
	 * @internal
	 */ constructor(){
        this._normalizers = new Map();
        this._extractors = new Map();
        this._reducers = new Map();
        this._consumables = new Map();
    }
    /**
	 * Parse style string value to a normalized object and appends it to styles object.
	 *
	 * ```ts
	 * const styles = {};
	 *
	 * stylesProcessor.toNormalizedForm( 'margin', '1px', styles );
	 *
	 * // styles will consist: { margin: { top: '1px', right: '1px', bottom: '1px', left: '1px; } }
	 * ```
	 *
	 * **Note**: To define normalizer callbacks use {@link #setNormalizer}.
	 *
	 * @param name Name of style property.
	 * @param propertyValue Value of style property.
	 * @param styles Object holding normalized styles.
	 */ toNormalizedForm(name, propertyValue, styles) {
        if (isObject(propertyValue)) {
            appendStyleValue(styles, toPath(name), propertyValue);
            return;
        }
        if (this._normalizers.has(name)) {
            const normalizer = this._normalizers.get(name);
            const { path, value } = normalizer(propertyValue);
            appendStyleValue(styles, path, value);
        } else {
            appendStyleValue(styles, name, propertyValue);
        }
    }
    /**
	 * Returns a normalized version of a style property.
	 *
	 * ```ts
	 * const styles = {
	 * 	margin: { top: '1px', right: '1px', bottom: '1px', left: '1px; },
	 * 	background: { color: '#f00' }
	 * };
	 *
	 * stylesProcessor.getNormalized( 'background' );
	 * // will return: { color: '#f00' }
	 *
	 * stylesProcessor.getNormalized( 'margin-top' );
	 * // will return: '1px'
	 * ```
	 *
	 * **Note**: In some cases extracting single value requires defining an extractor callback {@link #setExtractor}.
	 *
	 * @param name Name of style property.
	 * @param styles Object holding normalized styles.
	 */ getNormalized(name, styles) {
        if (!name) {
            return merge({}, styles);
        }
        // Might be empty string.
        if (styles[name] !== undefined) {
            return styles[name];
        }
        if (this._extractors.has(name)) {
            const extractor = this._extractors.get(name);
            if (typeof extractor === 'string') {
                return get(styles, extractor);
            }
            const value = extractor(name, styles);
            if (value) {
                return value;
            }
        }
        return get(styles, toPath(name));
    }
    /**
	 * Returns a reduced form of style property form normalized object.
	 *
	 * For default margin reducer, the below code:
	 *
	 * ```ts
	 * stylesProcessor.getReducedForm( 'margin', {
	 * 	margin: { top: '1px', right: '1px', bottom: '2px', left: '1px; }
	 * } );
	 * ```
	 *
	 * will return:
	 *
	 * ```ts
	 * [
	 * 	[ 'margin', '1px 1px 2px' ]
	 * ]
	 * ```
	 *
	 * because it might be represented as a shorthand 'margin' value. However if one of margin long hand values is missing it should return:
	 *
	 * ```ts
	 * [
	 * 	[ 'margin-top', '1px' ],
	 * 	[ 'margin-right', '1px' ],
	 * 	[ 'margin-bottom', '2px' ]
	 * 	// the 'left' value is missing - cannot use 'margin' shorthand.
	 * ]
	 * ```
	 *
	 * **Note**: To define reducer callbacks use {@link #setReducer}.
	 *
	 * @param name Name of style property.
	 */ getReducedForm(name, styles) {
        const normalizedValue = this.getNormalized(name, styles);
        // Might be empty string.
        if (normalizedValue === undefined) {
            return [];
        }
        if (this._reducers.has(name)) {
            const reducer = this._reducers.get(name);
            return reducer(normalizedValue);
        }
        return [
            [
                name,
                normalizedValue
            ]
        ];
    }
    /**
	 * Return all style properties. Also expand shorthand properties (e.g. `margin`, `background`) if respective extractor is available.
	 *
	 * @param styles Object holding normalized styles.
	 */ getStyleNames(styles) {
        const styleNamesKeysSet = new Set();
        // Find all extractable styles that have a value.
        for (const name of this._consumables.keys()){
            const style = this.getNormalized(name, styles);
            if (style && (typeof style != 'object' || Object.keys(style).length)) {
                styleNamesKeysSet.add(name);
            }
        }
        // For simple styles (for example `color`) we don't have a map of those styles
        // but they are 1 to 1 with normalized object keys.
        for (const name of Object.keys(styles)){
            styleNamesKeysSet.add(name);
        }
        return Array.from(styleNamesKeysSet);
    }
    /**
	 * Returns related style names.
	 *
	 * ```ts
	 * stylesProcessor.getRelatedStyles( 'margin' );
	 * // will return: [ 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ];
	 *
	 * stylesProcessor.getRelatedStyles( 'margin-top' );
	 * // will return: [ 'margin' ];
	 * ```
	 *
	 * **Note**: To define new style relations load an existing style processor or use
	 * {@link module:engine/view/stylesmap~StylesProcessor#setStyleRelation `StylesProcessor.setStyleRelation()`}.
	 */ getRelatedStyles(name) {
        return this._consumables.get(name) || [];
    }
    /**
	 * Adds a normalizer method for a style property.
	 *
	 * A normalizer returns describing how the value should be normalized.
	 *
	 * For instance 'margin' style is a shorthand for four margin values:
	 *
	 * - 'margin-top'
	 * - 'margin-right'
	 * - 'margin-bottom'
	 * - 'margin-left'
	 *
	 * and can be written in various ways if some values are equal to others. For instance `'margin: 1px 2em;'` is a shorthand for
	 * `'margin-top: 1px;margin-right: 2em;margin-bottom: 1px;margin-left: 2em'`.
	 *
	 * A normalizer should parse various margin notations as a single object:
	 *
	 * ```ts
	 * const styles = {
	 * 	margin: {
	 * 		top: '1px',
	 * 		right: '2em',
	 * 		bottom: '1px',
	 * 		left: '2em'
	 * 	}
	 * };
	 * ```
	 *
	 * Thus a normalizer for 'margin' style should return an object defining style path and value to store:
	 *
	 * ```ts
	 * const returnValue = {
	 * 	path: 'margin',
	 * 	value: {
	 * 		top: '1px',
	 * 		right: '2em',
	 * 		bottom: '1px',
	 * 		left: '2em'
	 * 	}
	 * };
	 * ```
	 *
	 * Additionally to fully support all margin notations there should be also defined 4 normalizers for longhand margin notations. Below
	 * is an example for 'margin-top' style property normalizer:
	 *
	 * ```ts
	 * stylesProcessor.setNormalizer( 'margin-top', valueString => {
	 * 	return {
	 * 		path: 'margin.top',
	 * 		value: valueString
	 * 	}
	 * } );
	 * ```
	 */ setNormalizer(name, callback) {
        this._normalizers.set(name, callback);
    }
    /**
	 * Adds a extractor callback for a style property.
	 *
	 * Most normalized style values are stored as one level objects. It is assumed that `'margin-top'` style will be stored as:
	 *
	 * ```ts
	 * const styles = {
	 * 	margin: {
	 * 		top: 'value'
	 * 	}
	 * }
	 * ```
	 *
	 * However, some styles can have conflicting notations and thus it might be harder to extract a style value from shorthand. For instance
	 * the 'border-top-style' can be defined using `'border-top:solid'`, `'border-style:solid none none none'` or by `'border:solid'`
	 * shorthands. The default border styles processors stores styles as:
	 *
	 * ```ts
	 * const styles = {
	 * 	border: {
	 * 		style: {
	 * 			top: 'solid'
	 * 		}
	 * 	}
	 * }
	 * ```
	 *
	 * as it is better to modify border style independently from other values. On the other part the output of the border might be
	 * desired as `border-top`, `border-left`, etc notation.
	 *
	 * In the above example an extractor should return a side border value that combines style, color and width:
	 *
	 * ```ts
	 * styleProcessor.setExtractor( 'border-top', styles => {
	 * 	return {
	 * 		color: styles.border.color.top,
	 * 		style: styles.border.style.top,
	 * 		width: styles.border.width.top
	 * 	}
	 * } );
	 * ```
	 *
	 * @param callbackOrPath Callback that return a requested value or path string for single values.
	 */ setExtractor(name, callbackOrPath) {
        this._extractors.set(name, callbackOrPath);
    }
    /**
	 * Adds a reducer callback for a style property.
	 *
	 * Reducer returns a minimal notation for given style name. For longhand properties it is not required to write a reducer as
	 * by default the direct value from style path is taken.
	 *
	 * For shorthand styles a reducer should return minimal style notation either by returning single name-value tuple or multiple tuples
	 * if a shorthand cannot be used. For instance for a margin shorthand a reducer might return:
	 *
	 * ```ts
	 * const marginShortHandTuple = [
	 * 	[ 'margin', '1px 1px 2px' ]
	 * ];
	 * ```
	 *
	 * or a longhand tuples for defined values:
	 *
	 * ```ts
	 * // Considering margin.bottom and margin.left are undefined.
	 * const marginLonghandsTuples = [
	 * 	[ 'margin-top', '1px' ],
	 * 	[ 'margin-right', '1px' ]
	 * ];
	 * ```
	 *
	 * A reducer obtains a normalized style value:
	 *
	 * ```ts
	 * // Simplified reducer that always outputs 4 values which are always present:
	 * stylesProcessor.setReducer( 'margin', margin => {
	 * 	return [
	 * 		[ 'margin', `${ margin.top } ${ margin.right } ${ margin.bottom } ${ margin.left }` ]
	 * 	]
	 * } );
	 * ```
	 */ setReducer(name, callback) {
        this._reducers.set(name, callback);
    }
    /**
	 * Defines a style shorthand relation to other style notations.
	 *
	 * ```ts
	 * stylesProcessor.setStyleRelation( 'margin', [
	 * 	'margin-top',
	 * 	'margin-right',
	 * 	'margin-bottom',
	 * 	'margin-left'
	 * ] );
	 * ```
	 *
	 * This enables expanding of style names for shorthands. For instance, if defined,
	 * {@link module:engine/conversion/viewconsumable~ViewConsumable view consumable} items are automatically created
	 * for long-hand margin style notation alongside the `'margin'` item.
	 *
	 * This means that when an element being converted has a style `margin`, a converter for `margin-left` will work just
	 * fine since the view consumable will contain a consumable `margin-left` item (thanks to the relation) and
	 * `element.getStyle( 'margin-left' )` will work as well assuming that the style processor was correctly configured.
	 * However, once `margin-left` is consumed, `margin` will not be consumable anymore.
	 */ setStyleRelation(shorthandName, styleNames) {
        this._mapStyleNames(shorthandName, styleNames);
        for (const alsoName of styleNames){
            this._mapStyleNames(alsoName, [
                shorthandName
            ]);
        }
    }
    /**
	 * Set two-way binding of style names.
	 */ _mapStyleNames(name, styleNames) {
        if (!this._consumables.has(name)) {
            this._consumables.set(name, []);
        }
        this._consumables.get(name).push(...styleNames);
    }
}
/**
 * Parses inline styles and puts property - value pairs into styles map.
 *
 * @param stylesString Styles to parse.
 * @returns Map of parsed properties and values.
 */ function parseInlineStyles(stylesString) {
    // `null` if no quote was found in input string or last found quote was a closing quote. See below.
    let quoteType = null;
    let propertyNameStart = 0;
    let propertyValueStart = 0;
    let propertyName = null;
    const stylesMap = new Map();
    // Do not set anything if input string is empty.
    if (stylesString === '') {
        return stylesMap;
    }
    // Fix inline styles that do not end with `;` so they are compatible with algorithm below.
    if (stylesString.charAt(stylesString.length - 1) != ';') {
        stylesString = stylesString + ';';
    }
    // Seek the whole string for "special characters".
    for(let i = 0; i < stylesString.length; i++){
        const char = stylesString.charAt(i);
        if (quoteType === null) {
            // No quote found yet or last found quote was a closing quote.
            switch(char){
                case ':':
                    // Most of time colon means that property name just ended.
                    // Sometimes however `:` is found inside property value (for example in background image url).
                    if (!propertyName) {
                        // Treat this as end of property only if property name is not already saved.
                        // Save property name.
                        propertyName = stylesString.substr(propertyNameStart, i - propertyNameStart);
                        // Save this point as the start of property value.
                        propertyValueStart = i + 1;
                    }
                    break;
                case '"':
                case '\'':
                    // Opening quote found (this is an opening quote, because `quoteType` is `null`).
                    quoteType = char;
                    break;
                case ';':
                    {
                        // Property value just ended.
                        // Use previously stored property value start to obtain property value.
                        const propertyValue = stylesString.substr(propertyValueStart, i - propertyValueStart);
                        if (propertyName) {
                            // Save parsed part.
                            stylesMap.set(propertyName.trim(), propertyValue.trim());
                        }
                        propertyName = null;
                        // Save this point as property name start. Property name starts immediately after previous property value ends.
                        propertyNameStart = i + 1;
                        break;
                    }
            }
        } else if (char === quoteType) {
            // If a quote char is found and it is a closing quote, mark this fact by `null`-ing `quoteType`.
            quoteType = null;
        }
    }
    return stylesMap;
}
/**
 * Return lodash compatible path from style name.
 */ function toPath(name) {
    return name.replace('-', '.');
}
/**
 * Appends style definition to the styles object.
 */ function appendStyleValue(stylesObject, nameOrPath, valueOrObject) {
    let valueToSet = valueOrObject;
    if (isObject(valueOrObject)) {
        valueToSet = merge({}, get(stylesObject, nameOrPath), valueOrObject);
    }
    set(stylesObject, nameOrPath, valueToSet);
}
/**
 * Modifies the `styles` deeply nested object by removing properties defined in `toRemove`.
 */ function removeStyles(styles, toRemove) {
    for (const key of Object.keys(toRemove)){
        if (styles[key] !== null && !Array.isArray(styles[key]) && typeof styles[key] == 'object' && typeof toRemove[key] == 'object') {
            removeStyles(styles[key], toRemove[key]);
            if (!Object.keys(styles[key]).length) {
                delete styles[key];
            }
        } else {
            delete styles[key];
        }
    }
}

/**
 * Token list. Allows handling (adding, removing, retrieving) a set of tokens (for example class names).
 */ class ViewTokenList {
    /**
	 * The set of tokens.
	 */ _set = new Set();
    /**
	 * Returns true if token list has no tokens set.
	 */ get isEmpty() {
        return this._set.size == 0;
    }
    /**
	 * Number of tokens.
	 */ get size() {
        return this._set.size;
    }
    /**
	 * Checks if a given token is set.
	 */ has(name) {
        return this._set.has(name);
    }
    /**
	 * Returns all tokens.
	 */ keys() {
        return Array.from(this._set.keys());
    }
    /**
	 * Resets the value to the given one.
	 */ setTo(value) {
        this.clear();
        for (const token of value.split(/\s+/)){
            if (token) {
                this._set.add(token);
            }
        }
        return this;
    }
    /**
	 * Sets a given token without affecting other tokens.
	 */ set(tokens) {
        for (const token of toArray(tokens)){
            if (token) {
                this._set.add(token);
            }
        }
    }
    /**
	 * Removes given token.
	 */ remove(tokens) {
        for (const token of toArray(tokens)){
            this._set.delete(token);
        }
    }
    /**
	 * Removes all tokens.
	 */ clear() {
        this._set.clear();
    }
    /**
	 * Returns a normalized tokens string.
	 */ toString() {
        return Array.from(this._set).join(' ');
    }
    /**
	 * Returns `true` if both attributes have the same tokens.
	 */ isSimilar(other) {
        if (this.size !== other.size) {
            return false;
        }
        for (const token of this.keys()){
            if (!other.has(token)) {
                return false;
            }
        }
        return true;
    }
    /**
	 * Clones the attribute value.
	 *
	 * @internal
	 */ _clone() {
        const clone = new this.constructor();
        clone._set = new Set(this._set);
        return clone;
    }
    /**
	 * Used by the {@link module:engine/view/matcher~Matcher Matcher} to collect matching attribute tokens.
	 *
	 * @internal
	 * @param tokenPattern The matched token name pattern.
	 * @returns An array of matching tokens.
	 */ _getTokensMatch(tokenPattern) {
        const match = [];
        if (tokenPattern === true) {
            for (const token of this._set.keys()){
                match.push(token);
            }
            return match;
        }
        if (typeof tokenPattern == 'string') {
            for (const token of tokenPattern.split(/\s+/)){
                if (this._set.has(token)) {
                    match.push(token);
                } else {
                    return undefined;
                }
            }
            return match;
        }
        for (const token of this._set.keys()){
            if (token.match(tokenPattern)) {
                match.push(token);
            }
        }
        return match.length ? match : undefined;
    }
    /**
	 * Returns a list of consumables for the attribute.
	 *
	 * Could be filtered by the given token name.
	 *
	 * @internal
	 */ _getConsumables(name) {
        return name ? [
            name
        ] : this.keys();
    }
    /**
	 * Used by {@link module:engine/view/element~ViewElement#_canMergeAttributesFrom} to verify if the given attribute
	 * can be merged without conflicts into the attribute.
	 *
	 * This method is indirectly used by the {@link module:engine/view/downcastwriter~ViewDowncastWriter} while downcasting
	 * an {@link module:engine/view/attributeelement~ViewAttributeElement} to merge it with other `AttributeElement`.
	 *
	 * @internal
	 */ _canMergeFrom() {
        return true;
    }
    /**
	 * Used by {@link module:engine/view/element~ViewElement#_mergeAttributesFrom} to merge a given attribute into the attribute.
	 *
	 * This method is indirectly used by the {@link module:engine/view/downcastwriter~ViewDowncastWriter} while down-casting
	 * an {@link module:engine/view/attributeelement~ViewAttributeElement} to merge it with other ViewAttributeElement.
	 *
	 * @internal
	 */ _mergeFrom(other) {
        for (const token of other._set.keys()){
            if (!this._set.has(token)) {
                this._set.add(token);
            }
        }
    }
    /**
	 * Used by {@link module:engine/view/element~ViewElement#_canSubtractAttributesOf} to verify if the given attribute
	 * can be fully subtracted from the attribute.
	 *
	 * This method is indirectly used by the {@link module:engine/view/downcastwriter~ViewDowncastWriter} while down-casting
	 * an {@link module:engine/view/attributeelement~ViewAttributeElement} to unwrap the ViewAttributeElement.
	 *
	 * @internal
	 */ _isMatching(other) {
        for (const name of other._set.keys()){
            if (!this._set.has(name)) {
                return false;
            }
        }
        return true;
    }
}

// @if CK_DEBUG_ENGINE // const { convertMapToTags } = require( '../dev-utils/utils' );
/**
 * View element.
 *
 * The editing engine does not define a fixed semantics of its elements (it is "DTD-free").
 * This is why the type of the {@link module:engine/view/element~ViewElement} need to
 * be defined by the feature developer. When creating an element you should use one of the following methods:
 *
 * * {@link module:engine/view/downcastwriter~ViewDowncastWriter#createContainerElement `downcastWriter#createContainerElement()`}
 * in order to create a {@link module:engine/view/containerelement~ViewContainerElement},
 * * {@link module:engine/view/downcastwriter~ViewDowncastWriter#createAttributeElement `downcastWriter#createAttributeElement()`}
 * in order to create a {@link module:engine/view/attributeelement~ViewAttributeElement},
 * * {@link module:engine/view/downcastwriter~ViewDowncastWriter#createEmptyElement `downcastWriter#createEmptyElement()`}
 * in order to create a {@link module:engine/view/emptyelement~ViewEmptyElement}.
 * * {@link module:engine/view/downcastwriter~ViewDowncastWriter#createUIElement `downcastWriter#createUIElement()`}
 * in order to create a {@link module:engine/view/uielement~ViewUIElement}.
 * * {@link module:engine/view/downcastwriter~ViewDowncastWriter#createEditableElement `downcastWriter#createEditableElement()`}
 * in order to create a {@link module:engine/view/editableelement~ViewEditableElement}.
 *
 * Note that for view elements which are not created from the model, like elements from mutations, paste or
 * {@link module:engine/controller/datacontroller~DataController#set data.set} it is not possible to define the type of the element.
 * In such cases the {@link module:engine/view/upcastwriter~ViewUpcastWriter#createElement `UpcastWriter#createElement()`} method
 * should be used to create generic view elements.
 */ class ViewElement extends ViewNode {
    /**
	 * Name of the element.
	 */ name;
    /**
	 * A list of attribute names that should be rendered in the editing pipeline even though filtering mechanisms
	 * implemented in the {@link module:engine/view/domconverter~ViewDomConverter} (for instance,
	 * {@link module:engine/view/domconverter~ViewDomConverter#shouldRenderAttribute}) would filter them out.
	 *
	 * These attributes can be specified as an option when the element is created by
	 * the {@link module:engine/view/downcastwriter~ViewDowncastWriter}. To check whether an unsafe an attribute should
	 * be permitted, use the {@link #shouldRenderUnsafeAttribute} method.
	 *
	 * @internal
	 */ _unsafeAttributesToRender = [];
    /**
	 * Map of attributes, where attributes names are keys and attributes values are values.
	 */ _attrs;
    /**
	 * Array of child nodes.
	 */ _children;
    /**
	 * Map of custom properties.
	 * Custom properties can be added to element instance, will be cloned but not rendered into DOM.
	 */ _customProperties = new Map();
    /**
	 * Set of classes associated with element instance.
	 *
	 * Note that this is just an alias for `this._attrs.get( 'class' );`
	 */ get _classes() {
        return this._attrs.get('class');
    }
    /**
	 * Normalized styles.
	 *
	 * Note that this is just an alias for `this._attrs.get( 'style' );`
	 */ get _styles() {
        return this._attrs.get('style');
    }
    /**
	 * Creates a view element.
	 *
	 * Attributes can be passed in various formats:
	 *
	 * ```ts
	 * new Element( viewDocument, 'div', { class: 'editor', contentEditable: 'true' } ); // object
	 * new Element( viewDocument, 'div', [ [ 'class', 'editor' ], [ 'contentEditable', 'true' ] ] ); // map-like iterator
	 * new Element( viewDocument, 'div', mapOfAttributes ); // map
	 * ```
	 *
	 * @internal
	 * @param document The document instance to which this element belongs.
	 * @param name Node name.
	 * @param attrs Collection of attributes.
	 * @param children A list of nodes to be inserted into created element.
	 */ constructor(document, name, attrs, children){
        super(document);
        this.name = name;
        this._attrs = this._parseAttributes(attrs);
        this._children = [];
        if (children) {
            this._insertChild(0, children);
        }
    }
    /**
	 * Number of element's children.
	 */ get childCount() {
        return this._children.length;
    }
    /**
	 * Is `true` if there are no nodes inside this element, `false` otherwise.
	 */ get isEmpty() {
        return this._children.length === 0;
    }
    /**
	 * Gets child at the given index.
	 *
	 * @param index Index of child.
	 * @returns Child node.
	 */ getChild(index) {
        return this._children[index];
    }
    /**
	 * Gets index of the given child node. Returns `-1` if child node is not found.
	 *
	 * @param node Child node.
	 * @returns Index of the child node.
	 */ getChildIndex(node) {
        return this._children.indexOf(node);
    }
    /**
	 * Gets child nodes iterator.
	 *
	 * @returns Child nodes iterator.
	 */ getChildren() {
        return this._children[Symbol.iterator]();
    }
    /**
	 * Returns an iterator that contains the keys for attributes. Order of inserting attributes is not preserved.
	 *
	 * @returns Keys for attributes.
	 */ *getAttributeKeys() {
        // This is yielded in this specific order to maintain backward compatibility of data.
        // Otherwise, we could simply just have the `for` loop only inside this method.
        if (this._classes) {
            yield 'class';
        }
        if (this._styles) {
            yield 'style';
        }
        for (const key of this._attrs.keys()){
            if (key != 'class' && key != 'style') {
                yield key;
            }
        }
    }
    /**
	 * Returns iterator that iterates over this element's attributes.
	 *
	 * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
	 * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
	 */ *getAttributes() {
        for (const [name, value] of this._attrs.entries()){
            yield [
                name,
                String(value)
            ];
        }
    }
    /**
	 * Gets attribute by key. If attribute is not present - returns undefined.
	 *
	 * @param key Attribute key.
	 * @returns Attribute value.
	 */ getAttribute(key) {
        return this._attrs.has(key) ? String(this._attrs.get(key)) : undefined;
    }
    /**
	 * Returns a boolean indicating whether an attribute with the specified key exists in the element.
	 *
	 * @param key Attribute key.
	 * @returns `true` if attribute with the specified key exists in the element, `false` otherwise.
	 */ hasAttribute(key, token) {
        if (!this._attrs.has(key)) {
            return false;
        }
        if (token !== undefined) {
            if (usesStylesMap(this.name, key) || usesTokenList(this.name, key)) {
                return this._attrs.get(key).has(token);
            } else {
                return this._attrs.get(key) === token;
            }
        }
        return true;
    }
    /**
	 * Checks if this element is similar to other element.
	 * Both elements should have the same name and attributes to be considered as similar. Two similar elements
	 * can contain different set of children nodes.
	 */ isSimilar(otherElement) {
        if (!(otherElement instanceof ViewElement)) {
            return false;
        }
        // If exactly the same Element is provided - return true immediately.
        if (this === otherElement) {
            return true;
        }
        // Check element name.
        if (this.name != otherElement.name) {
            return false;
        }
        // Check number of attributes, classes and styles.
        if (this._attrs.size !== otherElement._attrs.size) {
            return false;
        }
        // Check if attributes are the same.
        for (const [key, value] of this._attrs){
            const otherValue = otherElement._attrs.get(key);
            if (otherValue === undefined) {
                return false;
            }
            if (typeof value == 'string' || typeof otherValue == 'string') {
                if (otherValue !== value) {
                    return false;
                }
            } else if (!value.isSimilar(otherValue)) {
                return false;
            }
        }
        return true;
    }
    /**
	 * Returns true if class is present.
	 * If more then one class is provided - returns true only when all classes are present.
	 *
	 * ```ts
	 * element.hasClass( 'foo' ); // Returns true if 'foo' class is present.
	 * element.hasClass( 'foo', 'bar' ); // Returns true if 'foo' and 'bar' classes are both present.
	 * ```
	 */ hasClass(...className) {
        for (const name of className){
            if (!this._classes || !this._classes.has(name)) {
                return false;
            }
        }
        return true;
    }
    /**
	 * Returns iterator that contains all class names.
	 */ getClassNames() {
        const array = this._classes ? this._classes.keys() : [];
        // This is overcomplicated because we need to be backward compatible for use cases when iterator is expected.
        const iterator = array[Symbol.iterator]();
        return Object.assign(array, {
            next: iterator.next.bind(iterator)
        });
    }
    /**
	 * Returns style value for the given property name.
	 * If the style does not exist `undefined` is returned.
	 *
	 * **Note**: This method can work with normalized style names if
	 * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
	 * See {@link module:engine/view/stylesmap~StylesMap#getAsString `StylesMap#getAsString()`} for details.
	 *
	 * For an element with style set to `'margin:1px'`:
	 *
	 * ```ts
	 * // Enable 'margin' shorthand processing:
	 * editor.data.addStyleProcessorRules( addMarginStylesRules );
	 *
	 * const element = view.change( writer => {
	 * 	const element = writer.createElement();
	 * 	writer.setStyle( 'margin', '1px' );
	 * 	writer.setStyle( 'margin-bottom', '3em' );
	 *
	 * 	return element;
	 * } );
	 *
	 * element.getStyle( 'margin' ); // -> 'margin: 1px 1px 3em;'
	 * ```
	 */ getStyle(property) {
        return this._styles && this._styles.getAsString(property);
    }
    /**
	 * Returns a normalized style object or single style value.
	 *
	 * For an element with style set to: margin:1px 2px 3em;
	 *
	 * ```ts
	 * element.getNormalizedStyle( 'margin' ) );
	 * ```
	 *
	 * will return:
	 *
	 * ```ts
	 * {
	 * 	top: '1px',
	 * 	right: '2px',
	 * 	bottom: '3em',
	 * 	left: '2px'    // a normalized value from margin shorthand
	 * }
	 * ```
	 *
	 * and reading for single style value:
	 *
	 * ```ts
	 * styles.getNormalizedStyle( 'margin-left' );
	 * ```
	 *
	 * Will return a `2px` string.
	 *
	 * **Note**: This method will return normalized values only if
	 * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
	 * See {@link module:engine/view/stylesmap~StylesMap#getNormalized `StylesMap#getNormalized()`} for details.
	 *
	 * @param property Name of CSS property
	 */ getNormalizedStyle(property) {
        return this._styles && this._styles.getNormalized(property);
    }
    /**
	 * Returns an array that contains all style names.
	 *
	 * @param expand Expand shorthand style properties and return all equivalent style representations.
	 */ getStyleNames(expand) {
        return this._styles ? this._styles.getStyleNames(expand) : [];
    }
    /**
	 * Returns true if style keys are present.
	 * If more then one style property is provided - returns true only when all properties are present.
	 *
	 * ```ts
	 * element.hasStyle( 'color' ); // Returns true if 'border-top' style is present.
	 * element.hasStyle( 'color', 'border-top' ); // Returns true if 'color' and 'border-top' styles are both present.
	 * ```
	 */ hasStyle(...property) {
        for (const name of property){
            if (!this._styles || !this._styles.has(name)) {
                return false;
            }
        }
        return true;
    }
    /**
	 * Returns ancestor element that match specified pattern.
	 * Provided patterns should be compatible with {@link module:engine/view/matcher~Matcher Matcher} as it is used internally.
	 *
	 * @see module:engine/view/matcher~Matcher
	 * @param patterns Patterns used to match correct ancestor. See {@link module:engine/view/matcher~Matcher}.
	 * @returns Found element or `null` if no matching ancestor was found.
	 */ findAncestor(...patterns) {
        const matcher = new Matcher(...patterns);
        let parent = this.parent;
        while(parent && !parent.is('documentFragment')){
            if (matcher.match(parent)) {
                return parent;
            }
            parent = parent.parent;
        }
        return null;
    }
    /**
	 * Returns the custom property value for the given key.
	 */ getCustomProperty(key) {
        return this._customProperties.get(key);
    }
    /**
	 * Returns an iterator which iterates over this element's custom properties.
	 * Iterator provides `[ key, value ]` pairs for each stored property.
	 */ *getCustomProperties() {
        yield* this._customProperties.entries();
    }
    /**
	 * Returns identity string based on element's name, styles, classes and other attributes.
	 * Two elements that {@link #isSimilar are similar} will have same identity string.
	 * It has the following format:
	 *
	 * ```ts
	 * 'name class="class1,class2" style="style1:value1;style2:value2" attr1="val1" attr2="val2"'
	 * ```
 	 *
	 * For example:
	 *
	 * ```ts
	 * const element = writer.createContainerElement( 'foo', {
	 * 	banana: '10',
	 * 	apple: '20',
	 * 	style: 'color: red; border-color: white;',
	 * 	class: 'baz'
	 * } );
	 *
	 * // returns 'foo class="baz" style="border-color:white;color:red" apple="20" banana="10"'
	 * element.getIdentity();
	 * ```
	 *
	 * **Note**: Classes, styles and other attributes are sorted alphabetically.
	 */ getIdentity() {
        const classes = this._classes ? this._classes.keys().sort().join(',') : '';
        const styles = this._styles && String(this._styles);
        const attributes = Array.from(this._attrs).filter(([key])=>key != 'style' && key != 'class').map((i)=>`${i[0]}="${i[1]}"`).sort().join(' ');
        return this.name + (classes == '' ? '' : ` class="${classes}"`) + (!styles ? '' : ` style="${styles}"`) + (attributes == '' ? '' : ` ${attributes}`);
    }
    /**
	 * Decides whether an unsafe attribute is whitelisted and should be rendered in the editing pipeline even though filtering mechanisms
	 * like {@link module:engine/view/domconverter~ViewDomConverter#shouldRenderAttribute} say it should not.
	 *
	 * Unsafe attribute names can be specified when creating an element via {@link module:engine/view/downcastwriter~ViewDowncastWriter}.
	 *
	 * @param attributeName The name of the attribute to be checked.
	 */ shouldRenderUnsafeAttribute(attributeName) {
        return this._unsafeAttributesToRender.includes(attributeName);
    }
    /**
	 * Clones provided element.
	 *
	 * @internal
	 * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
	 * element will be cloned without any children.
	 * @returns Clone of this element.
	 */ _clone(deep = false) {
        const childrenClone = [];
        if (deep) {
            for (const child of this.getChildren()){
                childrenClone.push(child._clone(deep));
            }
        }
        // ViewContainerElement and ViewAttributeElement should be also cloned properly.
        const cloned = new this.constructor(this.document, this.name, this._attrs, childrenClone);
        // Clone custom properties.
        cloned._customProperties = new Map(this._customProperties);
        // Clone filler offset method.
        // We can't define this method in a prototype because it's behavior which
        // is changed by e.g. toWidget() function from ckeditor5-widget. Perhaps this should be one of custom props.
        cloned.getFillerOffset = this.getFillerOffset;
        // Clone unsafe attributes list.
        cloned._unsafeAttributesToRender = this._unsafeAttributesToRender;
        return cloned;
    }
    /**
	 * {@link module:engine/view/element~ViewElement#_insertChild Insert} a child node or a list of child nodes at the end of this node
	 * and sets the parent of these nodes to this element.
	 *
	 * @see module:engine/view/downcastwriter~ViewDowncastWriter#insert
	 * @internal
	 * @param items Items to be inserted.
	 * @fires change
	 * @returns Number of appended nodes.
	 */ _appendChild(items) {
        return this._insertChild(this.childCount, items);
    }
    /**
	 * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
	 * this element.
	 *
	 * @internal
	 * @see module:engine/view/downcastwriter~ViewDowncastWriter#insert
	 * @param index Position where nodes should be inserted.
	 * @param items Items to be inserted.
	 * @fires change
	 * @returns Number of inserted nodes.
	 */ _insertChild(index, items) {
        this._fireChange('children', this, {
            index
        });
        let count = 0;
        const nodes = normalize$3(this.document, items);
        for (const node of nodes){
            // If node that is being added to this element is already inside another element, first remove it from the old parent.
            if (node.parent !== null) {
                node._remove();
            }
            node.parent = this;
            node.document = this.document;
            this._children.splice(index, 0, node);
            index++;
            count++;
        }
        return count;
    }
    /**
	 * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.
	 *
	 * @see module:engine/view/downcastwriter~ViewDowncastWriter#remove
	 * @internal
	 * @param index Number of the first node to remove.
	 * @param howMany Number of nodes to remove.
	 * @fires change
	 * @returns The array of removed nodes.
	 */ _removeChildren(index, howMany = 1) {
        this._fireChange('children', this, {
            index
        });
        for(let i = index; i < index + howMany; i++){
            this._children[i].parent = null;
        }
        return this._children.splice(index, howMany);
    }
    /**
	 * Adds or overwrite attribute with a specified key and value.
	 *
	 * @see module:engine/view/downcastwriter~ViewDowncastWriter#setAttribute
	 * @internal
	 * @param key Attribute key.
	 * @param value Attribute value.
	 * @param overwrite Whether tokenized attribute should override the attribute value or just add a token.
	 * @fires change
	 */ _setAttribute(key, value, overwrite = true) {
        this._fireChange('attributes', this);
        if (usesStylesMap(this.name, key) || usesTokenList(this.name, key)) {
            let currentValue = this._attrs.get(key);
            if (!currentValue) {
                currentValue = usesStylesMap(this.name, key) ? new StylesMap(this.document.stylesProcessor) : new ViewTokenList();
                this._attrs.set(key, currentValue);
            }
            if (overwrite) {
                // If reset is set then value have to be a string to tokenize.
                currentValue.setTo(String(value));
            } else if (usesStylesMap(this.name, key)) {
                if (Array.isArray(value)) {
                    currentValue.set(value[0], value[1]);
                } else {
                    currentValue.set(value);
                }
            } else {
                currentValue.set(typeof value == 'string' ? value.split(/\s+/) : value);
            }
        } else {
            this._attrs.set(key, String(value));
        }
    }
    /**
	 * Removes attribute from the element.
	 *
	 * @see module:engine/view/downcastwriter~ViewDowncastWriter#removeAttribute
	 * @internal
	 * @param key Attribute key.
	 * @param tokens Attribute value tokens to remove. The whole attribute is removed if not specified.
	 * @returns Returns true if an attribute existed and has been removed.
	 * @fires change
	 */ _removeAttribute(key, tokens) {
        this._fireChange('attributes', this);
        if (tokens !== undefined && (usesStylesMap(this.name, key) || usesTokenList(this.name, key))) {
            const currentValue = this._attrs.get(key);
            if (!currentValue) {
                return false;
            }
            if (usesTokenList(this.name, key) && typeof tokens == 'string') {
                tokens = tokens.split(/\s+/);
            }
            currentValue.remove(tokens);
            if (currentValue.isEmpty) {
                return this._attrs.delete(key);
            }
            return false;
        }
        return this._attrs.delete(key);
    }
    /**
	 * Adds specified class.
	 *
	 * ```ts
	 * element._addClass( 'foo' ); // Adds 'foo' class.
	 * element._addClass( [ 'foo', 'bar' ] ); // Adds 'foo' and 'bar' classes.
	 * ```
	 *
	 * @see module:engine/view/downcastwriter~ViewDowncastWriter#addClass
	 * @internal
	 * @fires change
	 */ _addClass(className) {
        this._setAttribute('class', className, false);
    }
    /**
	 * Removes specified class.
	 *
	 * ```ts
	 * element._removeClass( 'foo' );  // Removes 'foo' class.
	 * element._removeClass( [ 'foo', 'bar' ] ); // Removes both 'foo' and 'bar' classes.
	 * ```
	 *
	 * @see module:engine/view/downcastwriter~ViewDowncastWriter#removeClass
	 * @internal
	 * @fires change
	 */ _removeClass(className) {
        this._removeAttribute('class', className);
    }
    _setStyle(property, value) {
        if (typeof property != 'string') {
            this._setAttribute('style', property, false);
        } else {
            this._setAttribute('style', [
                property,
                value
            ], false);
        }
    }
    /**
	 * Removes specified style.
	 *
	 * ```ts
	 * element._removeStyle( 'color' );  // Removes 'color' style.
	 * element._removeStyle( [ 'color', 'border-top' ] ); // Removes both 'color' and 'border-top' styles.
	 * ```
	 *
	 * **Note**: This method can work with normalized style names if
	 * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
	 * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.
	 *
	 * @see module:engine/view/downcastwriter~ViewDowncastWriter#removeStyle
	 * @internal
	 * @fires change
	 */ _removeStyle(property) {
        this._removeAttribute('style', property);
    }
    /**
	 * Used by the {@link module:engine/view/matcher~Matcher Matcher} to collect matching attribute tuples
	 * (attribute name and optional token).
	 *
	 * Normalized patterns can be used in following ways:
	 * - to match any attribute name with any or no value:
	 *
	 * ```ts
	 * patterns: [
	 * 	[ true, true ]
	 * ]
	 * ```
	 *
	 * - to match a specific attribute with any value:
	 *
	 * ```ts
	 * patterns: [
	 * 	[ 'required', true ]
	 * ]
	 * ```
	 *
	 * - to match an attribute name with a RegExp with any value:
	 *
	 * ```ts
	 * patterns: [
	 * 	[ /h[1-6]/, true ]
	 * ]
	 * ```
	 *
	 * 	- to match a specific attribute with the exact value:
	 *
	 * ```ts
	 * patterns: [
	 * 	[ 'rel', 'nofollow' ]
	 * ]
	 * ```
	 *
	 * 	- to match a specific attribute with a value matching a RegExp:
	 *
	 * ```ts
	 * patterns: [
	 * 	[ 'src', /^https/ ]
	 * ]
	 * ```
	 *
	 * 	- to match an attribute name with a RegExp and the exact value:
	 *
	 * ```ts
	 * patterns: [
	 * 	[ /^data-property-/, 'foobar' ],
	 * ]
	 * ```
	 *
	 * 	- to match an attribute name with a RegExp and match a value with another RegExp:
	 *
	 * ```ts
	 * patterns: [
	 * 	[ /^data-property-/, /^foo/ ]
	 * ]
	 * ```
	 *
	 * 	- to match a specific style property with the value matching a RegExp:
	 *
	 * ```ts
	 * patterns: [
	 * 	[ 'style', 'font-size', /px$/ ]
	 * ]
	 * ```
	 *
	 * 	- to match a specific class (class attribute is tokenized so it matches tokens individually):
	 *
	 * ```ts
	 * patterns: [
	 * 	[ 'class', 'foo' ]
	 * ]
	 * ```
	 *
	 * @internal
	 * @param patterns An array of normalized patterns (tuples of 2 or 3 items depending on if tokenized attribute value match is needed).
	 * @param match An array to populate with matching tuples.
	 * @param exclude Array of attribute names to exclude from match.
	 * @returns `true` if element matches all patterns. The matching tuples are pushed to the `match` array.
	 */ _collectAttributesMatch(patterns, match, exclude) {
        for (const [keyPattern, tokenPattern, valuePattern] of patterns){
            let hasKey = false;
            let hasValue = false;
            for (const [key, value] of this._attrs){
                if (exclude && exclude.includes(key) || !isPatternMatched(keyPattern, key)) {
                    continue;
                }
                hasKey = true;
                if (typeof value == 'string') {
                    if (isPatternMatched(tokenPattern, value)) {
                        match.push([
                            key
                        ]);
                        hasValue = true;
                    } else if (!(keyPattern instanceof RegExp)) {
                        return false;
                    }
                } else {
                    const tokenMatch = value._getTokensMatch(tokenPattern, valuePattern || true);
                    if (tokenMatch) {
                        hasValue = true;
                        for (const tokenMatchItem of tokenMatch){
                            match.push([
                                key,
                                tokenMatchItem
                            ]);
                        }
                    } else if (!(keyPattern instanceof RegExp)) {
                        return false;
                    }
                }
            }
            if (!hasKey || !hasValue) {
                return false;
            }
        }
        return true;
    }
    /**
	 * Used by the {@link module:engine/conversion/viewconsumable~ViewConsumable} to collect the
	 * {@link module:engine/view/element~ViewNormalizedConsumables} for the element.
	 *
	 * When `key` and `token` parameters are provided the output is filtered for the specified attribute and it's tokens and related tokens.
	 *
	 * @internal
	 * @param key Attribute name.
	 * @param token Reference token to collect all related tokens.
	 */ _getConsumables(key, token) {
        const attributes = [];
        if (key) {
            const value = this._attrs.get(key);
            if (value !== undefined) {
                if (typeof value == 'string') {
                    attributes.push([
                        key
                    ]);
                } else {
                    for (const prop of value._getConsumables(token)){
                        attributes.push([
                            key,
                            prop
                        ]);
                    }
                }
            }
        } else {
            for (const [key, value] of this._attrs){
                if (typeof value == 'string') {
                    attributes.push([
                        key
                    ]);
                } else {
                    for (const prop of value._getConsumables()){
                        attributes.push([
                            key,
                            prop
                        ]);
                    }
                }
            }
        }
        return {
            name: !key,
            attributes
        };
    }
    /**
	 * Verify if the given element can be merged without conflicts into the element.
	 *
	 * Note that this method is extended by the {@link module:engine/view/attributeelement~ViewAttributeElement} implementation.
	 *
	 * This method is used by the {@link module:engine/view/downcastwriter~ViewDowncastWriter} while down-casting
	 * an {@link module:engine/view/attributeelement~ViewAttributeElement} to merge it with other ViewAttributeElement.
	 *
	 * @internal
	 * @returns Returns `true` if elements can be merged.
	 */ _canMergeAttributesFrom(otherElement) {
        if (this.name != otherElement.name) {
            return false;
        }
        for (const [key, otherValue] of otherElement._attrs){
            const value = this._attrs.get(key);
            if (value === undefined) {
                continue;
            }
            if (typeof value == 'string' || typeof otherValue == 'string') {
                if (value !== otherValue) {
                    return false;
                }
            } else if (!value._canMergeFrom(otherValue)) {
                return false;
            }
        }
        return true;
    }
    /**
	 * Merges attributes of a given element into the element.
	 * This includes also tokenized attributes like style and class.
	 *
	 * Note that you should make sure there are no conflicts before merging (see {@link #_canMergeAttributesFrom}).
	 *
	 * This method is used by the {@link module:engine/view/downcastwriter~ViewDowncastWriter} while down-casting
	 * an {@link module:engine/view/attributeelement~ViewAttributeElement} to merge it with other ViewAttributeElement.
	 *
	 * @internal
	 */ _mergeAttributesFrom(otherElement) {
        this._fireChange('attributes', this);
        // Move all attributes/classes/styles from wrapper to wrapped ViewAttributeElement.
        for (const [key, otherValue] of otherElement._attrs){
            const value = this._attrs.get(key);
            if (value === undefined || typeof value == 'string' || typeof otherValue == 'string') {
                this._setAttribute(key, otherValue);
            } else {
                value._mergeFrom(otherValue);
            }
        }
    }
    /**
	 * Verify if the given element attributes can be fully subtracted from the element.
	 *
	 * Note that this method is extended by the {@link module:engine/view/attributeelement~ViewAttributeElement} implementation.
	 *
	 * This method is used by the {@link module:engine/view/downcastwriter~ViewDowncastWriter} while down-casting
	 * an {@link module:engine/view/attributeelement~ViewAttributeElement} to unwrap the ViewAttributeElement.
	 *
	 * @internal
	 * @returns Returns `true` if elements attributes can be fully subtracted.
	 */ _canSubtractAttributesOf(otherElement) {
        if (this.name != otherElement.name) {
            return false;
        }
        for (const [key, otherValue] of otherElement._attrs){
            const value = this._attrs.get(key);
            if (value === undefined) {
                return false;
            }
            if (typeof value == 'string' || typeof otherValue == 'string') {
                if (value !== otherValue) {
                    return false;
                }
            } else if (!value._isMatching(otherValue)) {
                return false;
            }
        }
        return true;
    }
    /**
	 * Removes (subtracts) corresponding attributes of the given element from the element.
	 * This includes also tokenized attributes like style and class.
	 * All attributes, classes and styles from given element should be present inside the element being unwrapped.
	 *
	 * Note that you should make sure all attributes could be subtracted before subtracting them (see {@link #_canSubtractAttributesOf}).
	 *
	 * This method is used by the {@link module:engine/view/downcastwriter~ViewDowncastWriter} while down-casting
	 * an {@link module:engine/view/attributeelement~ViewAttributeElement} to unwrap the ViewAttributeElement.
	 *
	 * @internal
	 */ _subtractAttributesOf(otherElement) {
        this._fireChange('attributes', this);
        for (const [key, otherValue] of otherElement._attrs){
            const value = this._attrs.get(key);
            if (typeof value == 'string' || typeof otherValue == 'string') {
                this._attrs.delete(key);
            } else {
                value.remove(otherValue.keys());
                if (value.isEmpty) {
                    this._attrs.delete(key);
                }
            }
        }
    }
    /**
	 * Sets a custom property. Unlike attributes, custom properties are not rendered to the DOM,
	 * so they can be used to add special data to elements.
	 *
	 * @see module:engine/view/downcastwriter~ViewDowncastWriter#setCustomProperty
	 * @internal
	 */ _setCustomProperty(key, value) {
        this._customProperties.set(key, value);
    }
    /**
	 * Removes the custom property stored under the given key.
	 *
	 * @see module:engine/view/downcastwriter~ViewDowncastWriter#removeCustomProperty
	 * @internal
	 * @returns Returns true if property was removed.
	 */ _removeCustomProperty(key) {
        return this._customProperties.delete(key);
    }
    /**
	 * Parses attributes provided to the element constructor before they are applied to an element. If attributes are passed
	 * as an object (instead of `Iterable`), the object is transformed to the map. Attributes with `null` value are removed.
	 * Attributes with non-`String` value are converted to `String`.
	 *
	 * @param attrs Attributes to parse.
	 * @returns Parsed attributes.
	 */ _parseAttributes(attrs) {
        const attrsMap = toMap(attrs);
        for (const [key, value] of attrsMap){
            if (value === null) {
                attrsMap.delete(key);
            } else if (usesStylesMap(this.name, key)) {
                // This is either an element clone so we need to clone styles map, or a new instance which requires value to be parsed.
                const newValue = value instanceof StylesMap ? value._clone() : new StylesMap(this.document.stylesProcessor).setTo(String(value));
                attrsMap.set(key, newValue);
            } else if (usesTokenList(this.name, key)) {
                // This is either an element clone so we need to clone token list, or a new instance which requires value to be parsed.
                const newValue = value instanceof ViewTokenList ? value._clone() : new ViewTokenList().setTo(String(value));
                attrsMap.set(key, newValue);
            } else if (typeof value != 'string') {
                attrsMap.set(key, String(value));
            }
        }
        return attrsMap;
    }
}
// The magic of type inference using `is` method is centralized in `TypeCheckable` class.
// Proper overload would interfere with that.
ViewElement.prototype.is = function(type, name) {
    if (!name) {
        return type === 'element' || type === 'view:element' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === 'node' || type === 'view:node';
    } else {
        return name === this.name && (type === 'element' || type === 'view:element');
    }
};
/**
 * Converts strings to Text and non-iterables to arrays.
 */ function normalize$3(document, nodes) {
    // Separate condition because string is iterable.
    if (typeof nodes == 'string') {
        return [
            new ViewText(document, nodes)
        ];
    }
    if (!isIterable(nodes)) {
        nodes = [
            nodes
        ];
    }
    const normalizedNodes = [];
    for (const node of nodes){
        if (typeof node == 'string') {
            normalizedNodes.push(new ViewText(document, node));
        } else if (node instanceof ViewTextProxy) {
            normalizedNodes.push(new ViewText(document, node.data));
        } else {
            normalizedNodes.push(node);
        }
    }
    return normalizedNodes;
}
/**
 * Returns `true` if an attribute on a given element should be handled as a TokenList.
 */ function usesTokenList(elementName, key) {
    return key == 'class' || elementName == 'a' && key == 'rel';
}
/**
 * Returns `true` if an attribute on a given element should be handled as a StylesMap.
 */ function usesStylesMap(elementName, key) {
    return key == 'style';
}

/**
 * Containers are elements which define document structure. They define boundaries for
 * {@link module:engine/view/attributeelement~ViewAttributeElement attributes}.
 * They are mostly used for block elements like `<p>` or `<div>`.
 *
 * Editing engine does not define a fixed HTML DTD. This is why a feature developer needs to choose between various
 * types (container element, {@link module:engine/view/attributeelement~ViewAttributeElement attribute element},
 * {@link module:engine/view/emptyelement~ViewEmptyElement empty element}, etc) when developing a feature.
 *
 * The container element should be your default choice when writing a converter, unless:
 *
 * * this element represents a model text attribute (then use {@link module:engine/view/attributeelement~ViewAttributeElement}),
 * * this is an empty element like `<img>` (then use {@link module:engine/view/emptyelement~ViewEmptyElement}),
 * * this is a root element,
 * * this is a nested editable element (then use  {@link module:engine/view/editableelement~ViewEditableElement}).
 *
 * To create a new container element instance use the
 * {@link module:engine/view/downcastwriter~ViewDowncastWriter#createContainerElement `ViewDowncastWriter#createContainerElement()`}
 * method.
 */ class ViewContainerElement extends ViewElement {
    /**
	 * Creates a container element.
	 *
	 * @see module:engine/view/downcastwriter~ViewDowncastWriter#createContainerElement
	 * @see module:engine/view/element~ViewElement
	 * @internal
	 * @param document The document instance to which this element belongs.
	 * @param name Node name.
	 * @param attrs Collection of attributes.
	 * @param children A list of nodes to be inserted into created element.
	 */ constructor(document, name, attrs, children){
        super(document, name, attrs, children);
        this.getFillerOffset = getViewFillerOffset;
    }
}
// The magic of type inference using `is` method is centralized in `TypeCheckable` class.
// Proper overload would interfere with that.
ViewContainerElement.prototype.is = function(type, name) {
    if (!name) {
        return type === 'containerElement' || type === 'view:containerElement' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === 'element' || type === 'view:element' || type === 'node' || type === 'view:node';
    } else {
        return name === this.name && (type === 'containerElement' || type === 'view:containerElement' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === 'element' || type === 'view:element');
    }
};
/**
 * Returns block {@link module:engine/view/filler filler} offset or `null` if block filler is not needed.
 *
 * @returns Block filler offset or `null` if block filler is not needed.
 */ function getViewFillerOffset() {
    const children = [
        ...this.getChildren()
    ];
    const lastChild = children[this.childCount - 1];
    // Block filler is required after a `<br>` if it's the last element in its container. See #1422.
    if (lastChild && lastChild.is('element', 'br')) {
        return this.childCount;
    }
    for (const child of children){
        // If there's any non-UI element – don't render the bogus.
        if (!child.is('uiElement')) {
            return null;
        }
    }
    // If there are only UI elements – render the bogus at the end of the element.
    return this.childCount;
}

/**
 * Editable element which can be a {@link module:engine/view/rooteditableelement~ViewRootEditableElement root}
 * or nested editable area in the editor.
 *
 * Editable is automatically read-only when its {@link module:engine/view/document~ViewDocument Document} is read-only.
 *
 * The constructor of this class shouldn't be used directly. To create new `ViewEditableElement` use the
 * {@link module:engine/view/downcastwriter~ViewDowncastWriter#createEditableElement `downcastWriter#createEditableElement()`} method.
 */ class ViewEditableElement extends /* #__PURE__ */ ObservableMixin(ViewContainerElement) {
    /**
	 * Creates an editable element.
	 *
	 * @see module:engine/view/downcastwriter~ViewDowncastWriter#createEditableElement
	 * @internal
	 * @param document The document instance to which this element belongs.
	 * @param name Node name.
	 * @param attributes Collection of attributes.
	 * @param children A list of nodes to be inserted into created element.
	 */ constructor(document, name, attributes, children){
        super(document, name, attributes, children);
        this.set('isReadOnly', false);
        this.set('isFocused', false);
        this.set('placeholder', undefined);
        this.bind('isReadOnly').to(document);
        this.bind('isFocused').to(document, 'isFocused', (isFocused)=>isFocused && document.selection.editableElement == this);
        // Update focus state based on selection changes.
        this.listenTo(document.selection, 'change', ()=>{
            this.isFocused = document.isFocused && document.selection.editableElement == this;
        });
    }
    destroy() {
        this.stopListening();
    }
}
// The magic of type inference using `is` method is centralized in `TypeCheckable` class.
// Proper overload would interfere with that.
ViewEditableElement.prototype.is = function(type, name) {
    if (!name) {
        return type === 'editableElement' || type === 'view:editableElement' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === 'containerElement' || type === 'view:containerElement' || type === 'element' || type === 'view:element' || type === 'node' || type === 'view:node';
    } else {
        return name === this.name && (type === 'editableElement' || type === 'view:editableElement' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === 'containerElement' || type === 'view:containerElement' || type === 'element' || type === 'view:element');
    }
};

const rootNameSymbol = Symbol('rootName');
/**
 * Class representing a single root in the data view. A root can be either
 * {@link ~ViewRootEditableElement#isReadOnly editable or read-only},
 * but in both cases it is called "an editable". Roots can contain other {@link module:engine/view/editableelement~ViewEditableElement
 * editable elements} making them "nested editables".
 */ class ViewRootEditableElement extends ViewEditableElement {
    /**
	 * Creates root editable element.
	 *
	 * @param document The document instance to which this element belongs.
	 * @param name Node name.
	 */ constructor(document, name){
        super(document, name);
        this.rootName = 'main';
    }
    /**
	 * Name of this root inside {@link module:engine/view/document~ViewDocument} that is an owner of this root. If no
	 * other name is set, `main` name is used.
	 *
	 * @readonly
	 */ get rootName() {
        return this.getCustomProperty(rootNameSymbol);
    }
    set rootName(rootName) {
        this._setCustomProperty(rootNameSymbol, rootName);
    }
    /**
	 * Overrides old element name and sets new one.
	 * This is needed because view roots are created before they are attached to the DOM.
	 * The name of the root element is temporary at this stage. It has to be changed when the
	 * view root element is attached to the DOM element.
	 *
	 * @internal
	 * @param name The new name of element.
	 */ set _name(name) {
        this.name = name;
    }
}
// The magic of type inference using `is` method is centralized in `TypeCheckable` class.
// Proper overload would interfere with that.
ViewRootEditableElement.prototype.is = function(type, name) {
    if (!name) {
        return type === 'rootElement' || type === 'view:rootElement' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === 'editableElement' || type === 'view:editableElement' || type === 'containerElement' || type === 'view:containerElement' || type === 'element' || type === 'view:element' || type === 'node' || type === 'view:node';
    } else {
        return name === this.name && (type === 'rootElement' || type === 'view:rootElement' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === 'editableElement' || type === 'view:editableElement' || type === 'containerElement' || type === 'view:containerElement' || type === 'element' || type === 'view:element');
    }
};

/**
 * Position iterator class. It allows to iterate forward and backward over the document.
 */ class ViewTreeWalker {
    /**
	 * Walking direction. Defaults `'forward'`.
	 */ direction;
    /**
	 * Iterator boundaries.
	 *
	 * When the iterator is walking `'forward'` on the end of boundary or is walking `'backward'`
	 * on the start of boundary, then `{ done: true }` is returned.
	 *
	 * If boundaries are not defined they are set before first and after last child of the root node.
	 */ boundaries;
    /**
	 * Flag indicating whether all characters from {@link module:engine/view/text~ViewText} should be returned as one
	 * {@link module:engine/view/text~ViewText} or one by one as {@link module:engine/view/textproxy~ViewTextProxy}.
	 */ singleCharacters;
    /**
	 * Flag indicating whether iterator should enter elements or not. If the iterator is shallow child nodes of any
	 * iterated node will not be returned along with `elementEnd` tag.
	 */ shallow;
    /**
	 * Flag indicating whether iterator should ignore `elementEnd` tags. If set to `true`, walker will not
	 * return a parent node of the start position. Each {@link module:engine/view/element~ViewElement} will be returned once.
	 * When set to `false` each element might be returned twice: for `'elementStart'` and `'elementEnd'`.
	 */ ignoreElementEnd;
    /**
	 * Iterator position. If start position is not defined then position depends on {@link #direction}. If direction is
	 * `'forward'` position starts form the beginning, when direction is `'backward'` position starts from the end.
	 */ _position;
    /**
	 * Start boundary parent.
	 */ _boundaryStartParent;
    /**
	 * End boundary parent.
	 */ _boundaryEndParent;
    /**
	 * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.
	 *
	 * @param options Object with configuration.
	 */ constructor(options = {}){
        if (!options.boundaries && !options.startPosition) {
            /**
			 * Neither boundaries nor starting position have been defined.
			 *
			 * @error view-tree-walker-no-start-position
			 */ throw new CKEditorError('view-tree-walker-no-start-position', null);
        }
        if (options.direction && options.direction != 'forward' && options.direction != 'backward') {
            /**
			 * Only `backward` and `forward` direction allowed.
			 *
			 * @error view-tree-walker-unknown-direction
			 */ throw new CKEditorError('view-tree-walker-unknown-direction', options.startPosition, {
                direction: options.direction
            });
        }
        this.boundaries = options.boundaries || null;
        if (options.startPosition) {
            this._position = ViewPosition._createAt(options.startPosition);
        } else {
            this._position = ViewPosition._createAt(options.boundaries[options.direction == 'backward' ? 'end' : 'start']);
        }
        this.direction = options.direction || 'forward';
        this.singleCharacters = !!options.singleCharacters;
        this.shallow = !!options.shallow;
        this.ignoreElementEnd = !!options.ignoreElementEnd;
        this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;
        this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
    }
    /**
	 * Iterable interface.
	 */ [Symbol.iterator]() {
        return this;
    }
    /**
	 * Iterator position. If start position is not defined then position depends on {@link #direction}. If direction is
	 * `'forward'` position starts form the beginning, when direction is `'backward'` position starts from the end.
	 */ get position() {
        return this._position;
    }
    /**
	 * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.
	 *
	 * For example:
	 *
	 * ```ts
	 * walker.skip( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>
	 * walker.skip( value => true ); // Move the position to the end: <p>{}foo</p> -> <p>foo</p>[]
	 * walker.skip( value => false ); // Do not move the position.
	 * ```
	 *
	 * @param skip Callback function. Gets {@link module:engine/view/treewalker~ViewTreeWalkerValue} and should
	 * return `true` if the value should be skipped or `false` if not.
	 */ skip(skip) {
        let nextResult;
        let prevPosition;
        do {
            prevPosition = this.position;
            nextResult = this.next();
        }while (!nextResult.done && skip(nextResult.value))
        if (!nextResult.done) {
            this._position = prevPosition;
        }
    }
    /**
	 * Moves tree walker {@link #position} to provided `position`. Tree walker will
	 * continue traversing from that position.
	 *
	 * Note: in contrary to {@link ~ViewTreeWalker#skip}, this method does not iterate over the nodes along the way.
	 * It simply sets the current tree walker position to a new one.
	 * From the performance standpoint, it is better to use {@link ~ViewTreeWalker#jumpTo} rather than {@link ~ViewTreeWalker#skip}.
	 *
	 * If the provided position is before the start boundary, the position will be
	 * set to the start boundary. If the provided position is after the end boundary,
	 * the position will be set to the end boundary.
	 * This is done to prevent the treewalker from traversing outside the boundaries.
	 *
	 * @param position Position to jump to.
	 */ jumpTo(position) {
        if (this._boundaryStartParent && position.isBefore(this.boundaries.start)) {
            position = this.boundaries.start;
        } else if (this._boundaryEndParent && position.isAfter(this.boundaries.end)) {
            position = this.boundaries.end;
        }
        this._position = position.clone();
    }
    /**
	 * Gets the next tree walker's value.
	 *
	 * @returns Object implementing iterator interface, returning
	 * information about taken step.
	 */ next() {
        if (this.direction == 'forward') {
            return this._next();
        } else {
            return this._previous();
        }
    }
    /**
	 * Makes a step forward in view. Moves the {@link #position} to the next position and returns the encountered value.
	 */ _next() {
        let position = this.position.clone();
        const previousPosition = this.position;
        const parent = position.parent;
        // We are at the end of the root.
        if (parent.parent === null && position.offset === parent.childCount) {
            return {
                done: true,
                value: undefined
            };
        }
        // We reached the walker boundary.
        if (parent === this._boundaryEndParent && position.offset == this.boundaries.end.offset) {
            return {
                done: true,
                value: undefined
            };
        }
        // Get node just after current position.
        let node;
        // Text is a specific parent because it contains string instead of child nodes.
        if (parent && parent.is('view:$text')) {
            if (position.isAtEnd) {
                // Prevent returning "elementEnd" for Text node. Skip that value and return the next walker step.
                this._position = ViewPosition._createAfter(parent);
                return this._next();
            }
            node = parent.data[position.offset];
        } else {
            node = parent.getChild(position.offset);
        }
        if (typeof node == 'string') {
            let textLength;
            if (this.singleCharacters) {
                textLength = 1;
            } else {
                // Check if text stick out of walker range.
                const endOffset = parent === this._boundaryEndParent ? this.boundaries.end.offset : parent.data.length;
                textLength = endOffset - position.offset;
            }
            const textProxy = new ViewTextProxy(parent, position.offset, textLength);
            position.offset += textLength;
            this._position = position;
            return this._formatReturnValue('text', textProxy, previousPosition, position, textLength);
        }
        if (node && node.is('view:element')) {
            if (!this.shallow) {
                position = new ViewPosition(node, 0);
            } else {
                // We are past the walker boundaries.
                if (this.boundaries && this.boundaries.end.isBefore(position)) {
                    return {
                        done: true,
                        value: undefined
                    };
                }
                position.offset++;
            }
            this._position = position;
            return this._formatReturnValue('elementStart', node, previousPosition, position, 1);
        }
        if (node && node.is('view:$text')) {
            if (this.singleCharacters) {
                position = new ViewPosition(node, 0);
                this._position = position;
                return this._next();
            }
            let charactersCount = node.data.length;
            let item;
            // If text stick out of walker range, we need to cut it and wrap in ViewTextProxy.
            if (node == this._boundaryEndParent) {
                charactersCount = this.boundaries.end.offset;
                item = new ViewTextProxy(node, 0, charactersCount);
                position = ViewPosition._createAfter(item);
            } else {
                item = new ViewTextProxy(node, 0, node.data.length);
                // If not just keep moving forward.
                position.offset++;
            }
            this._position = position;
            return this._formatReturnValue('text', item, previousPosition, position, charactersCount);
        }
        // `node` is not set, we reached the end of current `parent`.
        position = ViewPosition._createAfter(parent);
        this._position = position;
        if (this.ignoreElementEnd) {
            return this._next();
        }
        return this._formatReturnValue('elementEnd', parent, previousPosition, position);
    }
    /**
	 * Makes a step backward in view. Moves the {@link #position} to the previous position and returns the encountered value.
	 */ _previous() {
        let position = this.position.clone();
        const previousPosition = this.position;
        const parent = position.parent;
        // We are at the beginning of the root.
        if (parent.parent === null && position.offset === 0) {
            return {
                done: true,
                value: undefined
            };
        }
        // We reached the walker boundary.
        if (parent == this._boundaryStartParent && position.offset == this.boundaries.start.offset) {
            return {
                done: true,
                value: undefined
            };
        }
        // Get node just before current position.
        let node;
        // Text {@link module:engine/view/text~ViewText} element is a specific parent because contains string instead of child nodes.
        if (parent.is('view:$text')) {
            if (position.isAtStart) {
                // Prevent returning "elementStart" for Text node. Skip that value and return the next walker step.
                this._position = ViewPosition._createBefore(parent);
                return this._previous();
            }
            node = parent.data[position.offset - 1];
        } else {
            node = parent.getChild(position.offset - 1);
        }
        if (typeof node == 'string') {
            let textLength;
            if (!this.singleCharacters) {
                // Check if text stick out of walker range.
                const startOffset = parent === this._boundaryStartParent ? this.boundaries.start.offset : 0;
                textLength = position.offset - startOffset;
            } else {
                textLength = 1;
            }
            position.offset -= textLength;
            const textProxy = new ViewTextProxy(parent, position.offset, textLength);
            this._position = position;
            return this._formatReturnValue('text', textProxy, previousPosition, position, textLength);
        }
        if (node && node.is('view:element')) {
            if (this.shallow) {
                position.offset--;
                this._position = position;
                return this._formatReturnValue('elementStart', node, previousPosition, position, 1);
            }
            position = new ViewPosition(node, node.childCount);
            this._position = position;
            if (this.ignoreElementEnd) {
                return this._previous();
            }
            return this._formatReturnValue('elementEnd', node, previousPosition, position);
        }
        if (node && node.is('view:$text')) {
            if (this.singleCharacters) {
                position = new ViewPosition(node, node.data.length);
                this._position = position;
                return this._previous();
            }
            let charactersCount = node.data.length;
            let item;
            // If text stick out of walker range, we need to cut it and wrap in ViewTextProxy.
            if (node == this._boundaryStartParent) {
                const offset = this.boundaries.start.offset;
                item = new ViewTextProxy(node, offset, node.data.length - offset);
                charactersCount = item.data.length;
                position = ViewPosition._createBefore(item);
            } else {
                item = new ViewTextProxy(node, 0, node.data.length);
                // If not just keep moving backward.
                position.offset--;
            }
            this._position = position;
            return this._formatReturnValue('text', item, previousPosition, position, charactersCount);
        }
        // `node` is not set, we reached the beginning of current `parent`.
        position = ViewPosition._createBefore(parent);
        this._position = position;
        return this._formatReturnValue('elementStart', parent, previousPosition, position, 1);
    }
    /**
	 * Format returned data and adjust `previousPosition` and `nextPosition` if
	 * reach the bound of the {@link module:engine/view/text~ViewText}.
	 *
	 * @param type Type of step.
	 * @param item Item between old and new position.
	 * @param previousPosition Previous position of iterator.
	 * @param nextPosition Next position of iterator.
	 * @param length Length of the item.
	 */ _formatReturnValue(type, item, previousPosition, nextPosition, length) {
        // Text is a specific parent, because contains string instead of children.
        // Walker doesn't enter to the Text except situations when walker is iterating over every single character,
        // or the bound starts/ends inside the Text. So when the position is at the beginning or at the end of the Text
        // we move it just before or just after Text.
        if (item.is('view:$textProxy')) {
            // Position is at the end of Text.
            if (item.offsetInText + item.data.length == item.textNode.data.length) {
                if (this.direction == 'forward' && !(this.boundaries && this.boundaries.end.isEqual(this.position))) {
                    nextPosition = ViewPosition._createAfter(item.textNode);
                    // When we change nextPosition of returned value we need also update walker current position.
                    this._position = nextPosition;
                } else {
                    previousPosition = ViewPosition._createAfter(item.textNode);
                }
            }
            // Position is at the begining ot the text.
            if (item.offsetInText === 0) {
                if (this.direction == 'backward' && !(this.boundaries && this.boundaries.start.isEqual(this.position))) {
                    nextPosition = ViewPosition._createBefore(item.textNode);
                    // When we change nextPosition of returned value we need also update walker current position.
                    this._position = nextPosition;
                } else {
                    previousPosition = ViewPosition._createBefore(item.textNode);
                }
            }
        }
        return {
            done: false,
            value: {
                type,
                item,
                previousPosition,
                nextPosition,
                length
            }
        };
    }
}

/**
 * Position in the view tree. Position is represented by its parent node and an offset in this parent.
 *
 * In order to create a new position instance use the `createPosition*()` factory methods available in:
 *
 * * {@link module:engine/view/view~EditingView}
 * * {@link module:engine/view/downcastwriter~ViewDowncastWriter}
 * * {@link module:engine/view/upcastwriter~ViewUpcastWriter}
 */ class ViewPosition extends ViewTypeCheckable {
    /**
	 * Position parent.
	 */ parent;
    /**
	 * Position offset.
	 */ offset;
    /**
	 * Creates a position.
	 *
	 * @param parent Position parent.
	 * @param offset Position offset.
	 */ constructor(parent, offset){
        super();
        this.parent = parent;
        this.offset = offset;
    }
    /**
	 * Node directly after the position. Equals `null` when there is no node after position or position is located
	 * inside text node.
	 */ get nodeAfter() {
        if (this.parent.is('$text')) {
            return null;
        }
        return this.parent.getChild(this.offset) || null;
    }
    /**
	 * Node directly before the position. Equals `null` when there is no node before position or position is located
	 * inside text node.
	 */ get nodeBefore() {
        if (this.parent.is('$text')) {
            return null;
        }
        return this.parent.getChild(this.offset - 1) || null;
    }
    /**
	 * Is `true` if position is at the beginning of its {@link module:engine/view/position~ViewPosition#parent parent}, `false` otherwise.
	 */ get isAtStart() {
        return this.offset === 0;
    }
    /**
	 * Is `true` if position is at the end of its {@link module:engine/view/position~ViewPosition#parent parent}, `false` otherwise.
	 */ get isAtEnd() {
        const endOffset = this.parent.is('$text') ? this.parent.data.length : this.parent.childCount;
        return this.offset === endOffset;
    }
    /**
	 * Position's root, that is the root of the position's parent element.
	 */ get root() {
        return this.parent.root;
    }
    /**
	 * {@link module:engine/view/editableelement~ViewEditableElement ViewEditableElement} instance that contains this position, or `null` if
	 * position is not inside an editable element.
	 */ get editableElement() {
        let editable = this.parent;
        while(!(editable instanceof ViewEditableElement)){
            if (editable.parent) {
                editable = editable.parent;
            } else {
                return null;
            }
        }
        return editable;
    }
    /**
	 * Returns a new instance of Position with offset incremented by `shift` value.
	 *
	 * @param shift How position offset should get changed. Accepts negative values.
	 * @returns Shifted position.
	 */ getShiftedBy(shift) {
        const shifted = ViewPosition._createAt(this);
        const offset = shifted.offset + shift;
        shifted.offset = offset < 0 ? 0 : offset;
        return shifted;
    }
    /**
	 * Gets the farthest position which matches the callback using
	 * {@link module:engine/view/treewalker~ViewTreeWalker TreeWalker}.
	 *
	 * For example:
	 *
	 * ```ts
	 * getLastMatchingPosition( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>
	 * getLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } ); // <p>foo[]</p> -> <p>{}foo</p>
	 * getLastMatchingPosition( value => false ); // Do not move the position.
	 * ```
	 *
	 * @param skip Callback function. Gets {@link module:engine/view/treewalker~ViewTreeWalkerValue} and should
	 * return `true` if the value should be skipped or `false` if not.
	 * @param options Object with configuration options. See {@link module:engine/view/treewalker~ViewTreeWalker}.
	 * @returns The position after the last item which matches the `skip` callback test.
	 */ getLastMatchingPosition(skip, options = {}) {
        options.startPosition = this;
        const treeWalker = new ViewTreeWalker(options);
        treeWalker.skip(skip);
        return treeWalker.position;
    }
    /**
	 * Returns ancestors array of this position, that is this position's parent and it's ancestors.
	 *
	 * @returns Array with ancestors.
	 */ getAncestors() {
        if (this.parent.is('documentFragment')) {
            return [
                this.parent
            ];
        } else {
            return this.parent.getAncestors({
                includeSelf: true
            });
        }
    }
    /**
	 * Returns a {@link module:engine/view/node~ViewNode} or {@link module:engine/view/documentfragment~ViewDocumentFragment}
	 * which is a common ancestor of both positions.
	 */ getCommonAncestor(position) {
        const ancestorsA = this.getAncestors();
        const ancestorsB = position.getAncestors();
        let i = 0;
        while(ancestorsA[i] == ancestorsB[i] && ancestorsA[i]){
            i++;
        }
        return i === 0 ? null : ancestorsA[i - 1];
    }
    /**
	 * Checks whether this position equals given position.
	 *
	 * @param otherPosition Position to compare with.
	 * @returns True if positions are same.
	 */ isEqual(otherPosition) {
        return this.parent == otherPosition.parent && this.offset == otherPosition.offset;
    }
    /**
	 * Checks whether this position is located before given position. When method returns `false` it does not mean that
	 * this position is after give one. Two positions may be located inside separate roots and in that situation this
	 * method will still return `false`.
	 *
	 * @see module:engine/view/position~ViewPosition#isAfter
	 * @see module:engine/view/position~ViewPosition#compareWith
	 * @param otherPosition Position to compare with.
	 * @returns Returns `true` if this position is before given position.
	 */ isBefore(otherPosition) {
        return this.compareWith(otherPosition) == 'before';
    }
    /**
	 * Checks whether this position is located after given position. When method returns `false` it does not mean that
	 * this position is before give one. Two positions may be located inside separate roots and in that situation this
	 * method will still return `false`.
	 *
	 * @see module:engine/view/position~ViewPosition#isBefore
	 * @see module:engine/view/position~ViewPosition#compareWith
	 * @param otherPosition Position to compare with.
	 * @returns Returns `true` if this position is after given position.
	 */ isAfter(otherPosition) {
        return this.compareWith(otherPosition) == 'after';
    }
    /**
	 * Checks whether this position is before, after or in same position that other position. Two positions may be also
	 * different when they are located in separate roots.
	 *
	 * @param otherPosition Position to compare with.
	 */ compareWith(otherPosition) {
        if (this.root !== otherPosition.root) {
            return 'different';
        }
        if (this.isEqual(otherPosition)) {
            return 'same';
        }
        // Get path from root to position's parent element.
        const thisPath = this.parent.is('node') ? this.parent.getPath() : [];
        const otherPath = otherPosition.parent.is('node') ? otherPosition.parent.getPath() : [];
        // Add the positions' offsets to the parents offsets.
        thisPath.push(this.offset);
        otherPath.push(otherPosition.offset);
        // Compare both path arrays to find common ancestor.
        const result = compareArrays(thisPath, otherPath);
        switch(result){
            case 'prefix':
                return 'before';
            case 'extension':
                return 'after';
            default:
                // Cast to number to avoid having 'same' as a type of `result`.
                return thisPath[result] < otherPath[result] ? 'before' : 'after';
        }
    }
    /**
	 * Creates a {@link module:engine/view/treewalker~ViewTreeWalker TreeWalker} instance with this positions as a start position.
	 *
	 * @param options Object with configuration options. See {@link module:engine/view/treewalker~ViewTreeWalker}
	 */ getWalker(options = {}) {
        options.startPosition = this;
        return new ViewTreeWalker(options);
    }
    /**
	 * Clones this position.
	 */ clone() {
        return new ViewPosition(this.parent, this.offset);
    }
    /**
	 * Creates position at the given location. The location can be specified as:
	 *
	 * * a {@link module:engine/view/position~ViewPosition position},
	 * * parent element and offset (offset defaults to `0`),
	 * * parent element and `'end'` (sets position at the end of that element),
	 * * {@link module:engine/view/item~ViewItem view item} and `'before'` or `'after'` (sets position before or after given view item).
	 *
	 * This method is a shortcut to other constructors such as:
	 *
	 * * {@link module:engine/view/position~ViewPosition._createBefore},
	 * * {@link module:engine/view/position~ViewPosition._createAfter}.
	 *
	 * @internal
	 * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~ViewItem view item}.
	 */ static _createAt(itemOrPosition, offset) {
        if (itemOrPosition instanceof ViewPosition) {
            return new this(itemOrPosition.parent, itemOrPosition.offset);
        } else {
            const node = itemOrPosition;
            if (offset == 'end') {
                offset = node.is('$text') ? node.data.length : node.childCount;
            } else if (offset == 'before') {
                return this._createBefore(node);
            } else if (offset == 'after') {
                return this._createAfter(node);
            } else if (offset !== 0 && !offset) {
                /**
				 * {@link module:engine/view/view~EditingView#createPositionAt `View#createPositionAt()`}
				 * requires the offset to be specified when the first parameter is a view item.
				 *
				 * @error view-createpositionat-offset-required
				 */ throw new CKEditorError('view-createpositionat-offset-required', node);
            }
            return new ViewPosition(node, offset);
        }
    }
    /**
	 * Creates a new position after given view item.
	 *
	 * @internal
	 * @param item View item after which the position should be located.
	 */ static _createAfter(item) {
        // ViewTextProxy is not a instance of Node so we need do handle it in specific way.
        if (item.is('$textProxy')) {
            return new ViewPosition(item.textNode, item.offsetInText + item.data.length);
        }
        if (!item.parent) {
            /**
			 * You cannot make a position after a root.
			 *
			 * @error view-position-after-root
			 * @param {module:engine/view/node~ViewNode} root A root item.
			 */ throw new CKEditorError('view-position-after-root', item, {
                root: item
            });
        }
        return new ViewPosition(item.parent, item.index + 1);
    }
    /**
	 * Creates a new position before given view item.
	 *
	 * @internal
	 * @param item View item before which the position should be located.
	 */ static _createBefore(item) {
        // ViewTextProxy is not a instance of Node so we need do handle it in specific way.
        if (item.is('$textProxy')) {
            return new ViewPosition(item.textNode, item.offsetInText);
        }
        if (!item.parent) {
            /**
			 * You cannot make a position before a root.
			 *
			 * @error view-position-before-root
			 * @param {module:engine/view/node~ViewNode} root A root item.
			 */ throw new CKEditorError('view-position-before-root', item, {
                root: item
            });
        }
        return new ViewPosition(item.parent, item.index);
    }
}
// The magic of type inference using `is` method is centralized in `TypeCheckable` class.
// Proper overload would interfere with that.
ViewPosition.prototype.is = function(type) {
    return type === 'position' || type === 'view:position';
};

/**
 * Range in the view tree. A range is represented by its start and end {@link module:engine/view/position~ViewPosition positions}.
 *
 * In order to create a new position instance use the `createPosition*()` factory methods available in:
 *
 * * {@link module:engine/view/view~EditingView}
 * * {@link module:engine/view/downcastwriter~ViewDowncastWriter}
 * * {@link module:engine/view/upcastwriter~ViewUpcastWriter}
 */ class ViewRange extends ViewTypeCheckable {
    /**
	 * Start position.
	 */ start;
    /**
	 * End position.
	 */ end;
    /**
	 * Creates a range spanning from `start` position to `end` position.
	 *
	 * **Note:** Constructor creates it's own {@link module:engine/view/position~ViewPosition} instances basing on passed values.
	 *
	 * @param start Start position.
	 * @param end End position. If not set, range will be collapsed at the `start` position.
	 */ constructor(start, end = null){
        super();
        this.start = start.clone();
        this.end = end ? end.clone() : start.clone();
    }
    /**
	 * Iterable interface.
	 *
	 * Iterates over all {@link module:engine/view/item~ViewItem view items} that are in this range and returns
	 * them together with additional information like length or {@link module:engine/view/position~ViewPosition positions},
	 * grouped as {@link module:engine/view/treewalker~ViewTreeWalkerValue}.
	 *
	 * This iterator uses {@link module:engine/view/treewalker~ViewTreeWalker TreeWalker} with `boundaries` set to this range and
	 * `ignoreElementEnd` option
	 * set to `true`.
	 */ *[Symbol.iterator]() {
        yield* new ViewTreeWalker({
            boundaries: this,
            ignoreElementEnd: true
        });
    }
    /**
	 * Returns whether the range is collapsed, that is it start and end positions are equal.
	 */ get isCollapsed() {
        return this.start.isEqual(this.end);
    }
    /**
	 * Returns whether this range is flat, that is if {@link module:engine/view/range~ViewRange#start start} position and
	 * {@link module:engine/view/range~ViewRange#end end} position are in the same
	 * {@link module:engine/view/position~ViewPosition#parent parent}.
	 */ get isFlat() {
        return this.start.parent === this.end.parent;
    }
    /**
	 * Range root element.
	 */ get root() {
        return this.start.root;
    }
    /**
	 * Creates a maximal range that has the same content as this range but is expanded in both ways (at the beginning
	 * and at the end).
	 *
	 * For example:
	 *
	 * ```html
	 * <p>Foo</p><p><b>{Bar}</b></p> -> <p>Foo</p>[<p><b>Bar</b>]</p>
	 * <p><b>foo</b>{bar}<span></span></p> -> <p><b>foo[</b>bar<span></span>]</p>
	 * ```
	 *
	 * Note that in the sample above:
	 *
	 * - `<p>` have type of {@link module:engine/view/containerelement~ViewContainerElement},
	 * - `<b>` have type of {@link module:engine/view/attributeelement~ViewAttributeElement},
	 * - `<span>` have type of {@link module:engine/view/uielement~ViewUIElement}.
	 *
	 * @returns Enlarged range.
	 */ getEnlarged() {
        let start = this.start.getLastMatchingPosition(enlargeTrimSkip, {
            direction: 'backward'
        });
        let end = this.end.getLastMatchingPosition(enlargeTrimSkip);
        // Fix positions, in case if they are in Text node.
        if (start.parent.is('$text') && start.isAtStart) {
            start = ViewPosition._createBefore(start.parent);
        }
        if (end.parent.is('$text') && end.isAtEnd) {
            end = ViewPosition._createAfter(end.parent);
        }
        return new ViewRange(start, end);
    }
    /**
	 * Creates a minimum range that has the same content as this range but is trimmed in both ways (at the beginning
	 * and at the end).
	 *
	 * For example:
	 *
	 * ```html
	 * <p>Foo</p>[<p><b>Bar</b>]</p> -> <p>Foo</p><p><b>{Bar}</b></p>
	 * <p><b>foo[</b>bar<span></span>]</p> -> <p><b>foo</b>{bar}<span></span></p>
	 * ```
	 *
	 * Note that in the sample above:
	 *
	 * - `<p>` have type of {@link module:engine/view/containerelement~ViewContainerElement},
	 * - `<b>` have type of {@link module:engine/view/attributeelement~ViewAttributeElement},
	 * - `<span>` have type of {@link module:engine/view/uielement~ViewUIElement}.
	 *
	 * @returns Shrunk range.
	 */ getTrimmed() {
        let start = this.start.getLastMatchingPosition(enlargeTrimSkip);
        if (start.isAfter(this.end) || start.isEqual(this.end)) {
            return new ViewRange(start, start);
        }
        let end = this.end.getLastMatchingPosition(enlargeTrimSkip, {
            direction: 'backward'
        });
        const nodeAfterStart = start.nodeAfter;
        const nodeBeforeEnd = end.nodeBefore;
        // Because TreeWalker prefers positions next to text node, we need to move them manually into these text nodes.
        if (nodeAfterStart && nodeAfterStart.is('$text')) {
            start = new ViewPosition(nodeAfterStart, 0);
        }
        if (nodeBeforeEnd && nodeBeforeEnd.is('$text')) {
            end = new ViewPosition(nodeBeforeEnd, nodeBeforeEnd.data.length);
        }
        return new ViewRange(start, end);
    }
    /**
	 * Two ranges are equal if their start and end positions are equal.
	 *
	 * @param otherRange Range to compare with.
	 * @returns `true` if ranges are equal, `false` otherwise
	 */ isEqual(otherRange) {
        return this == otherRange || this.start.isEqual(otherRange.start) && this.end.isEqual(otherRange.end);
    }
    /**
	 * Checks whether this range contains given {@link module:engine/view/position~ViewPosition position}.
	 *
	 * @param position Position to check.
	 * @returns `true` if given {@link module:engine/view/position~ViewPosition position} is contained in this range, `false` otherwise.
	 */ containsPosition(position) {
        return position.isAfter(this.start) && position.isBefore(this.end);
    }
    /**
	 * Checks whether this range contains given {@link module:engine/view/range~ViewRange range}.
	 *
	 * @param otherRange Range to check.
	 * @param loose Whether the check is loose or strict. If the check is strict (`false`), compared range cannot
	 * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or
	 * even be equal to this range. Note that collapsed ranges are always compared in strict mode.
	 * @returns `true` if given {@link module:engine/view/range~ViewRange range} boundaries are contained by this range, `false`
	 * otherwise.
	 */ containsRange(otherRange, loose = false) {
        if (otherRange.isCollapsed) {
            loose = false;
        }
        const containsStart = this.containsPosition(otherRange.start) || loose && this.start.isEqual(otherRange.start);
        const containsEnd = this.containsPosition(otherRange.end) || loose && this.end.isEqual(otherRange.end);
        return containsStart && containsEnd;
    }
    /**
	 * Computes which part(s) of this {@link module:engine/view/range~ViewRange range} is not a part of given
	 * {@link module:engine/view/range~ViewRange range}.
	 * Returned array contains zero, one or two {@link module:engine/view/range~ViewRange ranges}.
	 *
	 * Examples:
	 *
	 * ```ts
	 * let foo = downcastWriter.createText( 'foo' );
	 * let img = downcastWriter.createContainerElement( 'img' );
	 * let bar = downcastWriter.createText( 'bar' );
	 * let p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );
	 *
	 * let range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // "o", img, "b" are in range.
	 * let otherRange = view.createRange( // "oo", img, "ba" are in range.
	 * 	view.createPositionAt( foo, 1 ),
	 * 	view.createPositionAt( bar, 2 )
	 * );
	 * let transformed = range.getDifference( otherRange );
	 * // transformed array has no ranges because `otherRange` contains `range`
	 *
	 * otherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // "oo", img are in range.
	 * transformed = range.getDifference( otherRange );
	 * // transformed array has one range: from ( p, 2 ) to ( bar, 1 )
	 *
	 * otherRange = view.createRange( view.createPositionAt( p, 1 ), view.createPositionAt( p, 2 ) ); // img is in range.
	 * transformed = range.getDifference( otherRange );
	 * // transformed array has two ranges: from ( foo, 1 ) to ( p, 1 ) and from ( p, 2 ) to ( bar, 1 )
	 * ```
	 *
	 * @param otherRange Range to differentiate against.
	 * @returns The difference between ranges.
	 */ getDifference(otherRange) {
        const ranges = [];
        if (this.isIntersecting(otherRange)) {
            // Ranges intersect.
            if (this.containsPosition(otherRange.start)) {
                // Given range start is inside this range. This means that we have to
                // add shrunken range - from the start to the middle of this range.
                ranges.push(new ViewRange(this.start, otherRange.start));
            }
            if (this.containsPosition(otherRange.end)) {
                // Given range end is inside this range. This means that we have to
                // add shrunken range - from the middle of this range to the end.
                ranges.push(new ViewRange(otherRange.end, this.end));
            }
        } else {
            // Ranges do not intersect, return the original range.
            ranges.push(this.clone());
        }
        return ranges;
    }
    /**
	 * Returns an intersection of this {@link module:engine/view/range~ViewRange range}
	 * and given {@link module:engine/view/range~ViewRange range}.
	 * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.
	 *
	 * Examples:
	 *
	 * ```ts
	 * let foo = downcastWriter.createText( 'foo' );
	 * let img = downcastWriter.createContainerElement( 'img' );
	 * let bar = downcastWriter.createText( 'bar' );
	 * let p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );
	 *
	 * let range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // "o", img, "b" are in range.
	 * let otherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // "oo", img are in range.
	 * let transformed = range.getIntersection( otherRange ); // range from ( foo, 1 ) to ( p, 2 ).
	 *
	 * otherRange = view.createRange( view.createPositionAt( bar, 1 ), view.createPositionAt( bar, 3 ); "ar" is in range.
	 * transformed = range.getIntersection( otherRange ); // null - no common part.
	 * ```
	 *
	 * @param otherRange Range to check for intersection.
	 * @returns A common part of given ranges or `null` if ranges have no common part.
	 */ getIntersection(otherRange) {
        if (this.isIntersecting(otherRange)) {
            // Ranges intersect, so a common range will be returned.
            // At most, it will be same as this range.
            let commonRangeStart = this.start;
            let commonRangeEnd = this.end;
            if (this.containsPosition(otherRange.start)) {
                // Given range start is inside this range. This means thaNt we have to
                // shrink common range to the given range start.
                commonRangeStart = otherRange.start;
            }
            if (this.containsPosition(otherRange.end)) {
                // Given range end is inside this range. This means that we have to
                // shrink common range to the given range end.
                commonRangeEnd = otherRange.end;
            }
            return new ViewRange(commonRangeStart, commonRangeEnd);
        }
        // Ranges do not intersect, so they do not have common part.
        return null;
    }
    /**
	 * Creates a {@link module:engine/view/treewalker~ViewTreeWalker TreeWalker} instance with this range as a boundary.
	 *
	 * @param options Object with configuration options. See {@link module:engine/view/treewalker~ViewTreeWalker}.
	 */ getWalker(options = {}) {
        options.boundaries = this;
        return new ViewTreeWalker(options);
    }
    /**
	 * Returns a {@link module:engine/view/node~ViewNode} or {@link module:engine/view/documentfragment~ViewDocumentFragment}
	 * which is a common ancestor of range's both ends (in which the entire range is contained).
	 */ getCommonAncestor() {
        return this.start.getCommonAncestor(this.end);
    }
    /**
	 * Returns an {@link module:engine/view/element~ViewElement Element} contained by the range.
	 * The element will be returned when it is the **only** node within the range and **fully–contained**
	 * at the same time.
	 */ getContainedElement() {
        if (this.isCollapsed) {
            return null;
        }
        let nodeAfterStart = this.start.nodeAfter;
        let nodeBeforeEnd = this.end.nodeBefore;
        // Handle the situation when the range position is at the beginning / at the end of a text node.
        // In such situation `.nodeAfter` and `.nodeBefore` are `null` but the range still might be spanning
        // over one element.
        //
        // <p>Foo{<span class="widget"></span>}bar</p> vs <p>Foo[<span class="widget"></span>]bar</p>
        //
        // These are basically the same range, only the difference is if the range position is at
        // at the end/at the beginning of a text node or just before/just after the text node.
        //
        if (this.start.parent.is('$text') && this.start.isAtEnd && this.start.parent.nextSibling) {
            nodeAfterStart = this.start.parent.nextSibling;
        }
        if (this.end.parent.is('$text') && this.end.isAtStart && this.end.parent.previousSibling) {
            nodeBeforeEnd = this.end.parent.previousSibling;
        }
        if (nodeAfterStart && nodeAfterStart.is('element') && nodeAfterStart === nodeBeforeEnd) {
            return nodeAfterStart;
        }
        return null;
    }
    /**
	 * Clones this range.
	 */ clone() {
        return new ViewRange(this.start, this.end);
    }
    /**
	 * Returns an iterator that iterates over all {@link module:engine/view/item~ViewItem view items} that are in this range and returns
	 * them.
	 *
	 * This method uses {@link module:engine/view/treewalker~ViewTreeWalker} with `boundaries` set to this range
	 * and `ignoreElementEnd` option set to `true`. However it returns only {@link module:engine/view/item~ViewItem items},
	 * not {@link module:engine/view/treewalker~ViewTreeWalkerValue}.
	 *
	 * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~ViewTreeWalker} for
	 * a full list of available options.
	 *
	 * @param options Object with configuration options. See {@link module:engine/view/treewalker~ViewTreeWalker}.
	 */ *getItems(options = {}) {
        options.boundaries = this;
        options.ignoreElementEnd = true;
        const treeWalker = new ViewTreeWalker(options);
        for (const value of treeWalker){
            yield value.item;
        }
    }
    /**
	 * Returns an iterator that iterates over all {@link module:engine/view/position~ViewPosition positions} that are boundaries or
	 * contained in this range.
	 *
	 * This method uses {@link module:engine/view/treewalker~ViewTreeWalker} with `boundaries` set to this range. However it returns only
	 * {@link module:engine/view/position~ViewPosition positions}, not {@link module:engine/view/treewalker~ViewTreeWalkerValue}.
	 *
	 * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~ViewTreeWalker} for
	 * a full list of available options.
	 *
	 * @param options Object with configuration options. See {@link module:engine/view/treewalker~ViewTreeWalker}.
	 */ *getPositions(options = {}) {
        options.boundaries = this;
        const treeWalker = new ViewTreeWalker(options);
        yield treeWalker.position;
        for (const value of treeWalker){
            yield value.nextPosition;
        }
    }
    /**
	 * Checks and returns whether this range intersects with the given range.
	 *
	 * @param otherRange Range to compare with.
	 * @returns True if ranges intersect.
	 */ isIntersecting(otherRange) {
        return this.start.isBefore(otherRange.end) && this.end.isAfter(otherRange.start);
    }
    /**
	 * Creates a range from the given parents and offsets.
	 *
	 * @internal
	 * @param startElement Start position parent element.
	 * @param startOffset Start position offset.
	 * @param endElement End position parent element.
	 * @param endOffset End position offset.
	 * @returns Created range.
	 */ static _createFromParentsAndOffsets(startElement, startOffset, endElement, endOffset) {
        return new this(new ViewPosition(startElement, startOffset), new ViewPosition(endElement, endOffset));
    }
    /**
	 * Creates a new range, spreading from specified {@link module:engine/view/position~ViewPosition position} to a position moved by
	 * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.
	 *
	 * @internal
	 * @param position Beginning of the range.
	 * @param shift How long the range should be.
	 */ static _createFromPositionAndShift(position, shift) {
        const start = position;
        const end = position.getShiftedBy(shift);
        return shift > 0 ? new this(start, end) : new this(end, start);
    }
    /**
	 * Creates a range inside an {@link module:engine/view/element~ViewElement element} which starts before the first child of
	 * that element and ends after the last child of that element.
	 *
	 * @internal
	 * @param element Element which is a parent for the range.
	 */ static _createIn(element) {
        return this._createFromParentsAndOffsets(element, 0, element, element.childCount);
    }
    /**
	 * Creates a range that starts before given {@link module:engine/view/item~ViewItem view item} and ends after it.
	 *
	 * @internal
	 */ static _createOn(item) {
        const size = item.is('$textProxy') ? item.offsetSize : 1;
        return this._createFromPositionAndShift(ViewPosition._createBefore(item), size);
    }
}
// The magic of type inference using `is` method is centralized in `TypeCheckable` class.
// Proper overload would interfere with that.
ViewRange.prototype.is = function(type) {
    return type === 'range' || type === 'view:range';
};
/**
 * Function used by getEnlarged and getTrimmed methods.
 */ function enlargeTrimSkip(value) {
    if (value.item.is('attributeElement') || value.item.is('uiElement')) {
        return true;
    }
    return false;
}

/**
 * Class representing an arbirtary selection in the view.
 * See also {@link module:engine/view/documentselection~ViewDocumentSelection}.
 *
 * New selection instances can be created via the constructor or one these methods:
 *
 * * {@link module:engine/view/view~EditingView#createSelection `View#createSelection()`},
 * * {@link module:engine/view/upcastwriter~ViewUpcastWriter#createSelection `UpcastWriter#createSelection()`}.
 *
 * A selection can consist of {@link module:engine/view/range~ViewRange ranges} that can be set by using
 * the {@link module:engine/view/selection~ViewSelection#setTo `Selection#setTo()`} method.
 */ class ViewSelection extends /* #__PURE__ */ EmitterMixin(ViewTypeCheckable) {
    /**
	 * Stores all ranges that are selected.
	 */ _ranges;
    /**
	 * Specifies whether the last added range was added as a backward or forward range.
	 */ _lastRangeBackward;
    /**
	 * Specifies whether selection instance is fake.
	 */ _isFake;
    /**
	 * Fake selection's label.
	 */ _fakeSelectionLabel;
    /**
	 * Creates new selection instance.
	 *
	 * **Note**: The selection constructor is available as a factory method:
	 *
	 * * {@link module:engine/view/view~EditingView#createSelection `View#createSelection()`},
	 * * {@link module:engine/view/upcastwriter~ViewUpcastWriter#createSelection `UpcastWriter#createSelection()`}.
	 *
	 * ```ts
	 * // Creates empty selection without ranges.
	 * const selection = writer.createSelection();
	 *
	 * // Creates selection at the given range.
	 * const range = writer.createRange( start, end );
	 * const selection = writer.createSelection( range );
	 *
	 * // Creates selection at the given ranges
	 * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
	 * const selection = writer.createSelection( ranges );
	 *
	 * // Creates selection from the other selection.
	 * const otherSelection = writer.createSelection();
	 * const selection = writer.createSelection( otherSelection );
	 *
	 * // Creates selection from the document selection.
	 * const selection = writer.createSelection( editor.editing.view.document.selection );
	 *
	 * // Creates selection at the given position.
	 * const position = writer.createPositionFromPath( root, path );
	 * const selection = writer.createSelection( position );
	 *
	 * // Creates collapsed selection at the position of given item and offset.
	 * const paragraph = writer.createContainerElement( 'paragraph' );
	 * const selection = writer.createSelection( paragraph, offset );
	 *
	 * // Creates a range inside an {@link module:engine/view/element~ViewElement element} which starts before the
	 * // first child of that element and ends after the last child of that element.
	 * const selection = writer.createSelection( paragraph, 'in' );
	 *
	 * // Creates a range on an {@link module:engine/view/item~ViewItem item} which starts before the item and ends
	 * // just after the item.
	 * const selection = writer.createSelection( paragraph, 'on' );
	 * ```
	 *
	 * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.
	 *
	 * ```ts
	 * // Creates backward selection.
	 * const selection = writer.createSelection( range, { backward: true } );
	 * ```
	 *
	 * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
	 * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
	 * represented in other way, for example by applying proper CSS class.
	 *
	 * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM
	 * (and be  properly handled by screen readers).
	 *
	 * ```ts
	 * // Creates fake selection with label.
	 * const selection = writer.createSelection( range, { fake: true, label: 'foo' } );
	 * ```
	 *
	 * @internal
	 */ constructor(...args){
        super();
        this._ranges = [];
        this._lastRangeBackward = false;
        this._isFake = false;
        this._fakeSelectionLabel = '';
        if (args.length) {
            this.setTo(...args);
        }
    }
    /**
	 * Returns true if selection instance is marked as `fake`.
	 *
	 * @see #setTo
	 */ get isFake() {
        return this._isFake;
    }
    /**
	 * Returns fake selection label.
	 *
	 * @see #setTo
	 */ get fakeSelectionLabel() {
        return this._fakeSelectionLabel;
    }
    /**
	 * Selection anchor. Anchor may be described as a position where the selection starts. Together with
	 * {@link #focus focus} they define the direction of selection, which is important
	 * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.
	 * It may be a bit unintuitive when there are multiple ranges in selection.
	 *
	 * @see #focus
	 */ get anchor() {
        if (!this._ranges.length) {
            return null;
        }
        const range = this._ranges[this._ranges.length - 1];
        const anchor = this._lastRangeBackward ? range.end : range.start;
        return anchor.clone();
    }
    /**
	 * Selection focus. Focus is a position where the selection ends.
	 *
	 * @see #anchor
	 */ get focus() {
        if (!this._ranges.length) {
            return null;
        }
        const range = this._ranges[this._ranges.length - 1];
        const focus = this._lastRangeBackward ? range.start : range.end;
        return focus.clone();
    }
    /**
	 * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
	 * collapsed.
	 */ get isCollapsed() {
        return this.rangeCount === 1 && this._ranges[0].isCollapsed;
    }
    /**
	 * Returns number of ranges in selection.
	 */ get rangeCount() {
        return this._ranges.length;
    }
    /**
	 * Specifies whether the {@link #focus} precedes {@link #anchor}.
	 */ get isBackward() {
        return !this.isCollapsed && this._lastRangeBackward;
    }
    /**
	 * {@link module:engine/view/editableelement~ViewEditableElement ViewEditableElement} instance that contains this selection, or `null`
	 * if the selection is not inside an editable element.
	 */ get editableElement() {
        if (this.anchor) {
            return this.anchor.editableElement;
        }
        return null;
    }
    /**
	 * Returns an iterable that contains copies of all ranges added to the selection.
	 */ *getRanges() {
        for (const range of this._ranges){
            yield range.clone();
        }
    }
    /**
	 * Returns copy of the first range in the selection. First range is the one which
	 * {@link module:engine/view/range~ViewRange#start start} position
	 * {@link module:engine/view/position~ViewPosition#isBefore is before} start
	 * position of all other ranges (not to confuse with the first range added to the selection).
	 * Returns `null` if no ranges are added to selection.
	 */ getFirstRange() {
        let first = null;
        for (const range of this._ranges){
            if (!first || range.start.isBefore(first.start)) {
                first = range;
            }
        }
        return first ? first.clone() : null;
    }
    /**
	 * Returns copy of the last range in the selection. Last range is the one which {@link module:engine/view/range~ViewRange#end end}
	 * position {@link module:engine/view/position~ViewPosition#isAfter is after} end position of all other ranges (not to confuse
	 * with the last range added to the selection). Returns `null` if no ranges are added to selection.
	 */ getLastRange() {
        let last = null;
        for (const range of this._ranges){
            if (!last || range.end.isAfter(last.end)) {
                last = range;
            }
        }
        return last ? last.clone() : null;
    }
    /**
	 * Returns copy of the first position in the selection. First position is the position that
	 * {@link module:engine/view/position~ViewPosition#isBefore is before} any other position in the selection ranges.
	 * Returns `null` if no ranges are added to selection.
	 */ getFirstPosition() {
        const firstRange = this.getFirstRange();
        return firstRange ? firstRange.start.clone() : null;
    }
    /**
	 * Returns copy of the last position in the selection. Last position is the position that
	 * {@link module:engine/view/position~ViewPosition#isAfter is after} any other position in the selection ranges.
	 * Returns `null` if no ranges are added to selection.
	 */ getLastPosition() {
        const lastRange = this.getLastRange();
        return lastRange ? lastRange.end.clone() : null;
    }
    /**
	 * Checks whether, this selection is equal to given selection. Selections are equal if they have same directions,
	 * same number of ranges and all ranges from one selection equal to a range from other selection.
	 *
	 * @param otherSelection Selection to compare with.
	 * @returns `true` if selections are equal, `false` otherwise.
	 */ isEqual(otherSelection) {
        if (this.isFake != otherSelection.isFake) {
            return false;
        }
        if (this.isFake && this.fakeSelectionLabel != otherSelection.fakeSelectionLabel) {
            return false;
        }
        if (this.rangeCount != otherSelection.rangeCount) {
            return false;
        } else if (this.rangeCount === 0) {
            return true;
        }
        if (!this.anchor.isEqual(otherSelection.anchor) || !this.focus.isEqual(otherSelection.focus)) {
            return false;
        }
        for (const thisRange of this._ranges){
            let found = false;
            for (const otherRange of otherSelection._ranges){
                if (thisRange.isEqual(otherRange)) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                return false;
            }
        }
        return true;
    }
    /**
	 * Checks whether this selection is similar to given selection. Selections are similar if they have same directions, same
	 * number of ranges, and all {@link module:engine/view/range~ViewRange#getTrimmed trimmed} ranges from one selection are
	 * equal to any trimmed range from other selection.
	 *
	 * @param otherSelection Selection to compare with.
	 * @returns `true` if selections are similar, `false` otherwise.
	 */ isSimilar(otherSelection) {
        if (this.isBackward != otherSelection.isBackward) {
            return false;
        }
        const numOfRangesA = count(this.getRanges());
        const numOfRangesB = count(otherSelection.getRanges());
        // If selections have different number of ranges, they cannot be similar.
        if (numOfRangesA != numOfRangesB) {
            return false;
        }
        // If both selections have no ranges, they are similar.
        if (numOfRangesA == 0) {
            return true;
        }
        // Check if each range in one selection has a similar range in other selection.
        for (let rangeA of this.getRanges()){
            rangeA = rangeA.getTrimmed();
            let found = false;
            for (let rangeB of otherSelection.getRanges()){
                rangeB = rangeB.getTrimmed();
                if (rangeA.start.isEqual(rangeB.start) && rangeA.end.isEqual(rangeB.end)) {
                    found = true;
                    break;
                }
            }
            // For `rangeA`, neither range in `otherSelection` was similar. So selections are not similar.
            if (!found) {
                return false;
            }
        }
        // There were no ranges that weren't matched. Selections are similar.
        return true;
    }
    /**
	 * Returns the selected element. {@link module:engine/view/element~ViewElement Element} is considered as selected if there is only
	 * one range in the selection, and that range contains exactly one element.
	 * Returns `null` if there is no selected element.
	 */ getSelectedElement() {
        if (this.rangeCount !== 1) {
            return null;
        }
        return this.getFirstRange().getContainedElement();
    }
    /**
	 * Sets this selection's ranges and direction to the specified location based on the given
	 * {@link module:engine/view/selection~ViewSelectable selectable}.
	 *
	 * ```ts
	 * // Sets selection to the given range.
	 * const range = writer.createRange( start, end );
	 * selection.setTo( range );
	 *
	 * // Sets selection to given ranges.
	 * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
	 * selection.setTo( range );
	 *
	 * // Sets selection to the other selection.
	 * const otherSelection = writer.createSelection();
	 * selection.setTo( otherSelection );
	 *
	 * // Sets selection to contents of ViewDocumentSelection.
	 * selection.setTo( editor.editing.view.document.selection );
	 *
	 * // Sets collapsed selection at the given position.
	 * const position = writer.createPositionAt( root, path );
	 * selection.setTo( position );
	 *
	 * // Sets collapsed selection at the position of given item and offset.
	 * selection.setTo( paragraph, offset );
	 * ```
	 *
	 * Creates a range inside an {@link module:engine/view/element~ViewElement element} which starts before the first child of
	 * that element and ends after the last child of that element.
	 *
	 * ```ts
	 * selection.setTo( paragraph, 'in' );
	 * ```
	 *
	 * Creates a range on an {@link module:engine/view/item~ViewItem item} which starts before the item and ends just after the item.
	 *
	 * ```ts
	 * selection.setTo( paragraph, 'on' );
	 *
	 * // Clears selection. Removes all ranges.
	 * selection.setTo( null );
	 * ```
	 *
	 * `Selection#setTo()` method allow passing additional options (`backward`, `fake` and `label`) as the last argument.
	 *
	 * ```ts
	 * // Sets selection as backward.
	 * selection.setTo( range, { backward: true } );
	 * ```
	 *
	 * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
	 * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
	 * represented in other way, for example by applying proper CSS class.
	 *
	 * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM
	 * (and be  properly handled by screen readers).
	 *
	 * ```ts
	 * // Creates fake selection with label.
	 * selection.setTo( range, { fake: true, label: 'foo' } );
	 * ```
	 *
	 * @fires change
	 */ setTo(...args) {
        let [selectable, placeOrOffset, options] = args;
        if (typeof placeOrOffset == 'object') {
            options = placeOrOffset;
            placeOrOffset = undefined;
        }
        if (selectable === null) {
            this._setRanges([]);
            this._setFakeOptions(options);
        } else if (selectable instanceof ViewSelection || selectable instanceof ViewDocumentSelection) {
            this._setRanges(selectable.getRanges(), selectable.isBackward);
            this._setFakeOptions({
                fake: selectable.isFake,
                label: selectable.fakeSelectionLabel
            });
        } else if (selectable instanceof ViewRange) {
            this._setRanges([
                selectable
            ], options && options.backward);
            this._setFakeOptions(options);
        } else if (selectable instanceof ViewPosition) {
            this._setRanges([
                new ViewRange(selectable)
            ]);
            this._setFakeOptions(options);
        } else if (selectable instanceof ViewNode) {
            const backward = !!options && !!options.backward;
            let range;
            if (placeOrOffset === undefined) {
                /**
				 * selection.setTo requires the second parameter when the first parameter is a node.
				 *
				 * @error view-selection-setto-required-second-parameter
				 */ throw new CKEditorError('view-selection-setto-required-second-parameter', this);
            } else if (placeOrOffset == 'in') {
                range = ViewRange._createIn(selectable);
            } else if (placeOrOffset == 'on') {
                range = ViewRange._createOn(selectable);
            } else {
                range = new ViewRange(ViewPosition._createAt(selectable, placeOrOffset));
            }
            this._setRanges([
                range
            ], backward);
            this._setFakeOptions(options);
        } else if (isIterable(selectable)) {
            // We assume that the selectable is an iterable of ranges.
            // Array.from() is used to prevent setting ranges to the old iterable
            this._setRanges(selectable, options && options.backward);
            this._setFakeOptions(options);
        } else {
            /**
			 * Cannot set selection to given place.
			 *
			 * @error view-selection-setto-not-selectable
			 */ throw new CKEditorError('view-selection-setto-not-selectable', this);
        }
        this.fire('change');
    }
    /**
	 * Moves {@link #focus} to the specified location.
	 *
	 * The location can be specified in the same form as
	 * {@link module:engine/view/view~EditingView#createPositionAt view.createPositionAt()}
	 * parameters.
	 *
	 * @fires change
	 * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~ViewItem view item}.
	 */ setFocus(itemOrPosition, offset) {
        if (this.anchor === null) {
            /**
			 * Cannot set selection focus if there are no ranges in selection.
			 *
			 * @error view-selection-setfocus-no-ranges
			 */ throw new CKEditorError('view-selection-setfocus-no-ranges', this);
        }
        const newFocus = ViewPosition._createAt(itemOrPosition, offset);
        if (newFocus.compareWith(this.focus) == 'same') {
            return;
        }
        const anchor = this.anchor;
        this._ranges.pop();
        if (newFocus.compareWith(anchor) == 'before') {
            this._addRange(new ViewRange(newFocus, anchor), true);
        } else {
            this._addRange(new ViewRange(anchor, newFocus));
        }
        this.fire('change');
    }
    /**
	 * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array
	 * is treated like the last added range and is used to set {@link #anchor anchor} and {@link #focus focus}.
	 * Accepts a flag describing in which way the selection is made.
	 *
	 * @param newRanges Iterable object of ranges to set.
	 * @param isLastBackward Flag describing if last added range was selected forward - from start to end
	 * (`false`) or backward - from end to start (`true`). Defaults to `false`.
	 */ _setRanges(newRanges, isLastBackward = false) {
        // New ranges should be copied to prevent removing them by setting them to `[]` first.
        // Only applies to situations when selection is set to the same selection or same selection's ranges.
        newRanges = Array.from(newRanges);
        this._ranges = [];
        for (const range of newRanges){
            this._addRange(range);
        }
        this._lastRangeBackward = !!isLastBackward;
    }
    /**
	 * Sets this selection instance to be marked as `fake`. A fake selection does not render as browser native selection
	 * over selected elements and is hidden to the user. This way, no native selection UI artifacts are displayed to
	 * the user and selection over elements can be represented in other way, for example by applying proper CSS class.
	 *
	 * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM (and be
	 * properly handled by screen readers).
	 */ _setFakeOptions(options = {}) {
        this._isFake = !!options.fake;
        this._fakeSelectionLabel = options.fake ? options.label || '' : '';
    }
    /**
	 * Adds a range to the selection. Added range is copied. This means that passed range is not saved in the
	 * selection instance and you can safely operate on it.
	 *
	 * Accepts a flag describing in which way the selection is made - passed range might be selected from
	 * {@link module:engine/view/range~ViewRange#start start} to {@link module:engine/view/range~ViewRange#end end}
	 * or from {@link module:engine/view/range~ViewRange#end end} to {@link module:engine/view/range~ViewRange#start start}.
	 * The flag is used to set {@link #anchor anchor} and {@link #focus focus} properties.
	 *
	 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects
	 * with ranges already stored in Selection instance.
	 */ _addRange(range, isBackward = false) {
        if (!(range instanceof ViewRange)) {
            /**
			 * Selection range set to an object that is not an instance of {@link module:engine/view/range~ViewRange}.
			 *
			 * @error view-selection-add-range-not-range
			 */ throw new CKEditorError('view-selection-add-range-not-range', this);
        }
        this._pushRange(range);
        this._lastRangeBackward = !!isBackward;
    }
    /**
	 * Adds range to selection - creates copy of given range so it can be safely used and modified.
	 *
	 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects
	 * with ranges already stored in selection instance.
	 */ _pushRange(range) {
        for (const storedRange of this._ranges){
            if (range.isIntersecting(storedRange)) {
                /**
				 * Trying to add a range that intersects with another range from selection.
				 *
				 * @error view-selection-range-intersects
				 * @param {module:engine/view/range~ViewRange} addedRange Range that was added to the selection.
				 * @param {module:engine/view/range~ViewRange} intersectingRange Range from selection that intersects with `addedRange`.
				 */ throw new CKEditorError('view-selection-range-intersects', this, {
                    addedRange: range,
                    intersectingRange: storedRange
                });
            }
        }
        this._ranges.push(new ViewRange(range.start, range.end));
    }
}
// The magic of type inference using `is` method is centralized in `TypeCheckable` class.
// Proper overload would interfere with that.
ViewSelection.prototype.is = function(type) {
    return type === 'selection' || type === 'view:selection';
};

/**
 * Class representing the document selection in the view.
 *
 * Its instance is available in {@link module:engine/view/document~ViewDocument#selection `Document#selection`}.
 *
 * It is similar to {@link module:engine/view/selection~ViewSelection} but
 * it has a read-only API and can be modified only by the writer available in
 * the {@link module:engine/view/view~EditingView#change `View#change()`} block
 * (so via {@link module:engine/view/downcastwriter~ViewDowncastWriter#setSelection `ViewDowncastWriter#setSelection()`}).
 */ class ViewDocumentSelection extends /* #__PURE__ */ EmitterMixin(ViewTypeCheckable) {
    /**
	 * Selection is used internally (`ViewDocumentSelection` is a proxy to that selection).
	 */ _selection;
    constructor(...args){
        super();
        this._selection = new ViewSelection();
        // Delegate change event to be fired on ViewDocumentSelection instance.
        this._selection.delegate('change').to(this);
        // Set selection data.
        if (args.length) {
            this._selection.setTo(...args);
        }
    }
    /**
	 * Returns true if selection instance is marked as `fake`.
	 *
	 * @see #_setTo
	 */ get isFake() {
        return this._selection.isFake;
    }
    /**
	 * Returns fake selection label.
	 *
	 * @see #_setTo
	 */ get fakeSelectionLabel() {
        return this._selection.fakeSelectionLabel;
    }
    /**
	 * Selection anchor. Anchor may be described as a position where the selection starts. Together with
	 * {@link #focus focus} they define the direction of selection, which is important
	 * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.
	 * It may be a bit unintuitive when there are multiple ranges in selection.
	 *
	 * @see #focus
	 */ get anchor() {
        return this._selection.anchor;
    }
    /**
	 * Selection focus. Focus is a position where the selection ends.
	 *
	 * @see #anchor
	 */ get focus() {
        return this._selection.focus;
    }
    /**
	 * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
	 * collapsed.
	 */ get isCollapsed() {
        return this._selection.isCollapsed;
    }
    /**
	 * Returns number of ranges in selection.
	 */ get rangeCount() {
        return this._selection.rangeCount;
    }
    /**
	 * Specifies whether the {@link #focus} precedes {@link #anchor}.
	 */ get isBackward() {
        return this._selection.isBackward;
    }
    /**
	 * {@link module:engine/view/editableelement~ViewEditableElement ViewEditableElement} instance that contains this selection, or `null`
	 * if the selection is not inside an editable element.
	 */ get editableElement() {
        return this._selection.editableElement;
    }
    /**
	 * Used for the compatibility with the {@link module:engine/view/selection~ViewSelection#isEqual} method.
	 *
	 * @internal
	 */ get _ranges() {
        return this._selection._ranges;
    }
    /**
	 * Returns an iterable that contains copies of all ranges added to the selection.
	 */ *getRanges() {
        yield* this._selection.getRanges();
    }
    /**
	 * Returns copy of the first range in the selection. First range is the one which
	 * {@link module:engine/view/range~ViewRange#start start} position
	 * {@link module:engine/view/position~ViewPosition#isBefore is before} start
	 * position of all other ranges (not to confuse with the first range added to the selection).
	 * Returns `null` if no ranges are added to selection.
	 */ getFirstRange() {
        return this._selection.getFirstRange();
    }
    /**
	 * Returns copy of the last range in the selection. Last range is the one which {@link module:engine/view/range~ViewRange#end end}
	 * position {@link module:engine/view/position~ViewPosition#isAfter is after} end position of all other ranges (not to confuse
	 * with the last range added to the selection). Returns `null` if no ranges are added to selection.
	 */ getLastRange() {
        return this._selection.getLastRange();
    }
    /**
	 * Returns copy of the first position in the selection. First position is the position that
	 * {@link module:engine/view/position~ViewPosition#isBefore is before} any other position in the selection ranges.
	 * Returns `null` if no ranges are added to selection.
	 */ getFirstPosition() {
        return this._selection.getFirstPosition();
    }
    /**
	 * Returns copy of the last position in the selection. Last position is the position that
	 * {@link module:engine/view/position~ViewPosition#isAfter is after} any other position in the selection ranges.
	 * Returns `null` if no ranges are added to selection.
	 */ getLastPosition() {
        return this._selection.getLastPosition();
    }
    /**
	 * Returns the selected element. {@link module:engine/view/element~ViewElement Element} is considered as selected if there is only
	 * one range in the selection, and that range contains exactly one element.
	 * Returns `null` if there is no selected element.
	 */ getSelectedElement() {
        return this._selection.getSelectedElement();
    }
    /**
	 * Checks whether, this selection is equal to given selection. Selections are equal if they have same directions,
	 * same number of ranges and all ranges from one selection equal to a range from other selection.
	 *
	 * @param otherSelection Selection to compare with.
	 * @returns `true` if selections are equal, `false` otherwise.
	 */ isEqual(otherSelection) {
        return this._selection.isEqual(otherSelection);
    }
    /**
	 * Checks whether this selection is similar to given selection. Selections are similar if they have same directions, same
	 * number of ranges, and all {@link module:engine/view/range~ViewRange#getTrimmed trimmed} ranges from one selection are
	 * equal to any trimmed range from other selection.
	 *
	 * @param otherSelection Selection to compare with.
	 * @returns `true` if selections are similar, `false` otherwise.
	 */ isSimilar(otherSelection) {
        return this._selection.isSimilar(otherSelection);
    }
    /**
	 * Sets this selection's ranges and direction to the specified location based on the given
	 * {@link module:engine/view/selection~ViewSelectable selectable}.
	 *
	 * ```ts
	 * // Sets selection to the given range.
	 * const range = writer.createRange( start, end );
	 * documentSelection._setTo( range );
	 *
	 * // Sets selection to given ranges.
	 * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( start2, end2 ) ];
	 * documentSelection._setTo( range );
	 *
	 * // Sets selection to the other selection.
	 * const otherSelection = writer.createSelection();
	 * documentSelection._setTo( otherSelection );
	 *
	 * // Sets collapsed selection at the given position.
	 * const position = writer.createPositionAt( root, offset );
	 * documentSelection._setTo( position );
	 *
	 * // Sets collapsed selection at the position of given item and offset.
	 * documentSelection._setTo( paragraph, offset );
	 * ```
	 *
	 * Creates a range inside an {@link module:engine/view/element~ViewElement element} which starts before the first child of
	 * that element and ends after the last child of that element.
	 *
	 * ```ts
	 * documentSelection._setTo( paragraph, 'in' );
	 * ```
	 *
	 * Creates a range on an {@link module:engine/view/item~ViewItem item} which starts before the item and ends just after the item.
	 *
	 * ```ts
	 * documentSelection._setTo( paragraph, 'on' );
	 *
	 * // Clears selection. Removes all ranges.
	 * documentSelection._setTo( null );
	 * ```
	 *
	 * `Selection#_setTo()` method allow passing additional options (`backward`, `fake` and `label`) as the last argument.
	 *
	 * ```ts
	 * // Sets selection as backward.
	 * documentSelection._setTo( range, { backward: true } );
	 * ```
	 *
	 * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
	 * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
	 * represented in other way, for example by applying proper CSS class.
	 *
	 * Additionally fake's selection label can be provided. It will be used to des cribe fake selection in DOM
	 * (and be  properly handled by screen readers).
	 *
	 * ```ts
	 * // Creates fake selection with label.
	 * documentSelection._setTo( range, { fake: true, label: 'foo' } );
	 * ```
	 *
	 * @internal
	 * @fires change
	 */ _setTo(...args) {
        this._selection.setTo(...args);
    }
    /**
	 * Moves {@link #focus} to the specified location.
	 *
	 * The location can be specified in the same form as
	 * {@link module:engine/view/view~EditingView#createPositionAt view.createPositionAt()}
	 * parameters.
	 *
	 * @internal
	 * @fires change
	 * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~ViewItem view item}.
	 */ _setFocus(itemOrPosition, offset) {
        this._selection.setFocus(itemOrPosition, offset);
    }
}
// The magic of type inference using `is` method is centralized in `TypeCheckable` class.
// Proper overload would interfere with that.
ViewDocumentSelection.prototype.is = function(type) {
    return type === 'selection' || type == 'documentSelection' || type == 'view:selection' || type == 'view:documentSelection';
};

/**
 * The event object passed to bubbling event callbacks. It is used to provide information about the event as well as a tool to
 * manipulate it.
 */ class BubblingEventInfo extends EventInfo {
    /**
	 * The view range that the bubbling should start from.
	 */ startRange;
    /**
	 * The current event phase.
	 */ _eventPhase;
    /**
	 * The current bubbling target.
	 */ _currentTarget;
    /**
	 * @param source The emitter.
	 * @param name The event name.
	 * @param startRange The view range that the bubbling should start from.
	 */ constructor(source, name, startRange){
        super(source, name);
        this.startRange = startRange;
        this._eventPhase = 'none';
        this._currentTarget = null;
    }
    /**
	 * The current event phase.
	 */ get eventPhase() {
        return this._eventPhase;
    }
    /**
	 * The current bubbling target.
	 */ get currentTarget() {
        return this._currentTarget;
    }
}

const contextsSymbol = Symbol('bubbling contexts');
/**
 * Bubbling emitter mixin for the view document as described in the {@link ~BubblingEmitter} interface.
 *
 * This function creates a class that inherits from the provided `base` and implements `Emitter` interface.
 * The base class must implement {@link module:utils/emittermixin~Emitter} interface.
 *
 * ```ts
 * class BaseClass extends EmitterMixin() {
 * 	// ...
 * }
 *
 * class MyClass extends BubblingEmitterMixin( BaseClass ) {
 * 	// This class derives from `BaseClass` and implements the `BubblingEmitter` interface.
 * }
 * ```
 */ function BubblingEmitterMixin(base) {
    class Mixin extends base {
        fire(eventOrInfo, ...eventArgs) {
            try {
                const eventInfo = eventOrInfo instanceof EventInfo ? eventOrInfo : new EventInfo(this, eventOrInfo);
                const eventContexts = getBubblingContexts(this);
                if (!eventContexts.size) {
                    return;
                }
                updateEventInfo(eventInfo, 'capturing', this);
                // The capture phase of the event.
                if (fireListenerFor(eventContexts, '$capture', eventInfo, ...eventArgs)) {
                    return eventInfo.return;
                }
                const startRange = eventInfo.startRange || this.selection.getFirstRange();
                const selectedElement = startRange ? startRange.getContainedElement() : null;
                const isCustomContext = selectedElement ? Boolean(getCustomContext(eventContexts, selectedElement)) : false;
                let node = selectedElement || getDeeperRangeParent(startRange);
                updateEventInfo(eventInfo, 'atTarget', node);
                // For the not yet bubbling event trigger for $text node if selection can be there and it's not a custom context selected.
                if (!isCustomContext) {
                    if (fireListenerFor(eventContexts, '$text', eventInfo, ...eventArgs)) {
                        return eventInfo.return;
                    }
                    updateEventInfo(eventInfo, 'bubbling', node);
                }
                while(node){
                    // Root node handling.
                    if (node.is('rootElement')) {
                        if (fireListenerFor(eventContexts, '$root', eventInfo, ...eventArgs)) {
                            return eventInfo.return;
                        }
                    } else if (node.is('element')) {
                        if (fireListenerFor(eventContexts, node.name, eventInfo, ...eventArgs)) {
                            return eventInfo.return;
                        }
                    }
                    // Check custom contexts (i.e., a widget).
                    if (fireListenerFor(eventContexts, node, eventInfo, ...eventArgs)) {
                        return eventInfo.return;
                    }
                    node = node.parent;
                    updateEventInfo(eventInfo, 'bubbling', node);
                }
                updateEventInfo(eventInfo, 'bubbling', this);
                // Document context.
                fireListenerFor(eventContexts, '$document', eventInfo, ...eventArgs);
                return eventInfo.return;
            } catch (err) {
                // @if CK_DEBUG // throw err;
                /* istanbul ignore next -- @preserve */ CKEditorError.rethrowUnexpectedError(err, this);
            }
        }
        _addEventListener(event, callback, options) {
            const contexts = toArray(options.context || '$document');
            const eventContexts = getBubblingContexts(this);
            for (const context of contexts){
                let emitter = eventContexts.get(context);
                if (!emitter) {
                    emitter = new (EmitterMixin())();
                    eventContexts.set(context, emitter);
                }
                this.listenTo(emitter, event, callback, options);
            }
        }
        _removeEventListener(event, callback) {
            const eventContexts = getBubblingContexts(this);
            for (const emitter of eventContexts.values()){
                this.stopListening(emitter, event, callback);
            }
        }
    }
    return Mixin;
}
/**
 * Update the event info bubbling fields.
 *
 * @param eventInfo The event info object to update.
 * @param eventPhase The current event phase.
 * @param currentTarget The current bubbling target.
 */ function updateEventInfo(eventInfo, eventPhase, currentTarget) {
    if (eventInfo instanceof BubblingEventInfo) {
        eventInfo._eventPhase = eventPhase;
        eventInfo._currentTarget = currentTarget;
    }
}
/**
 * Fires the listener for the specified context. Returns `true` if event was stopped.
 *
 * @param eventInfo The `EventInfo` object.
 * @param eventArgs Additional arguments to be passed to the callbacks.
 * @returns True if event stop was called.
 */ function fireListenerFor(eventContexts, context, eventInfo, ...eventArgs) {
    const emitter = typeof context == 'string' ? eventContexts.get(context) : getCustomContext(eventContexts, context);
    if (!emitter) {
        return false;
    }
    emitter.fire(eventInfo, ...eventArgs);
    return eventInfo.stop.called;
}
/**
 * Returns an emitter for a specified view node.
 */ function getCustomContext(eventContexts, node) {
    for (const [context, emitter] of eventContexts){
        if (typeof context == 'function' && context(node)) {
            return emitter;
        }
    }
    return null;
}
/**
 * Returns bubbling contexts map for the source (emitter).
 */ function getBubblingContexts(source) {
    if (!source[contextsSymbol]) {
        source[contextsSymbol] = new Map();
    }
    return source[contextsSymbol];
}
/**
 * Returns the deeper parent element for the range.
 */ function getDeeperRangeParent(range) {
    if (!range) {
        return null;
    }
    const startParent = range.start.parent;
    const endParent = range.end.parent;
    const startPath = startParent.getPath();
    const endPath = endParent.getPath();
    return startPath.length > endPath.length ? startParent : endParent;
}

// @if CK_DEBUG_ENGINE // const { logDocument } = require( '../dev-utils/utils' );
/**
 * Document class creates an abstract layer over the content editable area, contains a tree of view elements and
 * {@link module:engine/view/documentselection~ViewDocumentSelection view selection} associated with this document.
 */ class ViewDocument extends /* #__PURE__ */ BubblingEmitterMixin(/* #__PURE__ */ ObservableMixin()) {
    /**
	 * Selection done on this document.
	 */ selection;
    /**
	 * Roots of the view tree. Collection of the {@link module:engine/view/element~ViewElement view elements}.
	 *
	 * View roots are created as a result of binding between {@link module:engine/view/document~ViewDocument#roots} and
	 * {@link module:engine/model/document~ModelDocument#roots} and this is handled by
	 * {@link module:engine/controller/editingcontroller~EditingController}, so to create view root we need to create
	 * model root using {@link module:engine/model/document~ModelDocument#createRoot}.
	 */ roots;
    /**
	 * The styles processor instance used by this document when normalizing styles.
	 */ stylesProcessor;
    /**
	 * Post-fixer callbacks registered to the view document.
	 */ _postFixers = new Set();
    /**
	 * Creates a Document instance.
	 *
	 * @param stylesProcessor The styles processor instance.
	 */ constructor(stylesProcessor){
        super();
        this.selection = new ViewDocumentSelection();
        this.roots = new Collection({
            idProperty: 'rootName'
        });
        this.stylesProcessor = stylesProcessor;
        this.set('isReadOnly', false);
        this.set('isFocused', false);
        this.set('isSelecting', false);
        this.set('isComposing', false);
    }
    /**
	 * Gets a {@link module:engine/view/document~ViewDocument#roots view root element} with the specified name. If the name is not
	 * specific "main" root is returned.
	 *
	 * @param name Name of the root.
	 * @returns The view root element with the specified name or null when there is no root of given name.
	 */ getRoot(name = 'main') {
        return this.roots.get(name);
    }
    /**
	 * Allows registering post-fixer callbacks. A post-fixers mechanism allows to update the view tree just before it is rendered
	 * to the DOM.
	 *
	 * Post-fixers are executed right after all changes from the outermost change block were applied but
	 * before the {@link module:engine/view/view~EditingView#event:render render event} is fired. If a post-fixer callback made
	 * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should
	 * not be fixed in the new document tree state.
	 *
	 * View post-fixers are useful when you want to apply some fixes whenever the view structure changes. Keep in mind that
	 * changes executed in a view post-fixer should not break model-view mapping.
	 *
	 * The types of changes which should be safe:
	 *
	 * * adding or removing attribute from elements,
	 * * changes inside of {@link module:engine/view/uielement~ViewUIElement UI elements},
	 * * {@link module:engine/controller/editingcontroller~EditingController#reconvertItem marking some of the model elements to be
	 * re-converted}.
	 *
	 * Try to avoid changes which touch view structure:
	 *
	 * * you should not add or remove nor wrap or unwrap any view elements,
	 * * you should not change the editor data model in a view post-fixer.
	 *
	 * As a parameter, a post-fixer callback receives a {@link module:engine/view/downcastwriter~ViewDowncastWriter downcast writer}.
	 *
	 * Typically, a post-fixer will look like this:
	 *
	 * ```ts
	 * editor.editing.view.document.registerPostFixer( writer => {
	 * 	if ( checkSomeCondition() ) {
	 * 		writer.doSomething();
	 *
	 * 		// Let other post-fixers know that something changed.
	 * 		return true;
	 * 	}
	 *
	 * 	return false;
	 * } );
	 * ```
	 *
	 * Note that nothing happens right after you register a post-fixer (e.g. execute such a code in the console).
	 * That is because adding a post-fixer does not execute it.
	 * The post-fixer will be executed as soon as any change in the document needs to cause its rendering.
	 * If you want to re-render the editor's view after registering the post-fixer then you should do it manually by calling
	 * {@link module:engine/view/view~EditingView#forceRender `view.forceRender()`}.
	 *
	 * If you need to register a callback which is executed when DOM elements are already updated,
	 * use {@link module:engine/view/view~EditingView#event:render render event}.
	 */ registerPostFixer(postFixer) {
        this._postFixers.add(postFixer);
    }
    /**
	 * Destroys this instance. Makes sure that all observers are destroyed and listeners removed.
	 */ destroy() {
        this.roots.forEach((root)=>root.destroy());
        this.stopListening();
    }
    /**
	 * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.
	 *
	 * @internal
	 */ _callPostFixers(writer) {
        let wasFixed = false;
        do {
            for (const callback of this._postFixers){
                wasFixed = callback(writer);
                if (wasFixed) {
                    break;
                }
            }
        }while (wasFixed)
    }
}

// Default attribute priority.
const DEFAULT_PRIORITY = 10;
/**
 * Attribute elements are used to represent formatting elements in the view (think – `<b>`, `<span style="font-size: 2em">`, etc.).
 * Most often they are created when downcasting model text attributes.
 *
 * Editing engine does not define a fixed HTML DTD. This is why a feature developer needs to choose between various
 * types (container element, {@link module:engine/view/attributeelement~ViewAttributeElement attribute element},
 * {@link module:engine/view/emptyelement~ViewEmptyElement empty element}, etc) when developing a feature.
 *
 * To create a new attribute element instance use the
 * {@link module:engine/view/downcastwriter~ViewDowncastWriter#createAttributeElement `ViewDowncastWriter#createAttributeElement()`} method.
 */ class ViewAttributeElement extends ViewElement {
    static DEFAULT_PRIORITY = DEFAULT_PRIORITY;
    /**
	 * Element priority. Decides in what order elements are wrapped by {@link module:engine/view/downcastwriter~ViewDowncastWriter}.
	 *
	 * @internal
	 * @readonly
	 */ _priority = DEFAULT_PRIORITY;
    /**
	 * Element identifier. If set, it is used by {@link module:engine/view/element~ViewElement#isSimilar},
	 * and then two elements are considered similar if, and only if they have the same `_id`.
	 *
	 * @internal
	 * @readonly
	 */ _id = null;
    /**
	 * Keeps all the attribute elements that have the same {@link module:engine/view/attributeelement~ViewAttributeElement#id ids}
	 * and still exist in the view tree.
	 *
	 * This property is managed by {@link module:engine/view/downcastwriter~ViewDowncastWriter}.
	 */ _clonesGroup = null;
    /**
	 * Creates an attribute element.
	 *
	 * @see module:engine/view/downcastwriter~ViewDowncastWriter#createAttributeElement
	 * @see module:engine/view/element~ViewElement
	 * @protected
	 * @param document The document instance to which this element belongs.
	 * @param name Node name.
	 * @param attrs Collection of attributes.
	 * @param children A list of nodes to be inserted into created element.
	 */ constructor(document, name, attrs, children){
        super(document, name, attrs, children);
        this.getFillerOffset = getFillerOffset$3;
    }
    /**
	 * Element priority. Decides in what order elements are wrapped by {@link module:engine/view/downcastwriter~ViewDowncastWriter}.
	 */ get priority() {
        return this._priority;
    }
    /**
	 * Element identifier. If set, it is used by {@link module:engine/view/element~ViewElement#isSimilar},
	 * and then two elements are considered similar if, and only if they have the same `id`.
	 */ get id() {
        return this._id;
    }
    /**
	 * Returns all {@link module:engine/view/attributeelement~ViewAttributeElement attribute elements} that has the
	 * same {@link module:engine/view/attributeelement~ViewAttributeElement#id id} and are in the view tree (were not removed).
	 *
	 * Note: If this element has been removed from the tree, returned set will not include it.
	 *
	 * Throws {@link module:utils/ckeditorerror~CKEditorError attribute-element-get-elements-with-same-id-no-id}
	 * if this element has no `id`.
	 *
	 * @returns Set containing all the attribute elements
	 * with the same `id` that were added and not removed from the view tree.
	 */ getElementsWithSameId() {
        if (this.id === null) {
            /**
			 * Cannot get elements with the same id for an attribute element without id.
			 *
			 * @error attribute-element-get-elements-with-same-id-no-id
			 */ throw new CKEditorError('attribute-element-get-elements-with-same-id-no-id', this);
        }
        return new Set(this._clonesGroup);
    }
    /**
	 * Checks if this element is similar to other element.
	 *
	 * If none of elements has set {@link module:engine/view/attributeelement~ViewAttributeElement#id}, then both elements
	 * should have the same name, attributes and priority to be considered as similar. Two similar elements can contain
	 * different set of children nodes.
	 *
	 * If at least one element has {@link module:engine/view/attributeelement~ViewAttributeElement#id} set, then both
	 * elements have to have the same {@link module:engine/view/attributeelement~ViewAttributeElement#id} value to be
	 * considered similar.
	 *
	 * Similarity is important for {@link module:engine/view/downcastwriter~ViewDowncastWriter}. For example:
	 *
	 * * two following similar elements can be merged together into one, longer element,
	 * * {@link module:engine/view/downcastwriter~ViewDowncastWriter#unwrap} checks similarity of passed element and processed element to
	 * decide whether processed element should be unwrapped,
	 * * etc.
	 */ isSimilar(otherElement) {
        // If any element has an `id` set, just compare the ids.
        if (this.id !== null || otherElement.id !== null) {
            return this.id === otherElement.id;
        }
        return super.isSimilar(otherElement) && this.priority == otherElement.priority;
    }
    /**
	 * Clones provided element with priority.
	 *
	 * @internal
	 * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
	 * element will be cloned without any children.
	 * @returns Clone of this element.
	 */ _clone(deep = false) {
        const cloned = super._clone(deep);
        // Clone priority too.
        cloned._priority = this._priority;
        // And id too.
        cloned._id = this._id;
        return cloned;
    }
    /**
	 * Used by {@link module:engine/view/element~ViewElement#_mergeAttributesFrom} to verify if the given element can be merged without
	 * conflicts into this element.
	 *
	 * @internal
	 */ _canMergeAttributesFrom(otherElement) {
        // Can't merge if any of elements have an id or a difference of priority.
        if (this.id !== null || otherElement.id !== null || this.priority !== otherElement.priority) {
            return false;
        }
        return super._canMergeAttributesFrom(otherElement);
    }
    /**
	 * Used by {@link module:engine/view/element~ViewElement#_subtractAttributesOf} to verify if the given element attributes
	 * can be fully subtracted from this element.
	 *
	 * @internal
	 */ _canSubtractAttributesOf(otherElement) {
        // Can't subtract if any of elements have an id or a difference of priority.
        if (this.id !== null || otherElement.id !== null || this.priority !== otherElement.priority) {
            return false;
        }
        return super._canSubtractAttributesOf(otherElement);
    }
}
// The magic of type inference using `is` method is centralized in `TypeCheckable` class.
// Proper overload would interfere with that.
ViewAttributeElement.prototype.is = function(type, name) {
    if (!name) {
        return type === 'attributeElement' || type === 'view:attributeElement' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === 'element' || type === 'view:element' || type === 'node' || type === 'view:node';
    } else {
        return name === this.name && (type === 'attributeElement' || type === 'view:attributeElement' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === 'element' || type === 'view:element');
    }
};
/**
 * Returns block {@link module:engine/view/filler~Filler filler} offset or `null` if block filler is not needed.
 *
 * @returns Block filler offset or `null` if block filler is not needed.
 */ function getFillerOffset$3() {
    // <b>foo</b> does not need filler.
    if (nonUiChildrenCount(this)) {
        return null;
    }
    let element = this.parent;
    // <p><b></b></p> needs filler -> <p><b><br></b></p>
    while(element && element.is('attributeElement')){
        if (nonUiChildrenCount(element) > 1) {
            return null;
        }
        element = element.parent;
    }
    if (!element || nonUiChildrenCount(element) > 1) {
        return null;
    }
    // Render block filler at the end of element (after all ui elements).
    return this.childCount;
}
/**
 * Returns total count of children that are not {@link module:engine/view/uielement~ViewUIElement UIElements}.
 */ function nonUiChildrenCount(element) {
    return Array.from(element.getChildren()).filter((element)=>!element.is('uiElement')).length;
}

/**
 * Empty element class. It is used to represent elements that cannot contain any child nodes (for example `<img>` elements).
 *
 * To create a new empty element use the
 * {@link module:engine/view/downcastwriter~ViewDowncastWriter#createEmptyElement `downcastWriter#createEmptyElement()`} method.
 */ class ViewEmptyElement extends ViewElement {
    /**
	 * Creates new instance of ViewEmptyElement.
	 *
	 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-emptyelement-cannot-add` when third parameter is passed,
	 * to inform that usage of ViewEmptyElement is incorrect (adding child nodes to ViewEmptyElement is forbidden).
	 *
	 * @see module:engine/view/downcastwriter~ViewDowncastWriter#createEmptyElement
	 * @internal
	 * @param document The document instance to which this element belongs.
	 * @param name Node name.
	 * @param attributes Collection of attributes.
	 * @param children A list of nodes to be inserted into created element.
	 */ constructor(document, name, attributes, children){
        super(document, name, attributes, children);
        this.getFillerOffset = getFillerOffset$2;
    }
    /**
	 * Overrides {@link module:engine/view/element~ViewElement#_insertChild} method.
	 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-emptyelement-cannot-add` to prevent
	 * adding any child nodes to ViewEmptyElement.
	 *
	 * @internal
	 */ _insertChild(index, items) {
        if (items && (items instanceof ViewNode || Array.from(items).length > 0)) {
            /**
			 * Cannot add children to {@link module:engine/view/emptyelement~ViewEmptyElement}.
			 *
			 * @error view-emptyelement-cannot-add
			 */ throw new CKEditorError('view-emptyelement-cannot-add', [
                this,
                items
            ]);
        }
        return 0;
    }
}
// The magic of type inference using `is` method is centralized in `TypeCheckable` class.
// Proper overload would interfere with that.
ViewEmptyElement.prototype.is = function(type, name) {
    if (!name) {
        return type === 'emptyElement' || type === 'view:emptyElement' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === 'element' || type === 'view:element' || type === 'node' || type === 'view:node';
    } else {
        return name === this.name && (type === 'emptyElement' || type === 'view:emptyElement' || type === 'element' || type === 'view:element');
    }
};
/**
 * Returns `null` because block filler is not needed for ViewEmptyElements.
 */ function getFillerOffset$2() {
    return null;
}

/**
 * UI element class. It should be used to represent editing UI which needs to be injected into the editing view
 * If possible, you should keep your UI outside the editing view. However, if that is not possible,
 * UI elements can be used.
 *
 * How a UI element is rendered is in your control (you pass a callback to
 * {@link module:engine/view/downcastwriter~ViewDowncastWriter#createUIElement `downcastWriter#createUIElement()`}).
 * The editor will ignore your UI element – the selection cannot be placed in it, it is skipped (invisible) when
 * the user modifies the selection by using arrow keys and the editor does not listen to any mutations which
 * happen inside your UI elements.
 *
 * The limitation is that you cannot convert a model element to a UI element. UI elements need to be
 * created for {@link module:engine/model/markercollection~Marker markers} or as additinal elements
 * inside normal {@link module:engine/view/containerelement~ViewContainerElement container elements}.
 *
 * To create a new UI element use the
 * {@link module:engine/view/downcastwriter~ViewDowncastWriter#createUIElement `downcastWriter#createUIElement()`} method.
 */ class ViewUIElement extends ViewElement {
    /**
	 * Creates new instance of UIElement.
	 *
	 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` when third parameter is passed,
	 * to inform that usage of UIElement is incorrect (adding child nodes to UIElement is forbidden).
	 *
	 * @see module:engine/view/downcastwriter~ViewDowncastWriter#createUIElement
	 * @internal
	 * @param document The document instance to which this element belongs.
	 * @param name Node name.
	 * @param attrs Collection of attributes.
	 * @param children A list of nodes to be inserted into created element.
	 */ constructor(document, name, attrs, children){
        super(document, name, attrs, children);
        this.getFillerOffset = getFillerOffset$1;
    }
    /**
	 * Overrides {@link module:engine/view/element~ViewElement#_insertChild} method.
	 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` to prevent adding any child nodes
	 * to UIElement.
	 *
	 * @internal
	 */ _insertChild(index, items) {
        if (items && (items instanceof ViewNode || Array.from(items).length > 0)) {
            /**
			 * Cannot add children to {@link module:engine/view/uielement~ViewUIElement}.
			 *
			 * @error view-uielement-cannot-add
			 */ throw new CKEditorError('view-uielement-cannot-add', [
                this,
                items
            ]);
        }
        return 0;
    }
    /**
	 * Renders this {@link module:engine/view/uielement~ViewUIElement} to DOM. This method is called by
	 * {@link module:engine/view/domconverter~ViewDomConverter}.
	 * Do not use inheritance to create custom rendering method, replace `render()` method instead:
	 *
	 * ```ts
	 * const myUIElement = downcastWriter.createUIElement( 'span' );
	 * myUIElement.render = function( domDocument, domConverter ) {
	 * 	const domElement = this.toDomElement( domDocument );
	 *
	 * 	domConverter.setContentOf( domElement, '<b>this is ui element</b>' );
	 *
	 * 	return domElement;
	 * };
	 * ```
	 *
	 * If changes in your UI element should trigger some editor UI update you should call
	 * the {@link module:ui/editorui/editorui~EditorUI#update `editor.ui.update()`} method
	 * after rendering your UI element.
	 *
	 * @param domConverter Instance of the ViewDomConverter used to optimize the output.
	 */ render(domDocument, domConverter// eslint-disable-line @typescript-eslint/no-unused-vars
    ) {
        // Provide basic, default output.
        return this.toDomElement(domDocument);
    }
    /**
	 * Creates DOM element based on this view UIElement.
	 * Note that each time this method is called new DOM element is created.
	 */ toDomElement(domDocument) {
        const domElement = domDocument.createElement(this.name);
        for (const key of this.getAttributeKeys()){
            domElement.setAttribute(key, this.getAttribute(key));
        }
        return domElement;
    }
}
// The magic of type inference using `is` method is centralized in `TypeCheckable` class.
// Proper overload would interfere with that.
ViewUIElement.prototype.is = function(type, name) {
    if (!name) {
        return type === 'uiElement' || type === 'view:uiElement' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === 'element' || type === 'view:element' || type === 'node' || type === 'view:node';
    } else {
        return name === this.name && (type === 'uiElement' || type === 'view:uiElement' || type === 'element' || type === 'view:element');
    }
};
/**
 * This function injects UI element handling to the given {@link module:engine/view/document~ViewDocument document}.
 *
 * A callback is added to {@link module:engine/view/document~ViewDocument#event:keydown document keydown event}.
 * The callback handles the situation when right arrow key is pressed and selection is collapsed before a UI element.
 * Without this handler, it would be impossible to "jump over" UI element using right arrow key.
 *
 * @param view View controller to which the quirks handling will be injected.
 * @internal
 */ function injectUiElementHandling(view) {
    view.document.on('arrowKey', (evt, data)=>jumpOverUiElement(evt, data, view.domConverter), {
        priority: 'low'
    });
}
/**
 * Returns `null` because block filler is not needed for UIElements.
 */ function getFillerOffset$1() {
    return null;
}
/**
 * Selection cannot be placed in a `UIElement`. Whenever it is placed there, it is moved before it. This
 * causes a situation when it is impossible to jump over `UIElement` using right arrow key, because the selection
 * ends up in ui element (in DOM) and is moved back to the left. This handler fixes this situation.
 */ function jumpOverUiElement(evt, data, domConverter) {
    if (data.keyCode == keyCodes.arrowright) {
        const domSelection = data.domTarget.ownerDocument.defaultView.getSelection();
        const domSelectionCollapsed = domSelection.rangeCount == 1 && domSelection.getRangeAt(0).collapsed;
        // Jump over UI element if selection is collapsed or shift key is pressed. These are the cases when selection would extend.
        if (domSelectionCollapsed || data.shiftKey) {
            const domParent = domSelection.focusNode;
            const domOffset = domSelection.focusOffset;
            const viewPosition = domConverter.domPositionToView(domParent, domOffset);
            // In case if dom element is not converted to view or is not mapped or something. Happens for example in some tests.
            if (viewPosition === null) {
                return;
            }
            // Skip all following ui elements.
            let jumpedOverAnyUiElement = false;
            const nextViewPosition = viewPosition.getLastMatchingPosition((value)=>{
                if (value.item.is('uiElement')) {
                    // Remember that there was at least one ui element.
                    jumpedOverAnyUiElement = true;
                }
                // Jump over ui elements, jump over empty attribute elements, move up from inside of attribute element.
                if (value.item.is('uiElement') || value.item.is('attributeElement')) {
                    return true;
                }
                // Don't jump over text or don't get out of container element.
                return false;
            });
            // If anything has been skipped, fix position.
            // This `if` could be possibly omitted but maybe it is better not to mess with DOM selection if not needed.
            if (jumpedOverAnyUiElement) {
                const newDomPosition = domConverter.viewPositionToDom(nextViewPosition);
                if (domSelectionCollapsed) {
                    // Selection was collapsed, so collapse it at further position.
                    domSelection.collapse(newDomPosition.parent, newDomPosition.offset);
                } else {
                    // Selection was not collapse, so extend it instead of collapsing.
                    domSelection.extend(newDomPosition.parent, newDomPosition.offset);
                }
            }
        }
    }
}

/**
 * The raw element class.
 *
 * The raw elements work as data containers ("wrappers", "sandboxes") but their children are not managed or
 * even recognized by the editor. This encapsulation allows integrations to maintain custom DOM structures
 * in the editor content without, for instance, worrying about compatibility with other editor features.
 * Raw elements are a perfect tool for integration with external frameworks and data sources.
 *
 * Unlike {@link module:engine/view/uielement~ViewUIElement UI elements}, raw elements act like real editor
 * content (similar to {@link module:engine/view/containerelement~ViewContainerElement} or
 * {@link module:engine/view/emptyelement~ViewEmptyElement}), they are considered by the editor selection and
 * {@link module:widget/utils~toWidget they can work as widgets}.
 *
 * To create a new raw element, use the
 * {@link module:engine/view/downcastwriter~ViewDowncastWriter#createRawElement `downcastWriter#createRawElement()`} method.
 */ class ViewRawElement extends ViewElement {
    /**
	 * Creates a new instance of a raw element.
	 *
	 * Throws the `view-rawelement-cannot-add` {@link module:utils/ckeditorerror~CKEditorError CKEditorError} when the `children`
	 * parameter is passed to inform that the usage of `ViewRawElement` is incorrect (adding child nodes to `ViewRawElement` is forbidden).
	 *
	 * @see module:engine/view/downcastwriter~ViewDowncastWriter#createRawElement
	 * @internal
	 * @param document The document instance to which this element belongs.
	 * @param name Node name.
	 * @param attrs Collection of attributes.
	 * @param children A list of nodes to be inserted into created element.
	 */ constructor(document, name, attrs, children){
        super(document, name, attrs, children);
        // Returns `null` because filler is not needed for raw elements.
        this.getFillerOffset = getFillerOffset;
    }
    /**
	 * Overrides the {@link module:engine/view/element~ViewElement#_insertChild} method.
	 * Throws the `view-rawelement-cannot-add` {@link module:utils/ckeditorerror~CKEditorError CKEditorError} to prevent
	 * adding any child nodes to a raw element.
	 *
	 * @internal
	 */ _insertChild(index, items) {
        if (items && (items instanceof ViewNode || Array.from(items).length > 0)) {
            /**
			 * Cannot add children to a {@link module:engine/view/rawelement~ViewRawElement} instance.
			 *
			 * @error view-rawelement-cannot-add
			 */ throw new CKEditorError('view-rawelement-cannot-add', [
                this,
                items
            ]);
        }
        return 0;
    }
    /**
	 * This allows rendering the children of a {@link module:engine/view/rawelement~ViewRawElement} on the DOM level.
	 * This method is called by the {@link module:engine/view/domconverter~ViewDomConverter} with the raw DOM element
	 * passed as an argument, leaving the number and shape of the children up to the integrator.
	 *
	 * This method **must be defined** for the raw element to work:
	 *
	 * ```ts
	 * const myRawElement = downcastWriter.createRawElement( 'div' );
	 *
	 * myRawElement.render = function( domElement, domConverter ) {
	 * 	domConverter.setContentOf( domElement, '<b>This is the raw content of myRawElement.</b>' );
	 * };
	 * ```
	 *
	 * @param domElement The native DOM element representing the raw view element.
	 * @param domConverter Instance of the ViewDomConverter used to optimize the output.
	 */ render(domElement, domConverter) {}
}
// The magic of type inference using `is` method is centralized in `TypeCheckable` class.
// Proper overload would interfere with that.
ViewRawElement.prototype.is = function(type, name) {
    if (!name) {
        return type === 'rawElement' || type === 'view:rawElement' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === this.name || type === 'view:' + this.name || type === 'element' || type === 'view:element' || type === 'node' || type === 'view:node';
    } else {
        return name === this.name && (type === 'rawElement' || type === 'view:rawElement' || type === 'element' || type === 'view:element');
    }
};
/**
 * Returns `null` because block filler is not needed for raw elements.
 */ function getFillerOffset() {
    return null;
}

/**
 * Document fragment.
 *
 * To create a new document fragment instance use the
 * {@link module:engine/view/upcastwriter~ViewUpcastWriter#createDocumentFragment `ViewUpcastWriter#createDocumentFragment()`}
 * method.
 */ class ViewDocumentFragment extends /* #__PURE__ */ EmitterMixin(ViewTypeCheckable) {
    /**
	 * The document to which this document fragment belongs.
	 */ document;
    /**
	 * Array of child nodes.
	 */ _children = [];
    /**
	 * Map of custom properties.
	 * Custom properties can be added to document fragment instance.
	 */ _customProperties = new Map();
    /**
	 * Creates new DocumentFragment instance.
	 *
	 * @internal
	 * @param document The document to which this document fragment belongs.
	 * @param children A list of nodes to be inserted into the created document fragment.
	 */ constructor(document, children){
        super();
        this.document = document;
        if (children) {
            this._insertChild(0, children);
        }
    }
    /**
	 * Iterable interface.
	 *
	 * Iterates over nodes added to this document fragment.
	 */ [Symbol.iterator]() {
        return this._children[Symbol.iterator]();
    }
    /**
	 * Number of child nodes in this document fragment.
	 */ get childCount() {
        return this._children.length;
    }
    /**
	 * Is `true` if there are no nodes inside this document fragment, `false` otherwise.
	 */ get isEmpty() {
        return this.childCount === 0;
    }
    /**
	 * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.
	 */ get root() {
        return this;
    }
    /**
	 * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.
	 */ get parent() {
        return null;
    }
    /**
	 * Artificial element name. Returns `undefined`. Added for compatibility reasons.
	 */ get name() {
        return undefined;
    }
    /**
	 * Artificial element getFillerOffset. Returns `undefined`. Added for compatibility reasons.
	 */ get getFillerOffset() {
        return undefined;
    }
    /**
	 * Returns the custom property value for the given key.
	 */ getCustomProperty(key) {
        return this._customProperties.get(key);
    }
    /**
	 * Returns an iterator which iterates over this document fragment's custom properties.
	 * Iterator provides `[ key, value ]` pairs for each stored property.
	 */ *getCustomProperties() {
        yield* this._customProperties.entries();
    }
    /**
	 * {@link module:engine/view/documentfragment~ViewDocumentFragment#_insertChild Insert} a child node or a list of child nodes at the end
	 * and sets the parent of these nodes to this fragment.
	 *
	 * @internal
	 * @param items Items to be inserted.
	 * @returns Number of appended nodes.
	 */ _appendChild(items) {
        return this._insertChild(this.childCount, items);
    }
    /**
	 * Gets child at the given index.
	 *
	 * @param index Index of child.
	 * @returns Child node.
	 */ getChild(index) {
        return this._children[index];
    }
    /**
	 * Gets index of the given child node. Returns `-1` if child node is not found.
	 *
	 * @param node Child node.
	 * @returns Index of the child node.
	 */ getChildIndex(node) {
        return this._children.indexOf(node);
    }
    /**
	 * Gets child nodes iterator.
	 *
	 * @returns Child nodes iterator.
	 */ getChildren() {
        return this._children[Symbol.iterator]();
    }
    /**
	 * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
	 * this fragment.
	 *
	 * @internal
	 * @param index Position where nodes should be inserted.
	 * @param items Items to be inserted.
	 * @returns Number of inserted nodes.
	 */ _insertChild(index, items) {
        this._fireChange('children', this, {
            index
        });
        let count = 0;
        const nodes = normalize$2(this.document, items);
        for (const node of nodes){
            // If node that is being added to this element is already inside another element, first remove it from the old parent.
            if (node.parent !== null) {
                node._remove();
            }
            node.parent = this;
            this._children.splice(index, 0, node);
            index++;
            count++;
        }
        return count;
    }
    /**
	 * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.
	 *
	 * @internal
	 * @param index Number of the first node to remove.
	 * @param howMany Number of nodes to remove.
	 * @returns The array of removed nodes.
	 */ _removeChildren(index, howMany = 1) {
        this._fireChange('children', this, {
            index
        });
        for(let i = index; i < index + howMany; i++){
            this._children[i].parent = null;
        }
        return this._children.splice(index, howMany);
    }
    /**
	 * @internal
	 * @param type Type of the change.
	 * @param node Changed node.
	 * @param data Additional data.
	 * @fires module:engine/view/node~ViewNode#event:change
	 */ _fireChange(type, node, data) {
        this.fire(`change:${type}`, node, data);
    }
    /**
	 * Sets a custom property. They can be used to add special data to elements.
	 *
	 * @see module:engine/view/downcastwriter~ViewDowncastWriter#setCustomProperty
	 * @internal
	 */ _setCustomProperty(key, value) {
        this._customProperties.set(key, value);
    }
    /**
	 * Removes the custom property stored under the given key.
	 *
	 * @see module:engine/view/downcastwriter~ViewDowncastWriter#removeCustomProperty
	 * @internal
	 * @returns Returns true if property was removed.
	 */ _removeCustomProperty(key) {
        return this._customProperties.delete(key);
    }
}
// The magic of type inference using `is` method is centralized in `TypeCheckable` class.
// Proper overload would interfere with that.
ViewDocumentFragment.prototype.is = function(type) {
    return type === 'documentFragment' || type === 'view:documentFragment';
};
/**
 * Converts strings to Text and non-iterables to arrays.
 */ function normalize$2(document, nodes) {
    // Separate condition because string is iterable.
    if (typeof nodes == 'string') {
        return [
            new ViewText(document, nodes)
        ];
    }
    if (!isIterable(nodes)) {
        nodes = [
            nodes
        ];
    }
    // Array.from to enable .map() on non-arrays.
    return Array.from(nodes).map((node)=>{
        if (typeof node == 'string') {
            return new ViewText(document, node);
        }
        if (node instanceof ViewTextProxy) {
            return new ViewText(document, node.data);
        }
        return node;
    });
}

/**
 * View downcast writer.
 *
 * It provides a set of methods used to manipulate view nodes.
 *
 * Do not create an instance of this writer manually. To modify a view structure, use
 * the {@link module:engine/view/view~EditingView#change `View#change()`} block.
 *
 * The `ViewDowncastWriter` is designed to work with semantic views which are the views that were/are being downcasted from the model.
 * To work with ordinary views (e.g. parsed from a pasted content) use the
 * {@link module:engine/view/upcastwriter~ViewUpcastWriter upcast writer}.
 *
 * Read more about changing the view in the {@glink framework/architecture/editing-engine#changing-the-view Changing the view}
 * section of the {@glink framework/architecture/editing-engine Editing engine architecture} guide.
 */ class ViewDowncastWriter {
    /**
	 * The view document instance in which this writer operates.
	 */ document;
    /**
	 * Holds references to the attribute groups that share the same {@link module:engine/view/attributeelement~ViewAttributeElement#id id}.
	 * The keys are `id`s, the values are `Set`s holding {@link module:engine/view/attributeelement~ViewAttributeElement}s.
	 */ _cloneGroups = new Map();
    /**
	 * The slot factory used by the `elementToStructure` downcast helper.
	 */ _slotFactory = null;
    /**
	 * @param document The view document instance.
	 */ constructor(document){
        this.document = document;
    }
    setSelection(...args) {
        this.document.selection._setTo(...args);
    }
    /**
	 * Moves {@link module:engine/view/documentselection~ViewDocumentSelection#focus selection's focus} to the specified location.
	 *
	 * The location can be specified in the same form as
	 * {@link module:engine/view/view~EditingView#createPositionAt view.createPositionAt()}
	 * parameters.
	 *
	 * @param itemOrPosition
	 * @param offset Offset or one of the flags. Used only when the first parameter is a {@link module:engine/view/item~ViewItem view item}.
	 */ setSelectionFocus(itemOrPosition, offset) {
        this.document.selection._setFocus(itemOrPosition, offset);
    }
    /**
	 * Creates a new {@link module:engine/view/documentfragment~ViewDocumentFragment} instance.
	 *
	 * @param children A list of nodes to be inserted into the created document fragment.
	 * @returns The created document fragment.
	 */ createDocumentFragment(children) {
        return new ViewDocumentFragment(this.document, children);
    }
    /**
	 * Creates a new {@link module:engine/view/text~ViewText text node}.
	 *
	 * ```ts
	 * writer.createText( 'foo' );
	 * ```
	 *
	 * @param data The text's data.
	 * @returns The created text node.
	 */ createText(data) {
        return new ViewText(this.document, data);
    }
    /**
	 * Creates a new {@link module:engine/view/attributeelement~ViewAttributeElement}.
	 *
	 * ```ts
	 * writer.createAttributeElement( 'strong' );
	 * writer.createAttributeElement( 'a', { href: 'foo.bar' } );
	 *
	 * // Make `<a>` element contain other attributes element so the `<a>` element is not broken.
	 * writer.createAttributeElement( 'a', { href: 'foo.bar' }, { priority: 5 } );
	 *
	 * // Set `id` of a marker element so it is not joined or merged with "normal" elements.
	 * writer.createAttributeElement( 'span', { class: 'my-marker' }, { id: 'marker:my' } );
	 * ```
	 *
	 * @param name Name of the element.
	 * @param attributes Element's attributes.
	 * @param options Element's options.
	 * @param options.priority Element's {@link module:engine/view/attributeelement~ViewAttributeElement#priority priority}.
	 * @param options.id Element's {@link module:engine/view/attributeelement~ViewAttributeElement#id id}.
	 * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
	 * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
	 * @returns Created element.
	 */ createAttributeElement(name, attributes, options = {}) {
        const attributeElement = new ViewAttributeElement(this.document, name, attributes);
        if (typeof options.priority === 'number') {
            attributeElement._priority = options.priority;
        }
        if (options.id) {
            attributeElement._id = options.id;
        }
        if (options.renderUnsafeAttributes) {
            attributeElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
        }
        return attributeElement;
    }
    createContainerElement(name, attributes, childrenOrOptions = {}, options = {}) {
        let children = undefined;
        if (isContainerOptions(childrenOrOptions)) {
            options = childrenOrOptions;
        } else {
            children = childrenOrOptions;
        }
        const containerElement = new ViewContainerElement(this.document, name, attributes, children);
        if (options.renderUnsafeAttributes) {
            containerElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
        }
        return containerElement;
    }
    /**
	 * Creates a new {@link module:engine/view/editableelement~ViewEditableElement}.
	 *
	 * ```ts
	 * writer.createEditableElement( 'div' );
	 * writer.createEditableElement( 'div', { id: 'foo-1234' } );
	 * ```
	 *
	 * Note: The editable element is to be used in the editing pipeline. Usually, together with
	 * {@link module:widget/utils~toWidgetEditable `toWidgetEditable()`}.
	 *
	 * @param name Name of the element.
	 * @param attributes Elements attributes.
	 * @param options Element's options.
	 * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
	 * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
	 * @returns Created element.
	 */ createEditableElement(name, attributes, options = {}) {
        const editableElement = new ViewEditableElement(this.document, name, attributes);
        if (options.renderUnsafeAttributes) {
            editableElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
        }
        return editableElement;
    }
    /**
	 * Creates a new {@link module:engine/view/emptyelement~ViewEmptyElement}.
	 *
	 * ```ts
	 * writer.createEmptyElement( 'img' );
	 * writer.createEmptyElement( 'img', { id: 'foo-1234' } );
	 * ```
	 *
	 * @param name Name of the element.
	 * @param attributes Elements attributes.
	 * @param options Element's options.
	 * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
	 * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
	 * @returns Created element.
	 */ createEmptyElement(name, attributes, options = {}) {
        const emptyElement = new ViewEmptyElement(this.document, name, attributes);
        if (options.renderUnsafeAttributes) {
            emptyElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
        }
        return emptyElement;
    }
    /**
	 * Creates a new {@link module:engine/view/uielement~ViewUIElement}.
	 *
	 * ```ts
	 * writer.createUIElement( 'span' );
	 * writer.createUIElement( 'span', { id: 'foo-1234' } );
	 * ```
	 *
	 * A custom render function can be provided as the third parameter:
	 *
	 * ```ts
	 * writer.createUIElement( 'span', null, function( domDocument ) {
	 * 	const domElement = this.toDomElement( domDocument );
	 * 	domElement.innerHTML = '<b>this is ui element</b>';
	 *
	 * 	return domElement;
	 * } );
	 * ```
	 *
	 * Unlike {@link #createRawElement raw elements}, UI elements are by no means editor content, for instance,
	 * they are ignored by the editor selection system.
	 *
	 * You should not use UI elements as data containers. Check out {@link #createRawElement} instead.
	 *
	 * @param name The name of the element.
	 * @param attributes Element attributes.
	 * @param renderFunction A custom render function.
	 * @returns The created element.
	 */ createUIElement(name, attributes, renderFunction) {
        const uiElement = new ViewUIElement(this.document, name, attributes);
        if (renderFunction) {
            uiElement.render = renderFunction;
        }
        return uiElement;
    }
    /**
	 * Creates a new {@link module:engine/view/rawelement~ViewRawElement}.
	 *
	 * ```ts
	 * writer.createRawElement( 'span', { id: 'foo-1234' }, function( domElement ) {
	 * 	domElement.innerHTML = '<b>This is the raw content of the raw element.</b>';
	 * } );
	 * ```
	 *
	 * Raw elements work as data containers ("wrappers", "sandboxes") but their children are not managed or
	 * even recognized by the editor. This encapsulation allows integrations to maintain custom DOM structures
	 * in the editor content without, for instance, worrying about compatibility with other editor features.
	 * Raw elements are a perfect tool for integration with external frameworks and data sources.
	 *
	 * Unlike {@link #createUIElement UI elements}, raw elements act like "real" editor content (similar to
	 * {@link module:engine/view/containerelement~ViewContainerElement} or {@link module:engine/view/emptyelement~ViewEmptyElement}),
	 * and they are considered by the editor selection.
	 *
	 * You should not use raw elements to render the UI in the editor content. Check out {@link #createUIElement `#createUIElement()`}
	 * instead.
	 *
	 * @param name The name of the element.
	 * @param attributes Element attributes.
	 * @param renderFunction A custom render function.
	 * @param options Element's options.
	 * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
	 * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
	 * @returns The created element.
	 */ createRawElement(name, attributes, renderFunction, options = {}) {
        const rawElement = new ViewRawElement(this.document, name, attributes);
        if (renderFunction) {
            rawElement.render = renderFunction;
        }
        if (options.renderUnsafeAttributes) {
            rawElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
        }
        return rawElement;
    }
    setAttribute(key, value, elementOrOverwrite, element) {
        if (element !== undefined) {
            element._setAttribute(key, value, elementOrOverwrite);
        } else {
            elementOrOverwrite._setAttribute(key, value);
        }
    }
    removeAttribute(key, elementOrTokens, element) {
        if (element !== undefined) {
            element._removeAttribute(key, elementOrTokens);
        } else {
            elementOrTokens._removeAttribute(key);
        }
    }
    /**
	 * Adds specified class to the element.
	 *
	 * ```ts
	 * writer.addClass( 'foo', linkElement );
	 * writer.addClass( [ 'foo', 'bar' ], linkElement );
	 * ```
	 */ addClass(className, element) {
        element._addClass(className);
    }
    /**
	 * Removes specified class from the element.
	 *
	 * ```ts
	 * writer.removeClass( 'foo', linkElement );
	 * writer.removeClass( [ 'foo', 'bar' ], linkElement );
	 * ```
	 */ removeClass(className, element) {
        element._removeClass(className);
    }
    setStyle(property, value, element) {
        if (isPlainObject(property) && element === undefined) {
            value._setStyle(property);
        } else {
            element._setStyle(property, value);
        }
    }
    /**
	 * Removes specified style from the element.
	 *
	 * ```ts
	 * writer.removeStyle( 'color', element ); // Removes 'color' style.
	 * writer.removeStyle( [ 'color', 'border-top' ], element ); // Removes both 'color' and 'border-top' styles.
	 * ```
	 *
	 * **Note**: This method can work with normalized style names if
	 * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
	 * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.
	 */ removeStyle(property, element) {
        element._removeStyle(property);
    }
    /**
	 * Sets a custom property on element. Unlike attributes, custom properties are not rendered to the DOM,
	 * so they can be used to add special data to elements.
	 */ setCustomProperty(key, value, element) {
        element._setCustomProperty(key, value);
    }
    /**
	 * Removes a custom property stored under the given key.
	 *
	 * @returns Returns true if property was removed.
	 */ removeCustomProperty(key, element) {
        return element._removeCustomProperty(key);
    }
    /**
	 * Breaks attribute elements at the provided position or at the boundaries of a provided range. It breaks attribute elements
	 * up to their first ancestor that is a container element.
	 *
	 * In following examples `<p>` is a container, `<b>` and `<u>` are attribute elements:
	 *
	 * ```html
	 * <p>foo<b><u>bar{}</u></b></p> -> <p>foo<b><u>bar</u></b>[]</p>
	 * <p>foo<b><u>{}bar</u></b></p> -> <p>foo{}<b><u>bar</u></b></p>
	 * <p>foo<b><u>b{}ar</u></b></p> -> <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>
	 * <p><b>fo{o</b><u>ba}r</u></p> -> <p><b>fo</b><b>o</b><u>ba</u><u>r</u></b></p>
	 * ```
	 *
	 * **Note:** {@link module:engine/view/documentfragment~ViewDocumentFragment DocumentFragment} is treated like a container.
	 *
	 * **Note:** The difference between {@link module:engine/view/downcastwriter~ViewDowncastWriter#breakAttributes breakAttributes()} and
	 * {@link module:engine/view/downcastwriter~ViewDowncastWriter#breakContainer breakContainer()} is that `breakAttributes()` breaks all
	 * {@link module:engine/view/attributeelement~ViewAttributeElement attribute elements} that are ancestors of a given `position`,
	 * up to the first encountered {@link module:engine/view/containerelement~ViewContainerElement container element}.
	 * `breakContainer()` assumes that a given `position` is directly in the container element and breaks that container element.
	 *
	 * Throws the `view-writer-invalid-range-container` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
	 * when the {@link module:engine/view/range~ViewRange#start start}
	 * and {@link module:engine/view/range~ViewRange#end end} positions of a passed range are not placed inside same parent container.
	 *
	 * Throws the `view-writer-cannot-break-empty-element` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
	 * when trying to break attributes inside an {@link module:engine/view/emptyelement~ViewEmptyElement ViewEmptyElement}.
	 *
	 * Throws the `view-writer-cannot-break-ui-element` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
	 * when trying to break attributes inside a {@link module:engine/view/uielement~ViewUIElement UIElement}.
	 *
	 * @see module:engine/view/attributeelement~ViewAttributeElement
	 * @see module:engine/view/containerelement~ViewContainerElement
	 * @see module:engine/view/downcastwriter~ViewDowncastWriter#breakContainer
	 * @param positionOrRange The position where to break attribute elements.
	 * @returns The new position or range, after breaking the attribute elements.
	 */ breakAttributes(positionOrRange) {
        if (positionOrRange instanceof ViewPosition) {
            return this._breakAttributes(positionOrRange);
        } else {
            return this._breakAttributesRange(positionOrRange);
        }
    }
    /**
	 * Breaks a {@link module:engine/view/containerelement~ViewContainerElement container view element} into two, at the given position.
	 * The position has to be directly inside the container element and cannot be in the root. It does not break the conrainer view element
	 * if the position is at the beginning or at the end of its parent element.
	 *
	 * ```html
	 * <p>foo^bar</p> -> <p>foo</p><p>bar</p>
	 * <div><p>foo</p>^<p>bar</p></div> -> <div><p>foo</p></div><div><p>bar</p></div>
	 * <p>^foobar</p> -> ^<p>foobar</p>
	 * <p>foobar^</p> -> <p>foobar</p>^
	 * ```
	 *
	 * **Note:** The difference between {@link module:engine/view/downcastwriter~ViewDowncastWriter#breakAttributes breakAttributes()} and
	 * {@link module:engine/view/downcastwriter~ViewDowncastWriter#breakContainer breakContainer()} is that `breakAttributes()` breaks all
	 * {@link module:engine/view/attributeelement~ViewAttributeElement attribute elements} that are ancestors of a given `position`,
	 * up to the first encountered {@link module:engine/view/containerelement~ViewContainerElement container element}.
	 * `breakContainer()` assumes that the given `position` is directly in the container element and breaks that container element.
	 *
	 * @see module:engine/view/attributeelement~ViewAttributeElement
	 * @see module:engine/view/containerelement~ViewContainerElement
	 * @see module:engine/view/downcastwriter~ViewDowncastWriter#breakAttributes
	 * @param position The position where to break the element.
	 * @returns The position between broken elements. If an element has not been broken,
	 * the returned position is placed either before or after it.
	 */ breakContainer(position) {
        const element = position.parent;
        if (!element.is('containerElement')) {
            /**
			 * Trying to break an element which is not a container element.
			 *
			 * @error view-writer-break-non-container-element
			 */ throw new CKEditorError('view-writer-break-non-container-element', this.document);
        }
        if (!element.parent) {
            /**
			 * Trying to break root element.
			 *
			 * @error view-writer-break-root
			 */ throw new CKEditorError('view-writer-break-root', this.document);
        }
        if (position.isAtStart) {
            return ViewPosition._createBefore(element);
        } else if (!position.isAtEnd) {
            const newElement = element._clone(false);
            this.insert(ViewPosition._createAfter(element), newElement);
            const sourceRange = new ViewRange(position, ViewPosition._createAt(element, 'end'));
            const targetPosition = new ViewPosition(newElement, 0);
            this.move(sourceRange, targetPosition);
        }
        return ViewPosition._createAfter(element);
    }
    /**
	 * Merges {@link module:engine/view/attributeelement~ViewAttributeElement attribute elements}. It also merges text nodes if needed.
	 * Only {@link module:engine/view/attributeelement~ViewAttributeElement#isSimilar similar} attribute elements can be merged.
	 *
	 * In following examples `<p>` is a container and `<b>` is an attribute element:
	 *
	 * ```html
	 * <p>foo[]bar</p> -> <p>foo{}bar</p>
	 * <p><b>foo</b>[]<b>bar</b></p> -> <p><b>foo{}bar</b></p>
	 * <p><b foo="bar">a</b>[]<b foo="baz">b</b></p> -> <p><b foo="bar">a</b>[]<b foo="baz">b</b></p>
	 * ```
	 *
	 * It will also take care about empty attributes when merging:
	 *
	 * ```html
	 * <p><b>[]</b></p> -> <p>[]</p>
	 * <p><b>foo</b><i>[]</i><b>bar</b></p> -> <p><b>foo{}bar</b></p>
	 * ```
	 *
	 * **Note:** Difference between {@link module:engine/view/downcastwriter~ViewDowncastWriter#mergeAttributes mergeAttributes} and
	 * {@link module:engine/view/downcastwriter~ViewDowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two
	 * {@link module:engine/view/attributeelement~ViewAttributeElement attribute elements} or
	 * {@link module:engine/view/text~ViewText text nodes} while `mergeContainer` merges two
	 * {@link module:engine/view/containerelement~ViewContainerElement container elements}.
	 *
	 * @see module:engine/view/attributeelement~ViewAttributeElement
	 * @see module:engine/view/containerelement~ViewContainerElement
	 * @see module:engine/view/downcastwriter~ViewDowncastWriter#mergeContainers
	 * @param position Merge position.
	 * @returns Position after merge.
	 */ mergeAttributes(position) {
        const positionOffset = position.offset;
        const positionParent = position.parent;
        // When inside text node - nothing to merge.
        if (positionParent.is('$text')) {
            return position;
        }
        // When inside empty attribute - remove it.
        if (positionParent.is('attributeElement') && positionParent.childCount === 0) {
            const parent = positionParent.parent;
            const offset = positionParent.index;
            positionParent._remove();
            this._removeFromClonedElementsGroup(positionParent);
            return this.mergeAttributes(new ViewPosition(parent, offset));
        }
        const nodeBefore = positionParent.getChild(positionOffset - 1);
        const nodeAfter = positionParent.getChild(positionOffset);
        // Position should be placed between two nodes.
        if (!nodeBefore || !nodeAfter) {
            return position;
        }
        // When position is between two text nodes.
        if (nodeBefore.is('$text') && nodeAfter.is('$text')) {
            return mergeTextNodes(nodeBefore, nodeAfter);
        } else if (nodeBefore.is('attributeElement') && nodeAfter.is('attributeElement') && nodeBefore.isSimilar(nodeAfter)) {
            // Move all children nodes from node placed after selection and remove that node.
            const count = nodeBefore.childCount;
            nodeBefore._appendChild(nodeAfter.getChildren());
            nodeAfter._remove();
            this._removeFromClonedElementsGroup(nodeAfter);
            // New position is located inside the first node, before new nodes.
            // Call this method recursively to merge again if needed.
            return this.mergeAttributes(new ViewPosition(nodeBefore, count));
        }
        return position;
    }
    /**
	 * Merges two {@link module:engine/view/containerelement~ViewContainerElement container elements} that are
	 * before and after given position. Precisely, the element after the position is removed and it's contents are
	 * moved to element before the position.
	 *
	 * ```html
	 * <p>foo</p>^<p>bar</p> -> <p>foo^bar</p>
	 * <div>foo</div>^<p>bar</p> -> <div>foo^bar</div>
	 * ```
	 *
	 * **Note:** Difference between {@link module:engine/view/downcastwriter~ViewDowncastWriter#mergeAttributes mergeAttributes} and
	 * {@link module:engine/view/downcastwriter~ViewDowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two
	 * {@link module:engine/view/attributeelement~ViewAttributeElement attribute elements} or
	 * {@link module:engine/view/text~ViewText text nodes} while `mergeContainer` merges two
	 * {@link module:engine/view/containerelement~ViewContainerElement container elements}.
	 *
	 * @see module:engine/view/attributeelement~ViewAttributeElement
	 * @see module:engine/view/containerelement~ViewContainerElement
	 * @see module:engine/view/downcastwriter~ViewDowncastWriter#mergeAttributes
	 * @param position Merge position.
	 * @returns Position after merge.
	 */ mergeContainers(position) {
        const prev = position.nodeBefore;
        const next = position.nodeAfter;
        if (!prev || !next || !prev.is('containerElement') || !next.is('containerElement')) {
            /**
			 * Element before and after given position cannot be merged.
			 *
			 * @error view-writer-merge-containers-invalid-position
			 */ throw new CKEditorError('view-writer-merge-containers-invalid-position', this.document);
        }
        const lastChild = prev.getChild(prev.childCount - 1);
        const newPosition = lastChild instanceof ViewText ? ViewPosition._createAt(lastChild, 'end') : ViewPosition._createAt(prev, 'end');
        this.move(ViewRange._createIn(next), ViewPosition._createAt(prev, 'end'));
        this.remove(ViewRange._createOn(next));
        return newPosition;
    }
    /**
	 * Inserts a node or nodes at specified position. Takes care about breaking attributes before insertion
	 * and merging them afterwards.
	 *
	 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert
	 * contains instances that are not {@link module:engine/view/text~ViewText Texts},
	 * {@link module:engine/view/attributeelement~ViewAttributeElement ViewAttributeElements},
	 * {@link module:engine/view/containerelement~ViewContainerElement ViewContainerElements},
	 * {@link module:engine/view/emptyelement~ViewEmptyElement ViewEmptyElements},
	 * {@link module:engine/view/rawelement~ViewRawElement RawElements} or
	 * {@link module:engine/view/uielement~ViewUIElement UIElements}.
	 *
	 * @param position Insertion position.
	 * @param nodes Node or nodes to insert.
	 * @returns Range around inserted nodes.
	 */ insert(position, nodes) {
        nodes = isIterable(nodes) ? [
            ...nodes
        ] : [
            nodes
        ];
        // Check if nodes to insert are instances of ViewAttributeElements, ViewContainerElements, ViewEmptyElements, UIElements or Text.
        validateNodesToInsert(nodes, this.document);
        // Group nodes in batches of nodes that require or do not require breaking an ViewAttributeElements.
        const nodeGroups = nodes.reduce((groups, node)=>{
            const lastGroup = groups[groups.length - 1];
            // Break attributes on nodes that do exist in the model tree so they can have attributes, other elements
            // can't have an attribute in model and won't get wrapped with an ViewAttributeElement while down-casted.
            const breakAttributes = !node.is('uiElement');
            if (!lastGroup || lastGroup.breakAttributes != breakAttributes) {
                groups.push({
                    breakAttributes,
                    nodes: [
                        node
                    ]
                });
            } else {
                lastGroup.nodes.push(node);
            }
            return groups;
        }, []);
        // Insert nodes in batches.
        let start = null;
        let end = position;
        for (const { nodes, breakAttributes } of nodeGroups){
            const range = this._insertNodes(end, nodes, breakAttributes);
            if (!start) {
                start = range.start;
            }
            end = range.end;
        }
        // When no nodes were inserted - return collapsed range.
        if (!start) {
            return new ViewRange(position);
        }
        return new ViewRange(start, end);
    }
    /**
	 * Removes provided range from the container.
	 *
	 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
	 * {@link module:engine/view/range~ViewRange#start start} and {@link module:engine/view/range~ViewRange#end end}
	 * positions are not placed inside same parent container.
	 *
	 * @param rangeOrItem Range to remove from container
	 * or an {@link module:engine/view/item~ViewItem item} to remove. If range is provided, after removing, it will be updated
	 * to a collapsed range showing the new position.
	 * @returns Document fragment containing removed nodes.
	 */ remove(rangeOrItem) {
        const range = rangeOrItem instanceof ViewRange ? rangeOrItem : ViewRange._createOn(rangeOrItem);
        validateRangeContainer(range, this.document);
        // If range is collapsed - nothing to remove.
        if (range.isCollapsed) {
            return new ViewDocumentFragment(this.document);
        }
        // Break attributes at range start and end.
        const { start: breakStart, end: breakEnd } = this._breakAttributesRange(range, true);
        const parentContainer = breakStart.parent;
        const count = breakEnd.offset - breakStart.offset;
        // Remove nodes in range.
        const removed = parentContainer._removeChildren(breakStart.offset, count);
        for (const node of removed){
            this._removeFromClonedElementsGroup(node);
        }
        // Merge after removing.
        const mergePosition = this.mergeAttributes(breakStart);
        range.start = mergePosition;
        range.end = mergePosition.clone();
        // Return removed nodes.
        return new ViewDocumentFragment(this.document, removed);
    }
    /**
	 * Removes matching elements from given range.
	 *
	 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
	 * {@link module:engine/view/range~ViewRange#start start} and {@link module:engine/view/range~ViewRange#end end}
	 * positions are not placed inside same parent container.
	 *
	 * @param range Range to clear.
	 * @param element Element to remove.
	 */ clear(range, element) {
        validateRangeContainer(range, this.document);
        // Create walker on given range.
        // We walk backward because when we remove element during walk it modifies range end position.
        const walker = range.getWalker({
            direction: 'backward',
            ignoreElementEnd: true
        });
        // Let's walk.
        for (const current of walker){
            const item = current.item;
            let rangeToRemove;
            // When current item matches to the given element.
            if (item.is('element') && element.isSimilar(item)) {
                // Create range on this element.
                rangeToRemove = ViewRange._createOn(item);
            // When range starts inside Text or TextProxy element.
            } else if (!current.nextPosition.isAfter(range.start) && item.is('$textProxy')) {
                // We need to check if parent of this text matches to given element.
                const parentElement = item.getAncestors().find((ancestor)=>{
                    return ancestor.is('element') && element.isSimilar(ancestor);
                });
                // If it is then create range inside this element.
                if (parentElement) {
                    rangeToRemove = ViewRange._createIn(parentElement);
                }
            }
            // If we have found element to remove.
            if (rangeToRemove) {
                // We need to check if element range stick out of the given range and truncate if it is.
                if (rangeToRemove.end.isAfter(range.end)) {
                    rangeToRemove.end = range.end;
                }
                if (rangeToRemove.start.isBefore(range.start)) {
                    rangeToRemove.start = range.start;
                }
                // At the end we remove range with found element.
                this.remove(rangeToRemove);
            }
        }
    }
    /**
	 * Moves nodes from provided range to target position.
	 *
	 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
	 * {@link module:engine/view/range~ViewRange#start start} and {@link module:engine/view/range~ViewRange#end end}
	 * positions are not placed inside same parent container.
	 *
	 * @param sourceRange Range containing nodes to move.
	 * @param targetPosition Position to insert.
	 * @returns Range in target container. Inserted nodes are placed between
	 * {@link module:engine/view/range~ViewRange#start start} and {@link module:engine/view/range~ViewRange#end end} positions.
	 */ move(sourceRange, targetPosition) {
        let nodes;
        if (targetPosition.isAfter(sourceRange.end)) {
            targetPosition = this._breakAttributes(targetPosition, true);
            const parent = targetPosition.parent;
            const countBefore = parent.childCount;
            sourceRange = this._breakAttributesRange(sourceRange, true);
            nodes = this.remove(sourceRange);
            targetPosition.offset += parent.childCount - countBefore;
        } else {
            nodes = this.remove(sourceRange);
        }
        return this.insert(targetPosition, nodes);
    }
    /**
	 * Wraps elements within range with provided {@link module:engine/view/attributeelement~ViewAttributeElement ViewAttributeElement}.
	 * If a collapsed range is provided, it will be wrapped only if it is equal to view selection.
	 *
	 * If a collapsed range was passed and is same as selection, the selection
	 * will be moved to the inside of the wrapped attribute element.
	 *
	 * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-invalid-range-container`
	 * when {@link module:engine/view/range~ViewRange#start}
	 * and {@link module:engine/view/range~ViewRange#end} positions are not placed inside same parent container.
	 *
	 * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
	 * an instance of {@link module:engine/view/attributeelement~ViewAttributeElement ViewAttributeElement}.
	 *
	 * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-nonselection-collapsed-range` when passed range
	 * is collapsed and different than view selection.
	 *
	 * @param range Range to wrap.
	 * @param attribute Attribute element to use as wrapper.
	 * @returns range Range after wrapping, spanning over wrapping attribute element.
	 */ wrap(range, attribute) {
        if (!(attribute instanceof ViewAttributeElement)) {
            throw new CKEditorError('view-writer-wrap-invalid-attribute', this.document);
        }
        validateRangeContainer(range, this.document);
        if (!range.isCollapsed) {
            // Non-collapsed range. Wrap it with the attribute element.
            return this._wrapRange(range, attribute);
        } else {
            // Collapsed range. Wrap position.
            let position = range.start;
            if (position.parent.is('element') && !_hasNonUiChildren(position.parent)) {
                position = position.getLastMatchingPosition((value)=>value.item.is('uiElement'));
            }
            position = this._wrapPosition(position, attribute);
            const viewSelection = this.document.selection;
            // If wrapping position is equal to view selection, move view selection inside wrapping attribute element.
            if (viewSelection.isCollapsed && viewSelection.getFirstPosition().isEqual(range.start)) {
                this.setSelection(position);
            }
            return new ViewRange(position);
        }
    }
    /**
	 * Unwraps nodes within provided range from attribute element.
	 *
	 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
	 * {@link module:engine/view/range~ViewRange#start start} and {@link module:engine/view/range~ViewRange#end end}
	 * positions are not placed inside same parent container.
	 */ unwrap(range, attribute) {
        if (!(attribute instanceof ViewAttributeElement)) {
            /**
			 * The `attribute` passed to {@link module:engine/view/downcastwriter~ViewDowncastWriter#unwrap `ViewDowncastWriter#unwrap()`}
			 * must be an instance of {@link module:engine/view/attributeelement~ViewAttributeElement `AttributeElement`}.
			 *
			 * @error view-writer-unwrap-invalid-attribute
			 */ throw new CKEditorError('view-writer-unwrap-invalid-attribute', this.document);
        }
        validateRangeContainer(range, this.document);
        // If range is collapsed - nothing to unwrap.
        if (range.isCollapsed) {
            return range;
        }
        // Break attributes at range start and end.
        const { start: breakStart, end: breakEnd } = this._breakAttributesRange(range, true);
        const parentContainer = breakStart.parent;
        // Unwrap children located between break points.
        const newRange = this._unwrapChildren(parentContainer, breakStart.offset, breakEnd.offset, attribute);
        // Merge attributes at the both ends and return a new range.
        const start = this.mergeAttributes(newRange.start);
        // If start position was merged - move end position back.
        if (!start.isEqual(newRange.start)) {
            newRange.end.offset--;
        }
        const end = this.mergeAttributes(newRange.end);
        return new ViewRange(start, end);
    }
    /**
	 * Renames element by creating a copy of renamed element but with changed name and then moving contents of the
	 * old element to the new one. Keep in mind that this will invalidate all {@link module:engine/view/position~ViewPosition positions}
	 * which has renamed element as {@link module:engine/view/position~ViewPosition#parent a parent}.
	 *
	 * New element has to be created because `Element#tagName` property in DOM is readonly.
	 *
	 * Since this function creates a new element and removes the given one, the new element is returned to keep reference.
	 *
	 * @param newName New name for element.
	 * @param viewElement Element to be renamed.
	 * @returns Element created due to rename.
	 */ rename(newName, viewElement) {
        const newElement = new ViewContainerElement(this.document, newName, viewElement.getAttributes());
        this.insert(ViewPosition._createAfter(viewElement), newElement);
        this.move(ViewRange._createIn(viewElement), ViewPosition._createAt(newElement, 0));
        this.remove(ViewRange._createOn(viewElement));
        return newElement;
    }
    /**
	 * Cleans up memory by removing obsolete cloned elements group from the writer.
	 *
	 * Should be used whenever all {@link module:engine/view/attributeelement~ViewAttributeElement attribute elements}
	 * with the same {@link module:engine/view/attributeelement~ViewAttributeElement#id id} are going to be removed from the view and
	 * the group will no longer be needed.
	 *
	 * Cloned elements group are not removed automatically in case if the group is still needed after all its elements
	 * were removed from the view.
	 *
	 * Keep in mind that group names are equal to the `id` property of the attribute element.
	 *
	 * @param groupName Name of the group to clear.
	 */ clearClonedElementsGroup(groupName) {
        this._cloneGroups.delete(groupName);
    }
    /**
	 * Creates position at the given location. The location can be specified as:
	 *
	 * * a {@link module:engine/view/position~ViewPosition position},
	 * * parent element and offset (offset defaults to `0`),
	 * * parent element and `'end'` (sets position at the end of that element),
	 * * {@link module:engine/view/item~ViewItem view item} and `'before'` or `'after'` (sets position before or after given view item).
	 *
	 * This method is a shortcut to other constructors such as:
	 *
	 * * {@link #createPositionBefore},
	 * * {@link #createPositionAfter},
	 *
	 * @param offset Offset or one of the flags. Used only when the first parameter is a {@link module:engine/view/item~ViewItem view item}.
	 */ createPositionAt(itemOrPosition, offset) {
        return ViewPosition._createAt(itemOrPosition, offset);
    }
    /**
	 * Creates a new position after given view item.
	 *
	 * @param item View item after which the position should be located.
	 */ createPositionAfter(item) {
        return ViewPosition._createAfter(item);
    }
    /**
	 * Creates a new position before given view item.
	 *
	 * @param item View item before which the position should be located.
	 */ createPositionBefore(item) {
        return ViewPosition._createBefore(item);
    }
    /**
	 * Creates a range spanning from `start` position to `end` position.
	 *
	 * **Note:** This factory method creates its own {@link module:engine/view/position~ViewPosition} instances basing on passed values.
	 *
	 * @param start Start position.
	 * @param end End position. If not set, range will be collapsed at `start` position.
	 */ createRange(start, end) {
        return new ViewRange(start, end);
    }
    /**
	 * Creates a range that starts before given {@link module:engine/view/item~ViewItem view item} and ends after it.
	 */ createRangeOn(item) {
        return ViewRange._createOn(item);
    }
    /**
	 * Creates a range inside an {@link module:engine/view/element~ViewElement element} which starts before the first child of
	 * that element and ends after the last child of that element.
	 *
	 * @param element Element which is a parent for the range.
	 */ createRangeIn(element) {
        return ViewRange._createIn(element);
    }
    createSelection(...args) {
        return new ViewSelection(...args);
    }
    /**
	 * Creates placeholders for child elements of the {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure
	 * `elementToStructure()`} conversion helper.
	 *
	 * ```ts
	 * const viewSlot = conversionApi.writer.createSlot();
	 * const viewPosition = conversionApi.writer.createPositionAt( viewElement, 0 );
	 *
	 * conversionApi.writer.insert( viewPosition, viewSlot );
	 * ```
	 *
	 * It could be filtered down to a specific subset of children (only `<foo>` model elements in this case):
	 *
	 * ```ts
	 * const viewSlot = conversionApi.writer.createSlot( node => node.is( 'element', 'foo' ) );
	 * const viewPosition = conversionApi.writer.createPositionAt( viewElement, 0 );
	 *
	 * conversionApi.writer.insert( viewPosition, viewSlot );
	 * ```
	 *
	 * While providing a filtered slot, make sure to provide slots for all child nodes. A single node cannot be downcasted into
	 * multiple slots.
	 *
	 * **Note**: You should not change the order of nodes. View elements should be in the same order as model nodes.
	 *
	 * @param modeOrFilter The filter for child nodes.
	 * @returns The slot element to be placed in to the view structure while processing
	 * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure `elementToStructure()`}.
	 */ createSlot(modeOrFilter = 'children') {
        if (!this._slotFactory) {
            /**
			 * The `createSlot()` method is only allowed inside the `elementToStructure` downcast helper callback.
			 *
			 * @error view-writer-invalid-create-slot-context
			 */ throw new CKEditorError('view-writer-invalid-create-slot-context', this.document);
        }
        return this._slotFactory(this, modeOrFilter);
    }
    /**
	 * Registers a slot factory.
	 *
	 * @internal
	 * @param slotFactory The slot factory.
	 */ _registerSlotFactory(slotFactory) {
        this._slotFactory = slotFactory;
    }
    /**
	 * Clears the registered slot factory.
	 *
	 * @internal
	 */ _clearSlotFactory() {
        this._slotFactory = null;
    }
    /**
	 * Inserts a node or nodes at the specified position. Takes care of breaking attributes before insertion
	 * and merging them afterwards if requested by the breakAttributes param.
	 *
	 * @param position Insertion position.
	 * @param nodes Node or nodes to insert.
	 * @param breakAttributes Whether attributes should be broken.
	 * @returns Range around inserted nodes.
	 */ _insertNodes(position, nodes, breakAttributes) {
        let parentElement;
        // Break attributes on nodes that do exist in the model tree so they can have attributes, other elements
        // can't have an attribute in model and won't get wrapped with an ViewAttributeElement while down-casted.
        if (breakAttributes) {
            parentElement = getParentContainer(position);
        } else {
            parentElement = position.parent.is('$text') ? position.parent.parent : position.parent;
        }
        if (!parentElement) {
            /**
			 * Position's parent container cannot be found.
			 *
			 * @error view-writer-invalid-position-container
			 */ throw new CKEditorError('view-writer-invalid-position-container', this.document);
        }
        let insertionPosition;
        if (breakAttributes) {
            insertionPosition = this._breakAttributes(position, true);
        } else {
            insertionPosition = position.parent.is('$text') ? breakTextNode(position) : position;
        }
        const length = parentElement._insertChild(insertionPosition.offset, nodes);
        for (const node of nodes){
            this._addToClonedElementsGroup(node);
        }
        const endPosition = insertionPosition.getShiftedBy(length);
        const start = this.mergeAttributes(insertionPosition);
        // If start position was merged - move end position.
        if (!start.isEqual(insertionPosition)) {
            endPosition.offset--;
        }
        const end = this.mergeAttributes(endPosition);
        return new ViewRange(start, end);
    }
    /**
	 * Wraps children with provided `wrapElement`. Only children contained in `parent` element between
	 * `startOffset` and `endOffset` will be wrapped.
	 */ _wrapChildren(parent, startOffset, endOffset, wrapElement) {
        let i = startOffset;
        const wrapPositions = [];
        while(i < endOffset){
            const child = parent.getChild(i);
            const isText = child.is('$text');
            const isAttribute = child.is('attributeElement');
            //
            // (In all examples, assume that `wrapElement` is `<span class="foo">` element.)
            //
            // Check if `wrapElement` can be joined with the wrapped element. One of requirements is having same name.
            // If possible, join elements.
            //
            // <p><span class="bar">abc</span></p>  -->  <p><span class="foo bar">abc</span></p>
            //
            if (isAttribute && child._canMergeAttributesFrom(wrapElement)) {
                child._mergeAttributesFrom(wrapElement);
                wrapPositions.push(new ViewPosition(parent, i));
            } else if (isText || !isAttribute || shouldABeOutsideB(wrapElement, child)) {
                // Clone attribute.
                const newAttribute = wrapElement._clone();
                // Wrap current node with new attribute.
                child._remove();
                newAttribute._appendChild(child);
                parent._insertChild(i, newAttribute);
                this._addToClonedElementsGroup(newAttribute);
                wrapPositions.push(new ViewPosition(parent, i));
            } else /* if ( isAttribute ) */ {
                this._wrapChildren(child, 0, child.childCount, wrapElement);
            }
            i++;
        }
        // Merge at each wrap.
        let offsetChange = 0;
        for (const position of wrapPositions){
            position.offset -= offsetChange;
            // Do not merge with elements outside selected children.
            if (position.offset == startOffset) {
                continue;
            }
            const newPosition = this.mergeAttributes(position);
            // If nodes were merged - other merge offsets will change.
            if (!newPosition.isEqual(position)) {
                offsetChange++;
                endOffset--;
            }
        }
        return ViewRange._createFromParentsAndOffsets(parent, startOffset, parent, endOffset);
    }
    /**
	 * Unwraps children from provided `unwrapElement`. Only children contained in `parent` element between
	 * `startOffset` and `endOffset` will be unwrapped.
	 */ _unwrapChildren(parent, startOffset, endOffset, unwrapElement) {
        let i = startOffset;
        const unwrapPositions = [];
        // Iterate over each element between provided offsets inside parent.
        // We don't use tree walker or range iterator because we will be removing and merging potentially multiple nodes,
        // so it could get messy. It is safer to it manually in this case.
        while(i < endOffset){
            const child = parent.getChild(i);
            // Skip all text nodes. There should be no container element's here either.
            if (!child.is('attributeElement')) {
                i++;
                continue;
            }
            //
            // (In all examples, assume that `unwrapElement` is `<span class="foo">` element.)
            //
            // If the child is similar to the given attribute element, unwrap it - it will be completely removed.
            //
            // <p><span class="foo">abc</span>xyz</p>  -->  <p>abcxyz</p>
            //
            if (child.isSimilar(unwrapElement)) {
                const unwrapped = child.getChildren();
                const count = child.childCount;
                // Replace wrapper element with its children
                child._remove();
                parent._insertChild(i, unwrapped);
                this._removeFromClonedElementsGroup(child);
                // Save start and end position of moved items.
                unwrapPositions.push(new ViewPosition(parent, i), new ViewPosition(parent, i + count));
                // Skip elements that were unwrapped. Assuming there won't be another element to unwrap in child elements.
                i += count;
                endOffset += count - 1;
                continue;
            }
            //
            // If the child is not similar but is an attribute element, try partial unwrapping - remove the same attributes/styles/classes.
            // Partial unwrapping will happen only if the elements have the same name.
            //
            // <p><span class="foo bar">abc</span>xyz</p>  -->  <p><span class="bar">abc</span>xyz</p>
            // <p><i class="foo">abc</i>xyz</p>            -->  <p><i class="foo">abc</i>xyz</p>
            //
            if (child._canSubtractAttributesOf(unwrapElement)) {
                child._subtractAttributesOf(unwrapElement);
                unwrapPositions.push(new ViewPosition(parent, i), new ViewPosition(parent, i + 1));
                i++;
                continue;
            }
            //
            // If other nested attribute is found, look through it's children for elements to unwrap.
            //
            // <p><i><span class="foo">abc</span></i><p>  -->  <p><i>abc</i><p>
            //
            this._unwrapChildren(child, 0, child.childCount, unwrapElement);
            i++;
        }
        // Merge at each unwrap.
        let offsetChange = 0;
        for (const position of unwrapPositions){
            position.offset -= offsetChange;
            // Do not merge with elements outside selected children.
            if (position.offset == startOffset || position.offset == endOffset) {
                continue;
            }
            const newPosition = this.mergeAttributes(position);
            // If nodes were merged - other merge offsets will change.
            if (!newPosition.isEqual(position)) {
                offsetChange++;
                endOffset--;
            }
        }
        return ViewRange._createFromParentsAndOffsets(parent, startOffset, parent, endOffset);
    }
    /**
	 * Helper function for `view.writer.wrap`. Wraps range with provided attribute element.
	 * This method will also merge newly added attribute element with its siblings whenever possible.
	 *
	 * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
	 * an instance of {@link module:engine/view/attributeelement~ViewAttributeElement ViewAttributeElement}.
	 *
	 * @returns New range after wrapping, spanning over wrapping attribute element.
	 */ _wrapRange(range, attribute) {
        // Break attributes at range start and end.
        const { start: breakStart, end: breakEnd } = this._breakAttributesRange(range, true);
        const parentContainer = breakStart.parent;
        // Wrap all children with attribute.
        const newRange = this._wrapChildren(parentContainer, breakStart.offset, breakEnd.offset, attribute);
        // Merge attributes at the both ends and return a new range.
        const start = this.mergeAttributes(newRange.start);
        // If start position was merged - move end position back.
        if (!start.isEqual(newRange.start)) {
            newRange.end.offset--;
        }
        const end = this.mergeAttributes(newRange.end);
        return new ViewRange(start, end);
    }
    /**
	 * Helper function for {@link #wrap}. Wraps position with provided attribute element.
	 * This method will also merge newly added attribute element with its siblings whenever possible.
	 *
	 * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
	 * an instance of {@link module:engine/view/attributeelement~ViewAttributeElement ViewAttributeElement}.
	 *
	 * @returns New position after wrapping.
	 */ _wrapPosition(position, attribute) {
        // Return same position when trying to wrap with attribute similar to position parent.
        if (attribute.isSimilar(position.parent)) {
            return movePositionToTextNode(position.clone());
        }
        // When position is inside text node - break it and place new position between two text nodes.
        if (position.parent.is('$text')) {
            position = breakTextNode(position);
        }
        // Create fake element that will represent position, and will not be merged with other attributes.
        const fakeElement = this.createAttributeElement('_wrapPosition-fake-element');
        fakeElement._priority = Number.POSITIVE_INFINITY;
        fakeElement.isSimilar = ()=>false;
        // Insert fake element in position location.
        position.parent._insertChild(position.offset, fakeElement);
        // Range around inserted fake attribute element.
        const wrapRange = new ViewRange(position, position.getShiftedBy(1));
        // Wrap fake element with attribute (it will also merge if possible).
        this.wrap(wrapRange, attribute);
        // Remove fake element and place new position there.
        const newPosition = new ViewPosition(fakeElement.parent, fakeElement.index);
        fakeElement._remove();
        // If position is placed between text nodes - merge them and return position inside.
        const nodeBefore = newPosition.nodeBefore;
        const nodeAfter = newPosition.nodeAfter;
        if (nodeBefore && nodeBefore.is('view:$text') && nodeAfter && nodeAfter.is('view:$text')) {
            return mergeTextNodes(nodeBefore, nodeAfter);
        }
        // If position is next to text node - move position inside.
        return movePositionToTextNode(newPosition);
    }
    /**
	 * Helper function used by other `ViewDowncastWriter` methods. Breaks attribute elements at the boundaries of given range.
	 *
	 * @param range Range which `start` and `end` positions will be used to break attributes.
	 * @param forceSplitText If set to `true`, will break text nodes even if they are directly in container element.
	 * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.
	 * @returns New range with located at break positions.
	 */ _breakAttributesRange(range, forceSplitText = false) {
        const rangeStart = range.start;
        const rangeEnd = range.end;
        validateRangeContainer(range, this.document);
        // Break at the collapsed position. Return new collapsed range.
        if (range.isCollapsed) {
            const position = this._breakAttributes(range.start, forceSplitText);
            return new ViewRange(position, position);
        }
        const breakEnd = this._breakAttributes(rangeEnd, forceSplitText);
        const count = breakEnd.parent.childCount;
        const breakStart = this._breakAttributes(rangeStart, forceSplitText);
        // Calculate new break end offset.
        breakEnd.offset += breakEnd.parent.childCount - count;
        return new ViewRange(breakStart, breakEnd);
    }
    /**
	 * Helper function used by other `ViewDowncastWriter` methods. Breaks attribute elements at given position.
	 *
	 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-empty-element` when break position
	 * is placed inside {@link module:engine/view/emptyelement~ViewEmptyElement ViewEmptyElement}.
	 *
	 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-ui-element` when break position
	 * is placed inside {@link module:engine/view/uielement~ViewUIElement UIElement}.
	 *
	 * @param position Position where to break attributes.
	 * @param forceSplitText If set to `true`, will break text nodes even if they are directly in container element.
	 * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.
	 * @returns New position after breaking the attributes.
	 */ _breakAttributes(position, forceSplitText = false) {
        const positionOffset = position.offset;
        const positionParent = position.parent;
        // If position is placed inside ViewEmptyElement - throw an exception as we cannot break inside.
        if (position.parent.is('emptyElement')) {
            /**
			 * Cannot break an `EmptyElement` instance.
			 *
			 * This error is thrown if
			 * {@link module:engine/view/downcastwriter~ViewDowncastWriter#breakAttributes `ViewDowncastWriter#breakAttributes()`}
			 * was executed in an incorrect position.
			 *
			 * @error view-writer-cannot-break-empty-element
			 */ throw new CKEditorError('view-writer-cannot-break-empty-element', this.document);
        }
        // If position is placed inside UIElement - throw an exception as we cannot break inside.
        if (position.parent.is('uiElement')) {
            /**
			 * Cannot break a `UIElement` instance.
			 *
			 * This error is thrown if
			 * {@link module:engine/view/downcastwriter~ViewDowncastWriter#breakAttributes `ViewDowncastWriter#breakAttributes()`}
			 * was executed in an incorrect position.
			 *
			 * @error view-writer-cannot-break-ui-element
			 */ throw new CKEditorError('view-writer-cannot-break-ui-element', this.document);
        }
        // If position is placed inside RawElement - throw an exception as we cannot break inside.
        if (position.parent.is('rawElement')) {
            /**
			 * Cannot break a `RawElement` instance.
			 *
			 * This error is thrown if
			 * {@link module:engine/view/downcastwriter~ViewDowncastWriter#breakAttributes `ViewDowncastWriter#breakAttributes()`}
			 * was executed in an incorrect position.
			 *
			 * @error view-writer-cannot-break-raw-element
			 */ throw new CKEditorError('view-writer-cannot-break-raw-element', this.document);
        }
        // There are no attributes to break and text nodes breaking is not forced.
        if (!forceSplitText && positionParent.is('$text') && isContainerOrFragment(positionParent.parent)) {
            return position.clone();
        }
        // Position's parent is container, so no attributes to break.
        if (isContainerOrFragment(positionParent)) {
            return position.clone();
        }
        // Break text and start again in new position.
        if (positionParent.is('$text')) {
            return this._breakAttributes(breakTextNode(position), forceSplitText);
        }
        const length = positionParent.childCount;
        // <p>foo<b><u>bar{}</u></b></p>
        // <p>foo<b><u>bar</u>[]</b></p>
        // <p>foo<b><u>bar</u></b>[]</p>
        if (positionOffset == length) {
            const newPosition = new ViewPosition(positionParent.parent, positionParent.index + 1);
            return this._breakAttributes(newPosition, forceSplitText);
        } else {
            // <p>foo<b><u>{}bar</u></b></p>
            // <p>foo<b>[]<u>bar</u></b></p>
            // <p>foo{}<b><u>bar</u></b></p>
            if (positionOffset === 0) {
                const newPosition = new ViewPosition(positionParent.parent, positionParent.index);
                return this._breakAttributes(newPosition, forceSplitText);
            } else {
                const offsetAfter = positionParent.index + 1;
                // Break element.
                const clonedNode = positionParent._clone();
                // Insert cloned node to position's parent node.
                positionParent.parent._insertChild(offsetAfter, clonedNode);
                this._addToClonedElementsGroup(clonedNode);
                // Get nodes to move.
                const count = positionParent.childCount - positionOffset;
                const nodesToMove = positionParent._removeChildren(positionOffset, count);
                // Move nodes to cloned node.
                clonedNode._appendChild(nodesToMove);
                // Create new position to work on.
                const newPosition = new ViewPosition(positionParent.parent, offsetAfter);
                return this._breakAttributes(newPosition, forceSplitText);
            }
        }
    }
    /**
	 * Stores the information that an {@link module:engine/view/attributeelement~ViewAttributeElement attribute element} was
	 * added to the tree. Saves the reference to the group in the given element and updates the group, so other elements
	 * from the group now keep a reference to the given attribute element.
	 *
	 * The clones group can be obtained using {@link module:engine/view/attributeelement~ViewAttributeElement#getElementsWithSameId}.
	 *
	 * Does nothing if added element has no {@link module:engine/view/attributeelement~ViewAttributeElement#id id}.
	 *
	 * @param element Attribute element to save.
	 */ _addToClonedElementsGroup(element) {
        // Add only if the element is in document tree.
        if (!element.root.is('rootElement')) {
            return;
        }
        // Traverse the element's children recursively to find other attribute elements that also might got inserted.
        // The loop is at the beginning so we can make fast returns later in the code.
        if (element.is('element')) {
            for (const child of element.getChildren()){
                this._addToClonedElementsGroup(child);
            }
        }
        const id = element.id;
        if (!id) {
            return;
        }
        let group = this._cloneGroups.get(id);
        if (!group) {
            group = new Set();
            this._cloneGroups.set(id, group);
        }
        group.add(element);
        element._clonesGroup = group;
    }
    /**
	 * Removes all the information about the given {@link module:engine/view/attributeelement~ViewAttributeElement attribute element}
	 * from its clones group.
	 *
	 * Keep in mind, that the element will still keep a reference to the group (but the group will not keep a reference to it).
	 * This allows to reference the whole group even if the element was already removed from the tree.
	 *
	 * Does nothing if the element has no {@link module:engine/view/attributeelement~ViewAttributeElement#id id}.
	 *
	 * @param element Attribute element to remove.
	 */ _removeFromClonedElementsGroup(element) {
        // Traverse the element's children recursively to find other attribute elements that also got removed.
        // The loop is at the beginning so we can make fast returns later in the code.
        if (element.is('element')) {
            for (const child of element.getChildren()){
                this._removeFromClonedElementsGroup(child);
            }
        }
        const id = element.id;
        if (!id) {
            return;
        }
        const group = this._cloneGroups.get(id);
        if (!group) {
            return;
        }
        group.delete(element);
    // Not removing group from element on purpose!
    // If other parts of code have reference to this element, they will be able to get references to other elements from the group.
    }
}
// Helper function for `view.writer.wrap`. Checks if given element has any children that are not ui elements.
function _hasNonUiChildren(parent) {
    return Array.from(parent.getChildren()).some((child)=>!child.is('uiElement'));
}
/**
 * The `attribute` passed to {@link module:engine/view/downcastwriter~ViewDowncastWriter#wrap `ViewDowncastWriter#wrap()`}
 * must be an instance of {@link module:engine/view/attributeelement~ViewAttributeElement `AttributeElement`}.
 *
 * @error view-writer-wrap-invalid-attribute
 */ /**
 * Returns first parent container of specified {@link module:engine/view/position~ViewPosition Position}.
 * Position's parent node is checked as first, then next parents are checked.
 * Note that {@link module:engine/view/documentfragment~ViewDocumentFragment DocumentFragment} is treated like a container.
 *
 * @param position Position used as a start point to locate parent container.
 * @returns Parent container element or `undefined` if container is not found.
 */ function getParentContainer(position) {
    let parent = position.parent;
    while(!isContainerOrFragment(parent)){
        if (!parent) {
            return undefined;
        }
        parent = parent.parent;
    }
    return parent;
}
/**
 * Checks if first {@link module:engine/view/attributeelement~ViewAttributeElement ViewAttributeElement} provided to the function
 * can be wrapped outside second element. It is done by comparing elements'
 * {@link module:engine/view/attributeelement~ViewAttributeElement#priority priorities}, if both have same priority
 * {@link module:engine/view/element~ViewElement#getIdentity identities} are compared.
 */ function shouldABeOutsideB(a, b) {
    if (a.priority < b.priority) {
        return true;
    } else if (a.priority > b.priority) {
        return false;
    }
    // When priorities are equal and names are different - use identities.
    return a.getIdentity() < b.getIdentity();
}
/**
 * Returns new position that is moved to near text node. Returns same position if there is no text node before of after
 * specified position.
 *
 * ```html
 * <p>foo[]</p>  ->  <p>foo{}</p>
 * <p>[]foo</p>  ->  <p>{}foo</p>
 * ```
 *
 * @returns Position located inside text node or same position if there is no text nodes
 * before or after position location.
 */ function movePositionToTextNode(position) {
    const nodeBefore = position.nodeBefore;
    if (nodeBefore && nodeBefore.is('$text')) {
        return new ViewPosition(nodeBefore, nodeBefore.data.length);
    }
    const nodeAfter = position.nodeAfter;
    if (nodeAfter && nodeAfter.is('$text')) {
        return new ViewPosition(nodeAfter, 0);
    }
    return position;
}
/**
 * Breaks text node into two text nodes when possible.
 *
 * ```html
 * <p>foo{}bar</p> -> <p>foo[]bar</p>
 * <p>{}foobar</p> -> <p>[]foobar</p>
 * <p>foobar{}</p> -> <p>foobar[]</p>
 * ```
 *
 * @param position Position that need to be placed inside text node.
 * @returns New position after breaking text node.
 */ function breakTextNode(position) {
    if (position.offset == position.parent.data.length) {
        return new ViewPosition(position.parent.parent, position.parent.index + 1);
    }
    if (position.offset === 0) {
        return new ViewPosition(position.parent.parent, position.parent.index);
    }
    // Get part of the text that need to be moved.
    const textToMove = position.parent.data.slice(position.offset);
    // Leave rest of the text in position's parent.
    position.parent._data = position.parent.data.slice(0, position.offset);
    // Insert new text node after position's parent text node.
    position.parent.parent._insertChild(position.parent.index + 1, new ViewText(position.root.document, textToMove));
    // Return new position between two newly created text nodes.
    return new ViewPosition(position.parent.parent, position.parent.index + 1);
}
/**
 * Merges two text nodes into first node. Removes second node and returns merge position.
 *
 * @param t1 First text node to merge. Data from second text node will be moved at the end of this text node.
 * @param t2 Second text node to merge. This node will be removed after merging.
 * @returns Position after merging text nodes.
 */ function mergeTextNodes(t1, t2) {
    // Merge text data into first text node and remove second one.
    const nodeBeforeLength = t1.data.length;
    t1._data += t2.data;
    t2._remove();
    return new ViewPosition(t1, nodeBeforeLength);
}
const validNodesToInsert = [
    ViewText,
    ViewAttributeElement,
    ViewContainerElement,
    ViewEmptyElement,
    ViewRawElement,
    ViewUIElement
];
/**
 * Checks if provided nodes are valid to insert.
 *
 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert
 * contains instances that are not supported ones (see error description for valid ones.
 */ function validateNodesToInsert(nodes, errorContext) {
    for (const node of nodes){
        if (!validNodesToInsert.some((validNode)=>node instanceof validNode)) {
            /**
			 * One of the nodes to be inserted is of an invalid type.
			 *
			 * Nodes to be inserted with {@link module:engine/view/downcastwriter~ViewDowncastWriter#insert `ViewDowncastWriter#insert()`}
			 * should be of the following types:
			 *
			 * * {@link module:engine/view/attributeelement~ViewAttributeElement ViewAttributeElement},
			 * * {@link module:engine/view/containerelement~ViewContainerElement ViewContainerElement},
			 * * {@link module:engine/view/emptyelement~ViewEmptyElement ViewEmptyElement},
			 * * {@link module:engine/view/uielement~ViewUIElement UIElement},
			 * * {@link module:engine/view/rawelement~ViewRawElement RawElement},
			 * * {@link module:engine/view/text~ViewText Text}.
			 *
			 * @error view-writer-insert-invalid-node-type
			 */ throw new CKEditorError('view-writer-insert-invalid-node-type', errorContext);
        }
        if (!node.is('$text')) {
            validateNodesToInsert(node.getChildren(), errorContext);
        }
    }
}
/**
 * Checks if node is ViewContainerElement or DocumentFragment, because in most cases they should be treated the same way.
 *
 * @returns Returns `true` if node is instance of ViewContainerElement or DocumentFragment.
 */ function isContainerOrFragment(node) {
    return node && (node.is('containerElement') || node.is('documentFragment'));
}
/**
 * Checks if {@link module:engine/view/range~ViewRange#start range start} and {@link module:engine/view/range~ViewRange#end range end}
 * are placed inside same {@link module:engine/view/containerelement~ViewContainerElement container element}.
 * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when validation fails.
 */ function validateRangeContainer(range, errorContext) {
    const startContainer = getParentContainer(range.start);
    const endContainer = getParentContainer(range.end);
    if (!startContainer || !endContainer || startContainer !== endContainer) {
        /**
		 * The container of the given range is invalid.
		 *
		 * This may happen if {@link module:engine/view/range~ViewRange#start range start} and
		 * {@link module:engine/view/range~ViewRange#end range end} positions are not placed inside the same container element or
		 * a parent container for these positions cannot be found.
		 *
		 * Methods like {@link module:engine/view/downcastwriter~ViewDowncastWriter#wrap `ViewDowncastWriter#remove()`},
		 * {@link module:engine/view/downcastwriter~ViewDowncastWriter#wrap `ViewDowncastWriter#clean()`},
		 * {@link module:engine/view/downcastwriter~ViewDowncastWriter#wrap `ViewDowncastWriter#wrap()`},
		 * {@link module:engine/view/downcastwriter~ViewDowncastWriter#wrap `ViewDowncastWriter#unwrap()`} need to be called
		 * on a range that has its start and end positions located in the same container element. Both positions can be
		 * nested within other elements (e.g. an attribute element) but the closest container ancestor must be the same.
		 *
		 * @error view-writer-invalid-range-container
		 */ throw new CKEditorError('view-writer-invalid-range-container', errorContext);
    }
}
/**
 * Checks if the provided argument is a plain object that can be used as options for container element.
 */ function isContainerOptions(childrenOrOptions) {
    return isPlainObject(childrenOrOptions);
}

/**
 * Set of utilities related to handling block and inline fillers.
 *
 * Browsers do not allow to put caret in elements which does not have height. Because of it, we need to fill all
 * empty elements which should be selectable with elements or characters called "fillers". Unfortunately there is no one
 * universal filler, this is why two types are uses:
 *
 * * Block filler is an element which fill block elements, like `<p>`. CKEditor uses `<br>` as a block filler during the editing,
 * as browsers do natively. So instead of an empty `<p>` there will be `<p><br></p>`. The advantage of block filler is that
 * it is transparent for the selection, so when the caret is before the `<br>` and user presses right arrow he will be
 * moved to the next paragraph, not after the `<br>`. The disadvantage is that it breaks a block, so it cannot be used
 * in the middle of a line of text. The {@link module:engine/view/filler~BR_FILLER `<br>` filler} can be replaced with any other
 * character in the data output, for instance {@link module:engine/view/filler~NBSP_FILLER non-breaking space} or
 * {@link module:engine/view/filler~MARKED_NBSP_FILLER marked non-breaking space}.
 *
 * * Inline filler is a filler which does not break a line of text, so it can be used inside the text, for instance in the empty
 * `<b>` surrendered by text: `foo<b></b>bar`, if we want to put the caret there. CKEditor uses a sequence of the zero-width
 * spaces as an {@link module:engine/view/filler~INLINE_FILLER inline filler} having the predetermined
 * {@link module:engine/view/filler~INLINE_FILLER_LENGTH length}. A sequence is used, instead of a single character to
 * avoid treating random zero-width spaces as the inline filler. Disadvantage of the inline filler is that it is not
 * transparent for the selection. The arrow key moves the caret between zero-width spaces characters, so the additional
 * code is needed to handle the caret.
 *
 * Both inline and block fillers are handled by the {@link module:engine/view/renderer~ViewRenderer renderer} and are not present in the
 * view.
 *
 * @module engine/view/filler
 */ /**
 * Non-breaking space filler creator. This function creates the `&nbsp;` text node.
 * It defines how the filler is created.
 *
 * @see module:engine/view/filler~MARKED_NBSP_FILLER
 * @see module:engine/view/filler~BR_FILLER
 * @internal
 */ const NBSP_FILLER = (domDocument)=>domDocument.createTextNode('\u00A0');
/**
 * Marked non-breaking space filler creator. This function creates the `<span data-cke-filler="true">&nbsp;</span>` element.
 * It defines how the filler is created.
 *
 * @see module:engine/view/filler~NBSP_FILLER
 * @see module:engine/view/filler~BR_FILLER
 * @internal
 */ const MARKED_NBSP_FILLER = (domDocument)=>{
    const span = domDocument.createElement('span');
    span.dataset.ckeFiller = 'true';
    span.innerText = '\u00A0';
    return span;
};
/**
 * `<br>` filler creator. This function creates the `<br data-cke-filler="true">` element.
 * It defines how the filler is created.
 *
 * @see module:engine/view/filler~NBSP_FILLER
 * @see module:engine/view/filler~MARKED_NBSP_FILLER
 * @internal
 */ const BR_FILLER = (domDocument)=>{
    const fillerBr = domDocument.createElement('br');
    fillerBr.dataset.ckeFiller = 'true';
    return fillerBr;
};
/**
 * Length of the {@link module:engine/view/filler~INLINE_FILLER INLINE_FILLER}.
 *
 * @internal
 */ const INLINE_FILLER_LENGTH = 7;
/**
 * Inline filler which is a sequence of the word joiners.
 *
 * @internal
 */ const INLINE_FILLER = '\u2060'.repeat(INLINE_FILLER_LENGTH);
/**
 * Checks if the node is a text node which starts with the {@link module:engine/view/filler~INLINE_FILLER inline filler}.
 *
 * ```ts
 * startsWithFiller( document.createTextNode( INLINE_FILLER ) ); // true
 * startsWithFiller( document.createTextNode( INLINE_FILLER + 'foo' ) ); // true
 * startsWithFiller( document.createTextNode( 'foo' ) ); // false
 * startsWithFiller( document.createElement( 'p' ) ); // false
 * ```
 *
 * @param domNode DOM node.
 * @returns True if the text node starts with the {@link module:engine/view/filler~INLINE_FILLER inline filler}.
 * @internal
 */ function startsWithFiller(domNode) {
    if (typeof domNode == 'string') {
        return domNode.substr(0, INLINE_FILLER_LENGTH) === INLINE_FILLER;
    }
    return isText(domNode) && domNode.data.substr(0, INLINE_FILLER_LENGTH) === INLINE_FILLER;
}
/**
 * Checks if the text node contains only the {@link module:engine/view/filler~INLINE_FILLER inline filler}.
 *
 * ```ts
 * isInlineFiller( document.createTextNode( INLINE_FILLER ) ); // true
 * isInlineFiller( document.createTextNode( INLINE_FILLER + 'foo' ) ); // false
 * ```
 *
 * @param domText DOM text node.
 * @returns True if the text node contains only the {@link module:engine/view/filler~INLINE_FILLER inline filler}.
 * @internal
 */ function isInlineFiller(domText) {
    return domText.data.length == INLINE_FILLER_LENGTH && startsWithFiller(domText);
}
/**
 * Get string data from the text node, removing an {@link module:engine/view/filler~INLINE_FILLER inline filler} from it,
 * if text node contains it.
 *
 * ```ts
 * getDataWithoutFiller( document.createTextNode( INLINE_FILLER + 'foo' ) ) == 'foo' // true
 * getDataWithoutFiller( document.createTextNode( 'foo' ) ) == 'foo' // true
 * ```
 *
 * @param domText DOM text node, possible with inline filler.
 * @returns Data without filler.
 * @internal
 */ function getDataWithoutFiller(domText) {
    const data = typeof domText == 'string' ? domText : domText.data;
    if (startsWithFiller(domText)) {
        return data.slice(INLINE_FILLER_LENGTH);
    }
    return data;
}
/**
 * Assign key observer which move cursor from the end of the inline filler to the beginning of it when
 * the left arrow is pressed, so the filler does not break navigation.
 *
 * @param view View controller instance we should inject quirks handling on.
 * @internal
 */ function injectQuirksHandling(view) {
    view.document.on('arrowKey', jumpOverInlineFiller, {
        priority: 'low'
    });
}
/**
 * Move cursor from the end of the inline filler to the beginning of it when, so the filler does not break navigation.
 */ function jumpOverInlineFiller(evt, data) {
    if (data.keyCode == keyCodes.arrowleft) {
        const domSelection = data.domTarget.ownerDocument.defaultView.getSelection();
        if (domSelection.rangeCount == 1 && domSelection.getRangeAt(0).collapsed) {
            const domParent = domSelection.getRangeAt(0).startContainer;
            const domOffset = domSelection.getRangeAt(0).startOffset;
     