import {
  ReportsComponent
} from "./chunk-V3KCIW52.js";
import {
  ApiService
} from "./chunk-SOAGHE74.js";
import {
  Storage,
  deleteObject,
  getDownloadURL,
  ref,
  uploadBytes
} from "./chunk-LK2DFVWZ.js";
import {
  SmtpService
} from "./chunk-7QBO7AZP.js";
import "./chunk-CPSVUG3M.js";
import "./chunk-33HMBJ2T.js";
import {
  MainLayoutComponent
} from "./chunk-BGRXE4K2.js";
import "./chunk-VURM7YH2.js";
import {
  ToastService
} from "./chunk-RDMWVNUM.js";
import {
  ActivatedRoute,
  CheckboxControlValueAccessor,
  DefaultValueAccessor,
  FormBuilder,
  FormControlName,
  FormGroupDirective,
  FormsModule,
  MinValidator,
  NG_VALUE_ACCESSOR,
  NgControlStatus,
  NgControlStatusGroup,
  NgModel,
  NgSelectOption,
  NumberValueAccessor,
  RadioControlValueAccessor,
  ReactiveFormsModule,
  Router,
  SelectControlValueAccessor,
  Validators,
  ɵNgNoValidate,
  ɵNgSelectMultipleOption
} from "./chunk-2S4XXET5.js";
import "./chunk-L3ANR23A.js";
import {
  AuthService,
  CompanyService,
  FirestoreService,
  SubdomainService
} from "./chunk-NDNGZ4HQ.js";
import {
  APP_ID,
  ApplicationRef,
  BehaviorSubject,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  CommonModule,
  Component,
  ConnectableObservable,
  DOCUMENT,
  DestroyRef,
  Directive,
  ElementRef,
  EnvironmentInjector,
  EventEmitter,
  HostListener,
  Inject,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  IterableDiffers,
  NgClass,
  NgForOf,
  NgIf,
  NgModule,
  NgSwitch,
  NgSwitchCase,
  NgZone,
  Observable,
  Optional,
  Output,
  PLATFORM_ID,
  Renderer2,
  RendererFactory2,
  Subject,
  Subscription,
  TemplateRef,
  ViewChild,
  ViewContainerRef,
  ViewEncapsulation,
  __async,
  __name,
  __objRest,
  __publicField,
  __spreadProps,
  __spreadValues,
  afterNextRender,
  animationFrameScheduler,
  asapScheduler,
  auditTime,
  booleanAttribute,
  createComponent,
  distinctUntilChanged,
  effect,
  filter,
  first,
  forwardRef,
  fromEvent,
  inject,
  interval,
  isObservable,
  isPlatformBrowser,
  map,
  merge,
  numberAttribute,
  of,
  pairwise,
  setClassMetadata,
  shareReplay,
  signal,
  startWith,
  switchMap,
  take,
  takeUntil,
  tap,
  untracked,
  ɵsetClassDebugInfo,
  ɵɵInheritDefinitionFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassProp,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdirectiveInject,
  ɵɵdomElement,
  ɵɵdomElementEnd,
  ɵɵdomElementStart,
  ɵɵelement,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵinterpolate1,
  ɵɵinterpolate2,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnextContext,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpureFunction0,
  ɵɵpureFunction3,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵresetView,
  ɵɵresolveWindow,
  ɵɵrestoreView,
  ɵɵsanitizeHtml,
  ɵɵsanitizeUrl,
  ɵɵstyleMap,
  ɵɵstyleProp,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtextInterpolate2,
  ɵɵtextInterpolate3,
  ɵɵtwoWayBindingSet,
  ɵɵtwoWayListener,
  ɵɵtwoWayProperty,
  ɵɵviewQuery
} from "./chunk-GMR7JISZ.js";

// src/app/services/automation.service.ts
var _AutomationService = class _AutomationService {
  firestoreService = inject(FirestoreService);
  smtpService = inject(SmtpService);
  subdomainService = inject(SubdomainService);
  companyService = inject(CompanyService);
  // Lock para evitar execução simultânea de automações de tempo
  timeAutomationLocks = /* @__PURE__ */ new Map();
  // Processar automações quando um novo lead é criado
  processNewLeadAutomations(lead, boardId, ownerId) {
    return __async(this, null, function* () {
      try {
        const automations = yield this.firestoreService.getAutomations(ownerId, boardId);
        const newLeadAutomations = automations.filter((automation) => {
          if (!automation || !automation.active)
            return false;
          const type = automation.triggerType || automation.trigger?.type;
          const triggerPhase = automation.triggerPhase || automation.trigger?.phase;
          if (triggerPhase) {
            return type === "new-lead-created" && lead.columnId === triggerPhase;
          }
          return type === "new-lead-created";
        });
        for (const automation of newLeadAutomations) {
          yield this.executeAutomation(automation, lead, boardId, ownerId);
        }
      } catch (error) {
        console.error("Erro ao processar automa\xE7\xF5es de novo lead:", error);
      }
    });
  }
  // Processar automações quando um lead muda de fase
  processPhaseChangeAutomations(lead, newColumnId, oldColumnId, boardId, ownerId) {
    return __async(this, null, function* () {
      try {
        const automations = yield this.firestoreService.getAutomations(ownerId, boardId);
        const phaseChangeAutomations = automations.filter((automation) => {
          const isActive = automation.active;
          const isCardEntersPhase = automation.triggerType === "card-enters-phase";
          const matchesPhase = automation.triggerPhase === newColumnId;
          return isActive && isCardEntersPhase && matchesPhase;
        });
        for (const automation of phaseChangeAutomations) {
          yield this.executeAutomation(automation, lead, boardId, ownerId);
        }
      } catch (error) {
        console.error("Erro ao processar automa\xE7\xF5es de mudan\xE7a de fase:", error);
      }
    });
  }
  // Executar uma automação específica
  executeAutomation(automation, lead, boardId, ownerId) {
    return __async(this, null, function* () {
      try {
        for (const action of automation.actions) {
          yield this.executeAction(action, lead, boardId, ownerId, automation);
        }
        yield this.addAutomationHistory(automation, lead, boardId, ownerId, "success");
      } catch (error) {
        console.error(`Erro ao executar automa\xE7\xE3o ${automation.name}:`, error);
        yield this.addAutomationHistory(automation, lead, boardId, ownerId, "error", error.message);
      }
    });
  }
  // Executar uma ação específica
  executeAction(action, lead, boardId, ownerId, automation) {
    return __async(this, null, function* () {
      switch (action.type) {
        case "send-email":
          yield this.executeSendEmailAction(action, lead, boardId, ownerId);
          break;
        case "move-to-phase":
          yield this.executeMoveToPhaseAction(action, lead, boardId, ownerId);
          break;
        case "assign-user":
          yield this.executeAssignUserAction(action, lead, boardId, ownerId);
          break;
        case "add-note":
          yield this.executeAddNoteAction(action, lead, boardId, ownerId);
          break;
        default:
          console.warn(`Tipo de a\xE7\xE3o n\xE3o reconhecido: ${action.type}`);
      }
    });
  }
  // Executar ação de envio de email
  executeSendEmailAction(action, lead, boardId, ownerId, automation) {
    return __async(this, null, function* () {
      if (!action.templateId) {
        throw new Error("Template de email n\xE3o especificado");
      }
      const emailLockKey = `email_${ownerId}_${boardId}_${lead.id}_${action.templateId}_${automation?.id || "manual"}`;
      if (this.timeAutomationLocks.get(emailLockKey)) {
        console.log("\u{1F512} Email j\xE1 est\xE1 sendo enviado (lock ativo), pulando:", {
          leadId: lead.id,
          templateId: action.templateId,
          automationId: automation?.id,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
        return;
      }
      this.timeAutomationLocks.set(emailLockKey, true);
      try {
        const templates = yield this.firestoreService.getEmailTemplates(ownerId, boardId);
        const template = templates.find((t) => t.id === action.templateId);
        if (!template)
          throw new Error(`Template de email n\xE3o encontrado: ${action.templateId}`);
        const recipientFromTemplateRaw = template.recipients || "";
        const recipientFromTemplate = this.processEmailTemplate(recipientFromTemplateRaw, lead) || "";
        const parseEmails = /* @__PURE__ */ __name((input) => {
          if (!input)
            return [];
          return input.split(/[;,]/).map((s) => s.trim()).filter((s) => /.+@.+\..+/.test(s));
        }, "parseEmails");
        const templateEmails = parseEmails(recipientFromTemplate);
        const fallbackEmails = parseEmails(action.toEmail || "").concat(parseEmails(lead.fields.contactEmail || "")).concat(parseEmails(lead.fields.email || "")).concat(parseEmails(lead.fields.emailLead || "")).concat(parseEmails(lead.fields.contatoEmail || ""));
        const allRecipients = templateEmails.length ? templateEmails : fallbackEmails;
        const toValue = allRecipients.join(",");
        if (!toValue) {
          throw new Error("Destinat\xE1rio n\xE3o definido (template/a\xE7\xE3o/lead)");
        }
        const body = template.body || template.content || "";
        const processedContent = this.processEmailTemplate(body, lead, boardId, ownerId);
        const processedSubject = this.processEmailTemplate(template.subject || template.name || "Mensagem", lead, boardId, ownerId);
        let outboxId = null;
        try {
          const existing = yield this.firestoreService.findRecentOutboxEmail(ownerId, boardId, {
            automationId: automation?.id || void 0,
            leadId: lead.id,
            subject: processedSubject,
            withinMs: 30 * 60 * 1e3
          });
          if (existing) {
            console.log("\u{1F4E7} Email duplicado detectado (automa\xE7\xE3o + assunto, 30min), pulando envio:", {
              leadId: lead.id,
              automationId: automation?.id,
              subject: processedSubject,
              existingEmailId: existing,
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            });
            return;
          }
          const recentTemplate = yield this.firestoreService.findRecentOutboxEmail(ownerId, boardId, {
            templateId: action.templateId,
            leadId: lead.id,
            withinMs: 60 * 60 * 1e3
          });
          if (recentTemplate) {
            console.log("\u{1F4E7} Template duplicado detectado (template + lead, 60min), pulando envio:", {
              leadId: lead.id,
              templateId: action.templateId,
              subject: processedSubject,
              existingEmailId: recentTemplate,
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            });
            return;
          }
          const recentRecipient = yield this.firestoreService.findRecentOutboxEmail(ownerId, boardId, {
            leadId: lead.id,
            subject: processedSubject,
            withinMs: 15 * 60 * 1e3
          });
          if (recentRecipient) {
            console.log("\u{1F4E7} Email duplicado detectado (lead + assunto, 15min), pulando envio:", {
              leadId: lead.id,
              subject: processedSubject,
              to: toValue,
              existingEmailId: recentRecipient,
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            });
            return;
          }
          const ref2 = outboxId ? { id: outboxId } : yield this.firestoreService.createOutboxEmail(ownerId, boardId, {
            to: toValue,
            subject: processedSubject,
            html: processedContent,
            leadId: lead.id,
            automationId: automation?.id || null,
            templateId: action.templateId || null,
            delivery: { state: "PENDING" }
          });
          outboxId = ref2?.id || null;
        } catch (e) {
          console.warn("\u26A0\uFE0F N\xE3o foi poss\xEDvel registrar o email na caixa de sa\xEDda antes do envio.", e);
        }
        yield new Promise((resolve, reject) => {
          this.smtpService.sendEmail({ to: toValue, subject: processedSubject, html: processedContent }).subscribe({
            next: /* @__PURE__ */ __name((response) => __async(this, null, function* () {
              try {
                if (outboxId) {
                  yield this.firestoreService.updateOutboxEmail(ownerId, boardId, outboxId, {
                    delivery: { state: "SUCCESS", messageId: response?.messageId || "sent" }
                  });
                }
              } catch {
              }
              resolve();
            }), "next"),
            error: /* @__PURE__ */ __name((error) => __async(this, null, function* () {
              try {
                if (outboxId) {
                  yield this.firestoreService.updateOutboxEmail(ownerId, boardId, outboxId, {
                    delivery: { state: "ERROR", error: error?.error || error?.message || "Erro" }
                  });
                }
              } catch {
              }
              reject(error);
            }), "error")
          });
        });
        console.log("\u2705 Email enviado com sucesso:", {
          leadId: lead.id,
          templateId: action.templateId,
          automationId: automation?.id,
          subject: processedSubject,
          to: toValue,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
      } catch (error) {
        console.error("\u274C Erro ao enviar email:", {
          leadId: lead.id,
          templateId: action.templateId,
          automationId: automation?.id,
          error: error?.message || error,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
        throw error;
      } finally {
        this.timeAutomationLocks.delete(emailLockKey);
        console.log("\u{1F513} Lock de email liberado:", emailLockKey);
      }
    });
  }
  // Executar ação de mover para fase
  executeMoveToPhaseAction(action, lead, boardId, ownerId) {
    return __async(this, null, function* () {
      if (!action.phaseId) {
        throw new Error("Fase de destino n\xE3o especificada");
      }
      try {
        const now = /* @__PURE__ */ new Date();
        const phaseHistory = __spreadValues({}, lead.phaseHistory || {});
        const oldColumnId = lead.columnId;
        if (oldColumnId && phaseHistory[oldColumnId]) {
          const enteredAt = phaseHistory[oldColumnId].enteredAt?.toDate && phaseHistory[oldColumnId].enteredAt.toDate() || new Date(phaseHistory[oldColumnId].enteredAt || now);
          phaseHistory[oldColumnId].exitedAt = now;
          phaseHistory[oldColumnId].duration = now.getTime() - enteredAt.getTime();
        }
        phaseHistory[action.phaseId] = {
          phaseId: action.phaseId,
          enteredAt: now
        };
        yield this.firestoreService.updateLead(ownerId, boardId, lead.id, {
          columnId: action.phaseId,
          movedToCurrentColumnAt: now,
          phaseHistory
        });
        try {
          yield this.firestoreService.addLeadHistory(ownerId, boardId, lead.id, {
            type: "move",
            text: `Moveu automaticamente para outra fase`,
            user: "Automa\xE7\xE3o"
          });
        } catch (historyError) {
          console.warn("Erro ao registrar hist\xF3rico de movimenta\xE7\xE3o:", historyError);
        }
      } catch (error) {
        console.error("Erro ao executar a\xE7\xE3o de mover para fase:", error);
        throw error;
      }
    });
  }
  // Executar ação de atribuir usuário
  executeAssignUserAction(action, lead, boardId, ownerId) {
    return __async(this, null, function* () {
      if (!action.userId) {
        throw new Error("Usu\xE1rio n\xE3o especificado");
      }
      const companyId = this.subdomainService.getCurrentCompany()?.id;
      let userName = "";
      let userEmail = "";
      if (companyId && action.userId) {
        try {
          const user = yield this.companyService.getCompanyUser(companyId, action.userId);
          if (user) {
            userName = user.displayName || "";
            userEmail = user.email || action.userId;
          } else {
            const users = yield this.companyService.getCompanyUsers(companyId);
            const foundUser = users.find((u) => u.uid === action.userId || u.email === action.userId);
            if (foundUser) {
              userName = foundUser.displayName || "";
              userEmail = foundUser.email || "";
            }
          }
        } catch (error) {
          console.warn("Erro ao buscar dados do usu\xE1rio:", error);
        }
      }
      yield this.firestoreService.updateLead(ownerId, boardId, lead.id, {
        responsibleUserId: action.userId,
        responsibleUserName: userName,
        responsibleUserEmail: userEmail
      });
    });
  }
  // Executar ação de adicionar nota
  executeAddNoteAction(action, lead, boardId, ownerId) {
    return __async(this, null, function* () {
      if (!action.note) {
        throw new Error("Nota n\xE3o especificada");
      }
      const processedNote = this.processEmailTemplate(action.note, lead, boardId, ownerId);
      const currentNotes = lead.fields["notes"] || "";
      const newNotes = currentNotes + "\n\n[AUTOMA\xC7\xC3O] " + (/* @__PURE__ */ new Date()).toLocaleString("pt-BR") + ":\n" + processedNote;
      yield this.firestoreService.updateLead(ownerId, boardId, lead.id, {
        fields: __spreadProps(__spreadValues({}, lead.fields), {
          notes: newNotes
        })
      });
    });
  }
  // Processar template com dados do lead
  processEmailTemplate(template, lead, boardId, ownerId) {
    if (!template)
      return "";
    let processed = template;
    const variables = {
      "{{contactName}}": lead.fields.contactName || "",
      "{{companyName}}": lead.fields.companyName || "",
      "{{contactEmail}}": lead.fields.contactEmail || "",
      "{{contactPhone}}": lead.fields.contactPhone || "",
      "{{cnpj}}": lead.fields.cnpj || ""
    };
    const respName = lead.responsibleUserName || lead.fields.responsibleUserName || "";
    const respEmail = lead.responsibleUserEmail || lead.fields.responsibleUserEmail || "";
    const leadLink = this.buildLeadPublicLink(lead, boardId, ownerId);
    Object.assign(variables, {
      "{{responsibleUserName}}": respName,
      "{{responsibleUserEmail}}": respEmail,
      "{{nomeResponsavel}}": respName,
      "{{emailResponsavel}}": respEmail,
      "{{responsavel}}": respName,
      "{{leadLink}}": leadLink
    });
    Object.entries(variables).forEach(([placeholder, value]) => {
      processed = processed.replace(new RegExp(placeholder, "g"), value);
    });
    Object.entries(lead.fields).forEach(([key, value]) => {
      if (typeof value === "string") {
        processed = processed.replace(new RegExp(`{{${key}}}`, "g"), value);
      }
    });
    const rootReplacements = [
      ["id", lead.id],
      ["responsibleUserId", lead.responsibleUserId],
      ["responsibleUserName", lead.responsibleUserName],
      ["responsibleUserEmail", lead.responsibleUserEmail]
    ];
    rootReplacements.forEach(([k, v]) => {
      if (typeof v === "string") {
        processed = processed.replace(new RegExp(`{{${k}}}`, "g"), v);
      }
    });
    return processed;
  }
  buildLeadPublicLink(lead, boardId, ownerId) {
    try {
      const company = this.subdomainService.getCurrentCompany();
      if (!company || !boardId || !ownerId || !lead?.id || !lead?.columnId)
        return "";
      const params = new URLSearchParams({
        companyId: company.id,
        userId: ownerId,
        boardId,
        leadId: lead.id,
        columnId: lead.columnId
      });
      if (this.subdomainService.isDevelopment()) {
        const base = this.subdomainService.getBaseUrl();
        params.set("subdomain", company.subdomain);
        return `${base}/form?${params.toString()}`;
      }
      return `https://${company.subdomain}.taskboard.com.br/form?${params.toString()}`;
    } catch {
      return "";
    }
  }
  // Adicionar item ao histórico de automação
  addAutomationHistory(automation, lead, boardId, ownerId, status, errorMessage) {
    return __async(this, null, function* () {
      const historyItem = __spreadValues({
        automationId: automation.id,
        automationName: automation.name,
        leadId: lead.id,
        leadName: lead.fields.contactName || lead.fields.companyName || "Lead sem nome",
        status,
        executedAt: /* @__PURE__ */ new Date(),
        actions: automation.actions.map((action) => ({
          type: action.type,
          details: this.getActionDetails(action)
        }))
      }, errorMessage && { errorMessage });
      try {
        yield this.firestoreService.addAutomationHistoryItem(ownerId, boardId, historyItem);
      } catch (error) {
        console.error("Erro ao adicionar ao hist\xF3rico de automa\xE7\xE3o:", error);
      }
    });
  }
  // Obter detalhes da ação para histórico
  getActionDetails(action) {
    switch (action.type) {
      case "send-email":
        return `Template: ${action.templateId}`;
      case "move-to-phase":
        return `Fase: ${action.phaseId}`;
      case "assign-user":
        return `Usu\xE1rio: ${action.userId}`;
      case "add-note":
        return `Nota: ${action.note?.substring(0, 50)}...`;
      default:
        return "";
    }
  }
  // Método para processar automações de tempo (SLA, tempo em fase)
  processTimeBasedAutomations(leads, columns, boardId, ownerId) {
    return __async(this, null, function* () {
      const lockKey = `${ownerId}-${boardId}`;
      if (this.timeAutomationLocks.get(lockKey)) {
        console.log("\u23F3 Automa\xE7\xF5es de tempo j\xE1 em execu\xE7\xE3o para este board, pulando...");
        return;
      }
      this.timeAutomationLocks.set(lockKey, true);
      try {
        if (!leads || leads.length === 0) {
          return;
        }
        console.log("\u{1F504} Iniciando processamento de automa\xE7\xF5es de tempo:", {
          leadsCount: leads.length,
          boardId,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
        const automations = yield this.firestoreService.getAutomations(ownerId, boardId);
        const list = automations.filter((a) => a && a.active);
        if (list.length === 0) {
          console.log("\u2139\uFE0F Nenhuma automa\xE7\xE3o ativa encontrada");
          return;
        }
        console.log(`\u{1F4CB} Processando ${list.length} automa\xE7\xF5es ativas`);
        const formConfigCache = {};
        const getFormFieldsForPhase = /* @__PURE__ */ __name((phaseId) => __async(this, null, function* () {
          if (formConfigCache.hasOwnProperty(phaseId))
            return formConfigCache[phaseId]?.fields || [];
          const cfg = yield this.firestoreService.getPhaseFormConfig(ownerId, boardId, phaseId);
          formConfigCache[phaseId] = cfg;
          return cfg?.fields || [];
        }), "getFormFieldsForPhase");
        const DAY = 24 * 60 * 60 * 1e3;
        const now = Date.now();
        for (const automation of list) {
          const type = automation.triggerType || automation.trigger?.type;
          const phaseId = automation.triggerPhase || automation.trigger?.phase || "";
          const days = automation.triggerDays || automation.trigger?.days || 0;
          if (!type)
            continue;
          for (const lead of leads) {
            if (phaseId && lead.columnId !== phaseId)
              continue;
            const movedTs = lead.movedToCurrentColumnAt;
            const moved = movedTs?.toDate ? movedTs.toDate().getTime() : movedTs?.seconds ? movedTs.seconds * 1e3 : new Date(movedTs).getTime();
            const daysPassed = moved ? Math.floor((now - moved) / DAY) : "N/A";
            try {
              if (type === "card-in-phase-for-time") {
                if (!days || days <= 0)
                  continue;
                const movedTs2 = lead.movedToCurrentColumnAt;
                const moved2 = movedTs2?.toDate ? movedTs2.toDate().getTime() : movedTs2?.seconds ? movedTs2.seconds * 1e3 : new Date(movedTs2).getTime();
                if (!moved2)
                  continue;
                const elapsed = now - moved2;
                if (elapsed >= days * DAY && !this.hasRecentlyExecutedForDays(lead, automation.id, days, DAY)) {
                  yield this.executeAutomation(automation, lead, boardId, ownerId);
                  yield this.markExecutedForDays(ownerId, boardId, lead, automation.id, days);
                }
              } else if (type === "sla-overdue") {
                const column = columns.find((c) => c.id === lead.columnId);
                const slaDays = column?.slaDays || 0;
                if (!slaDays || slaDays <= 0)
                  continue;
                const movedTs2 = lead.movedToCurrentColumnAt;
                const moved2 = movedTs2?.toDate ? movedTs2.toDate().getTime() : movedTs2?.seconds ? movedTs2.seconds * 1e3 : new Date(movedTs2).getTime();
                if (!moved2)
                  continue;
                if (now - moved2 > slaDays * DAY && !this.hasRecentlyExecuted(lead, automation.id, DAY)) {
                  yield this.executeAutomation(automation, lead, boardId, ownerId);
                  yield this.markExecuted(ownerId, boardId, lead, automation.id);
                }
              } else if (type === "form-not-answered") {
                const targetPhase = phaseId || lead.columnId;
                if (phaseId && lead.columnId !== phaseId) {
                  continue;
                }
                const fields = yield getFormFieldsForPhase(targetPhase);
                if (!fields || fields.length === 0) {
                  continue;
                }
                const waitDays = days && days > 0 ? days : 1;
                const movedTs2 = lead.movedToCurrentColumnAt;
                let moved2 = null;
                if (movedTs2?.toDate) {
                  moved2 = movedTs2.toDate().getTime();
                } else if (movedTs2?.seconds) {
                  moved2 = movedTs2.seconds * 1e3;
                } else if (movedTs2) {
                  try {
                    moved2 = new Date(movedTs2).getTime();
                  } catch {
                    moved2 = null;
                  }
                }
                if (!moved2) {
                  const createdTs = lead.createdAt;
                  if (createdTs?.toDate) {
                    moved2 = createdTs.toDate().getTime();
                  } else if (createdTs?.seconds) {
                    moved2 = createdTs.seconds * 1e3;
                  } else if (createdTs) {
                    try {
                      moved2 = new Date(createdTs).getTime();
                    } catch {
                      moved2 = Date.now();
                    }
                  }
                }
                const daysPassed2 = moved2 ? Math.floor((now - moved2) / DAY) : 0;
                if (!moved2 || now - moved2 < waitDays * DAY) {
                  continue;
                }
                const fieldValues = {};
                const fieldAnalysis = [];
                const allEmpty = fields.every((f) => {
                  const key = f.apiFieldName || f.name;
                  const val = lead.fields?.[key];
                  fieldValues[key] = val;
                  let isEmpty = true;
                  if (val !== void 0 && val !== null && val !== "") {
                    const strVal = `${val}`.trim();
                    isEmpty = strVal === "" || strVal === "undefined" || strVal === "null";
                  }
                  fieldAnalysis.push({
                    fieldName: f.name,
                    apiFieldName: f.apiFieldName,
                    value: val,
                    isEmpty,
                    type: typeof val
                  });
                  return isEmpty;
                });
                if (allEmpty && !this.hasRecentlyExecuted(lead, automation.id, DAY)) {
                  try {
                    yield this.executeAutomation(automation, lead, boardId, ownerId);
                    yield this.markExecuted(ownerId, boardId, lead, automation.id);
                  } catch (executeError) {
                    console.error(`Erro ao executar automa\xE7\xE3o form-not-answered para lead ${lead.id}:`, executeError);
                  }
                }
              }
            } catch (e) {
              console.warn("Falha ao avaliar automa\xE7\xE3o baseada em tempo para lead:", lead.id, e);
            }
          }
        }
      } catch (error) {
        console.error("\u274C Erro ao processar automa\xE7\xF5es baseadas em tempo:", error);
      } finally {
        this.timeAutomationLocks.delete(lockKey);
        console.log("\u{1F513} Lock de automa\xE7\xF5es de tempo liberado");
      }
    });
  }
  hasRecentlyExecuted(lead, automationId, withinMs) {
    try {
      const executedAutomations = lead.executedAutomations || {};
      const record = executedAutomations[automationId];
      if (!record) {
        return false;
      }
      let timestamp = null;
      const lastExecutedAt = record.lastExecutedAt;
      if (lastExecutedAt?.toDate) {
        timestamp = lastExecutedAt.toDate().getTime();
      } else if (lastExecutedAt?.seconds) {
        timestamp = lastExecutedAt.seconds * 1e3;
      } else if (lastExecutedAt) {
        try {
          timestamp = new Date(lastExecutedAt).getTime();
        } catch {
          timestamp = null;
        }
      }
      if (!timestamp) {
        return false;
      }
      const elapsed = Date.now() - timestamp;
      const isRecent = elapsed < withinMs;
      return isRecent;
    } catch (error) {
      console.error(`Erro ao verificar execu\xE7\xE3o recente para automa\xE7\xE3o ${automationId}:`, error);
      return false;
    }
  }
  hasRecentlyExecutedForDays(lead, automationId, days, withinMs) {
    try {
      const executedAutomations = lead.executedAutomations || {};
      const key = `${automationId}_${days}days`;
      const record = executedAutomations[key];
      if (!record) {
        return false;
      }
      let timestamp = null;
      const lastExecutedAt = record.lastExecutedAt;
      if (lastExecutedAt?.toDate) {
        timestamp = lastExecutedAt.toDate().getTime();
      } else if (lastExecutedAt?.seconds) {
        timestamp = lastExecutedAt.seconds * 1e3;
      } else if (lastExecutedAt) {
        try {
          timestamp = new Date(lastExecutedAt).getTime();
        } catch {
          timestamp = null;
        }
      }
      if (!timestamp) {
        return false;
      }
      const elapsed = Date.now() - timestamp;
      const isRecent = elapsed < withinMs;
      console.log(`\u{1F50D} Verificando execu\xE7\xE3o para ${key}: timestamp=${new Date(timestamp).toISOString()}, elapsed=${Math.round(elapsed / 1e3 / 60)}min, isRecent=${isRecent}`);
      return isRecent;
    } catch (error) {
      console.error(`Erro ao verificar execu\xE7\xE3o recente para automa\xE7\xE3o ${automationId} (${days} dias):`, error);
      return false;
    }
  }
  markExecuted(ownerId, boardId, lead, automationId) {
    return __async(this, null, function* () {
      try {
        const exec = __spreadValues({}, lead.executedAutomations || {});
        const now = /* @__PURE__ */ new Date();
        exec[automationId] = { lastExecutedAt: now };
        yield this.firestoreService.updateLead(ownerId, boardId, lead.id, { executedAutomations: exec });
      } catch (error) {
        console.error(`Erro ao marcar automa\xE7\xE3o ${automationId} como executada para lead ${lead.id}:`, error);
      }
    });
  }
  markExecutedForDays(ownerId, boardId, lead, automationId, days) {
    return __async(this, null, function* () {
      try {
        const exec = __spreadValues({}, lead.executedAutomations || {});
        const now = /* @__PURE__ */ new Date();
        const key = `${automationId}_${days}days`;
        exec[key] = { lastExecutedAt: now, automationId, days };
        console.log(`\u2705 Marcando execu\xE7\xE3o para ${key}: ${now.toISOString()}`);
        yield this.firestoreService.updateLead(ownerId, boardId, lead.id, { executedAutomations: exec });
      } catch (error) {
        console.error(`Erro ao marcar automa\xE7\xE3o ${automationId} (${days} dias) como executada para lead ${lead.id}:`, error);
      }
    });
  }
};
__name(_AutomationService, "AutomationService");
__publicField(_AutomationService, "\u0275fac", /* @__PURE__ */ __name(function AutomationService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _AutomationService)();
}, "AutomationService_Factory"));
__publicField(_AutomationService, "\u0275prov", /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _AutomationService, factory: _AutomationService.\u0275fac, providedIn: "root" }));
var AutomationService = _AutomationService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AutomationService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/shadow-dom.mjs
var shadowDomIsSupported;
function _supportsShadowDom() {
  if (shadowDomIsSupported == null) {
    const head = typeof document !== "undefined" ? document.head : null;
    shadowDomIsSupported = !!(head && (head.createShadowRoot || head.attachShadow));
  }
  return shadowDomIsSupported;
}
__name(_supportsShadowDom, "_supportsShadowDom");
function _getShadowRoot(element) {
  if (_supportsShadowDom()) {
    const rootNode = element.getRootNode ? element.getRootNode() : null;
    if (typeof ShadowRoot !== "undefined" && ShadowRoot && rootNode instanceof ShadowRoot) {
      return rootNode;
    }
  }
  return null;
}
__name(_getShadowRoot, "_getShadowRoot");
function _getEventTarget(event) {
  return event.composedPath ? event.composedPath()[0] : event.target;
}
__name(_getEventTarget, "_getEventTarget");

// node_modules/@angular/cdk/fesm2022/fake-event-detection.mjs
function isFakeMousedownFromScreenReader(event) {
  return event.buttons === 0 || event.detail === 0;
}
__name(isFakeMousedownFromScreenReader, "isFakeMousedownFromScreenReader");
function isFakeTouchstartFromScreenReader(event) {
  const touch = event.touches && event.touches[0] || event.changedTouches && event.changedTouches[0];
  return !!touch && touch.identifier === -1 && (touch.radiusX == null || touch.radiusX === 1) && (touch.radiusY == null || touch.radiusY === 1);
}
__name(isFakeTouchstartFromScreenReader, "isFakeTouchstartFromScreenReader");

// node_modules/@angular/cdk/fesm2022/element.mjs
function coerceNumberProperty(value, fallbackValue = 0) {
  if (_isNumberValue(value)) {
    return Number(value);
  }
  return arguments.length === 2 ? fallbackValue : 0;
}
__name(coerceNumberProperty, "coerceNumberProperty");
function _isNumberValue(value) {
  return !isNaN(parseFloat(value)) && !isNaN(Number(value));
}
__name(_isNumberValue, "_isNumberValue");
function coerceElement(elementOrRef) {
  return elementOrRef instanceof ElementRef ? elementOrRef.nativeElement : elementOrRef;
}
__name(coerceElement, "coerceElement");

// node_modules/@angular/cdk/fesm2022/style-loader.mjs
var appsWithLoaders = /* @__PURE__ */ new WeakMap();
var __CdkPrivateStyleLoader = class __CdkPrivateStyleLoader {
  _appRef;
  _injector = inject(Injector);
  _environmentInjector = inject(EnvironmentInjector);
  /**
   * Loads a set of styles.
   * @param loader Component which will be instantiated to load the styles.
   */
  load(loader) {
    const appRef = this._appRef = this._appRef || this._injector.get(ApplicationRef);
    let data = appsWithLoaders.get(appRef);
    if (!data) {
      data = {
        loaders: /* @__PURE__ */ new Set(),
        refs: []
      };
      appsWithLoaders.set(appRef, data);
      appRef.onDestroy(() => {
        appsWithLoaders.get(appRef)?.refs.forEach((ref2) => ref2.destroy());
        appsWithLoaders.delete(appRef);
      });
    }
    if (!data.loaders.has(loader)) {
      data.loaders.add(loader);
      data.refs.push(createComponent(loader, {
        environmentInjector: this._environmentInjector
      }));
    }
  }
};
__name(__CdkPrivateStyleLoader, "_CdkPrivateStyleLoader");
__publicField(__CdkPrivateStyleLoader, "\u0275fac", /* @__PURE__ */ __name(function _CdkPrivateStyleLoader_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || __CdkPrivateStyleLoader)();
}, "_CdkPrivateStyleLoader_Factory"));
__publicField(__CdkPrivateStyleLoader, "\u0275prov", /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: __CdkPrivateStyleLoader,
  factory: __CdkPrivateStyleLoader.\u0275fac,
  providedIn: "root"
}));
var _CdkPrivateStyleLoader = __CdkPrivateStyleLoader;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_CdkPrivateStyleLoader, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/platform2.mjs
var hasV8BreakIterator;
try {
  hasV8BreakIterator = typeof Intl !== "undefined" && Intl.v8BreakIterator;
} catch {
  hasV8BreakIterator = false;
}
var _Platform = class _Platform {
  _platformId = inject(PLATFORM_ID);
  // We want to use the Angular platform check because if the Document is shimmed
  // without the navigator, the following checks will fail. This is preferred because
  // sometimes the Document may be shimmed without the user's knowledge or intention
  /** Whether the Angular application is being rendered in the browser. */
  isBrowser = this._platformId ? isPlatformBrowser(this._platformId) : typeof document === "object" && !!document;
  /** Whether the current browser is Microsoft Edge. */
  EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);
  /** Whether the current rendering engine is Microsoft Trident. */
  TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);
  // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.
  /** Whether the current rendering engine is Blink. */
  BLINK = this.isBrowser && !!(window.chrome || hasV8BreakIterator) && typeof CSS !== "undefined" && !this.EDGE && !this.TRIDENT;
  // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to
  // ensure that Webkit runs standalone and is not used as another engine's base.
  /** Whether the current rendering engine is WebKit. */
  WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;
  /** Whether the current platform is Apple iOS. */
  IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window);
  // It's difficult to detect the plain Gecko engine, because most of the browsers identify
  // them self as Gecko-like browsers and modify the userAgent's according to that.
  // Since we only cover one explicit Firefox case, we can simply check for Firefox
  // instead of having an unstable check for Gecko.
  /** Whether the current browser is Firefox. */
  FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);
  /** Whether the current platform is Android. */
  // Trident on mobile adds the android platform to the userAgent to trick detections.
  ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;
  // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake
  // this and just place the Safari keyword in the userAgent. To be more safe about Safari every
  // Safari browser should also use Webkit as its layout engine.
  /** Whether the current browser is Safari. */
  SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;
  constructor() {
  }
};
__name(_Platform, "Platform");
__publicField(_Platform, "\u0275fac", /* @__PURE__ */ __name(function Platform_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _Platform)();
}, "Platform_Factory"));
__publicField(_Platform, "\u0275prov", /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _Platform,
  factory: _Platform.\u0275fac,
  providedIn: "root"
}));
var Platform = _Platform;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Platform, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();

// node_modules/@angular/cdk/fesm2022/directionality.mjs
var DIR_DOCUMENT = new InjectionToken("cdk-dir-doc", {
  providedIn: "root",
  factory: DIR_DOCUMENT_FACTORY
});
function DIR_DOCUMENT_FACTORY() {
  return inject(DOCUMENT);
}
__name(DIR_DOCUMENT_FACTORY, "DIR_DOCUMENT_FACTORY");
var RTL_LOCALE_PATTERN = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;
function _resolveDirectionality(rawValue) {
  const value = rawValue?.toLowerCase() || "";
  if (value === "auto" && typeof navigator !== "undefined" && navigator?.language) {
    return RTL_LOCALE_PATTERN.test(navigator.language) ? "rtl" : "ltr";
  }
  return value === "rtl" ? "rtl" : "ltr";
}
__name(_resolveDirectionality, "_resolveDirectionality");
var _Directionality = class _Directionality {
  /** The current 'ltr' or 'rtl' value. */
  get value() {
    return this.valueSignal();
  }
  /**
   * The current 'ltr' or 'rtl' value.
   */
  valueSignal = signal("ltr", ...ngDevMode ? [{
    debugName: "valueSignal"
  }] : []);
  /** Stream that emits whenever the 'ltr' / 'rtl' state changes. */
  change = new EventEmitter();
  constructor() {
    const _document = inject(DIR_DOCUMENT, {
      optional: true
    });
    if (_document) {
      const bodyDir = _document.body ? _document.body.dir : null;
      const htmlDir = _document.documentElement ? _document.documentElement.dir : null;
      this.valueSignal.set(_resolveDirectionality(bodyDir || htmlDir || "ltr"));
    }
  }
  ngOnDestroy() {
    this.change.complete();
  }
};
__name(_Directionality, "Directionality");
__publicField(_Directionality, "\u0275fac", /* @__PURE__ */ __name(function Directionality_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _Directionality)();
}, "Directionality_Factory"));
__publicField(_Directionality, "\u0275prov", /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _Directionality,
  factory: _Directionality.\u0275fac,
  providedIn: "root"
}));
var Directionality = _Directionality;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Directionality, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();

// node_modules/@angular/cdk/fesm2022/scrolling2.mjs
var RtlScrollAxisType;
(function(RtlScrollAxisType2) {
  RtlScrollAxisType2[RtlScrollAxisType2["NORMAL"] = 0] = "NORMAL";
  RtlScrollAxisType2[RtlScrollAxisType2["NEGATED"] = 1] = "NEGATED";
  RtlScrollAxisType2[RtlScrollAxisType2["INVERTED"] = 2] = "INVERTED";
})(RtlScrollAxisType || (RtlScrollAxisType = {}));
var rtlScrollAxisType;
var scrollBehaviorSupported;
function supportsScrollBehavior() {
  if (scrollBehaviorSupported == null) {
    if (typeof document !== "object" || !document || typeof Element !== "function" || !Element) {
      scrollBehaviorSupported = false;
      return scrollBehaviorSupported;
    }
    if ("scrollBehavior" in document.documentElement.style) {
      scrollBehaviorSupported = true;
    } else {
      const scrollToFunction = Element.prototype.scrollTo;
      if (scrollToFunction) {
        scrollBehaviorSupported = !/\{\s*\[native code\]\s*\}/.test(scrollToFunction.toString());
      } else {
        scrollBehaviorSupported = false;
      }
    }
  }
  return scrollBehaviorSupported;
}
__name(supportsScrollBehavior, "supportsScrollBehavior");
function getRtlScrollAxisType() {
  if (typeof document !== "object" || !document) {
    return RtlScrollAxisType.NORMAL;
  }
  if (rtlScrollAxisType == null) {
    const scrollContainer = document.createElement("div");
    const containerStyle = scrollContainer.style;
    scrollContainer.dir = "rtl";
    containerStyle.width = "1px";
    containerStyle.overflow = "auto";
    containerStyle.visibility = "hidden";
    containerStyle.pointerEvents = "none";
    containerStyle.position = "absolute";
    const content = document.createElement("div");
    const contentStyle = content.style;
    contentStyle.width = "2px";
    contentStyle.height = "1px";
    scrollContainer.appendChild(content);
    document.body.appendChild(scrollContainer);
    rtlScrollAxisType = RtlScrollAxisType.NORMAL;
    if (scrollContainer.scrollLeft === 0) {
      scrollContainer.scrollLeft = 1;
      rtlScrollAxisType = scrollContainer.scrollLeft === 0 ? RtlScrollAxisType.NEGATED : RtlScrollAxisType.INVERTED;
    }
    scrollContainer.remove();
  }
  return rtlScrollAxisType;
}
__name(getRtlScrollAxisType, "getRtlScrollAxisType");

// node_modules/@angular/cdk/fesm2022/bidi.mjs
var _Dir = class _Dir {
  /** Whether the `value` has been set to its initial value. */
  _isInitialized = false;
  /** Direction as passed in by the consumer. */
  _rawDir;
  /** Event emitted when the direction changes. */
  change = new EventEmitter();
  /** @docs-private */
  get dir() {
    return this.valueSignal();
  }
  set dir(value) {
    const previousValue = this.valueSignal();
    this.valueSignal.set(_resolveDirectionality(value));
    this._rawDir = value;
    if (previousValue !== this.valueSignal() && this._isInitialized) {
      this.change.emit(this.valueSignal());
    }
  }
  /** Current layout direction of the element. */
  get value() {
    return this.dir;
  }
  valueSignal = signal("ltr", ...ngDevMode ? [{
    debugName: "valueSignal"
  }] : []);
  /** Initialize once default value has been set. */
  ngAfterContentInit() {
    this._isInitialized = true;
  }
  ngOnDestroy() {
    this.change.complete();
  }
};
__name(_Dir, "Dir");
__publicField(_Dir, "\u0275fac", /* @__PURE__ */ __name(function Dir_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _Dir)();
}, "Dir_Factory"));
__publicField(_Dir, "\u0275dir", /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _Dir,
  selectors: [["", "dir", ""]],
  hostVars: 1,
  hostBindings: /* @__PURE__ */ __name(function Dir_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("dir", ctx._rawDir);
    }
  }, "Dir_HostBindings"),
  inputs: {
    dir: "dir"
  },
  outputs: {
    change: "dirChange"
  },
  exportAs: ["dir"],
  features: [\u0275\u0275ProvidersFeature([{
    provide: Directionality,
    useExisting: _Dir
  }])]
}));
var Dir = _Dir;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Dir, [{
    type: Directive,
    args: [{
      selector: "[dir]",
      providers: [{
        provide: Directionality,
        useExisting: Dir
      }],
      host: {
        "[attr.dir]": "_rawDir"
      },
      exportAs: "dir"
    }]
  }], null, {
    change: [{
      type: Output,
      args: ["dirChange"]
    }],
    dir: [{
      type: Input
    }]
  });
})();
var _BidiModule = class _BidiModule {
};
__name(_BidiModule, "BidiModule");
__publicField(_BidiModule, "\u0275fac", /* @__PURE__ */ __name(function BidiModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _BidiModule)();
}, "BidiModule_Factory"));
__publicField(_BidiModule, "\u0275mod", /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _BidiModule,
  imports: [Dir],
  exports: [Dir]
}));
__publicField(_BidiModule, "\u0275inj", /* @__PURE__ */ \u0275\u0275defineInjector({}));
var BidiModule = _BidiModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BidiModule, [{
    type: NgModule,
    args: [{
      imports: [Dir],
      exports: [Dir]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/data-source.mjs
var _DataSource = class _DataSource {
};
__name(_DataSource, "DataSource");
var DataSource = _DataSource;
function isDataSource(value) {
  return value && typeof value.connect === "function" && !(value instanceof ConnectableObservable);
}
__name(isDataSource, "isDataSource");

// node_modules/@angular/cdk/fesm2022/recycle-view-repeater-strategy.mjs
var _ArrayDataSource = class _ArrayDataSource extends DataSource {
  _data;
  constructor(_data) {
    super();
    this._data = _data;
  }
  connect() {
    return isObservable(this._data) ? this._data : of(this._data);
  }
  disconnect() {
  }
};
__name(_ArrayDataSource, "ArrayDataSource");
var ArrayDataSource = _ArrayDataSource;
var _ViewRepeaterOperation;
(function(_ViewRepeaterOperation2) {
  _ViewRepeaterOperation2[_ViewRepeaterOperation2["REPLACED"] = 0] = "REPLACED";
  _ViewRepeaterOperation2[_ViewRepeaterOperation2["INSERTED"] = 1] = "INSERTED";
  _ViewRepeaterOperation2[_ViewRepeaterOperation2["MOVED"] = 2] = "MOVED";
  _ViewRepeaterOperation2[_ViewRepeaterOperation2["REMOVED"] = 3] = "REMOVED";
})(_ViewRepeaterOperation || (_ViewRepeaterOperation = {}));
var _VIEW_REPEATER_STRATEGY = new InjectionToken("_ViewRepeater");
var __RecycleViewRepeaterStrategy = class __RecycleViewRepeaterStrategy {
  /**
   * The size of the cache used to store unused views.
   * Setting the cache size to `0` will disable caching. Defaults to 20 views.
   */
  viewCacheSize = 20;
  /**
   * View cache that stores embedded view instances that have been previously stamped out,
   * but don't are not currently rendered. The view repeater will reuse these views rather than
   * creating brand new ones.
   *
   * TODO(michaeljamesparsons) Investigate whether using a linked list would improve performance.
   */
  _viewCache = [];
  /** Apply changes to the DOM. */
  applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {
    changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {
      let view;
      let operation;
      if (record.previousIndex == null) {
        const viewArgsFactory = /* @__PURE__ */ __name(() => itemContextFactory(record, adjustedPreviousIndex, currentIndex), "viewArgsFactory");
        view = this._insertView(viewArgsFactory, currentIndex, viewContainerRef, itemValueResolver(record));
        operation = view ? _ViewRepeaterOperation.INSERTED : _ViewRepeaterOperation.REPLACED;
      } else if (currentIndex == null) {
        this._detachAndCacheView(adjustedPreviousIndex, viewContainerRef);
        operation = _ViewRepeaterOperation.REMOVED;
      } else {
        view = this._moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, itemValueResolver(record));
        operation = _ViewRepeaterOperation.MOVED;
      }
      if (itemViewChanged) {
        itemViewChanged({
          context: view?.context,
          operation,
          record
        });
      }
    });
  }
  detach() {
    for (const view of this._viewCache) {
      view.destroy();
    }
    this._viewCache = [];
  }
  /**
   * Inserts a view for a new item, either from the cache or by creating a new
   * one. Returns `undefined` if the item was inserted into a cached view.
   */
  _insertView(viewArgsFactory, currentIndex, viewContainerRef, value) {
    const cachedView = this._insertViewFromCache(currentIndex, viewContainerRef);
    if (cachedView) {
      cachedView.context.$implicit = value;
      return void 0;
    }
    const viewArgs = viewArgsFactory();
    return viewContainerRef.createEmbeddedView(viewArgs.templateRef, viewArgs.context, viewArgs.index);
  }
  /** Detaches the view at the given index and inserts into the view cache. */
  _detachAndCacheView(index, viewContainerRef) {
    const detachedView = viewContainerRef.detach(index);
    this._maybeCacheView(detachedView, viewContainerRef);
  }
  /** Moves view at the previous index to the current index. */
  _moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, value) {
    const view = viewContainerRef.get(adjustedPreviousIndex);
    viewContainerRef.move(view, currentIndex);
    view.context.$implicit = value;
    return view;
  }
  /**
   * Cache the given detached view. If the cache is full, the view will be
   * destroyed.
   */
  _maybeCacheView(view, viewContainerRef) {
    if (this._viewCache.length < this.viewCacheSize) {
      this._viewCache.push(view);
    } else {
      const index = viewContainerRef.indexOf(view);
      if (index === -1) {
        view.destroy();
      } else {
        viewContainerRef.remove(index);
      }
    }
  }
  /** Inserts a recycled view from the cache at the given index. */
  _insertViewFromCache(index, viewContainerRef) {
    const cachedView = this._viewCache.pop();
    if (cachedView) {
      viewContainerRef.insert(cachedView, index);
    }
    return cachedView || null;
  }
};
__name(__RecycleViewRepeaterStrategy, "_RecycleViewRepeaterStrategy");
var _RecycleViewRepeaterStrategy = __RecycleViewRepeaterStrategy;

// node_modules/@angular/cdk/fesm2022/scrolling.mjs
var _c0 = ["contentWrapper"];
var _c1 = ["*"];
var VIRTUAL_SCROLL_STRATEGY = new InjectionToken("VIRTUAL_SCROLL_STRATEGY");
var _FixedSizeVirtualScrollStrategy = class _FixedSizeVirtualScrollStrategy {
  _scrolledIndexChange = new Subject();
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  scrolledIndexChange = this._scrolledIndexChange.pipe(distinctUntilChanged());
  /** The attached viewport. */
  _viewport = null;
  /** The size of the items in the virtually scrolling list. */
  _itemSize;
  /** The minimum amount of buffer rendered beyond the viewport (in pixels). */
  _minBufferPx;
  /** The number of buffer items to render beyond the edge of the viewport (in pixels). */
  _maxBufferPx;
  /**
   * @param itemSize The size of the items in the virtually scrolling list.
   * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more
   * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.
   */
  constructor(itemSize, minBufferPx, maxBufferPx) {
    this._itemSize = itemSize;
    this._minBufferPx = minBufferPx;
    this._maxBufferPx = maxBufferPx;
  }
  /**
   * Attaches this scroll strategy to a viewport.
   * @param viewport The viewport to attach this strategy to.
   */
  attach(viewport) {
    this._viewport = viewport;
    this._updateTotalContentSize();
    this._updateRenderedRange();
  }
  /** Detaches this scroll strategy from the currently attached viewport. */
  detach() {
    this._scrolledIndexChange.complete();
    this._viewport = null;
  }
  /**
   * Update the item size and buffer size.
   * @param itemSize The size of the items in the virtually scrolling list.
   * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more
   * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.
   */
  updateItemAndBufferSize(itemSize, minBufferPx, maxBufferPx) {
    if (maxBufferPx < minBufferPx && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx");
    }
    this._itemSize = itemSize;
    this._minBufferPx = minBufferPx;
    this._maxBufferPx = maxBufferPx;
    this._updateTotalContentSize();
    this._updateRenderedRange();
  }
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  onContentScrolled() {
    this._updateRenderedRange();
  }
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  onDataLengthChanged() {
    this._updateTotalContentSize();
    this._updateRenderedRange();
  }
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  onContentRendered() {
  }
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  onRenderedOffsetChanged() {
  }
  /**
   * Scroll to the offset for the given index.
   * @param index The index of the element to scroll to.
   * @param behavior The ScrollBehavior to use when scrolling.
   */
  scrollToIndex(index, behavior) {
    if (this._viewport) {
      this._viewport.scrollToOffset(index * this._itemSize, behavior);
    }
  }
  /** Update the viewport's total content size. */
  _updateTotalContentSize() {
    if (!this._viewport) {
      return;
    }
    this._viewport.setTotalContentSize(this._viewport.getDataLength() * this._itemSize);
  }
  /** Update the viewport's rendered range. */
  _updateRenderedRange() {
    if (!this._viewport) {
      return;
    }
    const renderedRange = this._viewport.getRenderedRange();
    const newRange = {
      start: renderedRange.start,
      end: renderedRange.end
    };
    const viewportSize = this._viewport.getViewportSize();
    const dataLength = this._viewport.getDataLength();
    let scrollOffset = this._viewport.measureScrollOffset();
    let firstVisibleIndex = this._itemSize > 0 ? scrollOffset / this._itemSize : 0;
    if (newRange.end > dataLength) {
      const maxVisibleItems = Math.ceil(viewportSize / this._itemSize);
      const newVisibleIndex = Math.max(0, Math.min(firstVisibleIndex, dataLength - maxVisibleItems));
      if (firstVisibleIndex != newVisibleIndex) {
        firstVisibleIndex = newVisibleIndex;
        scrollOffset = newVisibleIndex * this._itemSize;
        newRange.start = Math.floor(firstVisibleIndex);
      }
      newRange.end = Math.max(0, Math.min(dataLength, newRange.start + maxVisibleItems));
    }
    const startBuffer = scrollOffset - newRange.start * this._itemSize;
    if (startBuffer < this._minBufferPx && newRange.start != 0) {
      const expandStart = Math.ceil((this._maxBufferPx - startBuffer) / this._itemSize);
      newRange.start = Math.max(0, newRange.start - expandStart);
      newRange.end = Math.min(dataLength, Math.ceil(firstVisibleIndex + (viewportSize + this._minBufferPx) / this._itemSize));
    } else {
      const endBuffer = newRange.end * this._itemSize - (scrollOffset + viewportSize);
      if (endBuffer < this._minBufferPx && newRange.end != dataLength) {
        const expandEnd = Math.ceil((this._maxBufferPx - endBuffer) / this._itemSize);
        if (expandEnd > 0) {
          newRange.end = Math.min(dataLength, newRange.end + expandEnd);
          newRange.start = Math.max(0, Math.floor(firstVisibleIndex - this._minBufferPx / this._itemSize));
        }
      }
    }
    this._viewport.setRenderedRange(newRange);
    this._viewport.setRenderedContentOffset(this._itemSize * newRange.start);
    this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));
  }
};
__name(_FixedSizeVirtualScrollStrategy, "FixedSizeVirtualScrollStrategy");
var FixedSizeVirtualScrollStrategy = _FixedSizeVirtualScrollStrategy;
function _fixedSizeVirtualScrollStrategyFactory(fixedSizeDir) {
  return fixedSizeDir._scrollStrategy;
}
__name(_fixedSizeVirtualScrollStrategyFactory, "_fixedSizeVirtualScrollStrategyFactory");
var _CdkFixedSizeVirtualScroll = class _CdkFixedSizeVirtualScroll {
  /** The size of the items in the list (in pixels). */
  get itemSize() {
    return this._itemSize;
  }
  set itemSize(value) {
    this._itemSize = coerceNumberProperty(value);
  }
  _itemSize = 20;
  /**
   * The minimum amount of buffer rendered beyond the viewport (in pixels).
   * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.
   */
  get minBufferPx() {
    return this._minBufferPx;
  }
  set minBufferPx(value) {
    this._minBufferPx = coerceNumberProperty(value);
  }
  _minBufferPx = 100;
  /**
   * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.
   */
  get maxBufferPx() {
    return this._maxBufferPx;
  }
  set maxBufferPx(value) {
    this._maxBufferPx = coerceNumberProperty(value);
  }
  _maxBufferPx = 200;
  /** The scroll strategy used by this directive. */
  _scrollStrategy = new FixedSizeVirtualScrollStrategy(this.itemSize, this.minBufferPx, this.maxBufferPx);
  ngOnChanges() {
    this._scrollStrategy.updateItemAndBufferSize(this.itemSize, this.minBufferPx, this.maxBufferPx);
  }
};
__name(_CdkFixedSizeVirtualScroll, "CdkFixedSizeVirtualScroll");
__publicField(_CdkFixedSizeVirtualScroll, "\u0275fac", /* @__PURE__ */ __name(function CdkFixedSizeVirtualScroll_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _CdkFixedSizeVirtualScroll)();
}, "CdkFixedSizeVirtualScroll_Factory"));
__publicField(_CdkFixedSizeVirtualScroll, "\u0275dir", /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _CdkFixedSizeVirtualScroll,
  selectors: [["cdk-virtual-scroll-viewport", "itemSize", ""]],
  inputs: {
    itemSize: "itemSize",
    minBufferPx: "minBufferPx",
    maxBufferPx: "maxBufferPx"
  },
  features: [\u0275\u0275ProvidersFeature([{
    provide: VIRTUAL_SCROLL_STRATEGY,
    useFactory: _fixedSizeVirtualScrollStrategyFactory,
    deps: [forwardRef(() => _CdkFixedSizeVirtualScroll)]
  }]), \u0275\u0275NgOnChangesFeature]
}));
var CdkFixedSizeVirtualScroll = _CdkFixedSizeVirtualScroll;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkFixedSizeVirtualScroll, [{
    type: Directive,
    args: [{
      selector: "cdk-virtual-scroll-viewport[itemSize]",
      providers: [{
        provide: VIRTUAL_SCROLL_STRATEGY,
        useFactory: _fixedSizeVirtualScrollStrategyFactory,
        deps: [forwardRef(() => CdkFixedSizeVirtualScroll)]
      }]
    }]
  }], null, {
    itemSize: [{
      type: Input
    }],
    minBufferPx: [{
      type: Input
    }],
    maxBufferPx: [{
      type: Input
    }]
  });
})();
var DEFAULT_SCROLL_TIME = 20;
var _ScrollDispatcher = class _ScrollDispatcher {
  _ngZone = inject(NgZone);
  _platform = inject(Platform);
  _renderer = inject(RendererFactory2).createRenderer(null, null);
  _cleanupGlobalListener;
  constructor() {
  }
  /** Subject for notifying that a registered scrollable reference element has been scrolled. */
  _scrolled = new Subject();
  /** Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards. */
  _scrolledCount = 0;
  /**
   * Map of all the scrollable references that are registered with the service and their
   * scroll event subscriptions.
   */
  scrollContainers = /* @__PURE__ */ new Map();
  /**
   * Registers a scrollable instance with the service and listens for its scrolled events. When the
   * scrollable is scrolled, the service emits the event to its scrolled observable.
   * @param scrollable Scrollable instance to be registered.
   */
  register(scrollable) {
    if (!this.scrollContainers.has(scrollable)) {
      this.scrollContainers.set(scrollable, scrollable.elementScrolled().subscribe(() => this._scrolled.next(scrollable)));
    }
  }
  /**
   * De-registers a Scrollable reference and unsubscribes from its scroll event observable.
   * @param scrollable Scrollable instance to be deregistered.
   */
  deregister(scrollable) {
    const scrollableReference = this.scrollContainers.get(scrollable);
    if (scrollableReference) {
      scrollableReference.unsubscribe();
      this.scrollContainers.delete(scrollable);
    }
  }
  /**
   * Returns an observable that emits an event whenever any of the registered Scrollable
   * references (or window, document, or body) fire a scrolled event. Can provide a time in ms
   * to override the default "throttle" time.
   *
   * **Note:** in order to avoid hitting change detection for every scroll event,
   * all of the events emitted from this stream will be run outside the Angular zone.
   * If you need to update any data bindings as a result of a scroll event, you have
   * to run the callback using `NgZone.run`.
   */
  scrolled(auditTimeInMs = DEFAULT_SCROLL_TIME) {
    if (!this._platform.isBrowser) {
      return of();
    }
    return new Observable((observer) => {
      if (!this._cleanupGlobalListener) {
        this._cleanupGlobalListener = this._ngZone.runOutsideAngular(() => this._renderer.listen("document", "scroll", () => this._scrolled.next()));
      }
      const subscription = auditTimeInMs > 0 ? this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer) : this._scrolled.subscribe(observer);
      this._scrolledCount++;
      return () => {
        subscription.unsubscribe();
        this._scrolledCount--;
        if (!this._scrolledCount) {
          this._cleanupGlobalListener?.();
          this._cleanupGlobalListener = void 0;
        }
      };
    });
  }
  ngOnDestroy() {
    this._cleanupGlobalListener?.();
    this._cleanupGlobalListener = void 0;
    this.scrollContainers.forEach((_, container) => this.deregister(container));
    this._scrolled.complete();
  }
  /**
   * Returns an observable that emits whenever any of the
   * scrollable ancestors of an element are scrolled.
   * @param elementOrElementRef Element whose ancestors to listen for.
   * @param auditTimeInMs Time to throttle the scroll events.
   */
  ancestorScrolled(elementOrElementRef, auditTimeInMs) {
    const ancestors = this.getAncestorScrollContainers(elementOrElementRef);
    return this.scrolled(auditTimeInMs).pipe(filter((target) => !target || ancestors.indexOf(target) > -1));
  }
  /** Returns all registered Scrollables that contain the provided element. */
  getAncestorScrollContainers(elementOrElementRef) {
    const scrollingContainers = [];
    this.scrollContainers.forEach((_subscription, scrollable) => {
      if (this._scrollableContainsElement(scrollable, elementOrElementRef)) {
        scrollingContainers.push(scrollable);
      }
    });
    return scrollingContainers;
  }
  /** Returns true if the element is contained within the provided Scrollable. */
  _scrollableContainsElement(scrollable, elementOrElementRef) {
    let element = coerceElement(elementOrElementRef);
    let scrollableElement = scrollable.getElementRef().nativeElement;
    do {
      if (element == scrollableElement) {
        return true;
      }
    } while (element = element.parentElement);
    return false;
  }
};
__name(_ScrollDispatcher, "ScrollDispatcher");
__publicField(_ScrollDispatcher, "\u0275fac", /* @__PURE__ */ __name(function ScrollDispatcher_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ScrollDispatcher)();
}, "ScrollDispatcher_Factory"));
__publicField(_ScrollDispatcher, "\u0275prov", /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _ScrollDispatcher,
  factory: _ScrollDispatcher.\u0275fac,
  providedIn: "root"
}));
var ScrollDispatcher = _ScrollDispatcher;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var _CdkScrollable = class _CdkScrollable {
  elementRef = inject(ElementRef);
  scrollDispatcher = inject(ScrollDispatcher);
  ngZone = inject(NgZone);
  dir = inject(Directionality, {
    optional: true
  });
  _scrollElement = this.elementRef.nativeElement;
  _destroyed = new Subject();
  _renderer = inject(Renderer2);
  _cleanupScroll;
  _elementScrolled = new Subject();
  constructor() {
  }
  ngOnInit() {
    this._cleanupScroll = this.ngZone.runOutsideAngular(() => this._renderer.listen(this._scrollElement, "scroll", (event) => this._elementScrolled.next(event)));
    this.scrollDispatcher.register(this);
  }
  ngOnDestroy() {
    this._cleanupScroll?.();
    this._elementScrolled.complete();
    this.scrollDispatcher.deregister(this);
    this._destroyed.next();
    this._destroyed.complete();
  }
  /** Returns observable that emits when a scroll event is fired on the host element. */
  elementScrolled() {
    return this._elementScrolled;
  }
  /** Gets the ElementRef for the viewport. */
  getElementRef() {
    return this.elementRef;
  }
  /**
   * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
   * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
   * left and right always refer to the left and right side of the scrolling container irrespective
   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
   * in an RTL context.
   * @param options specified the offsets to scroll to.
   */
  scrollTo(options) {
    const el = this.elementRef.nativeElement;
    const isRtl = this.dir && this.dir.value == "rtl";
    if (options.left == null) {
      options.left = isRtl ? options.end : options.start;
    }
    if (options.right == null) {
      options.right = isRtl ? options.start : options.end;
    }
    if (options.bottom != null) {
      options.top = el.scrollHeight - el.clientHeight - options.bottom;
    }
    if (isRtl && getRtlScrollAxisType() != RtlScrollAxisType.NORMAL) {
      if (options.left != null) {
        options.right = el.scrollWidth - el.clientWidth - options.left;
      }
      if (getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {
        options.left = options.right;
      } else if (getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {
        options.left = options.right ? -options.right : options.right;
      }
    } else {
      if (options.right != null) {
        options.left = el.scrollWidth - el.clientWidth - options.right;
      }
    }
    this._applyScrollToOptions(options);
  }
  _applyScrollToOptions(options) {
    const el = this.elementRef.nativeElement;
    if (supportsScrollBehavior()) {
      el.scrollTo(options);
    } else {
      if (options.top != null) {
        el.scrollTop = options.top;
      }
      if (options.left != null) {
        el.scrollLeft = options.left;
      }
    }
  }
  /**
   * Measures the scroll offset relative to the specified edge of the viewport. This method can be
   * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent
   * about what scrollLeft means in RTL. The values returned by this method are normalized such that
   * left and right always refer to the left and right side of the scrolling container irrespective
   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
   * in an RTL context.
   * @param from The edge to measure from.
   */
  measureScrollOffset(from) {
    const LEFT = "left";
    const RIGHT = "right";
    const el = this.elementRef.nativeElement;
    if (from == "top") {
      return el.scrollTop;
    }
    if (from == "bottom") {
      return el.scrollHeight - el.clientHeight - el.scrollTop;
    }
    const isRtl = this.dir && this.dir.value == "rtl";
    if (from == "start") {
      from = isRtl ? RIGHT : LEFT;
    } else if (from == "end") {
      from = isRtl ? LEFT : RIGHT;
    }
    if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {
      if (from == LEFT) {
        return el.scrollWidth - el.clientWidth - el.scrollLeft;
      } else {
        return el.scrollLeft;
      }
    } else if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {
      if (from == LEFT) {
        return el.scrollLeft + el.scrollWidth - el.clientWidth;
      } else {
        return -el.scrollLeft;
      }
    } else {
      if (from == LEFT) {
        return el.scrollLeft;
      } else {
        return el.scrollWidth - el.clientWidth - el.scrollLeft;
      }
    }
  }
};
__name(_CdkScrollable, "CdkScrollable");
__publicField(_CdkScrollable, "\u0275fac", /* @__PURE__ */ __name(function CdkScrollable_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _CdkScrollable)();
}, "CdkScrollable_Factory"));
__publicField(_CdkScrollable, "\u0275dir", /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _CdkScrollable,
  selectors: [["", "cdk-scrollable", ""], ["", "cdkScrollable", ""]]
}));
var CdkScrollable = _CdkScrollable;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkScrollable, [{
    type: Directive,
    args: [{
      selector: "[cdk-scrollable], [cdkScrollable]"
    }]
  }], () => [], null);
})();
var DEFAULT_RESIZE_TIME = 20;
var _ViewportRuler = class _ViewportRuler {
  _platform = inject(Platform);
  _listeners;
  /** Cached viewport dimensions. */
  _viewportSize;
  /** Stream of viewport change events. */
  _change = new Subject();
  /** Used to reference correct document/window */
  _document = inject(DOCUMENT);
  constructor() {
    const ngZone = inject(NgZone);
    const renderer = inject(RendererFactory2).createRenderer(null, null);
    ngZone.runOutsideAngular(() => {
      if (this._platform.isBrowser) {
        const changeListener = /* @__PURE__ */ __name((event) => this._change.next(event), "changeListener");
        this._listeners = [renderer.listen("window", "resize", changeListener), renderer.listen("window", "orientationchange", changeListener)];
      }
      this.change().subscribe(() => this._viewportSize = null);
    });
  }
  ngOnDestroy() {
    this._listeners?.forEach((cleanup) => cleanup());
    this._change.complete();
  }
  /** Returns the viewport's width and height. */
  getViewportSize() {
    if (!this._viewportSize) {
      this._updateViewportSize();
    }
    const output = {
      width: this._viewportSize.width,
      height: this._viewportSize.height
    };
    if (!this._platform.isBrowser) {
      this._viewportSize = null;
    }
    return output;
  }
  /** Gets a DOMRect for the viewport's bounds. */
  getViewportRect() {
    const scrollPosition = this.getViewportScrollPosition();
    const {
      width,
      height
    } = this.getViewportSize();
    return {
      top: scrollPosition.top,
      left: scrollPosition.left,
      bottom: scrollPosition.top + height,
      right: scrollPosition.left + width,
      height,
      width
    };
  }
  /** Gets the (top, left) scroll position of the viewport. */
  getViewportScrollPosition() {
    if (!this._platform.isBrowser) {
      return {
        top: 0,
        left: 0
      };
    }
    const document2 = this._document;
    const window2 = this._getWindow();
    const documentElement = document2.documentElement;
    const documentRect = documentElement.getBoundingClientRect();
    const top = -documentRect.top || document2.body.scrollTop || window2.scrollY || documentElement.scrollTop || 0;
    const left = -documentRect.left || document2.body.scrollLeft || window2.scrollX || documentElement.scrollLeft || 0;
    return {
      top,
      left
    };
  }
  /**
   * Returns a stream that emits whenever the size of the viewport changes.
   * This stream emits outside of the Angular zone.
   * @param throttleTime Time in milliseconds to throttle the stream.
   */
  change(throttleTime = DEFAULT_RESIZE_TIME) {
    return throttleTime > 0 ? this._change.pipe(auditTime(throttleTime)) : this._change;
  }
  /** Use defaultView of injected document if available or fallback to global window reference */
  _getWindow() {
    return this._document.defaultView || window;
  }
  /** Updates the cached viewport size. */
  _updateViewportSize() {
    const window2 = this._getWindow();
    this._viewportSize = this._platform.isBrowser ? {
      width: window2.innerWidth,
      height: window2.innerHeight
    } : {
      width: 0,
      height: 0
    };
  }
};
__name(_ViewportRuler, "ViewportRuler");
__publicField(_ViewportRuler, "\u0275fac", /* @__PURE__ */ __name(function ViewportRuler_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ViewportRuler)();
}, "ViewportRuler_Factory"));
__publicField(_ViewportRuler, "\u0275prov", /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _ViewportRuler,
  factory: _ViewportRuler.\u0275fac,
  providedIn: "root"
}));
var ViewportRuler = _ViewportRuler;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ViewportRuler, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var VIRTUAL_SCROLLABLE = new InjectionToken("VIRTUAL_SCROLLABLE");
var _CdkVirtualScrollable = class _CdkVirtualScrollable extends CdkScrollable {
  constructor() {
    super();
  }
  /**
   * Measure the viewport size for the provided orientation.
   *
   * @param orientation The orientation to measure the size from.
   */
  measureViewportSize(orientation) {
    const viewportEl = this.elementRef.nativeElement;
    return orientation === "horizontal" ? viewportEl.clientWidth : viewportEl.clientHeight;
  }
};
__name(_CdkVirtualScrollable, "CdkVirtualScrollable");
__publicField(_CdkVirtualScrollable, "\u0275fac", /* @__PURE__ */ __name(function CdkVirtualScrollable_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _CdkVirtualScrollable)();
}, "CdkVirtualScrollable_Factory"));
__publicField(_CdkVirtualScrollable, "\u0275dir", /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _CdkVirtualScrollable,
  features: [\u0275\u0275InheritDefinitionFeature]
}));
var CdkVirtualScrollable = _CdkVirtualScrollable;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollable, [{
    type: Directive
  }], () => [], null);
})();
function rangesEqual(r1, r2) {
  return r1.start == r2.start && r1.end == r2.end;
}
__name(rangesEqual, "rangesEqual");
var SCROLL_SCHEDULER = typeof requestAnimationFrame !== "undefined" ? animationFrameScheduler : asapScheduler;
var _CdkVirtualScrollViewport = class _CdkVirtualScrollViewport extends CdkVirtualScrollable {
  elementRef = inject(ElementRef);
  _changeDetectorRef = inject(ChangeDetectorRef);
  _scrollStrategy = inject(VIRTUAL_SCROLL_STRATEGY, {
    optional: true
  });
  scrollable = inject(VIRTUAL_SCROLLABLE, {
    optional: true
  });
  _platform = inject(Platform);
  /** Emits when the viewport is detached from a CdkVirtualForOf. */
  _detachedSubject = new Subject();
  /** Emits when the rendered range changes. */
  _renderedRangeSubject = new Subject();
  /** The direction the viewport scrolls. */
  get orientation() {
    return this._orientation;
  }
  set orientation(orientation) {
    if (this._orientation !== orientation) {
      this._orientation = orientation;
      this._calculateSpacerSize();
    }
  }
  _orientation = "vertical";
  /**
   * Whether rendered items should persist in the DOM after scrolling out of view. By default, items
   * will be removed.
   */
  appendOnly = false;
  // Note: we don't use the typical EventEmitter here because we need to subscribe to the scroll
  // strategy lazily (i.e. only if the user is actually listening to the events). We do this because
  // depending on how the strategy calculates the scrolled index, it may come at a cost to
  // performance.
  /** Emits when the index of the first element visible in the viewport changes. */
  scrolledIndexChange = new Observable((observer) => this._scrollStrategy.scrolledIndexChange.subscribe((index) => Promise.resolve().then(() => this.ngZone.run(() => observer.next(index)))));
  /** The element that wraps the rendered content. */
  _contentWrapper;
  /** A stream that emits whenever the rendered range changes. */
  renderedRangeStream = this._renderedRangeSubject;
  /**
   * The total size of all content (in pixels), including content that is not currently rendered.
   */
  _totalContentSize = 0;
  /** A string representing the `style.width` property value to be used for the spacer element. */
  _totalContentWidth = signal("", ...ngDevMode ? [{
    debugName: "_totalContentWidth"
  }] : []);
  /** A string representing the `style.height` property value to be used for the spacer element. */
  _totalContentHeight = signal("", ...ngDevMode ? [{
    debugName: "_totalContentHeight"
  }] : []);
  /**
   * The CSS transform applied to the rendered subset of items so that they appear within the bounds
   * of the visible viewport.
   */
  _renderedContentTransform;
  /** The currently rendered range of indices. */
  _renderedRange = {
    start: 0,
    end: 0
  };
  /** The length of the data bound to this viewport (in number of items). */
  _dataLength = 0;
  /** The size of the viewport (in pixels). */
  _viewportSize = 0;
  /** the currently attached CdkVirtualScrollRepeater. */
  _forOf;
  /** The last rendered content offset that was set. */
  _renderedContentOffset = 0;
  /**
   * Whether the last rendered content offset was to the end of the content (and therefore needs to
   * be rewritten as an offset to the start of the content).
   */
  _renderedContentOffsetNeedsRewrite = false;
  _changeDetectionNeeded = signal(false, ...ngDevMode ? [{
    debugName: "_changeDetectionNeeded"
  }] : []);
  /** A list of functions to run after the next change detection cycle. */
  _runAfterChangeDetection = [];
  /** Subscription to changes in the viewport size. */
  _viewportChanges = Subscription.EMPTY;
  _injector = inject(Injector);
  _isDestroyed = false;
  constructor() {
    super();
    const viewportRuler = inject(ViewportRuler);
    if (!this._scrollStrategy && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error('Error: cdk-virtual-scroll-viewport requires the "itemSize" property to be set.');
    }
    this._viewportChanges = viewportRuler.change().subscribe(() => {
      this.checkViewportSize();
    });
    if (!this.scrollable) {
      this.elementRef.nativeElement.classList.add("cdk-virtual-scrollable");
      this.scrollable = this;
    }
    const ref2 = effect(() => {
      if (this._changeDetectionNeeded()) {
        this._doChangeDetection();
      }
    }, ...ngDevMode ? [{
      debugName: "ref",
      injector: inject(ApplicationRef).injector
    }] : [
      // Using ApplicationRef injector is important here because we want this to be a root
      // effect that runs before change detection of any application views (since we're depending on markForCheck marking parents dirty)
      {
        injector: inject(ApplicationRef).injector
      }
    ]);
    inject(DestroyRef).onDestroy(() => void ref2.destroy());
  }
  ngOnInit() {
    if (!this._platform.isBrowser) {
      return;
    }
    if (this.scrollable === this) {
      super.ngOnInit();
    }
    this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {
      this._measureViewportSize();
      this._scrollStrategy.attach(this);
      this.scrollable.elementScrolled().pipe(
        // Start off with a fake scroll event so we properly detect our initial position.
        startWith(null),
        // Collect multiple events into one until the next animation frame. This way if
        // there are multiple scroll events in the same frame we only need to recheck
        // our layout once.
        auditTime(0, SCROLL_SCHEDULER),
        // Usually `elementScrolled` is completed when the scrollable is destroyed, but
        // that may not be the case if a `CdkVirtualScrollableElement` is used so we have
        // to unsubscribe here just in case.
        takeUntil(this._destroyed)
      ).subscribe(() => this._scrollStrategy.onContentScrolled());
      this._markChangeDetectionNeeded();
    }));
  }
  ngOnDestroy() {
    this.detach();
    this._scrollStrategy.detach();
    this._renderedRangeSubject.complete();
    this._detachedSubject.complete();
    this._viewportChanges.unsubscribe();
    this._isDestroyed = true;
    super.ngOnDestroy();
  }
  /** Attaches a `CdkVirtualScrollRepeater` to this viewport. */
  attach(forOf) {
    if (this._forOf && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("CdkVirtualScrollViewport is already attached.");
    }
    this.ngZone.runOutsideAngular(() => {
      this._forOf = forOf;
      this._forOf.dataStream.pipe(takeUntil(this._detachedSubject)).subscribe((data) => {
        const newLength = data.length;
        if (newLength !== this._dataLength) {
          this._dataLength = newLength;
          this._scrollStrategy.onDataLengthChanged();
        }
        this._doChangeDetection();
      });
    });
  }
  /** Detaches the current `CdkVirtualForOf`. */
  detach() {
    this._forOf = null;
    this._detachedSubject.next();
  }
  /** Gets the length of the data bound to this viewport (in number of items). */
  getDataLength() {
    return this._dataLength;
  }
  /** Gets the size of the viewport (in pixels). */
  getViewportSize() {
    return this._viewportSize;
  }
  // TODO(mmalerba): This is technically out of sync with what's really rendered until a render
  // cycle happens. I'm being careful to only call it after the render cycle is complete and before
  // setting it to something else, but its error prone and should probably be split into
  // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.
  /** Get the current rendered range of items. */
  getRenderedRange() {
    return this._renderedRange;
  }
  measureBoundingClientRectWithScrollOffset(from) {
    return this.getElementRef().nativeElement.getBoundingClientRect()[from];
  }
  /**
   * Sets the total size of all content (in pixels), including content that is not currently
   * rendered.
   */
  setTotalContentSize(size) {
    if (this._totalContentSize !== size) {
      this._totalContentSize = size;
      this._calculateSpacerSize();
      this._markChangeDetectionNeeded();
    }
  }
  /** Sets the currently rendered range of indices. */
  setRenderedRange(range) {
    if (!rangesEqual(this._renderedRange, range)) {
      if (this.appendOnly) {
        range = {
          start: 0,
          end: Math.max(this._renderedRange.end, range.end)
        };
      }
      this._renderedRangeSubject.next(this._renderedRange = range);
      this._markChangeDetectionNeeded(() => this._scrollStrategy.onContentRendered());
    }
  }
  /**
   * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).
   */
  getOffsetToRenderedContentStart() {
    return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;
  }
  /**
   * Sets the offset from the start of the viewport to either the start or end of the rendered data
   * (in pixels).
   */
  setRenderedContentOffset(offset, to = "to-start") {
    offset = this.appendOnly && to === "to-start" ? 0 : offset;
    const isRtl = this.dir && this.dir.value == "rtl";
    const isHorizontal = this.orientation == "horizontal";
    const axis = isHorizontal ? "X" : "Y";
    const axisDirection = isHorizontal && isRtl ? -1 : 1;
    let transform = `translate${axis}(${Number(axisDirection * offset)}px)`;
    this._renderedContentOffset = offset;
    if (to === "to-end") {
      transform += ` translate${axis}(-100%)`;
      this._renderedContentOffsetNeedsRewrite = true;
    }
    if (this._renderedContentTransform != transform) {
      this._renderedContentTransform = transform;
      this._markChangeDetectionNeeded(() => {
        if (this._renderedContentOffsetNeedsRewrite) {
          this._renderedContentOffset -= this.measureRenderedContentSize();
          this._renderedContentOffsetNeedsRewrite = false;
          this.setRenderedContentOffset(this._renderedContentOffset);
        } else {
          this._scrollStrategy.onRenderedOffsetChanged();
        }
      });
    }
  }
  /**
   * Scrolls to the given offset from the start of the viewport. Please note that this is not always
   * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left
   * direction, this would be the equivalent of setting a fictional `scrollRight` property.
   * @param offset The offset to scroll to.
   * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
   */
  scrollToOffset(offset, behavior = "auto") {
    const options = {
      behavior
    };
    if (this.orientation === "horizontal") {
      options.start = offset;
    } else {
      options.top = offset;
    }
    this.scrollable.scrollTo(options);
  }
  /**
   * Scrolls to the offset for the given index.
   * @param index The index of the element to scroll to.
   * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
   */
  scrollToIndex(index, behavior = "auto") {
    this._scrollStrategy.scrollToIndex(index, behavior);
  }
  /**
   * Gets the current scroll offset from the start of the scrollable (in pixels).
   * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'
   *     in horizontal mode.
   */
  measureScrollOffset(from) {
    let measureScrollOffset;
    if (this.scrollable == this) {
      measureScrollOffset = /* @__PURE__ */ __name((_from) => super.measureScrollOffset(_from), "measureScrollOffset");
    } else {
      measureScrollOffset = /* @__PURE__ */ __name((_from) => this.scrollable.measureScrollOffset(_from), "measureScrollOffset");
    }
    return Math.max(0, measureScrollOffset(from ?? (this.orientation === "horizontal" ? "start" : "top")) - this.measureViewportOffset());
  }
  /**
   * Measures the offset of the viewport from the scrolling container
   * @param from The edge to measure from.
   */
  measureViewportOffset(from) {
    let fromRect;
    const LEFT = "left";
    const RIGHT = "right";
    const isRtl = this.dir?.value == "rtl";
    if (from == "start") {
      fromRect = isRtl ? RIGHT : LEFT;
    } else if (from == "end") {
      fromRect = isRtl ? LEFT : RIGHT;
    } else if (from) {
      fromRect = from;
    } else {
      fromRect = this.orientation === "horizontal" ? "left" : "top";
    }
    const scrollerClientRect = this.scrollable.measureBoundingClientRectWithScrollOffset(fromRect);
    const viewportClientRect = this.elementRef.nativeElement.getBoundingClientRect()[fromRect];
    return viewportClientRect - scrollerClientRect;
  }
  /** Measure the combined size of all of the rendered items. */
  measureRenderedContentSize() {
    const contentEl = this._contentWrapper.nativeElement;
    return this.orientation === "horizontal" ? contentEl.offsetWidth : contentEl.offsetHeight;
  }
  /**
   * Measure the total combined size of the given range. Throws if the range includes items that are
   * not rendered.
   */
  measureRangeSize(range) {
    if (!this._forOf) {
      return 0;
    }
    return this._forOf.measureRangeSize(range, this.orientation);
  }
  /** Update the viewport dimensions and re-render. */
  checkViewportSize() {
    this._measureViewportSize();
    this._scrollStrategy.onDataLengthChanged();
  }
  /** Measure the viewport size. */
  _measureViewportSize() {
    this._viewportSize = this.scrollable.measureViewportSize(this.orientation);
  }
  /** Queue up change detection to run. */
  _markChangeDetectionNeeded(runAfter) {
    if (runAfter) {
      this._runAfterChangeDetection.push(runAfter);
    }
    if (untracked(this._changeDetectionNeeded)) {
      return;
    }
    this.ngZone.runOutsideAngular(() => {
      Promise.resolve().then(() => {
        this.ngZone.run(() => {
          this._changeDetectionNeeded.set(true);
        });
      });
    });
  }
  /** Run change detection. */
  _doChangeDetection() {
    if (this._isDestroyed) {
      return;
    }
    this.ngZone.run(() => {
      this._changeDetectorRef.markForCheck();
      this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform;
      afterNextRender(() => {
        this._changeDetectionNeeded.set(false);
        const runAfterChangeDetection = this._runAfterChangeDetection;
        this._runAfterChangeDetection = [];
        for (const fn of runAfterChangeDetection) {
          fn();
        }
      }, {
        injector: this._injector
      });
    });
  }
  /** Calculates the `style.width` and `style.height` for the spacer element. */
  _calculateSpacerSize() {
    this._totalContentHeight.set(this.orientation === "horizontal" ? "" : `${this._totalContentSize}px`);
    this._totalContentWidth.set(this.orientation === "horizontal" ? `${this._totalContentSize}px` : "");
  }
};
__name(_CdkVirtualScrollViewport, "CdkVirtualScrollViewport");
__publicField(_CdkVirtualScrollViewport, "\u0275fac", /* @__PURE__ */ __name(function CdkVirtualScrollViewport_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _CdkVirtualScrollViewport)();
}, "CdkVirtualScrollViewport_Factory"));
__publicField(_CdkVirtualScrollViewport, "\u0275cmp", /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _CdkVirtualScrollViewport,
  selectors: [["cdk-virtual-scroll-viewport"]],
  viewQuery: /* @__PURE__ */ __name(function CdkVirtualScrollViewport_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c0, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx._contentWrapper = _t.first);
    }
  }, "CdkVirtualScrollViewport_Query"),
  hostAttrs: [1, "cdk-virtual-scroll-viewport"],
  hostVars: 4,
  hostBindings: /* @__PURE__ */ __name(function CdkVirtualScrollViewport_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("cdk-virtual-scroll-orientation-horizontal", ctx.orientation === "horizontal")("cdk-virtual-scroll-orientation-vertical", ctx.orientation !== "horizontal");
    }
  }, "CdkVirtualScrollViewport_HostBindings"),
  inputs: {
    orientation: "orientation",
    appendOnly: [2, "appendOnly", "appendOnly", booleanAttribute]
  },
  outputs: {
    scrolledIndexChange: "scrolledIndexChange"
  },
  features: [\u0275\u0275ProvidersFeature([{
    provide: CdkScrollable,
    useFactory: /* @__PURE__ */ __name((virtualScrollable, viewport) => virtualScrollable || viewport, "useFactory"),
    deps: [[new Optional(), new Inject(VIRTUAL_SCROLLABLE)], _CdkVirtualScrollViewport]
  }]), \u0275\u0275InheritDefinitionFeature],
  ngContentSelectors: _c1,
  decls: 4,
  vars: 4,
  consts: [["contentWrapper", ""], [1, "cdk-virtual-scroll-content-wrapper"], [1, "cdk-virtual-scroll-spacer"]],
  template: /* @__PURE__ */ __name(function CdkVirtualScrollViewport_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275domElementStart(0, "div", 1, 0);
      \u0275\u0275projection(2);
      \u0275\u0275domElementEnd();
      \u0275\u0275domElement(3, "div", 2);
    }
    if (rf & 2) {
      \u0275\u0275advance(3);
      \u0275\u0275styleProp("width", ctx._totalContentWidth())("height", ctx._totalContentHeight());
    }
  }, "CdkVirtualScrollViewport_Template"),
  styles: ["cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}\n"],
  encapsulation: 2,
  changeDetection: 0
}));
var CdkVirtualScrollViewport = _CdkVirtualScrollViewport;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollViewport, [{
    type: Component,
    args: [{
      selector: "cdk-virtual-scroll-viewport",
      host: {
        "class": "cdk-virtual-scroll-viewport",
        "[class.cdk-virtual-scroll-orientation-horizontal]": 'orientation === "horizontal"',
        "[class.cdk-virtual-scroll-orientation-vertical]": 'orientation !== "horizontal"'
      },
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: CdkScrollable,
        useFactory: /* @__PURE__ */ __name((virtualScrollable, viewport) => virtualScrollable || viewport, "useFactory"),
        deps: [[new Optional(), new Inject(VIRTUAL_SCROLLABLE)], CdkVirtualScrollViewport]
      }],
      template: '<!--\n  Wrap the rendered content in an element that will be used to offset it based on the scroll\n  position.\n-->\n<div #contentWrapper class="cdk-virtual-scroll-content-wrapper">\n  <ng-content></ng-content>\n</div>\n<!--\n  Spacer used to force the scrolling container to the correct size for the *total* number of items\n  so that the scrollbar captures the size of the entire data set.\n-->\n<div class="cdk-virtual-scroll-spacer"\n     [style.width]="_totalContentWidth()" [style.height]="_totalContentHeight()"></div>\n',
      styles: ["cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}\n"]
    }]
  }], () => [], {
    orientation: [{
      type: Input
    }],
    appendOnly: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    scrolledIndexChange: [{
      type: Output
    }],
    _contentWrapper: [{
      type: ViewChild,
      args: ["contentWrapper", {
        static: true
      }]
    }]
  });
})();
function getOffset(orientation, direction, node) {
  const el = node;
  if (!el.getBoundingClientRect) {
    return 0;
  }
  const rect = el.getBoundingClientRect();
  if (orientation === "horizontal") {
    return direction === "start" ? rect.left : rect.right;
  }
  return direction === "start" ? rect.top : rect.bottom;
}
__name(getOffset, "getOffset");
var _CdkVirtualForOf = class _CdkVirtualForOf {
  _viewContainerRef = inject(ViewContainerRef);
  _template = inject(TemplateRef);
  _differs = inject(IterableDiffers);
  _viewRepeater = inject(_VIEW_REPEATER_STRATEGY);
  _viewport = inject(CdkVirtualScrollViewport, {
    skipSelf: true
  });
  /** Emits when the rendered view of the data changes. */
  viewChange = new Subject();
  /** Subject that emits when a new DataSource instance is given. */
  _dataSourceChanges = new Subject();
  /** The DataSource to display. */
  get cdkVirtualForOf() {
    return this._cdkVirtualForOf;
  }
  set cdkVirtualForOf(value) {
    this._cdkVirtualForOf = value;
    if (isDataSource(value)) {
      this._dataSourceChanges.next(value);
    } else {
      this._dataSourceChanges.next(new ArrayDataSource(isObservable(value) ? value : Array.from(value || [])));
    }
  }
  _cdkVirtualForOf;
  /**
   * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and
   * the item and produces a value to be used as the item's identity when tracking changes.
   */
  get cdkVirtualForTrackBy() {
    return this._cdkVirtualForTrackBy;
  }
  set cdkVirtualForTrackBy(fn) {
    this._needsUpdate = true;
    this._cdkVirtualForTrackBy = fn ? (index, item) => fn(index + (this._renderedRange ? this._renderedRange.start : 0), item) : void 0;
  }
  _cdkVirtualForTrackBy;
  /** The template used to stamp out new elements. */
  set cdkVirtualForTemplate(value) {
    if (value) {
      this._needsUpdate = true;
      this._template = value;
    }
  }
  /**
   * The size of the cache used to store templates that are not being used for re-use later.
   * Setting the cache size to `0` will disable caching. Defaults to 20 templates.
   */
  get cdkVirtualForTemplateCacheSize() {
    return this._viewRepeater.viewCacheSize;
  }
  set cdkVirtualForTemplateCacheSize(size) {
    this._viewRepeater.viewCacheSize = coerceNumberProperty(size);
  }
  /** Emits whenever the data in the current DataSource changes. */
  dataStream = this._dataSourceChanges.pipe(
    // Start off with null `DataSource`.
    startWith(null),
    // Bundle up the previous and current data sources so we can work with both.
    pairwise(),
    // Use `_changeDataSource` to disconnect from the previous data source and connect to the
    // new one, passing back a stream of data changes which we run through `switchMap` to give
    // us a data stream that emits the latest data from whatever the current `DataSource` is.
    switchMap(([prev, cur]) => this._changeDataSource(prev, cur)),
    // Replay the last emitted data when someone subscribes.
    shareReplay(1)
  );
  /** The differ used to calculate changes to the data. */
  _differ = null;
  /** The most recent data emitted from the DataSource. */
  _data;
  /** The currently rendered items. */
  _renderedItems;
  /** The currently rendered range of indices. */
  _renderedRange;
  /** Whether the rendered data should be updated during the next ngDoCheck cycle. */
  _needsUpdate = false;
  _destroyed = new Subject();
  constructor() {
    const ngZone = inject(NgZone);
    this.dataStream.subscribe((data) => {
      this._data = data;
      this._onRenderedDataChange();
    });
    this._viewport.renderedRangeStream.pipe(takeUntil(this._destroyed)).subscribe((range) => {
      this._renderedRange = range;
      if (this.viewChange.observers.length) {
        ngZone.run(() => this.viewChange.next(this._renderedRange));
      }
      this._onRenderedDataChange();
    });
    this._viewport.attach(this);
  }
  /**
   * Measures the combined size (width for horizontal orientation, height for vertical) of all items
   * in the specified range. Throws an error if the range includes items that are not currently
   * rendered.
   */
  measureRangeSize(range, orientation) {
    if (range.start >= range.end) {
      return 0;
    }
    if ((range.start < this._renderedRange.start || range.end > this._renderedRange.end) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error(`Error: attempted to measure an item that isn't rendered.`);
    }
    const renderedStartIndex = range.start - this._renderedRange.start;
    const rangeLen = range.end - range.start;
    let firstNode;
    let lastNode;
    for (let i = 0; i < rangeLen; i++) {
      const view = this._viewContainerRef.get(i + renderedStartIndex);
      if (view && view.rootNodes.length) {
        firstNode = lastNode = view.rootNodes[0];
        break;
      }
    }
    for (let i = rangeLen - 1; i > -1; i--) {
      const view = this._viewContainerRef.get(i + renderedStartIndex);
      if (view && view.rootNodes.length) {
        lastNode = view.rootNodes[view.rootNodes.length - 1];
        break;
      }
    }
    return firstNode && lastNode ? getOffset(orientation, "end", lastNode) - getOffset(orientation, "start", firstNode) : 0;
  }
  ngDoCheck() {
    if (this._differ && this._needsUpdate) {
      const changes = this._differ.diff(this._renderedItems);
      if (!changes) {
        this._updateContext();
      } else {
        this._applyChanges(changes);
      }
      this._needsUpdate = false;
    }
  }
  ngOnDestroy() {
    this._viewport.detach();
    this._dataSourceChanges.next(void 0);
    this._dataSourceChanges.complete();
    this.viewChange.complete();
    this._destroyed.next();
    this._destroyed.complete();
    this._viewRepeater.detach();
  }
  /** React to scroll state changes in the viewport. */
  _onRenderedDataChange() {
    if (!this._renderedRange) {
      return;
    }
    this._renderedItems = this._data.slice(this._renderedRange.start, this._renderedRange.end);
    if (!this._differ) {
      this._differ = this._differs.find(this._renderedItems).create((index, item) => {
        return this.cdkVirtualForTrackBy ? this.cdkVirtualForTrackBy(index, item) : item;
      });
    }
    this._needsUpdate = true;
  }
  /** Swap out one `DataSource` for another. */
  _changeDataSource(oldDs, newDs) {
    if (oldDs) {
      oldDs.disconnect(this);
    }
    this._needsUpdate = true;
    return newDs ? newDs.connect(this) : of();
  }
  /** Update the `CdkVirtualForOfContext` for all views. */
  _updateContext() {
    const count = this._data.length;
    let i = this._viewContainerRef.length;
    while (i--) {
      const view = this._viewContainerRef.get(i);
      view.context.index = this._renderedRange.start + i;
      view.context.count = count;
      this._updateComputedContextProperties(view.context);
      view.detectChanges();
    }
  }
  /** Apply changes to the DOM. */
  _applyChanges(changes) {
    this._viewRepeater.applyChanges(changes, this._viewContainerRef, (record, _adjustedPreviousIndex, currentIndex) => this._getEmbeddedViewArgs(record, currentIndex), (record) => record.item);
    changes.forEachIdentityChange((record) => {
      const view = this._viewContainerRef.get(record.currentIndex);
      view.context.$implicit = record.item;
    });
    const count = this._data.length;
    let i = this._viewContainerRef.length;
    while (i--) {
      const view = this._viewContainerRef.get(i);
      view.context.index = this._renderedRange.start + i;
      view.context.count = count;
      this._updateComputedContextProperties(view.context);
    }
  }
  /** Update the computed properties on the `CdkVirtualForOfContext`. */
  _updateComputedContextProperties(context) {
    context.first = context.index === 0;
    context.last = context.index === context.count - 1;
    context.even = context.index % 2 === 0;
    context.odd = !context.even;
  }
  _getEmbeddedViewArgs(record, index) {
    return {
      templateRef: this._template,
      context: {
        $implicit: record.item,
        // It's guaranteed that the iterable is not "undefined" or "null" because we only
        // generate views for elements if the "cdkVirtualForOf" iterable has elements.
        cdkVirtualForOf: this._cdkVirtualForOf,
        index: -1,
        count: -1,
        first: false,
        last: false,
        odd: false,
        even: false
      },
      index
    };
  }
  static ngTemplateContextGuard(directive, context) {
    return true;
  }
};
__name(_CdkVirtualForOf, "CdkVirtualForOf");
__publicField(_CdkVirtualForOf, "\u0275fac", /* @__PURE__ */ __name(function CdkVirtualForOf_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _CdkVirtualForOf)();
}, "CdkVirtualForOf_Factory"));
__publicField(_CdkVirtualForOf, "\u0275dir", /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _CdkVirtualForOf,
  selectors: [["", "cdkVirtualFor", "", "cdkVirtualForOf", ""]],
  inputs: {
    cdkVirtualForOf: "cdkVirtualForOf",
    cdkVirtualForTrackBy: "cdkVirtualForTrackBy",
    cdkVirtualForTemplate: "cdkVirtualForTemplate",
    cdkVirtualForTemplateCacheSize: "cdkVirtualForTemplateCacheSize"
  },
  features: [\u0275\u0275ProvidersFeature([{
    provide: _VIEW_REPEATER_STRATEGY,
    useClass: _RecycleViewRepeaterStrategy
  }])]
}));
var CdkVirtualForOf = _CdkVirtualForOf;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualForOf, [{
    type: Directive,
    args: [{
      selector: "[cdkVirtualFor][cdkVirtualForOf]",
      providers: [{
        provide: _VIEW_REPEATER_STRATEGY,
        useClass: _RecycleViewRepeaterStrategy
      }]
    }]
  }], () => [], {
    cdkVirtualForOf: [{
      type: Input
    }],
    cdkVirtualForTrackBy: [{
      type: Input
    }],
    cdkVirtualForTemplate: [{
      type: Input
    }],
    cdkVirtualForTemplateCacheSize: [{
      type: Input
    }]
  });
})();
var _CdkVirtualScrollableElement = class _CdkVirtualScrollableElement extends CdkVirtualScrollable {
  constructor() {
    super();
  }
  measureBoundingClientRectWithScrollOffset(from) {
    return this.getElementRef().nativeElement.getBoundingClientRect()[from] - this.measureScrollOffset(from);
  }
};
__name(_CdkVirtualScrollableElement, "CdkVirtualScrollableElement");
__publicField(_CdkVirtualScrollableElement, "\u0275fac", /* @__PURE__ */ __name(function CdkVirtualScrollableElement_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _CdkVirtualScrollableElement)();
}, "CdkVirtualScrollableElement_Factory"));
__publicField(_CdkVirtualScrollableElement, "\u0275dir", /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _CdkVirtualScrollableElement,
  selectors: [["", "cdkVirtualScrollingElement", ""]],
  hostAttrs: [1, "cdk-virtual-scrollable"],
  features: [\u0275\u0275ProvidersFeature([{
    provide: VIRTUAL_SCROLLABLE,
    useExisting: _CdkVirtualScrollableElement
  }]), \u0275\u0275InheritDefinitionFeature]
}));
var CdkVirtualScrollableElement = _CdkVirtualScrollableElement;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollableElement, [{
    type: Directive,
    args: [{
      selector: "[cdkVirtualScrollingElement]",
      providers: [{
        provide: VIRTUAL_SCROLLABLE,
        useExisting: CdkVirtualScrollableElement
      }],
      host: {
        "class": "cdk-virtual-scrollable"
      }
    }]
  }], () => [], null);
})();
var _CdkVirtualScrollableWindow = class _CdkVirtualScrollableWindow extends CdkVirtualScrollable {
  constructor() {
    super();
    const document2 = inject(DOCUMENT);
    this.elementRef = new ElementRef(document2.documentElement);
    this._scrollElement = document2;
  }
  measureBoundingClientRectWithScrollOffset(from) {
    return this.getElementRef().nativeElement.getBoundingClientRect()[from];
  }
};
__name(_CdkVirtualScrollableWindow, "CdkVirtualScrollableWindow");
__publicField(_CdkVirtualScrollableWindow, "\u0275fac", /* @__PURE__ */ __name(function CdkVirtualScrollableWindow_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _CdkVirtualScrollableWindow)();
}, "CdkVirtualScrollableWindow_Factory"));
__publicField(_CdkVirtualScrollableWindow, "\u0275dir", /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _CdkVirtualScrollableWindow,
  selectors: [["cdk-virtual-scroll-viewport", "scrollWindow", ""]],
  features: [\u0275\u0275ProvidersFeature([{
    provide: VIRTUAL_SCROLLABLE,
    useExisting: _CdkVirtualScrollableWindow
  }]), \u0275\u0275InheritDefinitionFeature]
}));
var CdkVirtualScrollableWindow = _CdkVirtualScrollableWindow;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollableWindow, [{
    type: Directive,
    args: [{
      selector: "cdk-virtual-scroll-viewport[scrollWindow]",
      providers: [{
        provide: VIRTUAL_SCROLLABLE,
        useExisting: CdkVirtualScrollableWindow
      }]
    }]
  }], () => [], null);
})();
var _CdkScrollableModule = class _CdkScrollableModule {
};
__name(_CdkScrollableModule, "CdkScrollableModule");
__publicField(_CdkScrollableModule, "\u0275fac", /* @__PURE__ */ __name(function CdkScrollableModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _CdkScrollableModule)();
}, "CdkScrollableModule_Factory"));
__publicField(_CdkScrollableModule, "\u0275mod", /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _CdkScrollableModule,
  imports: [CdkScrollable],
  exports: [CdkScrollable]
}));
__publicField(_CdkScrollableModule, "\u0275inj", /* @__PURE__ */ \u0275\u0275defineInjector({}));
var CdkScrollableModule = _CdkScrollableModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkScrollableModule, [{
    type: NgModule,
    args: [{
      exports: [CdkScrollable],
      imports: [CdkScrollable]
    }]
  }], null, null);
})();
var _ScrollingModule = class _ScrollingModule {
};
__name(_ScrollingModule, "ScrollingModule");
__publicField(_ScrollingModule, "\u0275fac", /* @__PURE__ */ __name(function ScrollingModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ScrollingModule)();
}, "ScrollingModule_Factory"));
__publicField(_ScrollingModule, "\u0275mod", /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ScrollingModule,
  imports: [BidiModule, CdkScrollableModule, CdkVirtualScrollViewport, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollableWindow, CdkVirtualScrollableElement],
  exports: [BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport, CdkVirtualScrollableWindow, CdkVirtualScrollableElement]
}));
__publicField(_ScrollingModule, "\u0275inj", /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [BidiModule, CdkScrollableModule, BidiModule, CdkScrollableModule]
}));
var ScrollingModule = _ScrollingModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollingModule, [{
    type: NgModule,
    args: [{
      imports: [BidiModule, CdkScrollableModule, CdkVirtualScrollViewport, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollableWindow, CdkVirtualScrollableElement],
      exports: [BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport, CdkVirtualScrollableWindow, CdkVirtualScrollableElement]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/id-generator.mjs
var counters = {};
var __IdGenerator = class __IdGenerator {
  _appId = inject(APP_ID);
  /**
   * Generates a unique ID with a specific prefix.
   * @param prefix Prefix to add to the ID.
   */
  getId(prefix) {
    if (this._appId !== "ng") {
      prefix += this._appId;
    }
    if (!counters.hasOwnProperty(prefix)) {
      counters[prefix] = 0;
    }
    return `${prefix}${counters[prefix]++}`;
  }
};
__name(__IdGenerator, "_IdGenerator");
__publicField(__IdGenerator, "\u0275fac", /* @__PURE__ */ __name(function _IdGenerator_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || __IdGenerator)();
}, "_IdGenerator_Factory"));
__publicField(__IdGenerator, "\u0275prov", /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: __IdGenerator,
  factory: __IdGenerator.\u0275fac,
  providedIn: "root"
}));
var _IdGenerator = __IdGenerator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_IdGenerator, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/array.mjs
function coerceArray(value) {
  return Array.isArray(value) ? value : [value];
}
__name(coerceArray, "coerceArray");

// node_modules/@angular/cdk/fesm2022/drag-drop.mjs
function deepCloneNode(node) {
  const clone = node.cloneNode(true);
  const descendantsWithId = clone.querySelectorAll("[id]");
  const nodeName = node.nodeName.toLowerCase();
  clone.removeAttribute("id");
  for (let i = 0; i < descendantsWithId.length; i++) {
    descendantsWithId[i].removeAttribute("id");
  }
  if (nodeName === "canvas") {
    transferCanvasData(node, clone);
  } else if (nodeName === "input" || nodeName === "select" || nodeName === "textarea") {
    transferInputData(node, clone);
  }
  transferData("canvas", node, clone, transferCanvasData);
  transferData("input, textarea, select", node, clone, transferInputData);
  return clone;
}
__name(deepCloneNode, "deepCloneNode");
function transferData(selector, node, clone, callback) {
  const descendantElements = node.querySelectorAll(selector);
  if (descendantElements.length) {
    const cloneElements = clone.querySelectorAll(selector);
    for (let i = 0; i < descendantElements.length; i++) {
      callback(descendantElements[i], cloneElements[i]);
    }
  }
}
__name(transferData, "transferData");
var cloneUniqueId = 0;
function transferInputData(source, clone) {
  if (clone.type !== "file") {
    clone.value = source.value;
  }
  if (clone.type === "radio" && clone.name) {
    clone.name = `mat-clone-${clone.name}-${cloneUniqueId++}`;
  }
}
__name(transferInputData, "transferInputData");
function transferCanvasData(source, clone) {
  const context = clone.getContext("2d");
  if (context) {
    try {
      context.drawImage(source, 0, 0);
    } catch {
    }
  }
}
__name(transferCanvasData, "transferCanvasData");
function getMutableClientRect(element) {
  const rect = element.getBoundingClientRect();
  return {
    top: rect.top,
    right: rect.right,
    bottom: rect.bottom,
    left: rect.left,
    width: rect.width,
    height: rect.height,
    x: rect.x,
    y: rect.y
  };
}
__name(getMutableClientRect, "getMutableClientRect");
function isInsideClientRect(clientRect, x, y) {
  const {
    top,
    bottom,
    left,
    right
  } = clientRect;
  return y >= top && y <= bottom && x >= left && x <= right;
}
__name(isInsideClientRect, "isInsideClientRect");
function isOverflowingParent(parentRect, childRect) {
  const isLeftOverflowing = childRect.left < parentRect.left;
  const isRightOverflowing = childRect.left + childRect.width > parentRect.right;
  const isTopOverflowing = childRect.top < parentRect.top;
  const isBottomOverflowing = childRect.top + childRect.height > parentRect.bottom;
  return isLeftOverflowing || isRightOverflowing || isTopOverflowing || isBottomOverflowing;
}
__name(isOverflowingParent, "isOverflowingParent");
function adjustDomRect(domRect, top, left) {
  domRect.top += top;
  domRect.bottom = domRect.top + domRect.height;
  domRect.left += left;
  domRect.right = domRect.left + domRect.width;
}
__name(adjustDomRect, "adjustDomRect");
function isPointerNearDomRect(rect, threshold, pointerX, pointerY) {
  const {
    top,
    right,
    bottom,
    left,
    width,
    height
  } = rect;
  const xThreshold = width * threshold;
  const yThreshold = height * threshold;
  return pointerY > top - yThreshold && pointerY < bottom + yThreshold && pointerX > left - xThreshold && pointerX < right + xThreshold;
}
__name(isPointerNearDomRect, "isPointerNearDomRect");
var _ParentPositionTracker = class _ParentPositionTracker {
  _document;
  /** Cached positions of the scrollable parent elements. */
  positions = /* @__PURE__ */ new Map();
  constructor(_document) {
    this._document = _document;
  }
  /** Clears the cached positions. */
  clear() {
    this.positions.clear();
  }
  /** Caches the positions. Should be called at the beginning of a drag sequence. */
  cache(elements) {
    this.clear();
    this.positions.set(this._document, {
      scrollPosition: this.getViewportScrollPosition()
    });
    elements.forEach((element) => {
      this.positions.set(element, {
        scrollPosition: {
          top: element.scrollTop,
          left: element.scrollLeft
        },
        clientRect: getMutableClientRect(element)
      });
    });
  }
  /** Handles scrolling while a drag is taking place. */
  handleScroll(event) {
    const target = _getEventTarget(event);
    const cachedPosition = this.positions.get(target);
    if (!cachedPosition) {
      return null;
    }
    const scrollPosition = cachedPosition.scrollPosition;
    let newTop;
    let newLeft;
    if (target === this._document) {
      const viewportScrollPosition = this.getViewportScrollPosition();
      newTop = viewportScrollPosition.top;
      newLeft = viewportScrollPosition.left;
    } else {
      newTop = target.scrollTop;
      newLeft = target.scrollLeft;
    }
    const topDifference = scrollPosition.top - newTop;
    const leftDifference = scrollPosition.left - newLeft;
    this.positions.forEach((position, node) => {
      if (position.clientRect && target !== node && target.contains(node)) {
        adjustDomRect(position.clientRect, topDifference, leftDifference);
      }
    });
    scrollPosition.top = newTop;
    scrollPosition.left = newLeft;
    return {
      top: topDifference,
      left: leftDifference
    };
  }
  /**
   * Gets the scroll position of the viewport. Note that we use the scrollX and scrollY directly,
   * instead of going through the `ViewportRuler`, because the first value the ruler looks at is
   * the top/left offset of the `document.documentElement` which works for most cases, but breaks
   * if the element is offset by something like the `BlockScrollStrategy`.
   */
  getViewportScrollPosition() {
    return {
      top: window.scrollY,
      left: window.scrollX
    };
  }
};
__name(_ParentPositionTracker, "ParentPositionTracker");
var ParentPositionTracker = _ParentPositionTracker;
function getRootNode(viewRef, _document) {
  const rootNodes = viewRef.rootNodes;
  if (rootNodes.length === 1 && rootNodes[0].nodeType === _document.ELEMENT_NODE) {
    return rootNodes[0];
  }
  const wrapper = _document.createElement("div");
  rootNodes.forEach((node) => wrapper.appendChild(node));
  return wrapper;
}
__name(getRootNode, "getRootNode");
function extendStyles(dest, source, importantProperties2) {
  for (let key in source) {
    if (source.hasOwnProperty(key)) {
      const value = source[key];
      if (value) {
        dest.setProperty(key, value, importantProperties2?.has(key) ? "important" : "");
      } else {
        dest.removeProperty(key);
      }
    }
  }
  return dest;
}
__name(extendStyles, "extendStyles");
function toggleNativeDragInteractions(element, enable) {
  const userSelect = enable ? "" : "none";
  extendStyles(element.style, {
    "touch-action": enable ? "" : "none",
    "-webkit-user-drag": enable ? "" : "none",
    "-webkit-tap-highlight-color": enable ? "" : "transparent",
    "user-select": userSelect,
    "-ms-user-select": userSelect,
    "-webkit-user-select": userSelect,
    "-moz-user-select": userSelect
  });
}
__name(toggleNativeDragInteractions, "toggleNativeDragInteractions");
function toggleVisibility(element, enable, importantProperties2) {
  extendStyles(element.style, {
    position: enable ? "" : "fixed",
    top: enable ? "" : "0",
    opacity: enable ? "" : "0",
    left: enable ? "" : "-999em"
  }, importantProperties2);
}
__name(toggleVisibility, "toggleVisibility");
function combineTransforms(transform, initialTransform) {
  return initialTransform && initialTransform != "none" ? transform + " " + initialTransform : transform;
}
__name(combineTransforms, "combineTransforms");
function matchElementSize(target, sourceRect) {
  target.style.width = `${sourceRect.width}px`;
  target.style.height = `${sourceRect.height}px`;
  target.style.transform = getTransform(sourceRect.left, sourceRect.top);
}
__name(matchElementSize, "matchElementSize");
function getTransform(x, y) {
  return `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`;
}
__name(getTransform, "getTransform");
function parseCssTimeUnitsToMs(value) {
  const multiplier = value.toLowerCase().indexOf("ms") > -1 ? 1 : 1e3;
  return parseFloat(value) * multiplier;
}
__name(parseCssTimeUnitsToMs, "parseCssTimeUnitsToMs");
function getTransformTransitionDurationInMs(element) {
  const computedStyle = getComputedStyle(element);
  const transitionedProperties = parseCssPropertyValue(computedStyle, "transition-property");
  const property = transitionedProperties.find((prop) => prop === "transform" || prop === "all");
  if (!property) {
    return 0;
  }
  const propertyIndex = transitionedProperties.indexOf(property);
  const rawDurations = parseCssPropertyValue(computedStyle, "transition-duration");
  const rawDelays = parseCssPropertyValue(computedStyle, "transition-delay");
  return parseCssTimeUnitsToMs(rawDurations[propertyIndex]) + parseCssTimeUnitsToMs(rawDelays[propertyIndex]);
}
__name(getTransformTransitionDurationInMs, "getTransformTransitionDurationInMs");
function parseCssPropertyValue(computedStyle, name) {
  const value = computedStyle.getPropertyValue(name);
  return value.split(",").map((part) => part.trim());
}
__name(parseCssPropertyValue, "parseCssPropertyValue");
var importantProperties = /* @__PURE__ */ new Set([
  // Needs to be important, because some `mat-table` sets `position: sticky !important`. See #22781.
  "position"
]);
var _PreviewRef = class _PreviewRef {
  _document;
  _rootElement;
  _direction;
  _initialDomRect;
  _previewTemplate;
  _previewClass;
  _pickupPositionOnPage;
  _initialTransform;
  _zIndex;
  _renderer;
  /** Reference to the view of the preview element. */
  _previewEmbeddedView;
  /** Reference to the preview element. */
  _preview;
  get element() {
    return this._preview;
  }
  constructor(_document, _rootElement, _direction, _initialDomRect, _previewTemplate, _previewClass, _pickupPositionOnPage, _initialTransform, _zIndex, _renderer) {
    this._document = _document;
    this._rootElement = _rootElement;
    this._direction = _direction;
    this._initialDomRect = _initialDomRect;
    this._previewTemplate = _previewTemplate;
    this._previewClass = _previewClass;
    this._pickupPositionOnPage = _pickupPositionOnPage;
    this._initialTransform = _initialTransform;
    this._zIndex = _zIndex;
    this._renderer = _renderer;
  }
  attach(parent) {
    this._preview = this._createPreview();
    parent.appendChild(this._preview);
    if (supportsPopover(this._preview)) {
      this._preview["showPopover"]();
    }
  }
  destroy() {
    this._preview.remove();
    this._previewEmbeddedView?.destroy();
    this._preview = this._previewEmbeddedView = null;
  }
  setTransform(value) {
    this._preview.style.transform = value;
  }
  getBoundingClientRect() {
    return this._preview.getBoundingClientRect();
  }
  addClass(className) {
    this._preview.classList.add(className);
  }
  getTransitionDuration() {
    return getTransformTransitionDurationInMs(this._preview);
  }
  addEventListener(name, handler) {
    return this._renderer.listen(this._preview, name, handler);
  }
  _createPreview() {
    const previewConfig = this._previewTemplate;
    const previewClass = this._previewClass;
    const previewTemplate = previewConfig ? previewConfig.template : null;
    let preview;
    if (previewTemplate && previewConfig) {
      const rootRect = previewConfig.matchSize ? this._initialDomRect : null;
      const viewRef = previewConfig.viewContainer.createEmbeddedView(previewTemplate, previewConfig.context);
      viewRef.detectChanges();
      preview = getRootNode(viewRef, this._document);
      this._previewEmbeddedView = viewRef;
      if (previewConfig.matchSize) {
        matchElementSize(preview, rootRect);
      } else {
        preview.style.transform = getTransform(this._pickupPositionOnPage.x, this._pickupPositionOnPage.y);
      }
    } else {
      preview = deepCloneNode(this._rootElement);
      matchElementSize(preview, this._initialDomRect);
      if (this._initialTransform) {
        preview.style.transform = this._initialTransform;
      }
    }
    extendStyles(preview.style, {
      // It's important that we disable the pointer events on the preview, because
      // it can throw off the `document.elementFromPoint` calls in the `CdkDropList`.
      "pointer-events": "none",
      // If the preview has a margin, it can throw off our positioning so we reset it. The reset
      // value for `margin-right` needs to be `auto` when opened as a popover, because our
      // positioning is always top/left based, but native popover seems to position itself
      // to the top/right if `<html>` or `<body>` have `dir="rtl"` (see #29604). Setting it
      // to `auto` pushed it to the top/left corner in RTL and is a noop in LTR.
      "margin": supportsPopover(preview) ? "0 auto 0 0" : "0",
      "position": "fixed",
      "top": "0",
      "left": "0",
      "z-index": this._zIndex + ""
    }, importantProperties);
    toggleNativeDragInteractions(preview, false);
    preview.classList.add("cdk-drag-preview");
    preview.setAttribute("popover", "manual");
    preview.setAttribute("dir", this._direction);
    if (previewClass) {
      if (Array.isArray(previewClass)) {
        previewClass.forEach((className) => preview.classList.add(className));
      } else {
        preview.classList.add(previewClass);
      }
    }
    return preview;
  }
};
__name(_PreviewRef, "PreviewRef");
var PreviewRef = _PreviewRef;
function supportsPopover(element) {
  return "showPopover" in element;
}
__name(supportsPopover, "supportsPopover");
var passiveEventListenerOptions = {
  passive: true
};
var activeEventListenerOptions = {
  passive: false
};
var activeCapturingEventOptions$1 = {
  passive: false,
  capture: true
};
var MOUSE_EVENT_IGNORE_TIME = 800;
var PLACEHOLDER_CLASS = "cdk-drag-placeholder";
var dragImportantProperties = /* @__PURE__ */ new Set([
  // Needs to be important, because some `mat-table` sets `position: sticky !important`. See #22781.
  "position"
]);
var _DragRef = class _DragRef {
  _config;
  _document;
  _ngZone;
  _viewportRuler;
  _dragDropRegistry;
  _renderer;
  _rootElementCleanups;
  _cleanupShadowRootSelectStart;
  /** Element displayed next to the user's pointer while the element is dragged. */
  _preview;
  /** Container into which to insert the preview. */
  _previewContainer;
  /** Reference to the view of the placeholder element. */
  _placeholderRef;
  /** Element that is rendered instead of the draggable item while it is being sorted. */
  _placeholder;
  /** Coordinates within the element at which the user picked up the element. */
  _pickupPositionInElement;
  /** Coordinates on the page at which the user picked up the element. */
  _pickupPositionOnPage;
  /**
   * Marker node used to save the place in the DOM where the element was
   * picked up so that it can be restored at the end of the drag sequence.
   */
  _marker;
  /**
   * Element indicating the position from which the item was picked up initially.
   */
  _anchor = null;
  /**
   * CSS `transform` applied to the element when it isn't being dragged. We need a
   * passive transform in order for the dragged element to retain its new position
   * after the user has stopped dragging and because we need to know the relative
   * position in case they start dragging again. This corresponds to `element.style.transform`.
   */
  _passiveTransform = {
    x: 0,
    y: 0
  };
  /** CSS `transform` that is applied to the element while it's being dragged. */
  _activeTransform = {
    x: 0,
    y: 0
  };
  /** Inline `transform` value that the element had before the first dragging sequence. */
  _initialTransform;
  /**
   * Whether the dragging sequence has been started. Doesn't
   * necessarily mean that the element has been moved.
   */
  _hasStartedDragging = signal(false, ...ngDevMode ? [{
    debugName: "_hasStartedDragging"
  }] : []);
  /** Whether the element has moved since the user started dragging it. */
  _hasMoved;
  /** Drop container in which the DragRef resided when dragging began. */
  _initialContainer;
  /** Index at which the item started in its initial container. */
  _initialIndex;
  /** Cached positions of scrollable parent elements. */
  _parentPositions;
  /** Emits when the item is being moved. */
  _moveEvents = new Subject();
  /** Keeps track of the direction in which the user is dragging along each axis. */
  _pointerDirectionDelta;
  /** Pointer position at which the last change in the delta occurred. */
  _pointerPositionAtLastDirectionChange;
  /** Position of the pointer at the last pointer event. */
  _lastKnownPointerPosition;
  /**
   * Root DOM node of the drag instance. This is the element that will
   * be moved around as the user is dragging.
   */
  _rootElement;
  /**
   * Nearest ancestor SVG, relative to which coordinates are calculated if dragging SVGElement
   */
  _ownerSVGElement;
  /**
   * Inline style value of `-webkit-tap-highlight-color` at the time the
   * dragging was started. Used to restore the value once we're done dragging.
   */
  _rootElementTapHighlight;
  /** Subscription to pointer movement events. */
  _pointerMoveSubscription = Subscription.EMPTY;
  /** Subscription to the event that is dispatched when the user lifts their pointer. */
  _pointerUpSubscription = Subscription.EMPTY;
  /** Subscription to the viewport being scrolled. */
  _scrollSubscription = Subscription.EMPTY;
  /** Subscription to the viewport being resized. */
  _resizeSubscription = Subscription.EMPTY;
  /**
   * Time at which the last touch event occurred. Used to avoid firing the same
   * events multiple times on touch devices where the browser will fire a fake
   * mouse event for each touch event, after a certain time.
   */
  _lastTouchEventTime;
  /** Time at which the last dragging sequence was started. */
  _dragStartTime;
  /** Cached reference to the boundary element. */
  _boundaryElement = null;
  /** Whether the native dragging interactions have been enabled on the root element. */
  _nativeInteractionsEnabled = true;
  /** Client rect of the root element when the dragging sequence has started. */
  _initialDomRect;
  /** Cached dimensions of the preview element. Should be read via `_getPreviewRect`. */
  _previewRect;
  /** Cached dimensions of the boundary element. */
  _boundaryRect;
  /** Element that will be used as a template to create the draggable item's preview. */
  _previewTemplate;
  /** Template for placeholder element rendered to show where a draggable would be dropped. */
  _placeholderTemplate;
  /** Elements that can be used to drag the draggable item. */
  _handles = [];
  /** Registered handles that are currently disabled. */
  _disabledHandles = /* @__PURE__ */ new Set();
  /** Droppable container that the draggable is a part of. */
  _dropContainer;
  /** Layout direction of the item. */
  _direction = "ltr";
  /** Ref that the current drag item is nested in. */
  _parentDragRef;
  /**
   * Cached shadow root that the element is placed in. `null` means that the element isn't in
   * the shadow DOM and `undefined` means that it hasn't been resolved yet. Should be read via
   * `_getShadowRoot`, not directly.
   */
  _cachedShadowRoot;
  /** Axis along which dragging is locked. */
  lockAxis = null;
  /**
   * Amount of milliseconds to wait after the user has put their
   * pointer down before starting to drag the element.
   */
  dragStartDelay = 0;
  /** Class to be added to the preview element. */
  previewClass;
  /**
   * If the parent of the dragged element has a `scale` transform, it can throw off the
   * positioning when the user starts dragging. Use this input to notify the CDK of the scale.
   */
  scale = 1;
  /** Whether starting to drag this element is disabled. */
  get disabled() {
    return this._disabled || !!(this._dropContainer && this._dropContainer.disabled);
  }
  set disabled(value) {
    if (value !== this._disabled) {
      this._disabled = value;
      this._toggleNativeDragInteractions();
      this._handles.forEach((handle) => toggleNativeDragInteractions(handle, value));
    }
  }
  _disabled = false;
  /** Emits as the drag sequence is being prepared. */
  beforeStarted = new Subject();
  /** Emits when the user starts dragging the item. */
  started = new Subject();
  /** Emits when the user has released a drag item, before any animations have started. */
  released = new Subject();
  /** Emits when the user stops dragging an item in the container. */
  ended = new Subject();
  /** Emits when the user has moved the item into a new container. */
  entered = new Subject();
  /** Emits when the user removes the item its container by dragging it into another container. */
  exited = new Subject();
  /** Emits when the user drops the item inside a container. */
  dropped = new Subject();
  /**
   * Emits as the user is dragging the item. Use with caution,
   * because this event will fire for every pixel that the user has dragged.
   */
  moved = this._moveEvents;
  /** Arbitrary data that can be attached to the drag item. */
  data;
  /**
   * Function that can be used to customize the logic of how the position of the drag item
   * is limited while it's being dragged. Gets called with a point containing the current position
   * of the user's pointer on the page, a reference to the item being dragged and its dimensions.
   * Should return a point describing where the item should be rendered.
   */
  constrainPosition;
  constructor(element, _config, _document, _ngZone, _viewportRuler, _dragDropRegistry, _renderer) {
    this._config = _config;
    this._document = _document;
    this._ngZone = _ngZone;
    this._viewportRuler = _viewportRuler;
    this._dragDropRegistry = _dragDropRegistry;
    this._renderer = _renderer;
    this.withRootElement(element).withParent(_config.parentDragRef || null);
    this._parentPositions = new ParentPositionTracker(_document);
    _dragDropRegistry.registerDragItem(this);
  }
  /**
   * Returns the element that is being used as a placeholder
   * while the current element is being dragged.
   */
  getPlaceholderElement() {
    return this._placeholder;
  }
  /** Returns the root draggable element. */
  getRootElement() {
    return this._rootElement;
  }
  /**
   * Gets the currently-visible element that represents the drag item.
   * While dragging this is the placeholder, otherwise it's the root element.
   */
  getVisibleElement() {
    return this.isDragging() ? this.getPlaceholderElement() : this.getRootElement();
  }
  /** Registers the handles that can be used to drag the element. */
  withHandles(handles) {
    this._handles = handles.map((handle) => coerceElement(handle));
    this._handles.forEach((handle) => toggleNativeDragInteractions(handle, this.disabled));
    this._toggleNativeDragInteractions();
    const disabledHandles = /* @__PURE__ */ new Set();
    this._disabledHandles.forEach((handle) => {
      if (this._handles.indexOf(handle) > -1) {
        disabledHandles.add(handle);
      }
    });
    this._disabledHandles = disabledHandles;
    return this;
  }
  /**
   * Registers the template that should be used for the drag preview.
   * @param template Template that from which to stamp out the preview.
   */
  withPreviewTemplate(template) {
    this._previewTemplate = template;
    return this;
  }
  /**
   * Registers the template that should be used for the drag placeholder.
   * @param template Template that from which to stamp out the placeholder.
   */
  withPlaceholderTemplate(template) {
    this._placeholderTemplate = template;
    return this;
  }
  /**
   * Sets an alternate drag root element. The root element is the element that will be moved as
   * the user is dragging. Passing an alternate root element is useful when trying to enable
   * dragging on an element that you might not have access to.
   */
  withRootElement(rootElement) {
    const element = coerceElement(rootElement);
    if (element !== this._rootElement) {
      this._removeRootElementListeners();
      const renderer = this._renderer;
      this._rootElementCleanups = this._ngZone.runOutsideAngular(() => [renderer.listen(element, "mousedown", this._pointerDown, activeEventListenerOptions), renderer.listen(element, "touchstart", this._pointerDown, passiveEventListenerOptions), renderer.listen(element, "dragstart", this._nativeDragStart, activeEventListenerOptions)]);
      this._initialTransform = void 0;
      this._rootElement = element;
    }
    if (typeof SVGElement !== "undefined" && this._rootElement instanceof SVGElement) {
      this._ownerSVGElement = this._rootElement.ownerSVGElement;
    }
    return this;
  }
  /**
   * Element to which the draggable's position will be constrained.
   */
  withBoundaryElement(boundaryElement) {
    this._boundaryElement = boundaryElement ? coerceElement(boundaryElement) : null;
    this._resizeSubscription.unsubscribe();
    if (boundaryElement) {
      this._resizeSubscription = this._viewportRuler.change(10).subscribe(() => this._containInsideBoundaryOnResize());
    }
    return this;
  }
  /** Sets the parent ref that the ref is nested in.  */
  withParent(parent) {
    this._parentDragRef = parent;
    return this;
  }
  /** Removes the dragging functionality from the DOM element. */
  dispose() {
    this._removeRootElementListeners();
    if (this.isDragging()) {
      this._rootElement?.remove();
    }
    this._marker?.remove();
    this._destroyPreview();
    this._destroyPlaceholder();
    this._dragDropRegistry.removeDragItem(this);
    this._removeListeners();
    this.beforeStarted.complete();
    this.started.complete();
    this.released.complete();
    this.ended.complete();
    this.entered.complete();
    this.exited.complete();
    this.dropped.complete();
    this._moveEvents.complete();
    this._handles = [];
    this._disabledHandles.clear();
    this._dropContainer = void 0;
    this._resizeSubscription.unsubscribe();
    this._parentPositions.clear();
    this._boundaryElement = this._rootElement = this._ownerSVGElement = this._placeholderTemplate = this._previewTemplate = this._marker = this._parentDragRef = null;
  }
  /** Checks whether the element is currently being dragged. */
  isDragging() {
    return this._hasStartedDragging() && this._dragDropRegistry.isDragging(this);
  }
  /** Resets a standalone drag item to its initial position. */
  reset() {
    this._rootElement.style.transform = this._initialTransform || "";
    this._activeTransform = {
      x: 0,
      y: 0
    };
    this._passiveTransform = {
      x: 0,
      y: 0
    };
  }
  /** Resets drag item to end of boundary element. */
  resetToBoundary() {
    if (
      // can be null if the drag item was never dragged.
      this._boundaryElement && this._rootElement && // check if we are overflowing off our boundary element
      isOverflowingParent(this._boundaryElement.getBoundingClientRect(), this._rootElement.getBoundingClientRect())
    ) {
      const parentRect = this._boundaryElement.getBoundingClientRect();
      const childRect = this._rootElement.getBoundingClientRect();
      let offsetX = 0;
      let offsetY = 0;
      if (childRect.left < parentRect.left) {
        offsetX = parentRect.left - childRect.left;
      } else if (childRect.right > parentRect.right) {
        offsetX = parentRect.right - childRect.right;
      }
      if (childRect.top < parentRect.top) {
        offsetY = parentRect.top - childRect.top;
      } else if (childRect.bottom > parentRect.bottom) {
        offsetY = parentRect.bottom - childRect.bottom;
      }
      const currentLeft = this._activeTransform.x;
      const currentTop = this._activeTransform.y;
      let x = currentLeft + offsetX, y = currentTop + offsetY;
      this._rootElement.style.transform = getTransform(x, y);
      this._activeTransform = {
        x,
        y
      };
      this._passiveTransform = {
        x,
        y
      };
    }
  }
  /**
   * Sets a handle as disabled. While a handle is disabled, it'll capture and interrupt dragging.
   * @param handle Handle element that should be disabled.
   */
  disableHandle(handle) {
    if (!this._disabledHandles.has(handle) && this._handles.indexOf(handle) > -1) {
      this._disabledHandles.add(handle);
      toggleNativeDragInteractions(handle, true);
    }
  }
  /**
   * Enables a handle, if it has been disabled.
   * @param handle Handle element to be enabled.
   */
  enableHandle(handle) {
    if (this._disabledHandles.has(handle)) {
      this._disabledHandles.delete(handle);
      toggleNativeDragInteractions(handle, this.disabled);
    }
  }
  /** Sets the layout direction of the draggable item. */
  withDirection(direction) {
    this._direction = direction;
    return this;
  }
  /** Sets the container that the item is part of. */
  _withDropContainer(container) {
    this._dropContainer = container;
  }
  /**
   * Gets the current position in pixels the draggable outside of a drop container.
   */
  getFreeDragPosition() {
    const position = this.isDragging() ? this._activeTransform : this._passiveTransform;
    return {
      x: position.x,
      y: position.y
    };
  }
  /**
   * Sets the current position in pixels the draggable outside of a drop container.
   * @param value New position to be set.
   */
  setFreeDragPosition(value) {
    this._activeTransform = {
      x: 0,
      y: 0
    };
    this._passiveTransform.x = value.x;
    this._passiveTransform.y = value.y;
    if (!this._dropContainer) {
      this._applyRootElementTransform(value.x, value.y);
    }
    return this;
  }
  /**
   * Sets the container into which to insert the preview element.
   * @param value Container into which to insert the preview.
   */
  withPreviewContainer(value) {
    this._previewContainer = value;
    return this;
  }
  /** Updates the item's sort order based on the last-known pointer position. */
  _sortFromLastPointerPosition() {
    const position = this._lastKnownPointerPosition;
    if (position && this._dropContainer) {
      this._updateActiveDropContainer(this._getConstrainedPointerPosition(position), position);
    }
  }
  /** Unsubscribes from the global subscriptions. */
  _removeListeners() {
    this._pointerMoveSubscription.unsubscribe();
    this._pointerUpSubscription.unsubscribe();
    this._scrollSubscription.unsubscribe();
    this._cleanupShadowRootSelectStart?.();
    this._cleanupShadowRootSelectStart = void 0;
  }
  /** Destroys the preview element and its ViewRef. */
  _destroyPreview() {
    this._preview?.destroy();
    this._preview = null;
  }
  /** Destroys the placeholder element and its ViewRef. */
  _destroyPlaceholder() {
    this._anchor?.remove();
    this._placeholder?.remove();
    this._placeholderRef?.destroy();
    this._placeholder = this._anchor = this._placeholderRef = null;
  }
  /** Handler for the `mousedown`/`touchstart` events. */
  _pointerDown = /* @__PURE__ */ __name((event) => {
    this.beforeStarted.next();
    if (this._handles.length) {
      const targetHandle = this._getTargetHandle(event);
      if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {
        this._initializeDragSequence(targetHandle, event);
      }
    } else if (!this.disabled) {
      this._initializeDragSequence(this._rootElement, event);
    }
  }, "_pointerDown");
  /** Handler that is invoked when the user moves their pointer after they've initiated a drag. */
  _pointerMove = /* @__PURE__ */ __name((event) => {
    const pointerPosition = this._getPointerPositionOnPage(event);
    if (!this._hasStartedDragging()) {
      const distanceX = Math.abs(pointerPosition.x - this._pickupPositionOnPage.x);
      const distanceY = Math.abs(pointerPosition.y - this._pickupPositionOnPage.y);
      const isOverThreshold = distanceX + distanceY >= this._config.dragStartThreshold;
      if (isOverThreshold) {
        const isDelayElapsed = Date.now() >= this._dragStartTime + this._getDragStartDelay(event);
        const container = this._dropContainer;
        if (!isDelayElapsed) {
          this._endDragSequence(event);
          return;
        }
        if (!container || !container.isDragging() && !container.isReceiving()) {
          if (event.cancelable) {
            event.preventDefault();
          }
          this._hasStartedDragging.set(true);
          this._ngZone.run(() => this._startDragSequence(event));
        }
      }
      return;
    }
    if (event.cancelable) {
      event.preventDefault();
    }
    const constrainedPointerPosition = this._getConstrainedPointerPosition(pointerPosition);
    this._hasMoved = true;
    this._lastKnownPointerPosition = pointerPosition;
    this._updatePointerDirectionDelta(constrainedPointerPosition);
    if (this._dropContainer) {
      this._updateActiveDropContainer(constrainedPointerPosition, pointerPosition);
    } else {
      const offset = this.constrainPosition ? this._initialDomRect : this._pickupPositionOnPage;
      const activeTransform = this._activeTransform;
      activeTransform.x = constrainedPointerPosition.x - offset.x + this._passiveTransform.x;
      activeTransform.y = constrainedPointerPosition.y - offset.y + this._passiveTransform.y;
      this._applyRootElementTransform(activeTransform.x, activeTransform.y);
    }
    if (this._moveEvents.observers.length) {
      this._ngZone.run(() => {
        this._moveEvents.next({
          source: this,
          pointerPosition: constrainedPointerPosition,
          event,
          distance: this._getDragDistance(constrainedPointerPosition),
          delta: this._pointerDirectionDelta
        });
      });
    }
  }, "_pointerMove");
  /** Handler that is invoked when the user lifts their pointer up, after initiating a drag. */
  _pointerUp = /* @__PURE__ */ __name((event) => {
    this._endDragSequence(event);
  }, "_pointerUp");
  /**
   * Clears subscriptions and stops the dragging sequence.
   * @param event Browser event object that ended the sequence.
   */
  _endDragSequence(event) {
    if (!this._dragDropRegistry.isDragging(this)) {
      return;
    }
    this._removeListeners();
    this._dragDropRegistry.stopDragging(this);
    this._toggleNativeDragInteractions();
    if (this._handles) {
      this._rootElement.style.webkitTapHighlightColor = this._rootElementTapHighlight;
    }
    if (!this._hasStartedDragging()) {
      return;
    }
    this.released.next({
      source: this,
      event
    });
    if (this._dropContainer) {
      this._dropContainer._stopScrolling();
      this._animatePreviewToPlaceholder().then(() => {
        this._cleanupDragArtifacts(event);
        this._cleanupCachedDimensions();
        this._dragDropRegistry.stopDragging(this);
      });
    } else {
      this._passiveTransform.x = this._activeTransform.x;
      const pointerPosition = this._getPointerPositionOnPage(event);
      this._passiveTransform.y = this._activeTransform.y;
      this._ngZone.run(() => {
        this.ended.next({
          source: this,
          distance: this._getDragDistance(pointerPosition),
          dropPoint: pointerPosition,
          event
        });
      });
      this._cleanupCachedDimensions();
      this._dragDropRegistry.stopDragging(this);
    }
  }
  /** Starts the dragging sequence. */
  _startDragSequence(event) {
    if (isTouchEvent(event)) {
      this._lastTouchEventTime = Date.now();
    }
    this._toggleNativeDragInteractions();
    const shadowRoot = this._getShadowRoot();
    const dropContainer = this._dropContainer;
    if (shadowRoot) {
      this._ngZone.runOutsideAngular(() => {
        this._cleanupShadowRootSelectStart = this._renderer.listen(shadowRoot, "selectstart", shadowDomSelectStart, activeCapturingEventOptions$1);
      });
    }
    if (dropContainer) {
      const element = this._rootElement;
      const parent = element.parentNode;
      const placeholder = this._placeholder = this._createPlaceholderElement();
      const marker = this._marker = this._marker || this._document.createComment(typeof ngDevMode === "undefined" || ngDevMode ? "cdk-drag-marker" : "");
      parent.insertBefore(marker, element);
      this._initialTransform = element.style.transform || "";
      this._preview = new PreviewRef(this._document, this._rootElement, this._direction, this._initialDomRect, this._previewTemplate || null, this.previewClass || null, this._pickupPositionOnPage, this._initialTransform, this._config.zIndex || 1e3, this._renderer);
      this._preview.attach(this._getPreviewInsertionPoint(parent, shadowRoot));
      toggleVisibility(element, false, dragImportantProperties);
      this._document.body.appendChild(parent.replaceChild(placeholder, element));
      this.started.next({
        source: this,
        event
      });
      dropContainer.start();
      this._initialContainer = dropContainer;
      this._initialIndex = dropContainer.getItemIndex(this);
    } else {
      this.started.next({
        source: this,
        event
      });
      this._initialContainer = this._initialIndex = void 0;
    }
    this._parentPositions.cache(dropContainer ? dropContainer.getScrollableParents() : []);
  }
  /**
   * Sets up the different variables and subscriptions
   * that will be necessary for the dragging sequence.
   * @param referenceElement Element that started the drag sequence.
   * @param event Browser event object that started the sequence.
   */
  _initializeDragSequence(referenceElement, event) {
    if (this._parentDragRef) {
      event.stopPropagation();
    }
    const isDragging = this.isDragging();
    const isTouchSequence = isTouchEvent(event);
    const isAuxiliaryMouseButton = !isTouchSequence && event.button !== 0;
    const rootElement = this._rootElement;
    const target = _getEventTarget(event);
    const isSyntheticEvent = !isTouchSequence && this._lastTouchEventTime && this._lastTouchEventTime + MOUSE_EVENT_IGNORE_TIME > Date.now();
    const isFakeEvent = isTouchSequence ? isFakeTouchstartFromScreenReader(event) : isFakeMousedownFromScreenReader(event);
    if (target && target.draggable && event.type === "mousedown") {
      event.preventDefault();
    }
    if (isDragging || isAuxiliaryMouseButton || isSyntheticEvent || isFakeEvent) {
      return;
    }
    if (this._handles.length) {
      const rootStyles = rootElement.style;
      this._rootElementTapHighlight = rootStyles.webkitTapHighlightColor || "";
      rootStyles.webkitTapHighlightColor = "transparent";
    }
    this._hasMoved = false;
    this._hasStartedDragging.set(this._hasMoved);
    this._removeListeners();
    this._initialDomRect = this._rootElement.getBoundingClientRect();
    this._pointerMoveSubscription = this._dragDropRegistry.pointerMove.subscribe(this._pointerMove);
    this._pointerUpSubscription = this._dragDropRegistry.pointerUp.subscribe(this._pointerUp);
    this._scrollSubscription = this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe((scrollEvent) => this._updateOnScroll(scrollEvent));
    if (this._boundaryElement) {
      this._boundaryRect = getMutableClientRect(this._boundaryElement);
    }
    const previewTemplate = this._previewTemplate;
    this._pickupPositionInElement = previewTemplate && previewTemplate.template && !previewTemplate.matchSize ? {
      x: 0,
      y: 0
    } : this._getPointerPositionInElement(this._initialDomRect, referenceElement, event);
    const pointerPosition = this._pickupPositionOnPage = this._lastKnownPointerPosition = this._getPointerPositionOnPage(event);
    this._pointerDirectionDelta = {
      x: 0,
      y: 0
    };
    this._pointerPositionAtLastDirectionChange = {
      x: pointerPosition.x,
      y: pointerPosition.y
    };
    this._dragStartTime = Date.now();
    this._dragDropRegistry.startDragging(this, event);
  }
  /** Cleans up the DOM artifacts that were added to facilitate the element being dragged. */
  _cleanupDragArtifacts(event) {
    toggleVisibility(this._rootElement, true, dragImportantProperties);
    this._marker.parentNode.replaceChild(this._rootElement, this._marker);
    this._destroyPreview();
    this._destroyPlaceholder();
    this._initialDomRect = this._boundaryRect = this._previewRect = this._initialTransform = void 0;
    this._ngZone.run(() => {
      const container = this._dropContainer;
      const currentIndex = container.getItemIndex(this);
      const pointerPosition = this._getPointerPositionOnPage(event);
      const distance = this._getDragDistance(pointerPosition);
      const isPointerOverContainer = container._isOverContainer(pointerPosition.x, pointerPosition.y);
      this.ended.next({
        source: this,
        distance,
        dropPoint: pointerPosition,
        event
      });
      this.dropped.next({
        item: this,
        currentIndex,
        previousIndex: this._initialIndex,
        container,
        previousContainer: this._initialContainer,
        isPointerOverContainer,
        distance,
        dropPoint: pointerPosition,
        event
      });
      container.drop(this, currentIndex, this._initialIndex, this._initialContainer, isPointerOverContainer, distance, pointerPosition, event);
      this._dropContainer = this._initialContainer;
    });
  }
  /**
   * Updates the item's position in its drop container, or moves it
   * into a new one, depending on its current drag position.
   */
  _updateActiveDropContainer({
    x,
    y
  }, {
    x: rawX,
    y: rawY
  }) {
    let newContainer = this._initialContainer._getSiblingContainerFromPosition(this, x, y);
    if (!newContainer && this._dropContainer !== this._initialContainer && this._initialContainer._isOverContainer(x, y)) {
      newContainer = this._initialContainer;
    }
    if (newContainer && newContainer !== this._dropContainer) {
      this._ngZone.run(() => {
        const exitIndex = this._dropContainer.getItemIndex(this);
        const nextItemElement = this._dropContainer.getItemAtIndex(exitIndex + 1)?.getVisibleElement() || null;
        this.exited.next({
          item: this,
          container: this._dropContainer
        });
        this._dropContainer.exit(this);
        this._conditionallyInsertAnchor(newContainer, this._dropContainer, nextItemElement);
        this._dropContainer = newContainer;
        this._dropContainer.enter(
          this,
          x,
          y,
          // If we're re-entering the initial container and sorting is disabled,
          // put item the into its starting index to begin with.
          newContainer === this._initialContainer && newContainer.sortingDisabled ? this._initialIndex : void 0
        );
        this.entered.next({
          item: this,
          container: newContainer,
          currentIndex: newContainer.getItemIndex(this)
        });
      });
    }
    if (this.isDragging()) {
      this._dropContainer._startScrollingIfNecessary(rawX, rawY);
      this._dropContainer._sortItem(this, x, y, this._pointerDirectionDelta);
      if (this.constrainPosition) {
        this._applyPreviewTransform(x, y);
      } else {
        this._applyPreviewTransform(x - this._pickupPositionInElement.x, y - this._pickupPositionInElement.y);
      }
    }
  }
  /**
   * Animates the preview element from its current position to the location of the drop placeholder.
   * @returns Promise that resolves when the animation completes.
   */
  _animatePreviewToPlaceholder() {
    if (!this._hasMoved) {
      return Promise.resolve();
    }
    const placeholderRect = this._placeholder.getBoundingClientRect();
    this._preview.addClass("cdk-drag-animating");
    this._applyPreviewTransform(placeholderRect.left, placeholderRect.top);
    const duration = this._preview.getTransitionDuration();
    if (duration === 0) {
      return Promise.resolve();
    }
    return this._ngZone.runOutsideAngular(() => {
      return new Promise((resolve) => {
        const handler = /* @__PURE__ */ __name((event) => {
          if (!event || this._preview && _getEventTarget(event) === this._preview.element && event.propertyName === "transform") {
            cleanupListener();
            resolve();
            clearTimeout(timeout);
          }
        }, "handler");
        const timeout = setTimeout(handler, duration * 1.5);
        const cleanupListener = this._preview.addEventListener("transitionend", handler);
      });
    });
  }
  /** Creates an element that will be shown instead of the current element while dragging. */
  _createPlaceholderElement() {
    const placeholderConfig = this._placeholderTemplate;
    const placeholderTemplate = placeholderConfig ? placeholderConfig.template : null;
    let placeholder;
    if (placeholderTemplate) {
      this._placeholderRef = placeholderConfig.viewContainer.createEmbeddedView(placeholderTemplate, placeholderConfig.context);
      this._placeholderRef.detectChanges();
      placeholder = getRootNode(this._placeholderRef, this._document);
    } else {
      placeholder = deepCloneNode(this._rootElement);
    }
    placeholder.style.pointerEvents = "none";
    placeholder.classList.add(PLACEHOLDER_CLASS);
    return placeholder;
  }
  /**
   * Figures out the coordinates at which an element was picked up.
   * @param referenceElement Element that initiated the dragging.
   * @param event Event that initiated the dragging.
   */
  _getPointerPositionInElement(elementRect, referenceElement, event) {
    const handleElement = referenceElement === this._rootElement ? null : referenceElement;
    const referenceRect = handleElement ? handleElement.getBoundingClientRect() : elementRect;
    const point = isTouchEvent(event) ? event.targetTouches[0] : event;
    const scrollPosition = this._getViewportScrollPosition();
    const x = point.pageX - referenceRect.left - scrollPosition.left;
    const y = point.pageY - referenceRect.top - scrollPosition.top;
    return {
      x: referenceRect.left - elementRect.left + x,
      y: referenceRect.top - elementRect.top + y
    };
  }
  /** Determines the point of the page that was touched by the user. */
  _getPointerPositionOnPage(event) {
    const scrollPosition = this._getViewportScrollPosition();
    const point = isTouchEvent(event) ? (
      // `touches` will be empty for start/end events so we have to fall back to `changedTouches`.
      // Also note that on real devices we're guaranteed for either `touches` or `changedTouches`
      // to have a value, but Firefox in device emulation mode has a bug where both can be empty
      // for `touchstart` and `touchend` so we fall back to a dummy object in order to avoid
      // throwing an error. The value returned here will be incorrect, but since this only
      // breaks inside a developer tool and the value is only used for secondary information,
      // we can get away with it. See https://bugzilla.mozilla.org/show_bug.cgi?id=1615824.
      event.touches[0] || event.changedTouches[0] || {
        pageX: 0,
        pageY: 0
      }
    ) : event;
    const x = point.pageX - scrollPosition.left;
    const y = point.pageY - scrollPosition.top;
    if (this._ownerSVGElement) {
      const svgMatrix = this._ownerSVGElement.getScreenCTM();
      if (svgMatrix) {
        const svgPoint = this._ownerSVGElement.createSVGPoint();
        svgPoint.x = x;
        svgPoint.y = y;
        return svgPoint.matrixTransform(svgMatrix.inverse());
      }
    }
    return {
      x,
      y
    };
  }
  /** Gets the pointer position on the page, accounting for any position constraints. */
  _getConstrainedPointerPosition(point) {
    const dropContainerLock = this._dropContainer ? this._dropContainer.lockAxis : null;
    let {
      x,
      y
    } = this.constrainPosition ? this.constrainPosition(point, this, this._initialDomRect, this._pickupPositionInElement) : point;
    if (this.lockAxis === "x" || dropContainerLock === "x") {
      y = this._pickupPositionOnPage.y - (this.constrainPosition ? this._pickupPositionInElement.y : 0);
    } else if (this.lockAxis === "y" || dropContainerLock === "y") {
      x = this._pickupPositionOnPage.x - (this.constrainPosition ? this._pickupPositionInElement.x : 0);
    }
    if (this._boundaryRect) {
      const {
        x: pickupX,
        y: pickupY
      } = !this.constrainPosition ? this._pickupPositionInElement : {
        x: 0,
        y: 0
      };
      const boundaryRect = this._boundaryRect;
      const {
        width: previewWidth,
        height: previewHeight
      } = this._getPreviewRect();
      const minY = boundaryRect.top + pickupY;
      const maxY = boundaryRect.bottom - (previewHeight - pickupY);
      const minX = boundaryRect.left + pickupX;
      const maxX = boundaryRect.right - (previewWidth - pickupX);
      x = clamp$1(x, minX, maxX);
      y = clamp$1(y, minY, maxY);
    }
    return {
      x,
      y
    };
  }
  /** Updates the current drag delta, based on the user's current pointer position on the page. */
  _updatePointerDirectionDelta(pointerPositionOnPage) {
    const {
      x,
      y
    } = pointerPositionOnPage;
    const delta = this._pointerDirectionDelta;
    const positionSinceLastChange = this._pointerPositionAtLastDirectionChange;
    const changeX = Math.abs(x - positionSinceLastChange.x);
    const changeY = Math.abs(y - positionSinceLastChange.y);
    if (changeX > this._config.pointerDirectionChangeThreshold) {
      delta.x = x > positionSinceLastChange.x ? 1 : -1;
      positionSinceLastChange.x = x;
    }
    if (changeY > this._config.pointerDirectionChangeThreshold) {
      delta.y = y > positionSinceLastChange.y ? 1 : -1;
      positionSinceLastChange.y = y;
    }
    return delta;
  }
  /** Toggles the native drag interactions, based on how many handles are registered. */
  _toggleNativeDragInteractions() {
    if (!this._rootElement || !this._handles) {
      return;
    }
    const shouldEnable = this._handles.length > 0 || !this.isDragging();
    if (shouldEnable !== this._nativeInteractionsEnabled) {
      this._nativeInteractionsEnabled = shouldEnable;
      toggleNativeDragInteractions(this._rootElement, shouldEnable);
    }
  }
  /** Removes the manually-added event listeners from the root element. */
  _removeRootElementListeners() {
    this._rootElementCleanups?.forEach((cleanup) => cleanup());
    this._rootElementCleanups = void 0;
  }
  /**
   * Applies a `transform` to the root element, taking into account any existing transforms on it.
   * @param x New transform value along the X axis.
   * @param y New transform value along the Y axis.
   */
  _applyRootElementTransform(x, y) {
    const scale = 1 / this.scale;
    const transform = getTransform(x * scale, y * scale);
    const styles = this._rootElement.style;
    if (this._initialTransform == null) {
      this._initialTransform = styles.transform && styles.transform != "none" ? styles.transform : "";
    }
    styles.transform = combineTransforms(transform, this._initialTransform);
  }
  /**
   * Applies a `transform` to the preview, taking into account any existing transforms on it.
   * @param x New transform value along the X axis.
   * @param y New transform value along the Y axis.
   */
  _applyPreviewTransform(x, y) {
    const initialTransform = this._previewTemplate?.template ? void 0 : this._initialTransform;
    const transform = getTransform(x, y);
    this._preview.setTransform(combineTransforms(transform, initialTransform));
  }
  /**
   * Gets the distance that the user has dragged during the current drag sequence.
   * @param currentPosition Current position of the user's pointer.
   */
  _getDragDistance(currentPosition) {
    const pickupPosition = this._pickupPositionOnPage;
    if (pickupPosition) {
      return {
        x: currentPosition.x - pickupPosition.x,
        y: currentPosition.y - pickupPosition.y
      };
    }
    return {
      x: 0,
      y: 0
    };
  }
  /** Cleans up any cached element dimensions that we don't need after dragging has stopped. */
  _cleanupCachedDimensions() {
    this._boundaryRect = this._previewRect = void 0;
    this._parentPositions.clear();
  }
  /**
   * Checks whether the element is still inside its boundary after the viewport has been resized.
   * If not, the position is adjusted so that the element fits again.
   */
  _containInsideBoundaryOnResize() {
    let {
      x,
      y
    } = this._passiveTransform;
    if (x === 0 && y === 0 || this.isDragging() || !this._boundaryElement) {
      return;
    }
    const elementRect = this._rootElement.getBoundingClientRect();
    const boundaryRect = this._boundaryElement.getBoundingClientRect();
    if (boundaryRect.width === 0 && boundaryRect.height === 0 || elementRect.width === 0 && elementRect.height === 0) {
      return;
    }
    const leftOverflow = boundaryRect.left - elementRect.left;
    const rightOverflow = elementRect.right - boundaryRect.right;
    const topOverflow = boundaryRect.top - elementRect.top;
    const bottomOverflow = elementRect.bottom - boundaryRect.bottom;
    if (boundaryRect.width > elementRect.width) {
      if (leftOverflow > 0) {
        x += leftOverflow;
      }
      if (rightOverflow > 0) {
        x -= rightOverflow;
      }
    } else {
      x = 0;
    }
    if (boundaryRect.height > elementRect.height) {
      if (topOverflow > 0) {
        y += topOverflow;
      }
      if (bottomOverflow > 0) {
        y -= bottomOverflow;
      }
    } else {
      y = 0;
    }
    if (x !== this._passiveTransform.x || y !== this._passiveTransform.y) {
      this.setFreeDragPosition({
        y,
        x
      });
    }
  }
  /** Gets the drag start delay, based on the event type. */
  _getDragStartDelay(event) {
    const value = this.dragStartDelay;
    if (typeof value === "number") {
      return value;
    } else if (isTouchEvent(event)) {
      return value.touch;
    }
    return value ? value.mouse : 0;
  }
  /** Updates the internal state of the draggable element when scrolling has occurred. */
  _updateOnScroll(event) {
    const scrollDifference = this._parentPositions.handleScroll(event);
    if (scrollDifference) {
      const target = _getEventTarget(event);
      if (this._boundaryRect && target !== this._boundaryElement && target.contains(this._boundaryElement)) {
        adjustDomRect(this._boundaryRect, scrollDifference.top, scrollDifference.left);
      }
      this._pickupPositionOnPage.x += scrollDifference.left;
      this._pickupPositionOnPage.y += scrollDifference.top;
      if (!this._dropContainer) {
        this._activeTransform.x -= scrollDifference.left;
        this._activeTransform.y -= scrollDifference.top;
        this._applyRootElementTransform(this._activeTransform.x, this._activeTransform.y);
      }
    }
  }
  /** Gets the scroll position of the viewport. */
  _getViewportScrollPosition() {
    return this._parentPositions.positions.get(this._document)?.scrollPosition || this._parentPositions.getViewportScrollPosition();
  }
  /**
   * Lazily resolves and returns the shadow root of the element. We do this in a function, rather
   * than saving it in property directly on init, because we want to resolve it as late as possible
   * in order to ensure that the element has been moved into the shadow DOM. Doing it inside the
   * constructor might be too early if the element is inside of something like `ngFor` or `ngIf`.
   */
  _getShadowRoot() {
    if (this._cachedShadowRoot === void 0) {
      this._cachedShadowRoot = _getShadowRoot(this._rootElement);
    }
    return this._cachedShadowRoot;
  }
  /** Gets the element into which the drag preview should be inserted. */
  _getPreviewInsertionPoint(initialParent, shadowRoot) {
    const previewContainer = this._previewContainer || "global";
    if (previewContainer === "parent") {
      return initialParent;
    }
    if (previewContainer === "global") {
      const documentRef = this._document;
      return shadowRoot || documentRef.fullscreenElement || documentRef.webkitFullscreenElement || documentRef.mozFullScreenElement || documentRef.msFullscreenElement || documentRef.body;
    }
    return coerceElement(previewContainer);
  }
  /** Lazily resolves and returns the dimensions of the preview. */
  _getPreviewRect() {
    if (!this._previewRect || !this._previewRect.width && !this._previewRect.height) {
      this._previewRect = this._preview ? this._preview.getBoundingClientRect() : this._initialDomRect;
    }
    return this._previewRect;
  }
  /** Handles a native `dragstart` event. */
  _nativeDragStart = /* @__PURE__ */ __name((event) => {
    if (this._handles.length) {
      const targetHandle = this._getTargetHandle(event);
      if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {
        event.preventDefault();
      }
    } else if (!this.disabled) {
      event.preventDefault();
    }
  }, "_nativeDragStart");
  /** Gets a handle that is the target of an event. */
  _getTargetHandle(event) {
    return this._handles.find((handle) => {
      return event.target && (event.target === handle || handle.contains(event.target));
    });
  }
  /** Inserts the anchor element, if it's valid. */
  _conditionallyInsertAnchor(newContainer, exitContainer, nextItemElement) {
    if (newContainer === this._initialContainer) {
      this._anchor?.remove();
      this._anchor = null;
    } else if (exitContainer === this._initialContainer && exitContainer.hasAnchor) {
      const anchor = this._anchor ??= deepCloneNode(this._placeholder);
      anchor.classList.remove(PLACEHOLDER_CLASS);
      anchor.classList.add("cdk-drag-anchor");
      anchor.style.transform = "";
      if (nextItemElement) {
        nextItemElement.before(anchor);
      } else {
        coerceElement(exitContainer.element).appendChild(anchor);
      }
    }
  }
};
__name(_DragRef, "DragRef");
var DragRef = _DragRef;
function clamp$1(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
__name(clamp$1, "clamp$1");
function isTouchEvent(event) {
  return event.type[0] === "t";
}
__name(isTouchEvent, "isTouchEvent");
function shadowDomSelectStart(event) {
  event.preventDefault();
}
__name(shadowDomSelectStart, "shadowDomSelectStart");
function moveItemInArray(array, fromIndex, toIndex) {
  const from = clamp(fromIndex, array.length - 1);
  const to = clamp(toIndex, array.length - 1);
  if (from === to) {
    return;
  }
  const target = array[from];
  const delta = to < from ? -1 : 1;
  for (let i = from; i !== to; i += delta) {
    array[i] = array[i + delta];
  }
  array[to] = target;
}
__name(moveItemInArray, "moveItemInArray");
function transferArrayItem(currentArray, targetArray, currentIndex, targetIndex) {
  const from = clamp(currentIndex, currentArray.length - 1);
  const to = clamp(targetIndex, targetArray.length);
  if (currentArray.length) {
    targetArray.splice(to, 0, currentArray.splice(from, 1)[0]);
  }
}
__name(transferArrayItem, "transferArrayItem");
function clamp(value, max) {
  return Math.max(0, Math.min(max, value));
}
__name(clamp, "clamp");
var _SingleAxisSortStrategy = class _SingleAxisSortStrategy {
  _dragDropRegistry;
  /** Root element container of the drop list. */
  _element;
  /** Function used to determine if an item can be sorted into a specific index. */
  _sortPredicate;
  /** Cache of the dimensions of all the items inside the container. */
  _itemPositions = [];
  /**
   * Draggable items that are currently active inside the container. Includes the items
   * that were there at the start of the sequence, as well as any items that have been dragged
   * in, but haven't been dropped yet.
   */
  _activeDraggables;
  /** Direction in which the list is oriented. */
  orientation = "vertical";
  /** Layout direction of the drop list. */
  direction;
  constructor(_dragDropRegistry) {
    this._dragDropRegistry = _dragDropRegistry;
  }
  /**
   * Keeps track of the item that was last swapped with the dragged item, as well as what direction
   * the pointer was moving in when the swap occurred and whether the user's pointer continued to
   * overlap with the swapped item after the swapping occurred.
   */
  _previousSwap = {
    drag: null,
    delta: 0,
    overlaps: false
  };
  /**
   * To be called when the drag sequence starts.
   * @param items Items that are currently in the list.
   */
  start(items) {
    this.withItems(items);
  }
  /**
   * To be called when an item is being sorted.
   * @param item Item to be sorted.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param pointerDelta Direction in which the pointer is moving along each axis.
   */
  sort(item, pointerX, pointerY, pointerDelta) {
    const siblings = this._itemPositions;
    const newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY, pointerDelta);
    if (newIndex === -1 && siblings.length > 0) {
      return null;
    }
    const isHorizontal = this.orientation === "horizontal";
    const currentIndex = siblings.findIndex((currentItem) => currentItem.drag === item);
    const siblingAtNewPosition = siblings[newIndex];
    const currentPosition = siblings[currentIndex].clientRect;
    const newPosition = siblingAtNewPosition.clientRect;
    const delta = currentIndex > newIndex ? 1 : -1;
    const itemOffset = this._getItemOffsetPx(currentPosition, newPosition, delta);
    const siblingOffset = this._getSiblingOffsetPx(currentIndex, siblings, delta);
    const oldOrder = siblings.slice();
    moveItemInArray(siblings, currentIndex, newIndex);
    siblings.forEach((sibling, index) => {
      if (oldOrder[index] === sibling) {
        return;
      }
      const isDraggedItem = sibling.drag === item;
      const offset = isDraggedItem ? itemOffset : siblingOffset;
      const elementToOffset = isDraggedItem ? item.getPlaceholderElement() : sibling.drag.getRootElement();
      sibling.offset += offset;
      const transformAmount = Math.round(sibling.offset * (1 / sibling.drag.scale));
      if (isHorizontal) {
        elementToOffset.style.transform = combineTransforms(`translate3d(${transformAmount}px, 0, 0)`, sibling.initialTransform);
        adjustDomRect(sibling.clientRect, 0, offset);
      } else {
        elementToOffset.style.transform = combineTransforms(`translate3d(0, ${transformAmount}px, 0)`, sibling.initialTransform);
        adjustDomRect(sibling.clientRect, offset, 0);
      }
    });
    this._previousSwap.overlaps = isInsideClientRect(newPosition, pointerX, pointerY);
    this._previousSwap.drag = siblingAtNewPosition.drag;
    this._previousSwap.delta = isHorizontal ? pointerDelta.x : pointerDelta.y;
    return {
      previousIndex: currentIndex,
      currentIndex: newIndex
    };
  }
  /**
   * Called when an item is being moved into the container.
   * @param item Item that was moved into the container.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param index Index at which the item entered. If omitted, the container will try to figure it
   *   out automatically.
   */
  enter(item, pointerX, pointerY, index) {
    const newIndex = index == null || index < 0 ? (
      // We use the coordinates of where the item entered the drop
      // zone to figure out at which index it should be inserted.
      this._getItemIndexFromPointerPosition(item, pointerX, pointerY)
    ) : index;
    const activeDraggables = this._activeDraggables;
    const currentIndex = activeDraggables.indexOf(item);
    const placeholder = item.getPlaceholderElement();
    let newPositionReference = activeDraggables[newIndex];
    if (newPositionReference === item) {
      newPositionReference = activeDraggables[newIndex + 1];
    }
    if (!newPositionReference && (newIndex == null || newIndex === -1 || newIndex < activeDraggables.length - 1) && this._shouldEnterAsFirstChild(pointerX, pointerY)) {
      newPositionReference = activeDraggables[0];
    }
    if (currentIndex > -1) {
      activeDraggables.splice(currentIndex, 1);
    }
    if (newPositionReference && !this._dragDropRegistry.isDragging(newPositionReference)) {
      const element = newPositionReference.getRootElement();
      element.parentElement.insertBefore(placeholder, element);
      activeDraggables.splice(newIndex, 0, item);
    } else {
      this._element.appendChild(placeholder);
      activeDraggables.push(item);
    }
    placeholder.style.transform = "";
    this._cacheItemPositions();
  }
  /** Sets the items that are currently part of the list. */
  withItems(items) {
    this._activeDraggables = items.slice();
    this._cacheItemPositions();
  }
  /** Assigns a sort predicate to the strategy. */
  withSortPredicate(predicate) {
    this._sortPredicate = predicate;
  }
  /** Resets the strategy to its initial state before dragging was started. */
  reset() {
    this._activeDraggables?.forEach((item) => {
      const rootElement = item.getRootElement();
      if (rootElement) {
        const initialTransform = this._itemPositions.find((p) => p.drag === item)?.initialTransform;
        rootElement.style.transform = initialTransform || "";
      }
    });
    this._itemPositions = [];
    this._activeDraggables = [];
    this._previousSwap.drag = null;
    this._previousSwap.delta = 0;
    this._previousSwap.overlaps = false;
  }
  /**
   * Gets a snapshot of items currently in the list.
   * Can include items that we dragged in from another list.
   */
  getActiveItemsSnapshot() {
    return this._activeDraggables;
  }
  /** Gets the index of a specific item. */
  getItemIndex(item) {
    return this._getVisualItemPositions().findIndex((currentItem) => currentItem.drag === item);
  }
  /** Gets the item at a specific index. */
  getItemAtIndex(index) {
    return this._getVisualItemPositions()[index]?.drag || null;
  }
  /** Used to notify the strategy that the scroll position has changed. */
  updateOnScroll(topDifference, leftDifference) {
    this._itemPositions.forEach(({
      clientRect
    }) => {
      adjustDomRect(clientRect, topDifference, leftDifference);
    });
    this._itemPositions.forEach(({
      drag
    }) => {
      if (this._dragDropRegistry.isDragging(drag)) {
        drag._sortFromLastPointerPosition();
      }
    });
  }
  withElementContainer(container) {
    this._element = container;
  }
  /** Refreshes the position cache of the items and sibling containers. */
  _cacheItemPositions() {
    const isHorizontal = this.orientation === "horizontal";
    this._itemPositions = this._activeDraggables.map((drag) => {
      const elementToMeasure = drag.getVisibleElement();
      return {
        drag,
        offset: 0,
        initialTransform: elementToMeasure.style.transform || "",
        clientRect: getMutableClientRect(elementToMeasure)
      };
    }).sort((a, b) => {
      return isHorizontal ? a.clientRect.left - b.clientRect.left : a.clientRect.top - b.clientRect.top;
    });
  }
  _getVisualItemPositions() {
    return this.orientation === "horizontal" && this.direction === "rtl" ? this._itemPositions.slice().reverse() : this._itemPositions;
  }
  /**
   * Gets the offset in pixels by which the item that is being dragged should be moved.
   * @param currentPosition Current position of the item.
   * @param newPosition Position of the item where the current item should be moved.
   * @param delta Direction in which the user is moving.
   */
  _getItemOffsetPx(currentPosition, newPosition, delta) {
    const isHorizontal = this.orientation === "horizontal";
    let itemOffset = isHorizontal ? newPosition.left - currentPosition.left : newPosition.top - currentPosition.top;
    if (delta === -1) {
      itemOffset += isHorizontal ? newPosition.width - currentPosition.width : newPosition.height - currentPosition.height;
    }
    return itemOffset;
  }
  /**
   * Gets the offset in pixels by which the items that aren't being dragged should be moved.
   * @param currentIndex Index of the item currently being dragged.
   * @param siblings All of the items in the list.
   * @param delta Direction in which the user is moving.
   */
  _getSiblingOffsetPx(currentIndex, siblings, delta) {
    const isHorizontal = this.orientation === "horizontal";
    const currentPosition = siblings[currentIndex].clientRect;
    const immediateSibling = siblings[currentIndex + delta * -1];
    let siblingOffset = currentPosition[isHorizontal ? "width" : "height"] * delta;
    if (immediateSibling) {
      const start = isHorizontal ? "left" : "top";
      const end = isHorizontal ? "right" : "bottom";
      if (delta === -1) {
        siblingOffset -= immediateSibling.clientRect[start] - currentPosition[end];
      } else {
        siblingOffset += currentPosition[start] - immediateSibling.clientRect[end];
      }
    }
    return siblingOffset;
  }
  /**
   * Checks if pointer is entering in the first position
   * @param pointerX Position of the user's pointer along the X axis.
   * @param pointerY Position of the user's pointer along the Y axis.
   */
  _shouldEnterAsFirstChild(pointerX, pointerY) {
    if (!this._activeDraggables.length) {
      return false;
    }
    const itemPositions = this._itemPositions;
    const isHorizontal = this.orientation === "horizontal";
    const reversed = itemPositions[0].drag !== this._activeDraggables[0];
    if (reversed) {
      const lastItemRect = itemPositions[itemPositions.length - 1].clientRect;
      return isHorizontal ? pointerX >= lastItemRect.right : pointerY >= lastItemRect.bottom;
    } else {
      const firstItemRect = itemPositions[0].clientRect;
      return isHorizontal ? pointerX <= firstItemRect.left : pointerY <= firstItemRect.top;
    }
  }
  /**
   * Gets the index of an item in the drop container, based on the position of the user's pointer.
   * @param item Item that is being sorted.
   * @param pointerX Position of the user's pointer along the X axis.
   * @param pointerY Position of the user's pointer along the Y axis.
   * @param delta Direction in which the user is moving their pointer.
   */
  _getItemIndexFromPointerPosition(item, pointerX, pointerY, delta) {
    const isHorizontal = this.orientation === "horizontal";
    const index = this._itemPositions.findIndex(({
      drag,
      clientRect
    }) => {
      if (drag === item) {
        return false;
      }
      if (delta) {
        const direction = isHorizontal ? delta.x : delta.y;
        if (drag === this._previousSwap.drag && this._previousSwap.overlaps && direction === this._previousSwap.delta) {
          return false;
        }
      }
      return isHorizontal ? (
        // Round these down since most browsers report client rects with
        // sub-pixel precision, whereas the pointer coordinates are rounded to pixels.
        pointerX >= Math.floor(clientRect.left) && pointerX < Math.floor(clientRect.right)
      ) : pointerY >= Math.floor(clientRect.top) && pointerY < Math.floor(clientRect.bottom);
    });
    return index === -1 || !this._sortPredicate(index, item) ? -1 : index;
  }
};
__name(_SingleAxisSortStrategy, "SingleAxisSortStrategy");
var SingleAxisSortStrategy = _SingleAxisSortStrategy;
var _MixedSortStrategy = class _MixedSortStrategy {
  _document;
  _dragDropRegistry;
  /** Root element container of the drop list. */
  _element;
  /** Function used to determine if an item can be sorted into a specific index. */
  _sortPredicate;
  /** Lazily-resolved root node containing the list. Use `_getRootNode` to read this. */
  _rootNode;
  /**
   * Draggable items that are currently active inside the container. Includes the items
   * that were there at the start of the sequence, as well as any items that have been dragged
   * in, but haven't been dropped yet.
   */
  _activeItems;
  /**
   * Keeps track of the item that was last swapped with the dragged item, as well as what direction
   * the pointer was moving in when the swap occurred and whether the user's pointer continued to
   * overlap with the swapped item after the swapping occurred.
   */
  _previousSwap = {
    drag: null,
    deltaX: 0,
    deltaY: 0,
    overlaps: false
  };
  /**
   * Keeps track of the relationship between a node and its next sibling. This information
   * is used to restore the DOM to the order it was in before dragging started.
   */
  _relatedNodes = [];
  constructor(_document, _dragDropRegistry) {
    this._document = _document;
    this._dragDropRegistry = _dragDropRegistry;
  }
  /**
   * To be called when the drag sequence starts.
   * @param items Items that are currently in the list.
   */
  start(items) {
    const childNodes = this._element.childNodes;
    this._relatedNodes = [];
    for (let i = 0; i < childNodes.length; i++) {
      const node = childNodes[i];
      this._relatedNodes.push([node, node.nextSibling]);
    }
    this.withItems(items);
  }
  /**
   * To be called when an item is being sorted.
   * @param item Item to be sorted.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param pointerDelta Direction in which the pointer is moving along each axis.
   */
  sort(item, pointerX, pointerY, pointerDelta) {
    const newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY);
    const previousSwap = this._previousSwap;
    if (newIndex === -1 || this._activeItems[newIndex] === item) {
      return null;
    }
    const toSwapWith = this._activeItems[newIndex];
    if (previousSwap.drag === toSwapWith && previousSwap.overlaps && previousSwap.deltaX === pointerDelta.x && previousSwap.deltaY === pointerDelta.y) {
      return null;
    }
    const previousIndex = this.getItemIndex(item);
    const current = item.getPlaceholderElement();
    const overlapElement = toSwapWith.getRootElement();
    if (newIndex > previousIndex) {
      overlapElement.after(current);
    } else {
      overlapElement.before(current);
    }
    moveItemInArray(this._activeItems, previousIndex, newIndex);
    const newOverlapElement = this._getRootNode().elementFromPoint(pointerX, pointerY);
    previousSwap.deltaX = pointerDelta.x;
    previousSwap.deltaY = pointerDelta.y;
    previousSwap.drag = toSwapWith;
    previousSwap.overlaps = overlapElement === newOverlapElement || overlapElement.contains(newOverlapElement);
    return {
      previousIndex,
      currentIndex: newIndex
    };
  }
  /**
   * Called when an item is being moved into the container.
   * @param item Item that was moved into the container.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param index Index at which the item entered. If omitted, the container will try to figure it
   *   out automatically.
   */
  enter(item, pointerX, pointerY, index) {
    const currentIndex = this._activeItems.indexOf(item);
    if (currentIndex > -1) {
      this._activeItems.splice(currentIndex, 1);
    }
    let enterIndex = index == null || index < 0 ? this._getItemIndexFromPointerPosition(item, pointerX, pointerY) : index;
    if (enterIndex === -1) {
      enterIndex = this._getClosestItemIndexToPointer(item, pointerX, pointerY);
    }
    const targetItem = this._activeItems[enterIndex];
    if (targetItem && !this._dragDropRegistry.isDragging(targetItem)) {
      this._activeItems.splice(enterIndex, 0, item);
      targetItem.getRootElement().before(item.getPlaceholderElement());
    } else {
      this._activeItems.push(item);
      this._element.appendChild(item.getPlaceholderElement());
    }
  }
  /** Sets the items that are currently part of the list. */
  withItems(items) {
    this._activeItems = items.slice();
  }
  /** Assigns a sort predicate to the strategy. */
  withSortPredicate(predicate) {
    this._sortPredicate = predicate;
  }
  /** Resets the strategy to its initial state before dragging was started. */
  reset() {
    const root = this._element;
    const previousSwap = this._previousSwap;
    for (let i = this._relatedNodes.length - 1; i > -1; i--) {
      const [node, nextSibling] = this._relatedNodes[i];
      if (node.parentNode === root && node.nextSibling !== nextSibling) {
        if (nextSibling === null) {
          root.appendChild(node);
        } else if (nextSibling.parentNode === root) {
          root.insertBefore(node, nextSibling);
        }
      }
    }
    this._relatedNodes = [];
    this._activeItems = [];
    previousSwap.drag = null;
    previousSwap.deltaX = previousSwap.deltaY = 0;
    previousSwap.overlaps = false;
  }
  /**
   * Gets a snapshot of items currently in the list.
   * Can include items that we dragged in from another list.
   */
  getActiveItemsSnapshot() {
    return this._activeItems;
  }
  /** Gets the index of a specific item. */
  getItemIndex(item) {
    return this._activeItems.indexOf(item);
  }
  /** Gets the item at a specific index. */
  getItemAtIndex(index) {
    return this._activeItems[index] || null;
  }
  /** Used to notify the strategy that the scroll position has changed. */
  updateOnScroll() {
    this._activeItems.forEach((item) => {
      if (this._dragDropRegistry.isDragging(item)) {
        item._sortFromLastPointerPosition();
      }
    });
  }
  withElementContainer(container) {
    if (container !== this._element) {
      this._element = container;
      this._rootNode = void 0;
    }
  }
  /**
   * Gets the index of an item in the drop container, based on the position of the user's pointer.
   * @param item Item that is being sorted.
   * @param pointerX Position of the user's pointer along the X axis.
   * @param pointerY Position of the user's pointer along the Y axis.
   * @param delta Direction in which the user is moving their pointer.
   */
  _getItemIndexFromPointerPosition(item, pointerX, pointerY) {
    const elementAtPoint = this._getRootNode().elementFromPoint(Math.floor(pointerX), Math.floor(pointerY));
    const index = elementAtPoint ? this._activeItems.findIndex((item2) => {
      const root = item2.getRootElement();
      return elementAtPoint === root || root.contains(elementAtPoint);
    }) : -1;
    return index === -1 || !this._sortPredicate(index, item) ? -1 : index;
  }
  /** Lazily resolves the list's root node. */
  _getRootNode() {
    if (!this._rootNode) {
      this._rootNode = _getShadowRoot(this._element) || this._document;
    }
    return this._rootNode;
  }
  /**
   * Finds the index of the item that's closest to the item being dragged.
   * @param item Item being dragged.
   * @param pointerX Position of the user's pointer along the X axis.
   * @param pointerY Position of the user's pointer along the Y axis.
   */
  _getClosestItemIndexToPointer(item, pointerX, pointerY) {
    if (this._activeItems.length === 0) {
      return -1;
    }
    if (this._activeItems.length === 1) {
      return 0;
    }
    let minDistance = Infinity;
    let minIndex = -1;
    for (let i = 0; i < this._activeItems.length; i++) {
      const current = this._activeItems[i];
      if (current !== item) {
        const {
          x,
          y
        } = current.getRootElement().getBoundingClientRect();
        const distance = Math.hypot(pointerX - x, pointerY - y);
        if (distance < minDistance) {
          minDistance = distance;
          minIndex = i;
        }
      }
    }
    return minIndex;
  }
};
__name(_MixedSortStrategy, "MixedSortStrategy");
var MixedSortStrategy = _MixedSortStrategy;
var DROP_PROXIMITY_THRESHOLD = 0.05;
var SCROLL_PROXIMITY_THRESHOLD = 0.05;
var AutoScrollVerticalDirection;
(function(AutoScrollVerticalDirection2) {
  AutoScrollVerticalDirection2[AutoScrollVerticalDirection2["NONE"] = 0] = "NONE";
  AutoScrollVerticalDirection2[AutoScrollVerticalDirection2["UP"] = 1] = "UP";
  AutoScrollVerticalDirection2[AutoScrollVerticalDirection2["DOWN"] = 2] = "DOWN";
})(AutoScrollVerticalDirection || (AutoScrollVerticalDirection = {}));
var AutoScrollHorizontalDirection;
(function(AutoScrollHorizontalDirection2) {
  AutoScrollHorizontalDirection2[AutoScrollHorizontalDirection2["NONE"] = 0] = "NONE";
  AutoScrollHorizontalDirection2[AutoScrollHorizontalDirection2["LEFT"] = 1] = "LEFT";
  AutoScrollHorizontalDirection2[AutoScrollHorizontalDirection2["RIGHT"] = 2] = "RIGHT";
})(AutoScrollHorizontalDirection || (AutoScrollHorizontalDirection = {}));
var _DropListRef = class _DropListRef {
  _dragDropRegistry;
  _ngZone;
  _viewportRuler;
  /** Element that the drop list is attached to. */
  element;
  /** Whether starting a dragging sequence from this container is disabled. */
  disabled = false;
  /** Whether sorting items within the list is disabled. */
  sortingDisabled = false;
  /** Locks the position of the draggable elements inside the container along the specified axis. */
  lockAxis = null;
  /**
   * Whether auto-scrolling the view when the user
   * moves their pointer close to the edges is disabled.
   */
  autoScrollDisabled = false;
  /** Number of pixels to scroll for each frame when auto-scrolling an element. */
  autoScrollStep = 2;
  /**
   * Whether the items in the list should leave an anchor node when leaving the initial container.
   */
  hasAnchor = false;
  /**
   * Function that is used to determine whether an item
   * is allowed to be moved into a drop container.
   */
  enterPredicate = /* @__PURE__ */ __name(() => true, "enterPredicate");
  /** Function that is used to determine whether an item can be sorted into a particular index. */
  sortPredicate = /* @__PURE__ */ __name(() => true, "sortPredicate");
  /** Emits right before dragging has started. */
  beforeStarted = new Subject();
  /**
   * Emits when the user has moved a new drag item into this container.
   */
  entered = new Subject();
  /**
   * Emits when the user removes an item from the container
   * by dragging it into another container.
   */
  exited = new Subject();
  /** Emits when the user drops an item inside the container. */
  dropped = new Subject();
  /** Emits as the user is swapping items while actively dragging. */
  sorted = new Subject();
  /** Emits when a dragging sequence is started in a list connected to the current one. */
  receivingStarted = new Subject();
  /** Emits when a dragging sequence is stopped from a list connected to the current one. */
  receivingStopped = new Subject();
  /** Arbitrary data that can be attached to the drop list. */
  data;
  /** Element that is the direct parent of the drag items. */
  _container;
  /** Whether an item in the list is being dragged. */
  _isDragging = false;
  /** Keeps track of the positions of any parent scrollable elements. */
  _parentPositions;
  /** Strategy being used to sort items within the list. */
  _sortStrategy;
  /** Cached `DOMRect` of the drop list. */
  _domRect;
  /** Draggable items in the container. */
  _draggables = [];
  /** Drop lists that are connected to the current one. */
  _siblings = [];
  /** Connected siblings that currently have a dragged item. */
  _activeSiblings = /* @__PURE__ */ new Set();
  /** Subscription to the window being scrolled. */
  _viewportScrollSubscription = Subscription.EMPTY;
  /** Vertical direction in which the list is currently scrolling. */
  _verticalScrollDirection = AutoScrollVerticalDirection.NONE;
  /** Horizontal direction in which the list is currently scrolling. */
  _horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;
  /** Node that is being auto-scrolled. */
  _scrollNode;
  /** Used to signal to the current auto-scroll sequence when to stop. */
  _stopScrollTimers = new Subject();
  /** Shadow root of the current element. Necessary for `elementFromPoint` to resolve correctly. */
  _cachedShadowRoot = null;
  /** Reference to the document. */
  _document;
  /** Elements that can be scrolled while the user is dragging. */
  _scrollableElements = [];
  /** Initial value for the element's `scroll-snap-type` style. */
  _initialScrollSnap;
  /** Direction of the list's layout. */
  _direction = "ltr";
  constructor(element, _dragDropRegistry, _document, _ngZone, _viewportRuler) {
    this._dragDropRegistry = _dragDropRegistry;
    this._ngZone = _ngZone;
    this._viewportRuler = _viewportRuler;
    const coercedElement = this.element = coerceElement(element);
    this._document = _document;
    this.withOrientation("vertical").withElementContainer(coercedElement);
    _dragDropRegistry.registerDropContainer(this);
    this._parentPositions = new ParentPositionTracker(_document);
  }
  /** Removes the drop list functionality from the DOM element. */
  dispose() {
    this._stopScrolling();
    this._stopScrollTimers.complete();
    this._viewportScrollSubscription.unsubscribe();
    this.beforeStarted.complete();
    this.entered.complete();
    this.exited.complete();
    this.dropped.complete();
    this.sorted.complete();
    this.receivingStarted.complete();
    this.receivingStopped.complete();
    this._activeSiblings.clear();
    this._scrollNode = null;
    this._parentPositions.clear();
    this._dragDropRegistry.removeDropContainer(this);
  }
  /** Whether an item from this list is currently being dragged. */
  isDragging() {
    return this._isDragging;
  }
  /** Starts dragging an item. */
  start() {
    this._draggingStarted();
    this._notifyReceivingSiblings();
  }
  /**
   * Attempts to move an item into the container.
   * @param item Item that was moved into the container.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param index Index at which the item entered. If omitted, the container will try to figure it
   *   out automatically.
   */
  enter(item, pointerX, pointerY, index) {
    this._draggingStarted();
    if (index == null && this.sortingDisabled) {
      index = this._draggables.indexOf(item);
    }
    this._sortStrategy.enter(item, pointerX, pointerY, index);
    this._cacheParentPositions();
    this._notifyReceivingSiblings();
    this.entered.next({
      item,
      container: this,
      currentIndex: this.getItemIndex(item)
    });
  }
  /**
   * Removes an item from the container after it was dragged into another container by the user.
   * @param item Item that was dragged out.
   */
  exit(item) {
    this._reset();
    this.exited.next({
      item,
      container: this
    });
  }
  /**
   * Drops an item into this container.
   * @param item Item being dropped into the container.
   * @param currentIndex Index at which the item should be inserted.
   * @param previousIndex Index of the item when dragging started.
   * @param previousContainer Container from which the item got dragged in.
   * @param isPointerOverContainer Whether the user's pointer was over the
   *    container when the item was dropped.
   * @param distance Distance the user has dragged since the start of the dragging sequence.
   * @param event Event that triggered the dropping sequence.
   *
   * @breaking-change 15.0.0 `previousIndex` and `event` parameters to become required.
   */
  drop(item, currentIndex, previousIndex, previousContainer, isPointerOverContainer, distance, dropPoint, event = {}) {
    this._reset();
    this.dropped.next({
      item,
      currentIndex,
      previousIndex,
      container: this,
      previousContainer,
      isPointerOverContainer,
      distance,
      dropPoint,
      event
    });
  }
  /**
   * Sets the draggable items that are a part of this list.
   * @param items Items that are a part of this list.
   */
  withItems(items) {
    const previousItems = this._draggables;
    this._draggables = items;
    items.forEach((item) => item._withDropContainer(this));
    if (this.isDragging()) {
      const draggedItems = previousItems.filter((item) => item.isDragging());
      if (draggedItems.every((item) => items.indexOf(item) === -1)) {
        this._reset();
      } else {
        this._sortStrategy.withItems(this._draggables);
      }
    }
    return this;
  }
  /** Sets the layout direction of the drop list. */
  withDirection(direction) {
    this._direction = direction;
    if (this._sortStrategy instanceof SingleAxisSortStrategy) {
      this._sortStrategy.direction = direction;
    }
    return this;
  }
  /**
   * Sets the containers that are connected to this one. When two or more containers are
   * connected, the user will be allowed to transfer items between them.
   * @param connectedTo Other containers that the current containers should be connected to.
   */
  connectedTo(connectedTo) {
    this._siblings = connectedTo.slice();
    return this;
  }
  /**
   * Sets the orientation of the container.
   * @param orientation New orientation for the container.
   */
  withOrientation(orientation) {
    if (orientation === "mixed") {
      this._sortStrategy = new MixedSortStrategy(this._document, this._dragDropRegistry);
    } else {
      const strategy = new SingleAxisSortStrategy(this._dragDropRegistry);
      strategy.direction = this._direction;
      strategy.orientation = orientation;
      this._sortStrategy = strategy;
    }
    this._sortStrategy.withElementContainer(this._container);
    this._sortStrategy.withSortPredicate((index, item) => this.sortPredicate(index, item, this));
    return this;
  }
  /**
   * Sets which parent elements are can be scrolled while the user is dragging.
   * @param elements Elements that can be scrolled.
   */
  withScrollableParents(elements) {
    const element = this._container;
    this._scrollableElements = elements.indexOf(element) === -1 ? [element, ...elements] : elements.slice();
    return this;
  }
  /**
   * Configures the drop list so that a different element is used as the container for the
   * dragged items. This is useful for the cases when one might not have control over the
   * full DOM that sets up the dragging.
   * Note that the alternate container needs to be a descendant of the drop list.
   * @param container New element container to be assigned.
   */
  withElementContainer(container) {
    if (container === this._container) {
      return this;
    }
    const element = coerceElement(this.element);
    if ((typeof ngDevMode === "undefined" || ngDevMode) && container !== element && !element.contains(container)) {
      throw new Error("Invalid DOM structure for drop list. Alternate container element must be a descendant of the drop list.");
    }
    const oldContainerIndex = this._scrollableElements.indexOf(this._container);
    const newContainerIndex = this._scrollableElements.indexOf(container);
    if (oldContainerIndex > -1) {
      this._scrollableElements.splice(oldContainerIndex, 1);
    }
    if (newContainerIndex > -1) {
      this._scrollableElements.splice(newContainerIndex, 1);
    }
    if (this._sortStrategy) {
      this._sortStrategy.withElementContainer(container);
    }
    this._cachedShadowRoot = null;
    this._scrollableElements.unshift(container);
    this._container = container;
    return this;
  }
  /** Gets the scrollable parents that are registered with this drop container. */
  getScrollableParents() {
    return this._scrollableElements;
  }
  /**
   * Figures out the index of an item in the container.
   * @param item Item whose index should be determined.
   */
  getItemIndex(item) {
    return this._isDragging ? this._sortStrategy.getItemIndex(item) : this._draggables.indexOf(item);
  }
  /**
   * Gets the item at a specific index.
   * @param index Index at which to retrieve the item.
   */
  getItemAtIndex(index) {
    return this._isDragging ? this._sortStrategy.getItemAtIndex(index) : this._draggables[index] || null;
  }
  /**
   * Whether the list is able to receive the item that
   * is currently being dragged inside a connected drop list.
   */
  isReceiving() {
    return this._activeSiblings.size > 0;
  }
  /**
   * Sorts an item inside the container based on its position.
   * @param item Item to be sorted.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param pointerDelta Direction in which the pointer is moving along each axis.
   */
  _sortItem(item, pointerX, pointerY, pointerDelta) {
    if (this.sortingDisabled || !this._domRect || !isPointerNearDomRect(this._domRect, DROP_PROXIMITY_THRESHOLD, pointerX, pointerY)) {
      return;
    }
    const result = this._sortStrategy.sort(item, pointerX, pointerY, pointerDelta);
    if (result) {
      this.sorted.next({
        previousIndex: result.previousIndex,
        currentIndex: result.currentIndex,
        container: this,
        item
      });
    }
  }
  /**
   * Checks whether the user's pointer is close to the edges of either the
   * viewport or the drop list and starts the auto-scroll sequence.
   * @param pointerX User's pointer position along the x axis.
   * @param pointerY User's pointer position along the y axis.
   */
  _startScrollingIfNecessary(pointerX, pointerY) {
    if (this.autoScrollDisabled) {
      return;
    }
    let scrollNode;
    let verticalScrollDirection = AutoScrollVerticalDirection.NONE;
    let horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;
    this._parentPositions.positions.forEach((position, element) => {
      if (element === this._document || !position.clientRect || scrollNode) {
        return;
      }
      if (isPointerNearDomRect(position.clientRect, DROP_PROXIMITY_THRESHOLD, pointerX, pointerY)) {
        [verticalScrollDirection, horizontalScrollDirection] = getElementScrollDirections(element, position.clientRect, this._direction, pointerX, pointerY);
        if (verticalScrollDirection || horizontalScrollDirection) {
          scrollNode = element;
        }
      }
    });
    if (!verticalScrollDirection && !horizontalScrollDirection) {
      const {
        width,
        height
      } = this._viewportRuler.getViewportSize();
      const domRect = {
        width,
        height,
        top: 0,
        right: width,
        bottom: height,
        left: 0
      };
      verticalScrollDirection = getVerticalScrollDirection(domRect, pointerY);
      horizontalScrollDirection = getHorizontalScrollDirection(domRect, pointerX);
      scrollNode = window;
    }
    if (scrollNode && (verticalScrollDirection !== this._verticalScrollDirection || horizontalScrollDirection !== this._horizontalScrollDirection || scrollNode !== this._scrollNode)) {
      this._verticalScrollDirection = verticalScrollDirection;
      this._horizontalScrollDirection = horizontalScrollDirection;
      this._scrollNode = scrollNode;
      if ((verticalScrollDirection || horizontalScrollDirection) && scrollNode) {
        this._ngZone.runOutsideAngular(this._startScrollInterval);
      } else {
        this._stopScrolling();
      }
    }
  }
  /** Stops any currently-running auto-scroll sequences. */
  _stopScrolling() {
    this._stopScrollTimers.next();
  }
  /** Starts the dragging sequence within the list. */
  _draggingStarted() {
    const styles = this._container.style;
    this.beforeStarted.next();
    this._isDragging = true;
    if ((typeof ngDevMode === "undefined" || ngDevMode) && // Prevent the check from running on apps not using an alternate container. Ideally we
    // would always run it, but introducing it at this stage would be a breaking change.
    this._container !== coerceElement(this.element)) {
      for (const drag of this._draggables) {
        if (!drag.isDragging() && drag.getVisibleElement().parentNode !== this._container) {
          throw new Error("Invalid DOM structure for drop list. All items must be placed directly inside of the element container.");
        }
      }
    }
    this._initialScrollSnap = styles.msScrollSnapType || styles.scrollSnapType || "";
    styles.scrollSnapType = styles.msScrollSnapType = "none";
    this._sortStrategy.start(this._draggables);
    this._cacheParentPositions();
    this._viewportScrollSubscription.unsubscribe();
    this._listenToScrollEvents();
  }
  /** Caches the positions of the configured scrollable parents. */
  _cacheParentPositions() {
    this._parentPositions.cache(this._scrollableElements);
    this._domRect = this._parentPositions.positions.get(this._container).clientRect;
  }
  /** Resets the container to its initial state. */
  _reset() {
    this._isDragging = false;
    const styles = this._container.style;
    styles.scrollSnapType = styles.msScrollSnapType = this._initialScrollSnap;
    this._siblings.forEach((sibling) => sibling._stopReceiving(this));
    this._sortStrategy.reset();
    this._stopScrolling();
    this._viewportScrollSubscription.unsubscribe();
    this._parentPositions.clear();
  }
  /** Starts the interval that'll auto-scroll the element. */
  _startScrollInterval = /* @__PURE__ */ __name(() => {
    this._stopScrolling();
    interval(0, animationFrameScheduler).pipe(takeUntil(this._stopScrollTimers)).subscribe(() => {
      const node = this._scrollNode;
      const scrollStep = this.autoScrollStep;
      if (this._verticalScrollDirection === AutoScrollVerticalDirection.UP) {
        node.scrollBy(0, -scrollStep);
      } else if (this._verticalScrollDirection === AutoScrollVerticalDirection.DOWN) {
        node.scrollBy(0, scrollStep);
      }
      if (this._horizontalScrollDirection === AutoScrollHorizontalDirection.LEFT) {
        node.scrollBy(-scrollStep, 0);
      } else if (this._horizontalScrollDirection === AutoScrollHorizontalDirection.RIGHT) {
        node.scrollBy(scrollStep, 0);
      }
    });
  }, "_startScrollInterval");
  /**
   * Checks whether the user's pointer is positioned over the container.
   * @param x Pointer position along the X axis.
   * @param y Pointer position along the Y axis.
   */
  _isOverContainer(x, y) {
    return this._domRect != null && isInsideClientRect(this._domRect, x, y);
  }
  /**
   * Figures out whether an item should be moved into a sibling
   * drop container, based on its current position.
   * @param item Drag item that is being moved.
   * @param x Position of the item along the X axis.
   * @param y Position of the item along the Y axis.
   */
  _getSiblingContainerFromPosition(item, x, y) {
    return this._siblings.find((sibling) => sibling._canReceive(item, x, y));
  }
  /**
   * Checks whether the drop list can receive the passed-in item.
   * @param item Item that is being dragged into the list.
   * @param x Position of the item along the X axis.
   * @param y Position of the item along the Y axis.
   */
  _canReceive(item, x, y) {
    if (!this._domRect || !isInsideClientRect(this._domRect, x, y) || !this.enterPredicate(item, this)) {
      return false;
    }
    const elementFromPoint = this._getShadowRoot().elementFromPoint(x, y);
    if (!elementFromPoint) {
      return false;
    }
    return elementFromPoint === this._container || this._container.contains(elementFromPoint);
  }
  /**
   * Called by one of the connected drop lists when a dragging sequence has started.
   * @param sibling Sibling in which dragging has started.
   */
  _startReceiving(sibling, items) {
    const activeSiblings = this._activeSiblings;
    if (!activeSiblings.has(sibling) && items.every((item) => {
      return this.enterPredicate(item, this) || this._draggables.indexOf(item) > -1;
    })) {
      activeSiblings.add(sibling);
      this._cacheParentPositions();
      this._listenToScrollEvents();
      this.receivingStarted.next({
        initiator: sibling,
        receiver: this,
        items
      });
    }
  }
  /**
   * Called by a connected drop list when dragging has stopped.
   * @param sibling Sibling whose dragging has stopped.
   */
  _stopReceiving(sibling) {
    this._activeSiblings.delete(sibling);
    this._viewportScrollSubscription.unsubscribe();
    this.receivingStopped.next({
      initiator: sibling,
      receiver: this
    });
  }
  /**
   * Starts listening to scroll events on the viewport.
   * Used for updating the internal state of the list.
   */
  _listenToScrollEvents() {
    this._viewportScrollSubscription = this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe((event) => {
      if (this.isDragging()) {
        const scrollDifference = this._parentPositions.handleScroll(event);
        if (scrollDifference) {
          this._sortStrategy.updateOnScroll(scrollDifference.top, scrollDifference.left);
        }
      } else if (this.isReceiving()) {
        this._cacheParentPositions();
      }
    });
  }
  /**
   * Lazily resolves and returns the shadow root of the element. We do this in a function, rather
   * than saving it in property directly on init, because we want to resolve it as late as possible
   * in order to ensure that the element has been moved into the shadow DOM. Doing it inside the
   * constructor might be too early if the element is inside of something like `ngFor` or `ngIf`.
   */
  _getShadowRoot() {
    if (!this._cachedShadowRoot) {
      const shadowRoot = _getShadowRoot(this._container);
      this._cachedShadowRoot = shadowRoot || this._document;
    }
    return this._cachedShadowRoot;
  }
  /** Notifies any siblings that may potentially receive the item. */
  _notifyReceivingSiblings() {
    const draggedItems = this._sortStrategy.getActiveItemsSnapshot().filter((item) => item.isDragging());
    this._siblings.forEach((sibling) => sibling._startReceiving(this, draggedItems));
  }
};
__name(_DropListRef, "DropListRef");
var DropListRef = _DropListRef;
function getVerticalScrollDirection(clientRect, pointerY) {
  const {
    top,
    bottom,
    height
  } = clientRect;
  const yThreshold = height * SCROLL_PROXIMITY_THRESHOLD;
  if (pointerY >= top - yThreshold && pointerY <= top + yThreshold) {
    return AutoScrollVerticalDirection.UP;
  } else if (pointerY >= bottom - yThreshold && pointerY <= bottom + yThreshold) {
    return AutoScrollVerticalDirection.DOWN;
  }
  return AutoScrollVerticalDirection.NONE;
}
__name(getVerticalScrollDirection, "getVerticalScrollDirection");
function getHorizontalScrollDirection(clientRect, pointerX) {
  const {
    left,
    right,
    width
  } = clientRect;
  const xThreshold = width * SCROLL_PROXIMITY_THRESHOLD;
  if (pointerX >= left - xThreshold && pointerX <= left + xThreshold) {
    return AutoScrollHorizontalDirection.LEFT;
  } else if (pointerX >= right - xThreshold && pointerX <= right + xThreshold) {
    return AutoScrollHorizontalDirection.RIGHT;
  }
  return AutoScrollHorizontalDirection.NONE;
}
__name(getHorizontalScrollDirection, "getHorizontalScrollDirection");
function getElementScrollDirections(element, clientRect, direction, pointerX, pointerY) {
  const computedVertical = getVerticalScrollDirection(clientRect, pointerY);
  const computedHorizontal = getHorizontalScrollDirection(clientRect, pointerX);
  let verticalScrollDirection = AutoScrollVerticalDirection.NONE;
  let horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;
  if (computedVertical) {
    const scrollTop = element.scrollTop;
    if (computedVertical === AutoScrollVerticalDirection.UP) {
      if (scrollTop > 0) {
        verticalScrollDirection = AutoScrollVerticalDirection.UP;
      }
    } else if (element.scrollHeight - scrollTop > element.clientHeight) {
      verticalScrollDirection = AutoScrollVerticalDirection.DOWN;
    }
  }
  if (computedHorizontal) {
    const scrollLeft = element.scrollLeft;
    if (direction === "rtl") {
      if (computedHorizontal === AutoScrollHorizontalDirection.RIGHT) {
        if (scrollLeft < 0) {
          horizontalScrollDirection = AutoScrollHorizontalDirection.RIGHT;
        }
      } else if (element.scrollWidth + scrollLeft > element.clientWidth) {
        horizontalScrollDirection = AutoScrollHorizontalDirection.LEFT;
      }
    } else {
      if (computedHorizontal === AutoScrollHorizontalDirection.LEFT) {
        if (scrollLeft > 0) {
          horizontalScrollDirection = AutoScrollHorizontalDirection.LEFT;
        }
      } else if (element.scrollWidth - scrollLeft > element.clientWidth) {
        horizontalScrollDirection = AutoScrollHorizontalDirection.RIGHT;
      }
    }
  }
  return [verticalScrollDirection, horizontalScrollDirection];
}
__name(getElementScrollDirections, "getElementScrollDirections");
var capturingEventOptions = {
  capture: true
};
var activeCapturingEventOptions = {
  passive: false,
  capture: true
};
var __ResetsLoader = class __ResetsLoader {
};
__name(__ResetsLoader, "_ResetsLoader");
__publicField(__ResetsLoader, "\u0275fac", /* @__PURE__ */ __name(function _ResetsLoader_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || __ResetsLoader)();
}, "_ResetsLoader_Factory"));
__publicField(__ResetsLoader, "\u0275cmp", /* @__PURE__ */ \u0275\u0275defineComponent({
  type: __ResetsLoader,
  selectors: [["ng-component"]],
  hostAttrs: ["cdk-drag-resets-container", ""],
  decls: 0,
  vars: 0,
  template: /* @__PURE__ */ __name(function _ResetsLoader_Template(rf, ctx) {
  }, "_ResetsLoader_Template"),
  styles: ["@layer cdk-resets{.cdk-drag-preview{background:none;border:none;padding:0;color:inherit;inset:auto}}.cdk-drag-placeholder *,.cdk-drag-preview *{pointer-events:none !important}\n"],
  encapsulation: 2,
  changeDetection: 0
}));
var _ResetsLoader = __ResetsLoader;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_ResetsLoader, [{
    type: Component,
    args: [{
      encapsulation: ViewEncapsulation.None,
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        "cdk-drag-resets-container": ""
      },
      styles: ["@layer cdk-resets{.cdk-drag-preview{background:none;border:none;padding:0;color:inherit;inset:auto}}.cdk-drag-placeholder *,.cdk-drag-preview *{pointer-events:none !important}\n"]
    }]
  }], null, null);
})();
var _DragDropRegistry = class _DragDropRegistry {
  _ngZone = inject(NgZone);
  _document = inject(DOCUMENT);
  _styleLoader = inject(_CdkPrivateStyleLoader);
  _renderer = inject(RendererFactory2).createRenderer(null, null);
  _cleanupDocumentTouchmove;
  _scroll = new Subject();
  /** Registered drop container instances. */
  _dropInstances = /* @__PURE__ */ new Set();
  /** Registered drag item instances. */
  _dragInstances = /* @__PURE__ */ new Set();
  /** Drag item instances that are currently being dragged. */
  _activeDragInstances = signal([], ...ngDevMode ? [{
    debugName: "_activeDragInstances"
  }] : []);
  /** Keeps track of the event listeners that we've bound to the `document`. */
  _globalListeners;
  /**
   * Predicate function to check if an item is being dragged.  Moved out into a property,
   * because it'll be called a lot and we don't want to create a new function every time.
   */
  _draggingPredicate = /* @__PURE__ */ __name((item) => item.isDragging(), "_draggingPredicate");
  /**
   * Map tracking DOM nodes and their corresponding drag directives. Note that this is different
   * from looking through the `_dragInstances` and getting their root node, because the root node
   * isn't necessarily the node that the directive is set on.
   */
  _domNodesToDirectives = null;
  /**
   * Emits the `touchmove` or `mousemove` events that are dispatched
   * while the user is dragging a drag item instance.
   */
  pointerMove = new Subject();
  /**
   * Emits the `touchend` or `mouseup` events that are dispatched
   * while the user is dragging a drag item instance.
   */
  pointerUp = new Subject();
  constructor() {
  }
  /** Adds a drop container to the registry. */
  registerDropContainer(drop) {
    if (!this._dropInstances.has(drop)) {
      this._dropInstances.add(drop);
    }
  }
  /** Adds a drag item instance to the registry. */
  registerDragItem(drag) {
    this._dragInstances.add(drag);
    if (this._dragInstances.size === 1) {
      this._ngZone.runOutsideAngular(() => {
        this._cleanupDocumentTouchmove?.();
        this._cleanupDocumentTouchmove = this._renderer.listen(this._document, "touchmove", this._persistentTouchmoveListener, activeCapturingEventOptions);
      });
    }
  }
  /** Removes a drop container from the registry. */
  removeDropContainer(drop) {
    this._dropInstances.delete(drop);
  }
  /** Removes a drag item instance from the registry. */
  removeDragItem(drag) {
    this._dragInstances.delete(drag);
    this.stopDragging(drag);
    if (this._dragInstances.size === 0) {
      this._cleanupDocumentTouchmove?.();
    }
  }
  /**
   * Starts the dragging sequence for a drag instance.
   * @param drag Drag instance which is being dragged.
   * @param event Event that initiated the dragging.
   */
  startDragging(drag, event) {
    if (this._activeDragInstances().indexOf(drag) > -1) {
      return;
    }
    this._styleLoader.load(_ResetsLoader);
    this._activeDragInstances.update((instances) => [...instances, drag]);
    if (this._activeDragInstances().length === 1) {
      const isTouchEvent2 = event.type.startsWith("touch");
      const endEventHandler = /* @__PURE__ */ __name((e) => this.pointerUp.next(e), "endEventHandler");
      const toBind = [
        // Use capturing so that we pick up scroll changes in any scrollable nodes that aren't
        // the document. See https://github.com/angular/components/issues/17144.
        ["scroll", (e) => this._scroll.next(e), capturingEventOptions],
        // Preventing the default action on `mousemove` isn't enough to disable text selection
        // on Safari so we need to prevent the selection event as well. Alternatively this can
        // be done by setting `user-select: none` on the `body`, however it has causes a style
        // recalculation which can be expensive on pages with a lot of elements.
        ["selectstart", this._preventDefaultWhileDragging, activeCapturingEventOptions]
      ];
      if (isTouchEvent2) {
        toBind.push(["touchend", endEventHandler, capturingEventOptions], ["touchcancel", endEventHandler, capturingEventOptions]);
      } else {
        toBind.push(["mouseup", endEventHandler, capturingEventOptions]);
      }
      if (!isTouchEvent2) {
        toBind.push(["mousemove", (e) => this.pointerMove.next(e), activeCapturingEventOptions]);
      }
      this._ngZone.runOutsideAngular(() => {
        this._globalListeners = toBind.map(([name, handler, options]) => this._renderer.listen(this._document, name, handler, options));
      });
    }
  }
  /** Stops dragging a drag item instance. */
  stopDragging(drag) {
    this._activeDragInstances.update((instances) => {
      const index = instances.indexOf(drag);
      if (index > -1) {
        instances.splice(index, 1);
        return [...instances];
      }
      return instances;
    });
    if (this._activeDragInstances().length === 0) {
      this._clearGlobalListeners();
    }
  }
  /** Gets whether a drag item instance is currently being dragged. */
  isDragging(drag) {
    return this._activeDragInstances().indexOf(drag) > -1;
  }
  /**
   * Gets a stream that will emit when any element on the page is scrolled while an item is being
   * dragged.
   * @param shadowRoot Optional shadow root that the current dragging sequence started from.
   *   Top-level listeners won't pick up events coming from the shadow DOM so this parameter can
   *   be used to include an additional top-level listener at the shadow root level.
   */
  scrolled(shadowRoot) {
    const streams = [this._scroll];
    if (shadowRoot && shadowRoot !== this._document) {
      streams.push(new Observable((observer) => {
        return this._ngZone.runOutsideAngular(() => {
          const cleanup = this._renderer.listen(shadowRoot, "scroll", (event) => {
            if (this._activeDragInstances().length) {
              observer.next(event);
            }
          }, capturingEventOptions);
          return () => {
            cleanup();
          };
        });
      }));
    }
    return merge(...streams);
  }
  /**
   * Tracks the DOM node which has a draggable directive.
   * @param node Node to track.
   * @param dragRef Drag directive set on the node.
   */
  registerDirectiveNode(node, dragRef) {
    this._domNodesToDirectives ??= /* @__PURE__ */ new WeakMap();
    this._domNodesToDirectives.set(node, dragRef);
  }
  /**
   * Stops tracking a draggable directive node.
   * @param node Node to stop tracking.
   */
  removeDirectiveNode(node) {
    this._domNodesToDirectives?.delete(node);
  }
  /**
   * Gets the drag directive corresponding to a specific DOM node, if any.
   * @param node Node for which to do the lookup.
   */
  getDragDirectiveForNode(node) {
    return this._domNodesToDirectives?.get(node) || null;
  }
  ngOnDestroy() {
    this._dragInstances.forEach((instance) => this.removeDragItem(instance));
    this._dropInstances.forEach((instance) => this.removeDropContainer(instance));
    this._domNodesToDirectives = null;
    this._clearGlobalListeners();
    this.pointerMove.complete();
    this.pointerUp.complete();
  }
  /**
   * Event listener that will prevent the default browser action while the user is dragging.
   * @param event Event whose default action should be prevented.
   */
  _preventDefaultWhileDragging = /* @__PURE__ */ __name((event) => {
    if (this._activeDragInstances().length > 0) {
      event.preventDefault();
    }
  }, "_preventDefaultWhileDragging");
  /** Event listener for `touchmove` that is bound even if no dragging is happening. */
  _persistentTouchmoveListener = /* @__PURE__ */ __name((event) => {
    if (this._activeDragInstances().length > 0) {
      if (this._activeDragInstances().some(this._draggingPredicate)) {
        event.preventDefault();
      }
      this.pointerMove.next(event);
    }
  }, "_persistentTouchmoveListener");
  /** Clears out the global event listeners from the `document`. */
  _clearGlobalListeners() {
    this._globalListeners?.forEach((cleanup) => cleanup());
    this._globalListeners = void 0;
  }
};
__name(_DragDropRegistry, "DragDropRegistry");
__publicField(_DragDropRegistry, "\u0275fac", /* @__PURE__ */ __name(function DragDropRegistry_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _DragDropRegistry)();
}, "DragDropRegistry_Factory"));
__publicField(_DragDropRegistry, "\u0275prov", /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _DragDropRegistry,
  factory: _DragDropRegistry.\u0275fac,
  providedIn: "root"
}));
var DragDropRegistry = _DragDropRegistry;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragDropRegistry, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var DEFAULT_CONFIG = {
  dragStartThreshold: 5,
  pointerDirectionChangeThreshold: 5
};
var _DragDrop = class _DragDrop {
  _document = inject(DOCUMENT);
  _ngZone = inject(NgZone);
  _viewportRuler = inject(ViewportRuler);
  _dragDropRegistry = inject(DragDropRegistry);
  _renderer = inject(RendererFactory2).createRenderer(null, null);
  constructor() {
  }
  /**
   * Turns an element into a draggable item.
   * @param element Element to which to attach the dragging functionality.
   * @param config Object used to configure the dragging behavior.
   */
  createDrag(element, config = DEFAULT_CONFIG) {
    return new DragRef(element, config, this._document, this._ngZone, this._viewportRuler, this._dragDropRegistry, this._renderer);
  }
  /**
   * Turns an element into a drop list.
   * @param element Element to which to attach the drop list functionality.
   */
  createDropList(element) {
    return new DropListRef(element, this._dragDropRegistry, this._document, this._ngZone, this._viewportRuler);
  }
};
__name(_DragDrop, "DragDrop");
__publicField(_DragDrop, "\u0275fac", /* @__PURE__ */ __name(function DragDrop_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _DragDrop)();
}, "DragDrop_Factory"));
__publicField(_DragDrop, "\u0275prov", /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _DragDrop,
  factory: _DragDrop.\u0275fac,
  providedIn: "root"
}));
var DragDrop = _DragDrop;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragDrop, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var CDK_DRAG_PARENT = new InjectionToken("CDK_DRAG_PARENT");
function assertElementNode(node, name) {
  if (node.nodeType !== 1) {
    throw Error(`${name} must be attached to an element node. Currently attached to "${node.nodeName}".`);
  }
}
__name(assertElementNode, "assertElementNode");
var CDK_DRAG_HANDLE = new InjectionToken("CdkDragHandle");
var _CdkDragHandle = class _CdkDragHandle {
  element = inject(ElementRef);
  _parentDrag = inject(CDK_DRAG_PARENT, {
    optional: true,
    skipSelf: true
  });
  _dragDropRegistry = inject(DragDropRegistry);
  /** Emits when the state of the handle has changed. */
  _stateChanges = new Subject();
  /** Whether starting to drag through this handle is disabled. */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this._stateChanges.next(this);
  }
  _disabled = false;
  constructor() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      assertElementNode(this.element.nativeElement, "cdkDragHandle");
    }
    this._parentDrag?._addHandle(this);
  }
  ngAfterViewInit() {
    if (!this._parentDrag) {
      let parent = this.element.nativeElement.parentElement;
      while (parent) {
        const ref2 = this._dragDropRegistry.getDragDirectiveForNode(parent);
        if (ref2) {
          this._parentDrag = ref2;
          ref2._addHandle(this);
          break;
        }
        parent = parent.parentElement;
      }
    }
  }
  ngOnDestroy() {
    this._parentDrag?._removeHandle(this);
    this._stateChanges.complete();
  }
};
__name(_CdkDragHandle, "CdkDragHandle");
__publicField(_CdkDragHandle, "\u0275fac", /* @__PURE__ */ __name(function CdkDragHandle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _CdkDragHandle)();
}, "CdkDragHandle_Factory"));
__publicField(_CdkDragHandle, "\u0275dir", /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _CdkDragHandle,
  selectors: [["", "cdkDragHandle", ""]],
  hostAttrs: [1, "cdk-drag-handle"],
  inputs: {
    disabled: [2, "cdkDragHandleDisabled", "disabled", booleanAttribute]
  },
  features: [\u0275\u0275ProvidersFeature([{
    provide: CDK_DRAG_HANDLE,
    useExisting: _CdkDragHandle
  }])]
}));
var CdkDragHandle = _CdkDragHandle;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragHandle, [{
    type: Directive,
    args: [{
      selector: "[cdkDragHandle]",
      host: {
        "class": "cdk-drag-handle"
      },
      providers: [{
        provide: CDK_DRAG_HANDLE,
        useExisting: CdkDragHandle
      }]
    }]
  }], () => [], {
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkDragHandleDisabled",
        transform: booleanAttribute
      }]
    }]
  });
})();
var CDK_DRAG_CONFIG = new InjectionToken("CDK_DRAG_CONFIG");
var CDK_DROP_LIST = new InjectionToken("CdkDropList");
var _CdkDrag = class _CdkDrag {
  element = inject(ElementRef);
  dropContainer = inject(CDK_DROP_LIST, {
    optional: true,
    skipSelf: true
  });
  _ngZone = inject(NgZone);
  _viewContainerRef = inject(ViewContainerRef);
  _dir = inject(Directionality, {
    optional: true
  });
  _changeDetectorRef = inject(ChangeDetectorRef);
  _selfHandle = inject(CDK_DRAG_HANDLE, {
    optional: true,
    self: true
  });
  _parentDrag = inject(CDK_DRAG_PARENT, {
    optional: true,
    skipSelf: true
  });
  _dragDropRegistry = inject(DragDropRegistry);
  _destroyed = new Subject();
  _handles = new BehaviorSubject([]);
  _previewTemplate;
  _placeholderTemplate;
  /** Reference to the underlying drag instance. */
  _dragRef;
  /** Arbitrary data to attach to this drag instance. */
  data;
  /** Locks the position of the dragged element along the specified axis. */
  lockAxis = null;
  /**
   * Selector that will be used to determine the root draggable element, starting from
   * the `cdkDrag` element and going up the DOM. Passing an alternate root element is useful
   * when trying to enable dragging on an element that you might not have access to.
   */
  rootElementSelector;
  /**
   * Node or selector that will be used to determine the element to which the draggable's
   * position will be constrained. If a string is passed in, it'll be used as a selector that
   * will be matched starting from the element's parent and going up the DOM until a match
   * has been found.
   */
  boundaryElement;
  /**
   * Amount of milliseconds to wait after the user has put their
   * pointer down before starting to drag the element.
   */
  dragStartDelay;
  /**
   * Sets the position of a `CdkDrag` that is outside of a drop container.
   * Can be used to restore the element's position for a returning user.
   */
  freeDragPosition;
  /** Whether starting to drag this element is disabled. */
  get disabled() {
    return this._disabled || !!(this.dropContainer && this.dropContainer.disabled);
  }
  set disabled(value) {
    this._disabled = value;
    this._dragRef.disabled = this._disabled;
  }
  _disabled;
  /**
   * Function that can be used to customize the logic of how the position of the drag item
   * is limited while it's being dragged. Gets called with a point containing the current position
   * of the user's pointer on the page, a reference to the item being dragged and its dimensions.
   * Should return a point describing where the item should be rendered.
   */
  constrainPosition;
  /** Class to be added to the preview element. */
  previewClass;
  /**
   * Configures the place into which the preview of the item will be inserted. Can be configured
   * globally through `CDK_DROP_LIST`. Possible values:
   * - `global` - Preview will be inserted at the bottom of the `<body>`. The advantage is that
   * you don't have to worry about `overflow: hidden` or `z-index`, but the item won't retain
   * its inherited styles.
   * - `parent` - Preview will be inserted into the parent of the drag item. The advantage is that
   * inherited styles will be preserved, but it may be clipped by `overflow: hidden` or not be
   * visible due to `z-index`. Furthermore, the preview is going to have an effect over selectors
   * like `:nth-child` and some flexbox configurations.
   * - `ElementRef<HTMLElement> | HTMLElement` - Preview will be inserted into a specific element.
   * Same advantages and disadvantages as `parent`.
   */
  previewContainer;
  /**
   * If the parent of the dragged element has a `scale` transform, it can throw off the
   * positioning when the user starts dragging. Use this input to notify the CDK of the scale.
   */
  scale = 1;
  /** Emits when the user starts dragging the item. */
  started = new EventEmitter();
  /** Emits when the user has released a drag item, before any animations have started. */
  released = new EventEmitter();
  /** Emits when the user stops dragging an item in the container. */
  ended = new EventEmitter();
  /** Emits when the user has moved the item into a new container. */
  entered = new EventEmitter();
  /** Emits when the user removes the item its container by dragging it into another container. */
  exited = new EventEmitter();
  /** Emits when the user drops the item inside a container. */
  dropped = new EventEmitter();
  /**
   * Emits as the user is dragging the item. Use with caution,
   * because this event will fire for every pixel that the user has dragged.
   */
  moved = new Observable((observer) => {
    const subscription = this._dragRef.moved.pipe(map((movedEvent) => ({
      source: this,
      pointerPosition: movedEvent.pointerPosition,
      event: movedEvent.event,
      delta: movedEvent.delta,
      distance: movedEvent.distance
    }))).subscribe(observer);
    return () => {
      subscription.unsubscribe();
    };
  });
  _injector = inject(Injector);
  constructor() {
    const dropContainer = this.dropContainer;
    const config = inject(CDK_DRAG_CONFIG, {
      optional: true
    });
    const dragDrop = inject(DragDrop);
    this._dragRef = dragDrop.createDrag(this.element, {
      dragStartThreshold: config && config.dragStartThreshold != null ? config.dragStartThreshold : 5,
      pointerDirectionChangeThreshold: config && config.pointerDirectionChangeThreshold != null ? config.pointerDirectionChangeThreshold : 5,
      zIndex: config?.zIndex
    });
    this._dragRef.data = this;
    this._dragDropRegistry.registerDirectiveNode(this.element.nativeElement, this);
    if (config) {
      this._assignDefaults(config);
    }
    if (dropContainer) {
      dropContainer.addItem(this);
      dropContainer._dropListRef.beforeStarted.pipe(takeUntil(this._destroyed)).subscribe(() => {
        this._dragRef.scale = this.scale;
      });
    }
    this._syncInputs(this._dragRef);
    this._handleEvents(this._dragRef);
  }
  /**
   * Returns the element that is being used as a placeholder
   * while the current element is being dragged.
   */
  getPlaceholderElement() {
    return this._dragRef.getPlaceholderElement();
  }
  /** Returns the root draggable element. */
  getRootElement() {
    return this._dragRef.getRootElement();
  }
  /** Resets a standalone drag item to its initial position. */
  reset() {
    this._dragRef.reset();
  }
  /** Resets drag item to end of boundary element. */
  resetToBoundary() {
    this._dragRef.resetToBoundary();
  }
  /**
   * Gets the pixel coordinates of the draggable outside of a drop container.
   */
  getFreeDragPosition() {
    return this._dragRef.getFreeDragPosition();
  }
  /**
   * Sets the current position in pixels the draggable outside of a drop container.
   * @param value New position to be set.
   */
  setFreeDragPosition(value) {
    this._dragRef.setFreeDragPosition(value);
  }
  ngAfterViewInit() {
    afterNextRender(() => {
      this._updateRootElement();
      this._setupHandlesListener();
      this._dragRef.scale = this.scale;
      if (this.freeDragPosition) {
        this._dragRef.setFreeDragPosition(this.freeDragPosition);
      }
    }, {
      injector: this._injector
    });
  }
  ngOnChanges(changes) {
    const rootSelectorChange = changes["rootElementSelector"];
    const positionChange = changes["freeDragPosition"];
    if (rootSelectorChange && !rootSelectorChange.firstChange) {
      this._updateRootElement();
    }
    this._dragRef.scale = this.scale;
    if (positionChange && !positionChange.firstChange && this.freeDragPosition) {
      this._dragRef.setFreeDragPosition(this.freeDragPosition);
    }
  }
  ngOnDestroy() {
    if (this.dropContainer) {
      this.dropContainer.removeItem(this);
    }
    this._dragDropRegistry.removeDirectiveNode(this.element.nativeElement);
    this._ngZone.runOutsideAngular(() => {
      this._handles.complete();
      this._destroyed.next();
      this._destroyed.complete();
      this._dragRef.dispose();
    });
  }
  _addHandle(handle) {
    const handles = this._handles.getValue();
    handles.push(handle);
    this._handles.next(handles);
  }
  _removeHandle(handle) {
    const handles = this._handles.getValue();
    const index = handles.indexOf(handle);
    if (index > -1) {
      handles.splice(index, 1);
      this._handles.next(handles);
    }
  }
  _setPreviewTemplate(preview) {
    this._previewTemplate = preview;
  }
  _resetPreviewTemplate(preview) {
    if (preview === this._previewTemplate) {
      this._previewTemplate = null;
    }
  }
  _setPlaceholderTemplate(placeholder) {
    this._placeholderTemplate = placeholder;
  }
  _resetPlaceholderTemplate(placeholder) {
    if (placeholder === this._placeholderTemplate) {
      this._placeholderTemplate = null;
    }
  }
  /** Syncs the root element with the `DragRef`. */
  _updateRootElement() {
    const element = this.element.nativeElement;
    let rootElement = element;
    if (this.rootElementSelector) {
      rootElement = element.closest !== void 0 ? element.closest(this.rootElementSelector) : (
        // Comment tag doesn't have closest method, so use parent's one.
        element.parentElement?.closest(this.rootElementSelector)
      );
    }
    if (rootElement && (typeof ngDevMode === "undefined" || ngDevMode)) {
      assertElementNode(rootElement, "cdkDrag");
    }
    this._dragRef.withRootElement(rootElement || element);
  }
  /** Gets the boundary element, based on the `boundaryElement` value. */
  _getBoundaryElement() {
    const boundary = this.boundaryElement;
    if (!boundary) {
      return null;
    }
    if (typeof boundary === "string") {
      return this.element.nativeElement.closest(boundary);
    }
    return coerceElement(boundary);
  }
  /** Syncs the inputs of the CdkDrag with the options of the underlying DragRef. */
  _syncInputs(ref2) {
    ref2.beforeStarted.subscribe(() => {
      if (!ref2.isDragging()) {
        const dir = this._dir;
        const dragStartDelay = this.dragStartDelay;
        const placeholder = this._placeholderTemplate ? {
          template: this._placeholderTemplate.templateRef,
          context: this._placeholderTemplate.data,
          viewContainer: this._viewContainerRef
        } : null;
        const preview = this._previewTemplate ? {
          template: this._previewTemplate.templateRef,
          context: this._previewTemplate.data,
          matchSize: this._previewTemplate.matchSize,
          viewContainer: this._viewContainerRef
        } : null;
        ref2.disabled = this.disabled;
        ref2.lockAxis = this.lockAxis;
        ref2.scale = this.scale;
        ref2.dragStartDelay = typeof dragStartDelay === "object" && dragStartDelay ? dragStartDelay : coerceNumberProperty(dragStartDelay);
        ref2.constrainPosition = this.constrainPosition;
        ref2.previewClass = this.previewClass;
        ref2.withBoundaryElement(this._getBoundaryElement()).withPlaceholderTemplate(placeholder).withPreviewTemplate(preview).withPreviewContainer(this.previewContainer || "global");
        if (dir) {
          ref2.withDirection(dir.value);
        }
      }
    });
    ref2.beforeStarted.pipe(take(1)).subscribe(() => {
      if (this._parentDrag) {
        ref2.withParent(this._parentDrag._dragRef);
        return;
      }
      let parent = this.element.nativeElement.parentElement;
      while (parent) {
        const parentDrag = this._dragDropRegistry.getDragDirectiveForNode(parent);
        if (parentDrag) {
          ref2.withParent(parentDrag._dragRef);
          break;
        }
        parent = parent.parentElement;
      }
    });
  }
  /** Handles the events from the underlying `DragRef`. */
  _handleEvents(ref2) {
    ref2.started.subscribe((startEvent) => {
      this.started.emit({
        source: this,
        event: startEvent.event
      });
      this._changeDetectorRef.markForCheck();
    });
    ref2.released.subscribe((releaseEvent) => {
      this.released.emit({
        source: this,
        event: releaseEvent.event
      });
    });
    ref2.ended.subscribe((endEvent) => {
      this.ended.emit({
        source: this,
        distance: endEvent.distance,
        dropPoint: endEvent.dropPoint,
        event: endEvent.event
      });
      this._changeDetectorRef.markForCheck();
    });
    ref2.entered.subscribe((enterEvent) => {
      this.entered.emit({
        container: enterEvent.container.data,
        item: this,
        currentIndex: enterEvent.currentIndex
      });
    });
    ref2.exited.subscribe((exitEvent) => {
      this.exited.emit({
        container: exitEvent.container.data,
        item: this
      });
    });
    ref2.dropped.subscribe((dropEvent) => {
      this.dropped.emit({
        previousIndex: dropEvent.previousIndex,
        currentIndex: dropEvent.currentIndex,
        previousContainer: dropEvent.previousContainer.data,
        container: dropEvent.container.data,
        isPointerOverContainer: dropEvent.isPointerOverContainer,
        item: this,
        distance: dropEvent.distance,
        dropPoint: dropEvent.dropPoint,
        event: dropEvent.event
      });
    });
  }
  /** Assigns the default input values based on a provided config object. */
  _assignDefaults(config) {
    const {
      lockAxis,
      dragStartDelay,
      constrainPosition,
      previewClass,
      boundaryElement,
      draggingDisabled,
      rootElementSelector,
      previewContainer
    } = config;
    this.disabled = draggingDisabled == null ? false : draggingDisabled;
    this.dragStartDelay = dragStartDelay || 0;
    this.lockAxis = lockAxis || null;
    if (constrainPosition) {
      this.constrainPosition = constrainPosition;
    }
    if (previewClass) {
      this.previewClass = previewClass;
    }
    if (boundaryElement) {
      this.boundaryElement = boundaryElement;
    }
    if (rootElementSelector) {
      this.rootElementSelector = rootElementSelector;
    }
    if (previewContainer) {
      this.previewContainer = previewContainer;
    }
  }
  /** Sets up the listener that syncs the handles with the drag ref. */
  _setupHandlesListener() {
    this._handles.pipe(
      // Sync the new handles with the DragRef.
      tap((handles) => {
        const handleElements = handles.map((handle) => handle.element);
        if (this._selfHandle && this.rootElementSelector) {
          handleElements.push(this.element);
        }
        this._dragRef.withHandles(handleElements);
      }),
      // Listen if the state of any of the handles changes.
      switchMap((handles) => {
        return merge(...handles.map((item) => item._stateChanges.pipe(startWith(item))));
      }),
      takeUntil(this._destroyed)
    ).subscribe((handleInstance) => {
      const dragRef = this._dragRef;
      const handle = handleInstance.element.nativeElement;
      handleInstance.disabled ? dragRef.disableHandle(handle) : dragRef.enableHandle(handle);
    });
  }
};
__name(_CdkDrag, "CdkDrag");
__publicField(_CdkDrag, "\u0275fac", /* @__PURE__ */ __name(function CdkDrag_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _CdkDrag)();
}, "CdkDrag_Factory"));
__publicField(_CdkDrag, "\u0275dir", /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _CdkDrag,
  selectors: [["", "cdkDrag", ""]],
  hostAttrs: [1, "cdk-drag"],
  hostVars: 4,
  hostBindings: /* @__PURE__ */ __name(function CdkDrag_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("cdk-drag-disabled", ctx.disabled)("cdk-drag-dragging", ctx._dragRef.isDragging());
    }
  }, "CdkDrag_HostBindings"),
  inputs: {
    data: [0, "cdkDragData", "data"],
    lockAxis: [0, "cdkDragLockAxis", "lockAxis"],
    rootElementSelector: [0, "cdkDragRootElement", "rootElementSelector"],
    boundaryElement: [0, "cdkDragBoundary", "boundaryElement"],
    dragStartDelay: [0, "cdkDragStartDelay", "dragStartDelay"],
    freeDragPosition: [0, "cdkDragFreeDragPosition", "freeDragPosition"],
    disabled: [2, "cdkDragDisabled", "disabled", booleanAttribute],
    constrainPosition: [0, "cdkDragConstrainPosition", "constrainPosition"],
    previewClass: [0, "cdkDragPreviewClass", "previewClass"],
    previewContainer: [0, "cdkDragPreviewContainer", "previewContainer"],
    scale: [2, "cdkDragScale", "scale", numberAttribute]
  },
  outputs: {
    started: "cdkDragStarted",
    released: "cdkDragReleased",
    ended: "cdkDragEnded",
    entered: "cdkDragEntered",
    exited: "cdkDragExited",
    dropped: "cdkDragDropped",
    moved: "cdkDragMoved"
  },
  exportAs: ["cdkDrag"],
  features: [\u0275\u0275ProvidersFeature([{
    provide: CDK_DRAG_PARENT,
    useExisting: _CdkDrag
  }]), \u0275\u0275NgOnChangesFeature]
}));
var CdkDrag = _CdkDrag;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDrag, [{
    type: Directive,
    args: [{
      selector: "[cdkDrag]",
      exportAs: "cdkDrag",
      host: {
        "class": "cdk-drag",
        "[class.cdk-drag-disabled]": "disabled",
        "[class.cdk-drag-dragging]": "_dragRef.isDragging()"
      },
      providers: [{
        provide: CDK_DRAG_PARENT,
        useExisting: CdkDrag
      }]
    }]
  }], () => [], {
    data: [{
      type: Input,
      args: ["cdkDragData"]
    }],
    lockAxis: [{
      type: Input,
      args: ["cdkDragLockAxis"]
    }],
    rootElementSelector: [{
      type: Input,
      args: ["cdkDragRootElement"]
    }],
    boundaryElement: [{
      type: Input,
      args: ["cdkDragBoundary"]
    }],
    dragStartDelay: [{
      type: Input,
      args: ["cdkDragStartDelay"]
    }],
    freeDragPosition: [{
      type: Input,
      args: ["cdkDragFreeDragPosition"]
    }],
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkDragDisabled",
        transform: booleanAttribute
      }]
    }],
    constrainPosition: [{
      type: Input,
      args: ["cdkDragConstrainPosition"]
    }],
    previewClass: [{
      type: Input,
      args: ["cdkDragPreviewClass"]
    }],
    previewContainer: [{
      type: Input,
      args: ["cdkDragPreviewContainer"]
    }],
    scale: [{
      type: Input,
      args: [{
        alias: "cdkDragScale",
        transform: numberAttribute
      }]
    }],
    started: [{
      type: Output,
      args: ["cdkDragStarted"]
    }],
    released: [{
      type: Output,
      args: ["cdkDragReleased"]
    }],
    ended: [{
      type: Output,
      args: ["cdkDragEnded"]
    }],
    entered: [{
      type: Output,
      args: ["cdkDragEntered"]
    }],
    exited: [{
      type: Output,
      args: ["cdkDragExited"]
    }],
    dropped: [{
      type: Output,
      args: ["cdkDragDropped"]
    }],
    moved: [{
      type: Output,
      args: ["cdkDragMoved"]
    }]
  });
})();
var CDK_DROP_LIST_GROUP = new InjectionToken("CdkDropListGroup");
var _CdkDropListGroup = class _CdkDropListGroup {
  /** Drop lists registered inside the group. */
  _items = /* @__PURE__ */ new Set();
  /** Whether starting a dragging sequence from inside this group is disabled. */
  disabled = false;
  ngOnDestroy() {
    this._items.clear();
  }
};
__name(_CdkDropListGroup, "CdkDropListGroup");
__publicField(_CdkDropListGroup, "\u0275fac", /* @__PURE__ */ __name(function CdkDropListGroup_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _CdkDropListGroup)();
}, "CdkDropListGroup_Factory"));
__publicField(_CdkDropListGroup, "\u0275dir", /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _CdkDropListGroup,
  selectors: [["", "cdkDropListGroup", ""]],
  inputs: {
    disabled: [2, "cdkDropListGroupDisabled", "disabled", booleanAttribute]
  },
  exportAs: ["cdkDropListGroup"],
  features: [\u0275\u0275ProvidersFeature([{
    provide: CDK_DROP_LIST_GROUP,
    useExisting: _CdkDropListGroup
  }])]
}));
var CdkDropListGroup = _CdkDropListGroup;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDropListGroup, [{
    type: Directive,
    args: [{
      selector: "[cdkDropListGroup]",
      exportAs: "cdkDropListGroup",
      providers: [{
        provide: CDK_DROP_LIST_GROUP,
        useExisting: CdkDropListGroup
      }]
    }]
  }], null, {
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkDropListGroupDisabled",
        transform: booleanAttribute
      }]
    }]
  });
})();
var _CdkDropList = class _CdkDropList {
  element = inject(ElementRef);
  _changeDetectorRef = inject(ChangeDetectorRef);
  _scrollDispatcher = inject(ScrollDispatcher);
  _dir = inject(Directionality, {
    optional: true
  });
  _group = inject(CDK_DROP_LIST_GROUP, {
    optional: true,
    skipSelf: true
  });
  /** Refs that have been synced with the drop ref most recently. */
  _latestSortedRefs;
  /** Emits when the list has been destroyed. */
  _destroyed = new Subject();
  /** Whether the element's scrollable parents have been resolved. */
  _scrollableParentsResolved;
  /** Reference to the underlying drop list instance. */
  _dropListRef;
  /**
   * Other draggable containers that this container is connected to and into which the
   * container's items can be transferred. Can either be references to other drop containers,
   * or their unique IDs.
   */
  connectedTo = [];
  /** Arbitrary data to attach to this container. */
  data;
  /** Direction in which the list is oriented. */
  orientation;
  /**
   * Unique ID for the drop zone. Can be used as a reference
   * in the `connectedTo` of another `CdkDropList`.
   */
  id = inject(_IdGenerator).getId("cdk-drop-list-");
  /** Locks the position of the draggable elements inside the container along the specified axis. */
  lockAxis = null;
  /** Whether starting a dragging sequence from this container is disabled. */
  get disabled() {
    return this._disabled || !!this._group && this._group.disabled;
  }
  set disabled(value) {
    this._dropListRef.disabled = this._disabled = value;
  }
  _disabled;
  /** Whether sorting within this drop list is disabled. */
  sortingDisabled;
  /**
   * Function that is used to determine whether an item
   * is allowed to be moved into a drop container.
   */
  enterPredicate = /* @__PURE__ */ __name(() => true, "enterPredicate");
  /** Functions that is used to determine whether an item can be sorted into a particular index. */
  sortPredicate = /* @__PURE__ */ __name(() => true, "sortPredicate");
  /** Whether to auto-scroll the view when the user moves their pointer close to the edges. */
  autoScrollDisabled;
  /** Number of pixels to scroll for each frame when auto-scrolling an element. */
  autoScrollStep;
  /**
   * Selector that will be used to resolve an alternate element container for the drop list.
   * Passing an alternate container is useful for the cases where one might not have control
   * over the parent node of the draggable items within the list (e.g. due to content projection).
   * This allows for usages like:
   *
   * ```
   * <div cdkDropList cdkDropListElementContainer=".inner">
   *   <div class="inner">
   *     <div cdkDrag></div>
   *   </div>
   * </div>
   * ```
   */
  elementContainerSelector;
  /**
   * By default when an item leaves its initial container, its placeholder will be transferred
   * to the new container. If that's not desirable for your use case, you can enable this option
   * which will clone the placeholder and leave it inside the original container. If the item is
   * returned to the initial container, the anchor element will be removed automatically.
   *
   * The cloned placeholder can be styled by targeting the `cdk-drag-anchor` class.
   *
   * This option is useful in combination with `cdkDropListSortingDisabled` to implement copying
   * behavior in a drop list.
   */
  hasAnchor;
  /** Emits when the user drops an item inside the container. */
  dropped = new EventEmitter();
  /**
   * Emits when the user has moved a new drag item into this container.
   */
  entered = new EventEmitter();
  /**
   * Emits when the user removes an item from the container
   * by dragging it into another container.
   */
  exited = new EventEmitter();
  /** Emits as the user is swapping items while actively dragging. */
  sorted = new EventEmitter();
  /**
   * Keeps track of the items that are registered with this container. Historically we used to
   * do this with a `ContentChildren` query, however queries don't handle transplanted views very
   * well which means that we can't handle cases like dragging the headers of a `mat-table`
   * correctly. What we do instead is to have the items register themselves with the container
   * and then we sort them based on their position in the DOM.
   */
  _unsortedItems = /* @__PURE__ */ new Set();
  constructor() {
    const dragDrop = inject(DragDrop);
    const config = inject(CDK_DRAG_CONFIG, {
      optional: true
    });
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      assertElementNode(this.element.nativeElement, "cdkDropList");
    }
    this._dropListRef = dragDrop.createDropList(this.element);
    this._dropListRef.data = this;
    if (config) {
      this._assignDefaults(config);
    }
    this._dropListRef.enterPredicate = (drag, drop) => {
      return this.enterPredicate(drag.data, drop.data);
    };
    this._dropListRef.sortPredicate = (index, drag, drop) => {
      return this.sortPredicate(index, drag.data, drop.data);
    };
    this._setupInputSyncSubscription(this._dropListRef);
    this._handleEvents(this._dropListRef);
    _CdkDropList._dropLists.push(this);
    if (this._group) {
      this._group._items.add(this);
    }
  }
  /** Registers an items with the drop list. */
  addItem(item) {
    this._unsortedItems.add(item);
    item._dragRef._withDropContainer(this._dropListRef);
    if (this._dropListRef.isDragging()) {
      this._syncItemsWithRef(this.getSortedItems().map((item2) => item2._dragRef));
    }
  }
  /** Removes an item from the drop list. */
  removeItem(item) {
    this._unsortedItems.delete(item);
    if (this._latestSortedRefs) {
      const index = this._latestSortedRefs.indexOf(item._dragRef);
      if (index > -1) {
        this._latestSortedRefs.splice(index, 1);
        this._syncItemsWithRef(this._latestSortedRefs);
      }
    }
  }
  /** Gets the registered items in the list, sorted by their position in the DOM. */
  getSortedItems() {
    return Array.from(this._unsortedItems).sort((a, b) => {
      const documentPosition = a._dragRef.getVisibleElement().compareDocumentPosition(b._dragRef.getVisibleElement());
      return documentPosition & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
    });
  }
  ngOnDestroy() {
    const index = _CdkDropList._dropLists.indexOf(this);
    if (index > -1) {
      _CdkDropList._dropLists.splice(index, 1);
    }
    if (this._group) {
      this._group._items.delete(this);
    }
    this._latestSortedRefs = void 0;
    this._unsortedItems.clear();
    this._dropListRef.dispose();
    this._destroyed.next();
    this._destroyed.complete();
  }
  /** Syncs the inputs of the CdkDropList with the options of the underlying DropListRef. */
  _setupInputSyncSubscription(ref2) {
    if (this._dir) {
      this._dir.change.pipe(startWith(this._dir.value), takeUntil(this._destroyed)).subscribe((value) => ref2.withDirection(value));
    }
    ref2.beforeStarted.subscribe(() => {
      const siblings = coerceArray(this.connectedTo).map((drop) => {
        if (typeof drop === "string") {
          const correspondingDropList = _CdkDropList._dropLists.find((list) => list.id === drop);
          if (!correspondingDropList && (typeof ngDevMode === "undefined" || ngDevMode)) {
            console.warn(`CdkDropList could not find connected drop list with id "${drop}"`);
          }
          return correspondingDropList;
        }
        return drop;
      });
      if (this._group) {
        this._group._items.forEach((drop) => {
          if (siblings.indexOf(drop) === -1) {
            siblings.push(drop);
          }
        });
      }
      if (!this._scrollableParentsResolved) {
        const scrollableParents = this._scrollDispatcher.getAncestorScrollContainers(this.element).map((scrollable) => scrollable.getElementRef().nativeElement);
        this._dropListRef.withScrollableParents(scrollableParents);
        this._scrollableParentsResolved = true;
      }
      if (this.elementContainerSelector) {
        const container = this.element.nativeElement.querySelector(this.elementContainerSelector);
        if (!container && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throw new Error(`CdkDropList could not find an element container matching the selector "${this.elementContainerSelector}"`);
        }
        ref2.withElementContainer(container);
      }
      ref2.disabled = this.disabled;
      ref2.lockAxis = this.lockAxis;
      ref2.sortingDisabled = this.sortingDisabled;
      ref2.autoScrollDisabled = this.autoScrollDisabled;
      ref2.autoScrollStep = coerceNumberProperty(this.autoScrollStep, 2);
      ref2.hasAnchor = this.hasAnchor;
      ref2.connectedTo(siblings.filter((drop) => drop && drop !== this).map((list) => list._dropListRef)).withOrientation(this.orientation);
    });
  }
  /** Handles events from the underlying DropListRef. */
  _handleEvents(ref2) {
    ref2.beforeStarted.subscribe(() => {
      this._syncItemsWithRef(this.getSortedItems().map((item) => item._dragRef));
      this._changeDetectorRef.markForCheck();
    });
    ref2.entered.subscribe((event) => {
      this.entered.emit({
        container: this,
        item: event.item.data,
        currentIndex: event.currentIndex
      });
    });
    ref2.exited.subscribe((event) => {
      this.exited.emit({
        container: this,
        item: event.item.data
      });
      this._changeDetectorRef.markForCheck();
    });
    ref2.sorted.subscribe((event) => {
      this.sorted.emit({
        previousIndex: event.previousIndex,
        currentIndex: event.currentIndex,
        container: this,
        item: event.item.data
      });
    });
    ref2.dropped.subscribe((dropEvent) => {
      this.dropped.emit({
        previousIndex: dropEvent.previousIndex,
        currentIndex: dropEvent.currentIndex,
        previousContainer: dropEvent.previousContainer.data,
        container: dropEvent.container.data,
        item: dropEvent.item.data,
        isPointerOverContainer: dropEvent.isPointerOverContainer,
        distance: dropEvent.distance,
        dropPoint: dropEvent.dropPoint,
        event: dropEvent.event
      });
      this._changeDetectorRef.markForCheck();
    });
    merge(ref2.receivingStarted, ref2.receivingStopped).subscribe(() => this._changeDetectorRef.markForCheck());
  }
  /** Assigns the default input values based on a provided config object. */
  _assignDefaults(config) {
    const {
      lockAxis,
      draggingDisabled,
      sortingDisabled,
      listAutoScrollDisabled,
      listOrientation
    } = config;
    this.disabled = draggingDisabled == null ? false : draggingDisabled;
    this.sortingDisabled = sortingDisabled == null ? false : sortingDisabled;
    this.autoScrollDisabled = listAutoScrollDisabled == null ? false : listAutoScrollDisabled;
    this.orientation = listOrientation || "vertical";
    this.lockAxis = lockAxis || null;
  }
  /** Syncs up the registered drag items with underlying drop list ref. */
  _syncItemsWithRef(items) {
    this._latestSortedRefs = items;
    this._dropListRef.withItems(items);
  }
};
__name(_CdkDropList, "CdkDropList");
/** Keeps track of the drop lists that are currently on the page. */
__publicField(_CdkDropList, "_dropLists", []);
__publicField(_CdkDropList, "\u0275fac", /* @__PURE__ */ __name(function CdkDropList_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _CdkDropList)();
}, "CdkDropList_Factory"));
__publicField(_CdkDropList, "\u0275dir", /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _CdkDropList,
  selectors: [["", "cdkDropList", ""], ["cdk-drop-list"]],
  hostAttrs: [1, "cdk-drop-list"],
  hostVars: 7,
  hostBindings: /* @__PURE__ */ __name(function CdkDropList_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275attribute("id", ctx.id);
      \u0275\u0275classProp("cdk-drop-list-disabled", ctx.disabled)("cdk-drop-list-dragging", ctx._dropListRef.isDragging())("cdk-drop-list-receiving", ctx._dropListRef.isReceiving());
    }
  }, "CdkDropList_HostBindings"),
  inputs: {
    connectedTo: [0, "cdkDropListConnectedTo", "connectedTo"],
    data: [0, "cdkDropListData", "data"],
    orientation: [0, "cdkDropListOrientation", "orientation"],
    id: "id",
    lockAxis: [0, "cdkDropListLockAxis", "lockAxis"],
    disabled: [2, "cdkDropListDisabled", "disabled", booleanAttribute],
    sortingDisabled: [2, "cdkDropListSortingDisabled", "sortingDisabled", booleanAttribute],
    enterPredicate: [0, "cdkDropListEnterPredicate", "enterPredicate"],
    sortPredicate: [0, "cdkDropListSortPredicate", "sortPredicate"],
    autoScrollDisabled: [2, "cdkDropListAutoScrollDisabled", "autoScrollDisabled", booleanAttribute],
    autoScrollStep: [0, "cdkDropListAutoScrollStep", "autoScrollStep"],
    elementContainerSelector: [0, "cdkDropListElementContainer", "elementContainerSelector"],
    hasAnchor: [2, "cdkDropListHasAnchor", "hasAnchor", booleanAttribute]
  },
  outputs: {
    dropped: "cdkDropListDropped",
    entered: "cdkDropListEntered",
    exited: "cdkDropListExited",
    sorted: "cdkDropListSorted"
  },
  exportAs: ["cdkDropList"],
  features: [\u0275\u0275ProvidersFeature([
    // Prevent child drop lists from picking up the same group as their parent.
    {
      provide: CDK_DROP_LIST_GROUP,
      useValue: void 0
    },
    {
      provide: CDK_DROP_LIST,
      useExisting: _CdkDropList
    }
  ])]
}));
var CdkDropList = _CdkDropList;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDropList, [{
    type: Directive,
    args: [{
      selector: "[cdkDropList], cdk-drop-list",
      exportAs: "cdkDropList",
      providers: [
        // Prevent child drop lists from picking up the same group as their parent.
        {
          provide: CDK_DROP_LIST_GROUP,
          useValue: void 0
        },
        {
          provide: CDK_DROP_LIST,
          useExisting: CdkDropList
        }
      ],
      host: {
        "class": "cdk-drop-list",
        "[attr.id]": "id",
        "[class.cdk-drop-list-disabled]": "disabled",
        "[class.cdk-drop-list-dragging]": "_dropListRef.isDragging()",
        "[class.cdk-drop-list-receiving]": "_dropListRef.isReceiving()"
      }
    }]
  }], () => [], {
    connectedTo: [{
      type: Input,
      args: ["cdkDropListConnectedTo"]
    }],
    data: [{
      type: Input,
      args: ["cdkDropListData"]
    }],
    orientation: [{
      type: Input,
      args: ["cdkDropListOrientation"]
    }],
    id: [{
      type: Input
    }],
    lockAxis: [{
      type: Input,
      args: ["cdkDropListLockAxis"]
    }],
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkDropListDisabled",
        transform: booleanAttribute
      }]
    }],
    sortingDisabled: [{
      type: Input,
      args: [{
        alias: "cdkDropListSortingDisabled",
        transform: booleanAttribute
      }]
    }],
    enterPredicate: [{
      type: Input,
      args: ["cdkDropListEnterPredicate"]
    }],
    sortPredicate: [{
      type: Input,
      args: ["cdkDropListSortPredicate"]
    }],
    autoScrollDisabled: [{
      type: Input,
      args: [{
        alias: "cdkDropListAutoScrollDisabled",
        transform: booleanAttribute
      }]
    }],
    autoScrollStep: [{
      type: Input,
      args: ["cdkDropListAutoScrollStep"]
    }],
    elementContainerSelector: [{
      type: Input,
      args: ["cdkDropListElementContainer"]
    }],
    hasAnchor: [{
      type: Input,
      args: [{
        alias: "cdkDropListHasAnchor",
        transform: booleanAttribute
      }]
    }],
    dropped: [{
      type: Output,
      args: ["cdkDropListDropped"]
    }],
    entered: [{
      type: Output,
      args: ["cdkDropListEntered"]
    }],
    exited: [{
      type: Output,
      args: ["cdkDropListExited"]
    }],
    sorted: [{
      type: Output,
      args: ["cdkDropListSorted"]
    }]
  });
})();
var CDK_DRAG_PREVIEW = new InjectionToken("CdkDragPreview");
var _CdkDragPreview = class _CdkDragPreview {
  templateRef = inject(TemplateRef);
  _drag = inject(CDK_DRAG_PARENT, {
    optional: true
  });
  /** Context data to be added to the preview template instance. */
  data;
  /** Whether the preview should preserve the same size as the item that is being dragged. */
  matchSize = false;
  constructor() {
    this._drag?._setPreviewTemplate(this);
  }
  ngOnDestroy() {
    this._drag?._resetPreviewTemplate(this);
  }
};
__name(_CdkDragPreview, "CdkDragPreview");
__publicField(_CdkDragPreview, "\u0275fac", /* @__PURE__ */ __name(function CdkDragPreview_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _CdkDragPreview)();
}, "CdkDragPreview_Factory"));
__publicField(_CdkDragPreview, "\u0275dir", /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _CdkDragPreview,
  selectors: [["ng-template", "cdkDragPreview", ""]],
  inputs: {
    data: "data",
    matchSize: [2, "matchSize", "matchSize", booleanAttribute]
  },
  features: [\u0275\u0275ProvidersFeature([{
    provide: CDK_DRAG_PREVIEW,
    useExisting: _CdkDragPreview
  }])]
}));
var CdkDragPreview = _CdkDragPreview;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragPreview, [{
    type: Directive,
    args: [{
      selector: "ng-template[cdkDragPreview]",
      providers: [{
        provide: CDK_DRAG_PREVIEW,
        useExisting: CdkDragPreview
      }]
    }]
  }], () => [], {
    data: [{
      type: Input
    }],
    matchSize: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }]
  });
})();
var CDK_DRAG_PLACEHOLDER = new InjectionToken("CdkDragPlaceholder");
var _CdkDragPlaceholder = class _CdkDragPlaceholder {
  templateRef = inject(TemplateRef);
  _drag = inject(CDK_DRAG_PARENT, {
    optional: true
  });
  /** Context data to be added to the placeholder template instance. */
  data;
  constructor() {
    this._drag?._setPlaceholderTemplate(this);
  }
  ngOnDestroy() {
    this._drag?._resetPlaceholderTemplate(this);
  }
};
__name(_CdkDragPlaceholder, "CdkDragPlaceholder");
__publicField(_CdkDragPlaceholder, "\u0275fac", /* @__PURE__ */ __name(function CdkDragPlaceholder_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _CdkDragPlaceholder)();
}, "CdkDragPlaceholder_Factory"));
__publicField(_CdkDragPlaceholder, "\u0275dir", /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _CdkDragPlaceholder,
  selectors: [["ng-template", "cdkDragPlaceholder", ""]],
  inputs: {
    data: "data"
  },
  features: [\u0275\u0275ProvidersFeature([{
    provide: CDK_DRAG_PLACEHOLDER,
    useExisting: _CdkDragPlaceholder
  }])]
}));
var CdkDragPlaceholder = _CdkDragPlaceholder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragPlaceholder, [{
    type: Directive,
    args: [{
      selector: "ng-template[cdkDragPlaceholder]",
      providers: [{
        provide: CDK_DRAG_PLACEHOLDER,
        useExisting: CdkDragPlaceholder
      }]
    }]
  }], () => [], {
    data: [{
      type: Input
    }]
  });
})();
var DRAG_DROP_DIRECTIVES = [CdkDropList, CdkDropListGroup, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder];
var _DragDropModule = class _DragDropModule {
};
__name(_DragDropModule, "DragDropModule");
__publicField(_DragDropModule, "\u0275fac", /* @__PURE__ */ __name(function DragDropModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _DragDropModule)();
}, "DragDropModule_Factory"));
__publicField(_DragDropModule, "\u0275mod", /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _DragDropModule,
  imports: [CdkDropList, CdkDropListGroup, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder],
  exports: [CdkScrollableModule, CdkDropList, CdkDropListGroup, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder]
}));
__publicField(_DragDropModule, "\u0275inj", /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [DragDrop],
  imports: [CdkScrollableModule]
}));
var DragDropModule = _DragDropModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragDropModule, [{
    type: NgModule,
    args: [{
      imports: DRAG_DROP_DIRECTIVES,
      exports: [CdkScrollableModule, ...DRAG_DROP_DIRECTIVES],
      providers: [DragDrop]
    }]
  }], null, null);
})();

// src/app/services/storage.service.ts
var _StorageService = class _StorageService {
  storage = inject(Storage);
  uploadFile(file, path) {
    return __async(this, null, function* () {
      try {
        const storageRef = ref(this.storage, path);
        const snapshot = yield uploadBytes(storageRef, file);
        return yield getDownloadURL(snapshot.ref);
      } catch (error) {
        console.error("Erro ao fazer upload:", error);
        throw error;
      }
    });
  }
  uploadLeadAttachment(userId, boardId, leadId, file, companyId) {
    return __async(this, null, function* () {
      const timestamp = Date.now();
      const storageBase = companyId ? `companies/${companyId}` : `users/${userId}`;
      const path = `${storageBase}/boards/${boardId}/leads/${leadId}/attachments/${timestamp}_${file.name}`;
      try {
        const url = yield this.uploadFile(file, path);
        return {
          name: file.name,
          url
        };
      } catch (error) {
        console.error("Erro ao fazer upload do anexo:", error);
        throw error;
      }
    });
  }
  deleteFile(path) {
    return __async(this, null, function* () {
      try {
        const storageRef = ref(this.storage, path);
        yield deleteObject(storageRef);
      } catch (error) {
        console.error("Erro ao deletar arquivo:", error);
        throw error;
      }
    });
  }
};
__name(_StorageService, "StorageService");
__publicField(_StorageService, "\u0275fac", /* @__PURE__ */ __name(function StorageService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _StorageService)();
}, "StorageService_Factory"));
__publicField(_StorageService, "\u0275prov", /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _StorageService, factory: _StorageService.\u0275fac, providedIn: "root" }));
var StorageService = _StorageService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StorageService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();

// src/app/services/mask.service.ts
var _MaskService = class _MaskService {
  // Aplicar máscara de CPF: 000.000.000-00
  applyCpfMask(value) {
    if (!value)
      return "";
    const cleaned = value.replace(/\D/g, "");
    if (cleaned.length <= 11) {
      return cleaned.replace(/(\d{3})(\d)/, "$1.$2").replace(/(\d{3})(\d)/, "$1.$2").replace(/(\d{3})(\d{1,2})$/, "$1-$2");
    }
    return cleaned.slice(0, 11).replace(/(\d{3})(\d)/, "$1.$2").replace(/(\d{3})(\d)/, "$1.$2").replace(/(\d{3})(\d{1,2})$/, "$1-$2");
  }
  // Aplicar máscara de CNPJ: 00.000.000/0000-00
  applyCnpjMask(value) {
    if (!value)
      return "";
    const cleaned = value.replace(/\D/g, "");
    if (cleaned.length <= 14) {
      return cleaned.replace(/(\d{2})(\d)/, "$1.$2").replace(/(\d{3})(\d)/, "$1.$2").replace(/(\d{3})(\d)/, "$1/$2").replace(/(\d{4})(\d{1,2})$/, "$1-$2");
    }
    return cleaned.slice(0, 14).replace(/(\d{2})(\d)/, "$1.$2").replace(/(\d{3})(\d)/, "$1.$2").replace(/(\d{3})(\d)/, "$1/$2").replace(/(\d{4})(\d{1,2})$/, "$1-$2");
  }
  // Aplicar máscara de telefone brasileiro: (00) 00000-0000 ou (00) 0000-0000
  applyPhoneMask(value) {
    if (!value)
      return "";
    const cleaned = value.replace(/\D/g, "");
    if (cleaned.length === 11) {
      return cleaned.replace(/(\d{2})(\d)/, "($1) $2").replace(/(\d{5})(\d{4})$/, "$1-$2");
    }
    if (cleaned.length === 10) {
      return cleaned.replace(/(\d{2})(\d)/, "($1) $2").replace(/(\d{4})(\d{4})$/, "$1-$2");
    }
    if (cleaned.length <= 11) {
      let masked = cleaned;
      if (cleaned.length >= 2) {
        masked = cleaned.replace(/(\d{2})(\d)/, "($1) $2");
      }
      if (cleaned.length >= 7) {
        masked = masked.replace(/(\d{4,5})(\d{4})$/, "$1-$2");
      }
      return masked;
    }
    return this.applyPhoneMask(cleaned.slice(0, 11));
  }
  // Validar CPF
  isValidCpf(cpf) {
    if (!cpf)
      return false;
    const cleaned = cpf.replace(/\D/g, "");
    if (cleaned.length !== 11)
      return false;
    if (/^(\d)\1+$/.test(cleaned))
      return false;
    let sum = 0;
    for (let i = 0; i < 9; i++) {
      sum += parseInt(cleaned.charAt(i)) * (10 - i);
    }
    let digit1 = 11 - sum % 11;
    if (digit1 > 9)
      digit1 = 0;
    sum = 0;
    for (let i = 0; i < 10; i++) {
      sum += parseInt(cleaned.charAt(i)) * (11 - i);
    }
    let digit2 = 11 - sum % 11;
    if (digit2 > 9)
      digit2 = 0;
    return parseInt(cleaned.charAt(9)) === digit1 && parseInt(cleaned.charAt(10)) === digit2;
  }
  // Validar CNPJ
  isValidCnpj(cnpj) {
    if (!cnpj)
      return false;
    const cleaned = cnpj.replace(/\D/g, "");
    if (cleaned.length !== 14)
      return false;
    if (/^(\d)\1+$/.test(cleaned))
      return false;
    const digits = cleaned.split("").map(Number);
    let sum1 = 0;
    const weights1 = [5, 4, 3, 2, 9, 8, 7, 6, 5, 4, 3, 2];
    for (let i = 0; i < 12; i++) {
      sum1 += digits[i] * weights1[i];
    }
    const remainder1 = sum1 % 11;
    const digit1 = remainder1 < 2 ? 0 : 11 - remainder1;
    let sum2 = 0;
    const weights2 = [6, 5, 4, 3, 2, 9, 8, 7, 6, 5, 4, 3, 2];
    for (let i = 0; i < 13; i++) {
      sum2 += digits[i] * weights2[i];
    }
    const remainder2 = sum2 % 11;
    const digit2 = remainder2 < 2 ? 0 : 11 - remainder2;
    return digits[12] === digit1 && digits[13] === digit2;
  }
  // Validar email
  isValidEmail(email) {
    if (!email)
      return false;
    const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
    return emailRegex.test(email);
  }
  // Remover formatação (manter só números)
  removeFormatting(value) {
    if (!value)
      return "";
    return value.replace(/\D/g, "");
  }
  // Obter cores da temperatura
  getTemperatureColor(temperature) {
    switch (temperature?.toLowerCase()) {
      case "quente":
        return "#EF4444";
      // red-500
      case "morno":
        return "#EAB308";
      // yellow-500  
      case "frio":
        return "#3B82F6";
      // blue-500
      default:
        return "#6B7280";
    }
  }
  // Obter classe CSS da temperatura
  getTemperatureClass(temperature) {
    switch (temperature?.toLowerCase()) {
      case "quente":
        return "bg-red-500 text-white";
      case "morno":
        return "bg-yellow-500 text-white";
      case "frio":
        return "bg-blue-500 text-white";
      default:
        return "bg-gray-500 text-white";
    }
  }
  // Métodos de máscara para eventos de input
  maskPhone(event) {
    const input = event.target;
    const value = input.value;
    const maskedValue = this.applyPhoneMask(value);
    input.value = maskedValue;
    const inputEvent = new Event("input", { bubbles: true });
    input.dispatchEvent(inputEvent);
  }
  maskCPF(event) {
    const input = event.target;
    const value = input.value;
    const maskedValue = this.applyCpfMask(value);
    input.value = maskedValue;
    const inputEvent = new Event("input", { bubbles: true });
    input.dispatchEvent(inputEvent);
  }
  maskCNPJ(event) {
    const input = event.target;
    const value = input.value;
    const maskedValue = this.applyCnpjMask(value);
    input.value = maskedValue;
    const inputEvent = new Event("input", { bubbles: true });
    input.dispatchEvent(inputEvent);
  }
  // Métodos de validação com nomes alternativos
  validateCPF(value) {
    return this.isValidCpf(value);
  }
  validateCNPJ(value) {
    return this.isValidCnpj(value);
  }
};
__name(_MaskService, "MaskService");
__publicField(_MaskService, "\u0275fac", /* @__PURE__ */ __name(function MaskService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _MaskService)();
}, "MaskService_Factory"));
__publicField(_MaskService, "\u0275prov", /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _MaskService, factory: _MaskService.\u0275fac, providedIn: "root" }));
var MaskService = _MaskService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaskService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();

// src/app/components/lead-modal/lead-modal.component.ts
var _c02 = /* @__PURE__ */ __name(() => ["Quente", "Morno", "Frio"], "_c0");
function LeadModalComponent_div_0_div_9_span_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 27);
    \u0275\u0275text(1, "*");
    \u0275\u0275elementEnd();
  }
}
__name(LeadModalComponent_div_0_div_9_span_3_Template, "LeadModalComponent_div_0_div_9_span_3_Template");
function LeadModalComponent_div_0_div_9_input_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "input", 28);
  }
  if (rf & 2) {
    let tmp_4_0;
    const field_r3 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classProp("border-red-500", ((tmp_4_0 = ctx_r1.leadForm.get(field_r3.name)) == null ? null : tmp_4_0.invalid) && ((tmp_4_0 = ctx_r1.leadForm.get(field_r3.name)) == null ? null : tmp_4_0.touched));
    \u0275\u0275property("type", field_r3.type)("id", field_r3.name)("formControlName", field_r3.name)("placeholder", field_r3.placeholder || "")("disabled", ctx_r1.isLoading);
  }
}
__name(LeadModalComponent_div_0_div_9_input_4_Template, "LeadModalComponent_div_0_div_9_input_4_Template");
function LeadModalComponent_div_0_div_9_input_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "input", 29);
    \u0275\u0275listener("input", /* @__PURE__ */ __name(function LeadModalComponent_div_0_div_9_input_5_Template_input_input_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.maskHelper.maskPhone($event));
    }, "LeadModalComponent_div_0_div_9_input_5_Template_input_input_0_listener"))("keyup", /* @__PURE__ */ __name(function LeadModalComponent_div_0_div_9_input_5_Template_input_keyup_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.maskHelper.maskPhone($event));
    }, "LeadModalComponent_div_0_div_9_input_5_Template_input_keyup_0_listener"));
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    let tmp_4_0;
    const field_r3 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classProp("border-red-500", ((tmp_4_0 = ctx_r1.leadForm.get(field_r3.name)) == null ? null : tmp_4_0.invalid) && ((tmp_4_0 = ctx_r1.leadForm.get(field_r3.name)) == null ? null : tmp_4_0.touched));
    \u0275\u0275property("id", field_r3.name)("formControlName", field_r3.name)("placeholder", field_r3.placeholder || "(11) 99999-9999")("disabled", ctx_r1.isLoading);
  }
}
__name(LeadModalComponent_div_0_div_9_input_5_Template, "LeadModalComponent_div_0_div_9_input_5_Template");
function LeadModalComponent_div_0_div_9_input_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "input", 30);
    \u0275\u0275listener("input", /* @__PURE__ */ __name(function LeadModalComponent_div_0_div_9_input_6_Template_input_input_0_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.maskHelper.maskCNPJ($event));
    }, "LeadModalComponent_div_0_div_9_input_6_Template_input_input_0_listener"))("keyup", /* @__PURE__ */ __name(function LeadModalComponent_div_0_div_9_input_6_Template_input_keyup_0_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.maskHelper.maskCNPJ($event));
    }, "LeadModalComponent_div_0_div_9_input_6_Template_input_keyup_0_listener"));
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    let tmp_4_0;
    const field_r3 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classProp("border-red-500", ((tmp_4_0 = ctx_r1.leadForm.get(field_r3.name)) == null ? null : tmp_4_0.invalid) && ((tmp_4_0 = ctx_r1.leadForm.get(field_r3.name)) == null ? null : tmp_4_0.touched));
    \u0275\u0275property("id", field_r3.name)("formControlName", field_r3.name)("disabled", ctx_r1.isLoading);
  }
}
__name(LeadModalComponent_div_0_div_9_input_6_Template, "LeadModalComponent_div_0_div_9_input_6_Template");
function LeadModalComponent_div_0_div_9_input_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "input", 31);
    \u0275\u0275listener("input", /* @__PURE__ */ __name(function LeadModalComponent_div_0_div_9_input_7_Template_input_input_0_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.maskHelper.maskCPF($event));
    }, "LeadModalComponent_div_0_div_9_input_7_Template_input_input_0_listener"))("keyup", /* @__PURE__ */ __name(function LeadModalComponent_div_0_div_9_input_7_Template_input_keyup_0_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.maskHelper.maskCPF($event));
    }, "LeadModalComponent_div_0_div_9_input_7_Template_input_keyup_0_listener"));
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    let tmp_4_0;
    const field_r3 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classProp("border-red-500", ((tmp_4_0 = ctx_r1.leadForm.get(field_r3.name)) == null ? null : tmp_4_0.invalid) && ((tmp_4_0 = ctx_r1.leadForm.get(field_r3.name)) == null ? null : tmp_4_0.touched));
    \u0275\u0275property("id", field_r3.name)("formControlName", field_r3.name)("disabled", ctx_r1.isLoading);
  }
}
__name(LeadModalComponent_div_0_div_9_input_7_Template, "LeadModalComponent_div_0_div_9_input_7_Template");
function LeadModalComponent_div_0_div_9_select_8_option_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "option", 35);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const option_r7 = ctx.$implicit;
    \u0275\u0275property("value", option_r7);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", option_r7, " ");
  }
}
__name(LeadModalComponent_div_0_div_9_select_8_option_3_Template, "LeadModalComponent_div_0_div_9_select_8_option_3_Template");
function LeadModalComponent_div_0_div_9_select_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "select", 32)(1, "option", 33);
    \u0275\u0275text(2, "Selecione...");
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, LeadModalComponent_div_0_div_9_select_8_option_3_Template, 2, 2, "option", 34);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    let tmp_4_0;
    const field_r3 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classProp("border-red-500", ((tmp_4_0 = ctx_r1.leadForm.get(field_r3.name)) == null ? null : tmp_4_0.invalid) && ((tmp_4_0 = ctx_r1.leadForm.get(field_r3.name)) == null ? null : tmp_4_0.touched));
    \u0275\u0275property("id", field_r3.name)("formControlName", field_r3.name)("disabled", ctx_r1.isLoading);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", field_r3.options);
  }
}
__name(LeadModalComponent_div_0_div_9_select_8_Template, "LeadModalComponent_div_0_div_9_select_8_Template");
function LeadModalComponent_div_0_div_9_select_9_option_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "option", 35);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const option_r8 = ctx.$implicit;
    \u0275\u0275property("value", option_r8);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", option_r8, " ");
  }
}
__name(LeadModalComponent_div_0_div_9_select_9_option_3_Template, "LeadModalComponent_div_0_div_9_select_9_option_3_Template");
function LeadModalComponent_div_0_div_9_select_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "select", 32)(1, "option", 33);
    \u0275\u0275text(2, "Selecione a temperatura");
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, LeadModalComponent_div_0_div_9_select_9_option_3_Template, 2, 2, "option", 34);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    let tmp_4_0;
    const field_r3 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classProp("border-red-500", ((tmp_4_0 = ctx_r1.leadForm.get(field_r3.name)) == null ? null : tmp_4_0.invalid) && ((tmp_4_0 = ctx_r1.leadForm.get(field_r3.name)) == null ? null : tmp_4_0.touched));
    \u0275\u0275property("id", field_r3.name)("formControlName", field_r3.name)("disabled", ctx_r1.isLoading);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", field_r3.options || \u0275\u0275pureFunction0(6, _c02));
  }
}
__name(LeadModalComponent_div_0_div_9_select_9_Template, "LeadModalComponent_div_0_div_9_select_9_Template");
function LeadModalComponent_div_0_div_9_div_10_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 38);
    \u0275\u0275element(1, "input", 39);
    \u0275\u0275elementStart(2, "label", 40);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const option_r9 = ctx.$implicit;
    const i_r10 = ctx.index;
    const field_r3 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("id", field_r3.name + "_radio_" + i_r10)("formControlName", field_r3.name)("value", option_r9)("disabled", ctx_r1.isLoading);
    \u0275\u0275advance();
    \u0275\u0275property("for", field_r3.name + "_radio_" + i_r10);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", option_r9, " ");
  }
}
__name(LeadModalComponent_div_0_div_9_div_10_div_1_Template, "LeadModalComponent_div_0_div_9_div_10_div_1_Template");
function LeadModalComponent_div_0_div_9_div_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 36);
    \u0275\u0275template(1, LeadModalComponent_div_0_div_9_div_10_div_1_Template, 4, 6, "div", 37);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const field_r3 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", field_r3.options);
  }
}
__name(LeadModalComponent_div_0_div_9_div_10_Template, "LeadModalComponent_div_0_div_9_div_10_Template");
function LeadModalComponent_div_0_div_9_label_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "label", 41);
    \u0275\u0275element(1, "input", 42);
    \u0275\u0275elementStart(2, "span", 43);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const field_r3 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("id", field_r3.name)("formControlName", field_r3.name)("disabled", ctx_r1.isLoading);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(field_r3.placeholder || field_r3.label);
  }
}
__name(LeadModalComponent_div_0_div_9_label_11_Template, "LeadModalComponent_div_0_div_9_label_11_Template");
function LeadModalComponent_div_0_div_9_textarea_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "textarea", 44);
  }
  if (rf & 2) {
    let tmp_4_0;
    const field_r3 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classProp("border-red-500", ((tmp_4_0 = ctx_r1.leadForm.get(field_r3.name)) == null ? null : tmp_4_0.invalid) && ((tmp_4_0 = ctx_r1.leadForm.get(field_r3.name)) == null ? null : tmp_4_0.touched));
    \u0275\u0275property("id", field_r3.name)("formControlName", field_r3.name)("disabled", ctx_r1.isLoading);
  }
}
__name(LeadModalComponent_div_0_div_9_textarea_12_Template, "LeadModalComponent_div_0_div_9_textarea_12_Template");
function LeadModalComponent_div_0_div_9_div_13_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div")(1, "input", 45);
    \u0275\u0275listener("change", /* @__PURE__ */ __name(function LeadModalComponent_div_0_div_9_div_13_Template_input_change_1_listener($event) {
      \u0275\u0275restoreView(_r11);
      const field_r3 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onFileSelected($event, field_r3.name));
    }, "LeadModalComponent_div_0_div_9_div_13_Template_input_change_1_listener"));
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "p", 46);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    let tmp_4_0;
    const field_r3 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275classProp("border-red-500", ((tmp_4_0 = ctx_r1.leadForm.get(field_r3.name)) == null ? null : tmp_4_0.invalid) && ((tmp_4_0 = ctx_r1.leadForm.get(field_r3.name)) == null ? null : tmp_4_0.touched));
    \u0275\u0275property("id", field_r3.name)("multiple", field_r3.placeholder === "multiple")("disabled", ctx_r1.isLoading);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", field_r3.placeholder || "Voc\xEA pode anexar arquivos como documentos, imagens, etc.", " ");
  }
}
__name(LeadModalComponent_div_0_div_9_div_13_Template, "LeadModalComponent_div_0_div_9_div_13_Template");
function LeadModalComponent_div_0_div_9_div_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 47);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const field_r3 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.getFieldError(field_r3.name), " ");
  }
}
__name(LeadModalComponent_div_0_div_9_div_14_Template, "LeadModalComponent_div_0_div_9_div_14_Template");
function LeadModalComponent_div_0_div_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 14)(1, "label", 15);
    \u0275\u0275text(2);
    \u0275\u0275template(3, LeadModalComponent_div_0_div_9_span_3_Template, 2, 0, "span", 16);
    \u0275\u0275elementEnd();
    \u0275\u0275template(4, LeadModalComponent_div_0_div_9_input_4_Template, 1, 7, "input", 17)(5, LeadModalComponent_div_0_div_9_input_5_Template, 1, 6, "input", 18)(6, LeadModalComponent_div_0_div_9_input_6_Template, 1, 5, "input", 19)(7, LeadModalComponent_div_0_div_9_input_7_Template, 1, 5, "input", 20)(8, LeadModalComponent_div_0_div_9_select_8_Template, 4, 6, "select", 21)(9, LeadModalComponent_div_0_div_9_select_9_Template, 4, 7, "select", 21)(10, LeadModalComponent_div_0_div_9_div_10_Template, 2, 1, "div", 22)(11, LeadModalComponent_div_0_div_9_label_11_Template, 4, 4, "label", 23)(12, LeadModalComponent_div_0_div_9_textarea_12_Template, 1, 5, "textarea", 24)(13, LeadModalComponent_div_0_div_9_div_13_Template, 4, 6, "div", 25)(14, LeadModalComponent_div_0_div_9_div_14_Template, 2, 1, "div", 26);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const field_r3 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("for", field_r3.name);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", field_r3.label, " ");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r3.required);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r3.type === "text" || field_r3.type === "email" || field_r3.type === "date" || field_r3.type === "time" || field_r3.type === "number");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r3.type === "tel");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r3.type === "cnpj");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r3.type === "cpf");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r3.type === "select");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r3.type === "temperatura");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r3.type === "radio");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r3.type === "checkbox");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r3.type === "textarea");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r3.type === "file");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.getFieldError(field_r3.name));
  }
}
__name(LeadModalComponent_div_0_div_9_Template, "LeadModalComponent_div_0_div_9_Template");
function LeadModalComponent_div_0_div_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 48);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.errorMessage, " ");
  }
}
__name(LeadModalComponent_div_0_div_10_Template, "LeadModalComponent_div_0_div_10_Template");
function LeadModalComponent_div_0_div_15_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 49);
  }
}
__name(LeadModalComponent_div_0_div_15_Template, "LeadModalComponent_div_0_div_15_Template");
function LeadModalComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 1);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function LeadModalComponent_div_0_Template_div_click_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onBackdropClick($event));
    }, "LeadModalComponent_div_0_Template_div_click_0_listener"));
    \u0275\u0275elementStart(1, "div", 2)(2, "div", 3)(3, "h2", 4);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "button", 5);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function LeadModalComponent_div_0_Template_button_click_5_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.hide());
    }, "LeadModalComponent_div_0_Template_button_click_5_listener"));
    \u0275\u0275text(6, " \xD7 ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(7, "form", 6);
    \u0275\u0275listener("ngSubmit", /* @__PURE__ */ __name(function LeadModalComponent_div_0_Template_form_ngSubmit_7_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.saveLead());
    }, "LeadModalComponent_div_0_Template_form_ngSubmit_7_listener"));
    \u0275\u0275elementStart(8, "div", 7);
    \u0275\u0275template(9, LeadModalComponent_div_0_div_9_Template, 15, 14, "div", 8)(10, LeadModalComponent_div_0_div_10_Template, 2, 1, "div", 9);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "div", 10)(12, "button", 11);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function LeadModalComponent_div_0_Template_button_click_12_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.hide());
    }, "LeadModalComponent_div_0_Template_button_click_12_listener"));
    \u0275\u0275text(13, " Cancelar ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(14, "button", 12);
    \u0275\u0275template(15, LeadModalComponent_div_0_div_15_Template, 1, 0, "div", 13);
    \u0275\u0275text(16);
    \u0275\u0275elementEnd()()()()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", ctx_r1.isEditing ? "Editar Registro" : "Novo Registro", " ");
    \u0275\u0275advance();
    \u0275\u0275property("disabled", ctx_r1.isLoading);
    \u0275\u0275advance(2);
    \u0275\u0275property("formGroup", ctx_r1.leadForm);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx_r1.formFields);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.errorMessage);
    \u0275\u0275advance(2);
    \u0275\u0275property("disabled", ctx_r1.isLoading);
    \u0275\u0275advance(2);
    \u0275\u0275property("disabled", ctx_r1.isLoading || !ctx_r1.leadForm.valid);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.isLoading);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.isLoading ? "Salvando..." : ctx_r1.isEditing ? "Atualizar Registro" : "Salvar Registro", " ");
  }
}
__name(LeadModalComponent_div_0_Template, "LeadModalComponent_div_0_Template");
var _LeadModalComponent = class _LeadModalComponent {
  authService = inject(AuthService);
  firestoreService = inject(FirestoreService);
  storageService = inject(StorageService);
  fb = inject(FormBuilder);
  maskService = inject(MaskService);
  ownerId = "";
  boardId = "";
  columns = [];
  leadCreated = new EventEmitter();
  leadUpdated = new EventEmitter();
  closeModal = new EventEmitter();
  isVisible = false;
  isEditing = false;
  isLoading = false;
  errorMessage = "";
  currentLead = null;
  leadForm = this.fb.group({});
  formFields = [];
  selectedFiles = [];
  ngOnInit() {
    this.initializeForm();
  }
  initializeForm() {
    return __async(this, null, function* () {
      yield this.loadFormFieldsFromInitialBoard();
      if (this.formFields.length === 0) {
        yield this.loadFormFieldsFromInitialPhase();
      }
      this.buildForm();
    });
  }
  loadFormFieldsFromInitialBoard() {
    return __async(this, null, function* () {
      try {
        if (!this.boardId)
          return;
        const cfg = yield this.firestoreService.getInitialFormConfig(this.boardId);
        if (cfg && cfg.fields) {
          this.formFields = cfg.fields.map((field, index) => __spreadProps(__spreadValues({}, field), {
            includeInApi: field.includeInApi !== false,
            order: field.order ?? index
          })).sort((a, b) => (a.order || 0) - (b.order || 0));
        }
      } catch (e) {
      }
    });
  }
  loadFormFieldsFromInitialPhase() {
    return __async(this, null, function* () {
      try {
        if (this.boardId && this.ownerId) {
          console.log("\u{1F50D} Carregando campos do formul\xE1rio da fase inicial...", {
            boardId: this.boardId,
            ownerId: this.ownerId
          });
          const columns = yield this.firestoreService.getColumns(this.ownerId, this.boardId);
          console.log("\u{1F4CB} Colunas encontradas:", columns);
          const initialColumn = columns.find((col) => col.isInitialPhase) || columns.sort((a, b) => (a.order || 0) - (b.order || 0))[0];
          if (initialColumn) {
            console.log("\u{1F3AF} Fase inicial encontrada:", initialColumn);
            const phaseFormConfig = yield this.firestoreService.getPhaseFormConfig(this.ownerId, this.boardId, initialColumn.id);
            console.log("\u2699\uFE0F Configura\xE7\xE3o da fase encontrada:", phaseFormConfig);
            if (phaseFormConfig && phaseFormConfig.fields) {
              this.formFields = phaseFormConfig.fields.map((field) => {
                if (field.type === "temperatura") {
                  if (!field.options || field.options.length === 0) {
                    field.options = ["Quente", "Morno", "Frio"];
                  }
                  console.log("\u{1F321}\uFE0F Campo temperatura reconstru\xEDdo:", field);
                }
                return __spreadProps(__spreadValues({}, field), {
                  includeInApi: field.includeInApi !== false,
                  order: field.order || 0
                });
              }).sort((a, b) => (a.order || 0) - (b.order || 0));
              console.log("\u2705 Formul\xE1rio carregado da fase inicial:", this.formFields);
            } else {
              console.log("\u26A0\uFE0F Nenhuma configura\xE7\xE3o de formul\xE1rio encontrada para a fase");
            }
          } else {
            console.log("\u26A0\uFE0F Nenhuma coluna encontrada no quadro");
          }
        } else {
          console.log("\u26A0\uFE0F BoardId ou OwnerId n\xE3o definidos:", { boardId: this.boardId, ownerId: this.ownerId });
        }
      } catch (error) {
        console.error("\u274C Erro ao carregar campos do formul\xE1rio da fase:", error);
      }
    });
  }
  buildForm() {
    const group = {};
    this.formFields.forEach((field) => {
      const validators = field.required ? [Validators.required] : [];
      switch (field.type) {
        case "email":
          validators.push(Validators.email);
          break;
        case "cnpj":
          validators.push((control) => {
            const value = control.value;
            if (!value)
              return null;
            return this.maskService.validateCNPJ(value) ? null : { cnpj: true };
          });
          break;
        case "cpf":
          validators.push((control) => {
            const value = control.value;
            if (!value)
              return null;
            return this.maskService.validateCPF(value) ? null : { cpf: true };
          });
          break;
      }
      group[field.name] = ["", validators];
    });
    this.leadForm = this.fb.group(group);
  }
  showCreateModal() {
    this.isEditing = false;
    this.currentLead = null;
    this.isVisible = true;
    this.resetForm();
  }
  showEditModal(lead) {
    this.isEditing = true;
    this.currentLead = lead;
    this.isVisible = true;
    this.populateForm(lead);
  }
  hide() {
    this.isVisible = false;
    this.resetForm();
    this.closeModal.emit();
  }
  resetForm() {
    this.leadForm.reset();
    this.errorMessage = "";
    this.selectedFiles = [];
    this.isLoading = false;
  }
  populateForm(lead) {
    if (lead.fields) {
      Object.keys(lead.fields).forEach((key) => {
        if (this.leadForm.controls[key]) {
          this.leadForm.patchValue({ [key]: lead.fields[key] });
        }
      });
    }
  }
  saveLead() {
    return __async(this, null, function* () {
      if (!this.leadForm.valid) {
        this.errorMessage = "Por favor, preencha todos os campos obrigat\xF3rios.";
        return;
      }
      this.isLoading = true;
      this.errorMessage = "";
      try {
        const formData = this.leadForm.value;
        const currentUser = this.authService.getCurrentUser();
        if (!currentUser) {
          throw new Error("Usu\xE1rio n\xE3o autenticado");
        }
        if (this.isEditing && this.currentLead) {
          yield this.firestoreService.updateLead(this.ownerId, this.boardId, this.currentLead.id, { fields: formData });
          yield this.firestoreService.addLeadHistory(this.ownerId, this.boardId, this.currentLead.id, {
            type: "update",
            text: "Lead atualizado",
            user: currentUser.displayName || currentUser.email
          });
          this.leadUpdated.emit();
        } else {
          let initialColumn = this.columns.find((c) => c.isInitialPhase) || this.columns.sort((a, b) => (a.order || 0) - (b.order || 0))[0];
          if (!initialColumn) {
            const initialColumnId = yield this.firestoreService.getInitialColumnId(this.boardId);
            if (initialColumnId) {
              initialColumn = this.columns.find((c) => c.id === initialColumnId) || null;
            }
          }
          if (!initialColumn)
            throw new Error("Nenhuma coluna inicial encontrada");
          const now = /* @__PURE__ */ new Date();
          const newLead = {
            fields: formData,
            columnId: initialColumn.id,
            companyId: "",
            // Será preenchido pelo FirestoreService
            boardId: this.boardId,
            createdAt: null,
            // será preenchido pelo serverTimestamp
            movedToCurrentColumnAt: null,
            responsibleUserId: currentUser.uid,
            responsibleUserName: currentUser.displayName || "",
            responsibleUserEmail: currentUser.email || "",
            phaseHistory: { [initialColumn.id]: { phaseId: initialColumn.id, enteredAt: now } },
            executedAutomations: {}
          };
          const leadRef = yield this.firestoreService.createLead(this.ownerId, this.boardId, newLead);
          try {
            const createdLead = yield this.firestoreService.getLead(this.ownerId, this.boardId, leadRef.id);
            if (createdLead && (!createdLead.phaseHistory || !createdLead.phaseHistory[initialColumn.id])) {
              yield this.firestoreService.updateLead(this.ownerId, this.boardId, leadRef.id, {
                phaseHistory: { [initialColumn.id]: { phaseId: initialColumn.id, enteredAt: /* @__PURE__ */ new Date() } }
              });
            }
          } catch {
          }
          yield this.firestoreService.addLeadHistory(this.ownerId, this.boardId, leadRef.id, {
            type: "creation",
            text: `Lead criado na fase <b>${initialColumn.name}</b>`,
            user: currentUser.displayName || currentUser.email
          });
          this.leadCreated.emit();
        }
        this.hide();
      } catch (error) {
        console.error("Erro ao salvar lead:", error);
        this.errorMessage = "Erro ao salvar lead. Tente novamente.";
      } finally {
        this.isLoading = false;
      }
    });
  }
  onFileSelected(event, fieldName) {
    const files = event.target.files;
    if (files) {
      if (fieldName) {
        this.leadForm.patchValue({ [fieldName]: Array.from(files) });
      } else {
        this.selectedFiles = Array.from(files);
      }
    }
  }
  onBackdropClick(event) {
    if (event.target === event.currentTarget) {
      this.hide();
    }
  }
  getFieldError(fieldName) {
    const control = this.leadForm.get(fieldName);
    if (control?.errors && control.touched) {
      if (control.errors["required"]) {
        return `${this.getFieldLabel(fieldName)} \xE9 obrigat\xF3rio`;
      }
      if (control.errors["email"]) {
        return "Email inv\xE1lido";
      }
      if (control.errors["cnpj"]) {
        return "CNPJ inv\xE1lido";
      }
      if (control.errors["cpf"]) {
        return "CPF inv\xE1lido";
      }
    }
    return "";
  }
  getFieldLabel(fieldName) {
    const field = this.formFields.find((f) => f.name === fieldName);
    return field?.label || fieldName;
  }
  // Getter para acessar o maskService no template
  get maskHelper() {
    return this.maskService;
  }
};
__name(_LeadModalComponent, "LeadModalComponent");
__publicField(_LeadModalComponent, "\u0275fac", /* @__PURE__ */ __name(function LeadModalComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _LeadModalComponent)();
}, "LeadModalComponent_Factory"));
__publicField(_LeadModalComponent, "\u0275cmp", /* @__PURE__ */ \u0275\u0275defineComponent({ type: _LeadModalComponent, selectors: [["app-lead-modal"]], inputs: { ownerId: "ownerId", boardId: "boardId", columns: "columns" }, outputs: { leadCreated: "leadCreated", leadUpdated: "leadUpdated", closeModal: "closeModal" }, decls: 1, vars: 1, consts: [["class", "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", 3, "click", 4, "ngIf"], [1, "fixed", "inset-0", "bg-black", "bg-opacity-50", "flex", "items-center", "justify-center", "z-50", "p-4", 3, "click"], [1, "bg-white", "rounded-xl", "shadow-2xl", "w-full", "max-w-2xl", "max-h-[90vh]", "overflow-y-auto"], [1, "flex", "justify-between", "items-center", "p-6", "border-b", "border-gray-200"], [1, "text-2xl", "font-bold", "text-gray-900"], [1, "text-gray-400", "hover:text-gray-600", "text-2xl", "font-bold", 3, "click", "disabled"], [1, "p-6", 3, "ngSubmit", "formGroup"], [1, "space-y-4"], ["class", "form-group", 4, "ngFor", "ngForOf"], ["class", "bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg", 4, "ngIf"], [1, "flex", "justify-end", "gap-3", "mt-6", "pt-4", "border-t", "border-gray-200"], ["type", "button", 1, "px-4", "py-2", "text-gray-700", "bg-gray-200", "hover:bg-gray-300", "rounded-lg", "font-medium", "transition-colors", 3, "click", "disabled"], ["type", "submit", 1, "px-6", "py-2", "bg-blue-500", "hover:bg-blue-600", "disabled:bg-blue-300", "text-white", "rounded-lg", "font-medium", "transition-colors", "flex", "items-center", 3, "disabled"], ["class", "animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2", 4, "ngIf"], [1, "form-group"], [1, "block", "text-sm", "font-medium", "text-gray-700", "mb-1", 3, "for"], ["class", "text-red-500", 4, "ngIf"], ["class", "w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors", 3, "type", "id", "formControlName", "placeholder", "border-red-500", "disabled", 4, "ngIf"], ["type", "tel", "class", "w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors", 3, "id", "formControlName", "placeholder", "border-red-500", "disabled", "input", "keyup", 4, "ngIf"], ["type", "text", "placeholder", "00.000.000/0000-00", "class", "w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors", 3, "id", "formControlName", "border-red-500", "disabled", "input", "keyup", 4, "ngIf"], ["type", "text", "placeholder", "000.000.000-00", "class", "w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors", 3, "id", "formControlName", "border-red-500", "disabled", "input", "keyup", 4, "ngIf"], ["class", "w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors", 3, "id", "formControlName", "border-red-500", "disabled", 4, "ngIf"], ["class", "space-y-2", 4, "ngIf"], ["class", "flex items-center cursor-pointer", 4, "ngIf"], ["rows", "3", "class", "w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors resize-none", 3, "id", "formControlName", "border-red-500", "disabled", 4, "ngIf"], [4, "ngIf"], ["class", "text-red-500 text-sm mt-1", 4, "ngIf"], [1, "text-red-500"], [1, "w-full", "p-3", "border", "border-gray-300", "rounded-lg", "focus:ring-2", "focus:ring-blue-500", "focus:border-blue-500", "transition-colors", 3, "type", "id", "formControlName", "placeholder", "disabled"], ["type", "tel", 1, "w-full", "p-3", "border", "border-gray-300", "rounded-lg", "focus:ring-2", "focus:ring-blue-500", "focus:border-blue-500", "transition-colors", 3, "input", "keyup", "id", "formControlName", "placeholder", "disabled"], ["type", "text", "placeholder", "00.000.000/0000-00", 1, "w-full", "p-3", "border", "border-gray-300", "rounded-lg", "focus:ring-2", "focus:ring-blue-500", "focus:border-blue-500", "transition-colors", 3, "input", "keyup", "id", "formControlName", "disabled"], ["type", "text", "placeholder", "000.000.000-00", 1, "w-full", "p-3", "border", "border-gray-300", "rounded-lg", "focus:ring-2", "focus:ring-blue-500", "focus:border-blue-500", "transition-colors", 3, "input", "keyup", "id", "formControlName", "disabled"], [1, "w-full", "p-3", "border", "border-gray-300", "rounded-lg", "focus:ring-2", "focus:ring-blue-500", "focus:border-blue-500", "transition-colors", 3, "id", "formControlName", "disabled"], ["value", ""], [3, "value", 4, "ngFor", "ngForOf"], [3, "value"], [1, "space-y-2"], ["class", "flex items-center", 4, "ngFor", "ngForOf"], [1, "flex", "items-center"], ["type", "radio", 1, "mr-2", "text-blue-600", "focus:ring-blue-500", "border-gray-300", 3, "id", "formControlName", "value", "disabled"], [1, "text-gray-700", "cursor-pointer", 3, "for"], [1, "flex", "items-center", "cursor-pointer"], ["type", "checkbox", 1, "mr-2", "text-blue-600", "focus:ring-blue-500", "border-gray-300", "rounded", 3, "id", "formControlName", "disabled"], [1, "text-gray-700"], ["rows", "3", 1, "w-full", "p-3", "border", "border-gray-300", "rounded-lg", "focus:ring-2", "focus:ring-blue-500", "focus:border-blue-500", "transition-colors", "resize-none", 3, "id", "formControlName", "disabled"], ["type", "file", 1, "w-full", "p-3", "border", "border-gray-300", "rounded-lg", "focus:ring-2", "focus:ring-blue-500", "focus:border-blue-500", "transition-colors", 3, "change", "id", "multiple", "disabled"], [1, "text-xs", "text-gray-500", "mt-1"], [1, "text-red-500", "text-sm", "mt-1"], [1, "bg-red-50", "border", "border-red-200", "text-red-700", "px-4", "py-3", "rounded-lg"], [1, "animate-spin", "rounded-full", "h-4", "w-4", "border-b-2", "border-white", "mr-2"]], template: /* @__PURE__ */ __name(function LeadModalComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, LeadModalComponent_div_0_Template, 17, 9, "div", 0);
  }
  if (rf & 2) {
    \u0275\u0275property("ngIf", ctx.isVisible);
  }
}, "LeadModalComponent_Template"), dependencies: [CommonModule, NgForOf, NgIf, FormsModule, \u0275NgNoValidate, NgSelectOption, \u0275NgSelectMultipleOption, DefaultValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, ReactiveFormsModule, FormGroupDirective, FormControlName], styles: [`

.fixed[_ngcontent-%COMP%] {
  animation: _ngcontent-%COMP%_fadeIn 0.2s ease-out;
}
.bg-white[_ngcontent-%COMP%] {
  animation: _ngcontent-%COMP%_slideUp 0.3s ease-out;
}
@keyframes _ngcontent-%COMP%_fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
@keyframes _ngcontent-%COMP%_slideUp {
  from {
    opacity: 0;
    transform: translateY(20px) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}
.form-group[_ngcontent-%COMP%] {
  position: relative;
}
input[_ngcontent-%COMP%]:focus, 
select[_ngcontent-%COMP%]:focus, 
textarea[_ngcontent-%COMP%]:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}
.border-red-500[_ngcontent-%COMP%] {
  border-color: #ef4444 !important;
}
select[_ngcontent-%COMP%] {
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
  background-position: right 0.5rem center;
  background-repeat: no-repeat;
  background-size: 1.5em 1.5em;
  padding-right: 2.5rem;
}
.overflow-y-auto[_ngcontent-%COMP%]::-webkit-scrollbar {
  width: 6px;
}
.overflow-y-auto[_ngcontent-%COMP%]::-webkit-scrollbar-track {
  background: #f1f5f9;
}
.overflow-y-auto[_ngcontent-%COMP%]::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 3px;
}
.overflow-y-auto[_ngcontent-%COMP%]::-webkit-scrollbar-thumb:hover {
  background: #94a3b8;
}
/*# sourceMappingURL=lead-modal.component.css.map */`] }));
var LeadModalComponent = _LeadModalComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LeadModalComponent, [{
    type: Component,
    args: [{ selector: "app-lead-modal", standalone: true, imports: [CommonModule, FormsModule, ReactiveFormsModule], template: `<div *ngIf="isVisible" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" (click)="onBackdropClick($event)">
  <div class="bg-white rounded-xl shadow-2xl w-full max-w-2xl max-h-[90vh] overflow-y-auto">
    <!-- Header -->
    <div class="flex justify-between items-center p-6 border-b border-gray-200">
      <h2 class="text-2xl font-bold text-gray-900">
        {{ isEditing ? 'Editar Registro' : 'Novo Registro' }}
      </h2>
      <button 
        (click)="hide()" 
        class="text-gray-400 hover:text-gray-600 text-2xl font-bold"
        [disabled]="isLoading">
        &times;
      </button>
    </div>

    <!-- Form -->
    <form [formGroup]="leadForm" (ngSubmit)="saveLead()" class="p-6">
      <div class="space-y-4">
        <!-- Dynamic Fields -->
        <div *ngFor="let field of formFields" class="form-group">
          <label [for]="field.name" class="block text-sm font-medium text-gray-700 mb-1">
            {{ field.label }}
            <span *ngIf="field.required" class="text-red-500">*</span>
          </label>

          <!-- Text Input -->
          <input 
            *ngIf="field.type === 'text' || field.type === 'email' || field.type === 'date' || field.type === 'time' || field.type === 'number'"
            [type]="field.type"
            [id]="field.name"
            [formControlName]="field.name"
            [placeholder]="field.placeholder || ''"
            class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors"
            [class.border-red-500]="leadForm.get(field.name)?.invalid && leadForm.get(field.name)?.touched"
            [disabled]="isLoading">

          <!-- Phone Input with Brazilian Mask -->
          <input 
            *ngIf="field.type === 'tel'"
            type="tel"
            [id]="field.name"
            [formControlName]="field.name"
            [placeholder]="field.placeholder || '(11) 99999-9999'"
            class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors"
            [class.border-red-500]="leadForm.get(field.name)?.invalid && leadForm.get(field.name)?.touched"
            [disabled]="isLoading"
            (input)="maskHelper.maskPhone($event)"
            (keyup)="maskHelper.maskPhone($event)">

          <!-- CNPJ Input -->
          <input 
            *ngIf="field.type === 'cnpj'"
            type="text"
            [id]="field.name"
            [formControlName]="field.name"
            placeholder="00.000.000/0000-00"
            class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors"
            [class.border-red-500]="leadForm.get(field.name)?.invalid && leadForm.get(field.name)?.touched"
            [disabled]="isLoading"
            (input)="maskHelper.maskCNPJ($event)"
            (keyup)="maskHelper.maskCNPJ($event)">

          <!-- CPF Input -->
          <input 
            *ngIf="field.type === 'cpf'"
            type="text"
            [id]="field.name"
            [formControlName]="field.name"
            placeholder="000.000.000-00"
            class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors"
            [class.border-red-500]="leadForm.get(field.name)?.invalid && leadForm.get(field.name)?.touched"
            [disabled]="isLoading"
            (input)="maskHelper.maskCPF($event)"
            (keyup)="maskHelper.maskCPF($event)">

          <!-- Select -->
          <select 
            *ngIf="field.type === 'select'"
            [id]="field.name"
            [formControlName]="field.name"
            class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors"
            [class.border-red-500]="leadForm.get(field.name)?.invalid && leadForm.get(field.name)?.touched"
            [disabled]="isLoading">
            <option value="">Selecione...</option>
            <option *ngFor="let option of field.options" [value]="option">
              {{ option }}
            </option>
          </select>

          <!-- Temperatura Select -->
          <select 
            *ngIf="field.type === 'temperatura'"
            [id]="field.name"
            [formControlName]="field.name"
            class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors"
            [class.border-red-500]="leadForm.get(field.name)?.invalid && leadForm.get(field.name)?.touched"
            [disabled]="isLoading">
            <option value="">Selecione a temperatura</option>
            <option *ngFor="let option of (field.options || ['Quente', 'Morno', 'Frio'])" [value]="option">
              {{ option }}
            </option>
          </select>

          <!-- Radio Buttons -->
          <div *ngIf="field.type === 'radio'" class="space-y-2">
            <div *ngFor="let option of field.options; let i = index" class="flex items-center">
              <input
                type="radio"
                [id]="field.name + '_radio_' + i"
                [formControlName]="field.name"
                [value]="option"
                [disabled]="isLoading"
                class="mr-2 text-blue-600 focus:ring-blue-500 border-gray-300">
              <label [for]="field.name + '_radio_' + i" class="text-gray-700 cursor-pointer">
                {{ option }}
              </label>
            </div>
          </div>

          <!-- Checkbox -->
          <label *ngIf="field.type === 'checkbox'" class="flex items-center cursor-pointer">
            <input
              type="checkbox"
              [id]="field.name"
              [formControlName]="field.name"
              [disabled]="isLoading"
              class="mr-2 text-blue-600 focus:ring-blue-500 border-gray-300 rounded">
            <span class="text-gray-700">{{ field.placeholder || field.label }}</span>
          </label>

          <!-- Textarea -->
          <textarea 
            *ngIf="field.type === 'textarea'"
            [id]="field.name"
            [formControlName]="field.name"
            rows="3"
            class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors resize-none"
            [class.border-red-500]="leadForm.get(field.name)?.invalid && leadForm.get(field.name)?.touched"
            [disabled]="isLoading"></textarea>

          <!-- File Upload -->
          <div *ngIf="field.type === 'file'">
            <input 
              type="file"
              [id]="field.name"
              [multiple]="field.placeholder === 'multiple'"
              (change)="onFileSelected($event, field.name)"
              class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors"
              [class.border-red-500]="leadForm.get(field.name)?.invalid && leadForm.get(field.name)?.touched"
              [disabled]="isLoading">
            <p class="text-xs text-gray-500 mt-1">
              {{ field.placeholder || 'Voc\xEA pode anexar arquivos como documentos, imagens, etc.' }}
            </p>
          </div>

          <!-- Error Message -->
          <div *ngIf="getFieldError(field.name)" class="text-red-500 text-sm mt-1">
            {{ getFieldError(field.name) }}
          </div>
        </div>


        <!-- Error Message -->
        <div *ngIf="errorMessage" class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg">
          {{ errorMessage }}
        </div>

      </div>

      <!-- Actions -->
      <div class="flex justify-end gap-3 mt-6 pt-4 border-t border-gray-200">
        <button 
          type="button" 
          (click)="hide()"
          class="px-4 py-2 text-gray-700 bg-gray-200 hover:bg-gray-300 rounded-lg font-medium transition-colors"
          [disabled]="isLoading">
          Cancelar
        </button>
        
        <button 
          type="submit" 
          [disabled]="isLoading || !leadForm.valid"
          class="px-6 py-2 bg-blue-500 hover:bg-blue-600 disabled:bg-blue-300 text-white rounded-lg font-medium transition-colors flex items-center">
          <div *ngIf="isLoading" class="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2"></div>
          {{ isLoading ? 'Salvando...' : (isEditing ? 'Atualizar Registro' : 'Salvar Registro') }}
        </button>
      </div>
    </form>
  </div>
</div>`, styles: [`/* src/app/components/lead-modal/lead-modal.component.scss */
.fixed {
  animation: fadeIn 0.2s ease-out;
}
.bg-white {
  animation: slideUp 0.3s ease-out;
}
@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(20px) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}
.form-group {
  position: relative;
}
input:focus,
select:focus,
textarea:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}
.border-red-500 {
  border-color: #ef4444 !important;
}
select {
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
  background-position: right 0.5rem center;
  background-repeat: no-repeat;
  background-size: 1.5em 1.5em;
  padding-right: 2.5rem;
}
.overflow-y-auto::-webkit-scrollbar {
  width: 6px;
}
.overflow-y-auto::-webkit-scrollbar-track {
  background: #f1f5f9;
}
.overflow-y-auto::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 3px;
}
.overflow-y-auto::-webkit-scrollbar-thumb:hover {
  background: #94a3b8;
}
/*# sourceMappingURL=lead-modal.component.css.map */
`] }]
  }], null, { ownerId: [{
    type: Input
  }], boardId: [{
    type: Input
  }], columns: [{
    type: Input
  }], leadCreated: [{
    type: Output
  }], leadUpdated: [{
    type: Output
  }], closeModal: [{
    type: Output
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(LeadModalComponent, { className: "LeadModalComponent", filePath: "src/app/components/lead-modal/lead-modal.component.ts", lineNumber: 29 });
})();

// src/app/components/column-modal/column-modal.component.ts
function ColumnModalComponent_div_0_div_15_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 42);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.getFieldError("name"), " ");
  }
}
__name(ColumnModalComponent_div_0_div_15_Template, "ColumnModalComponent_div_0_div_15_Template");
function ColumnModalComponent_div_0_div_20_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 45);
    \u0275\u0275element(1, "i", 46);
    \u0275\u0275elementEnd();
  }
}
__name(ColumnModalComponent_div_0_div_20_div_1_Template, "ColumnModalComponent_div_0_div_20_div_1_Template");
function ColumnModalComponent_div_0_div_20_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 43);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function ColumnModalComponent_div_0_div_20_Template_div_click_0_listener() {
      const color_r4 = \u0275\u0275restoreView(_r3).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(!ctx_r1.isLoading && ctx_r1.columnForm.patchValue({ color: color_r4 }));
    }, "ColumnModalComponent_div_0_div_20_Template_div_click_0_listener"));
    \u0275\u0275template(1, ColumnModalComponent_div_0_div_20_div_1_Template, 2, 0, "div", 44);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    let tmp_5_0;
    let tmp_6_0;
    let tmp_7_0;
    let tmp_8_0;
    let tmp_12_0;
    const color_r4 = ctx.$implicit;
    const i_r5 = ctx.index;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275styleMap("background-color: " + color_r4 + " !important;");
    \u0275\u0275classProp("border-gray-800", ((tmp_5_0 = ctx_r1.columnForm.get("color")) == null ? null : tmp_5_0.value) === color_r4)("border-gray-300", ((tmp_6_0 = ctx_r1.columnForm.get("color")) == null ? null : tmp_6_0.value) !== color_r4)("ring-2", ((tmp_7_0 = ctx_r1.columnForm.get("color")) == null ? null : tmp_7_0.value) === color_r4)("ring-blue-500", ((tmp_8_0 = ctx_r1.columnForm.get("color")) == null ? null : tmp_8_0.value) === color_r4);
    \u0275\u0275property("title", color_r4);
    \u0275\u0275attribute("data-color", color_r4)("data-index", i_r5);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ((tmp_12_0 = ctx_r1.columnForm.get("color")) == null ? null : tmp_12_0.value) === color_r4);
  }
}
__name(ColumnModalComponent_div_0_div_20_Template, "ColumnModalComponent_div_0_div_20_Template");
function ColumnModalComponent_div_0_option_31_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "option", 47);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const type_r6 = ctx.$implicit;
    \u0275\u0275property("value", type_r6.value);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", type_r6.label, " ");
  }
}
__name(ColumnModalComponent_div_0_option_31_Template, "ColumnModalComponent_div_0_option_31_Template");
function ColumnModalComponent_div_0_div_38_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 42);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.getFieldError("slaDays"), " ");
  }
}
__name(ColumnModalComponent_div_0_div_38_Template, "ColumnModalComponent_div_0_div_38_Template");
function ColumnModalComponent_div_0_div_48_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 48);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.errorMessage, " ");
  }
}
__name(ColumnModalComponent_div_0_div_48_Template, "ColumnModalComponent_div_0_div_48_Template");
function ColumnModalComponent_div_0_button_71_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 49);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function ColumnModalComponent_div_0_button_71_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.deleteColumn());
    }, "ColumnModalComponent_div_0_button_71_Template_button_click_0_listener"));
    \u0275\u0275element(1, "i", 50);
    \u0275\u0275text(2, " Excluir Fase ");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("disabled", ctx_r1.isLoading);
  }
}
__name(ColumnModalComponent_div_0_button_71_Template, "ColumnModalComponent_div_0_button_71_Template");
function ColumnModalComponent_div_0_div_72_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div");
  }
}
__name(ColumnModalComponent_div_0_div_72_Template, "ColumnModalComponent_div_0_div_72_Template");
function ColumnModalComponent_div_0_div_77_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 51);
  }
}
__name(ColumnModalComponent_div_0_div_77_Template, "ColumnModalComponent_div_0_div_77_Template");
function ColumnModalComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 1);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function ColumnModalComponent_div_0_Template_div_click_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onBackdropClick($event));
    }, "ColumnModalComponent_div_0_Template_div_click_0_listener"));
    \u0275\u0275elementStart(1, "div", 2)(2, "div", 3)(3, "h2", 4);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "button", 5);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function ColumnModalComponent_div_0_Template_button_click_5_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.hide());
    }, "ColumnModalComponent_div_0_Template_button_click_5_listener"));
    \u0275\u0275text(6, " \xD7 ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(7, "form", 6);
    \u0275\u0275listener("ngSubmit", /* @__PURE__ */ __name(function ColumnModalComponent_div_0_Template_form_ngSubmit_7_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.saveColumn());
    }, "ColumnModalComponent_div_0_Template_form_ngSubmit_7_listener"));
    \u0275\u0275elementStart(8, "div", 7)(9, "div", 8)(10, "label", 9);
    \u0275\u0275text(11, " Nome da Fase ");
    \u0275\u0275elementStart(12, "span", 10);
    \u0275\u0275text(13, "*");
    \u0275\u0275elementEnd()();
    \u0275\u0275element(14, "input", 11);
    \u0275\u0275template(15, ColumnModalComponent_div_0_div_15_Template, 2, 1, "div", 12);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(16, "div", 8)(17, "label", 13);
    \u0275\u0275text(18, " Cor da Fase ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(19, "div", 14);
    \u0275\u0275template(20, ColumnModalComponent_div_0_div_20_Template, 2, 14, "div", 15);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(21, "div", 16)(22, "label", 17);
    \u0275\u0275text(23, "Cor personalizada:");
    \u0275\u0275elementEnd();
    \u0275\u0275element(24, "input", 18);
    \u0275\u0275elementStart(25, "span", 19);
    \u0275\u0275text(26);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(27, "div", 8)(28, "label", 20);
    \u0275\u0275text(29, " Tipo de Finaliza\xE7\xE3o ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(30, "select", 21);
    \u0275\u0275template(31, ColumnModalComponent_div_0_option_31_Template, 2, 2, "option", 22);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(32, "p", 23);
    \u0275\u0275text(33, " Fases de finaliza\xE7\xE3o n\xE3o permitem que leads sejam movidos para outras fases. ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(34, "div", 8)(35, "label", 24);
    \u0275\u0275text(36, " SLA (dias) ");
    \u0275\u0275elementEnd();
    \u0275\u0275element(37, "input", 25);
    \u0275\u0275template(38, ColumnModalComponent_div_0_div_38_Template, 2, 1, "div", 12);
    \u0275\u0275elementStart(39, "p", 23);
    \u0275\u0275text(40, " Defina um prazo em dias para esta fase. Use 0 para desabilitar o SLA. ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(41, "div", 8)(42, "label", 26);
    \u0275\u0275element(43, "input", 27);
    \u0275\u0275elementStart(44, "span", 28);
    \u0275\u0275text(45, " Esta \xE9 a fase inicial ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(46, "p", 23);
    \u0275\u0275text(47, " A fase inicial ser\xE1 usada automaticamente ao criar novos registros. ");
    \u0275\u0275elementEnd()();
    \u0275\u0275template(48, ColumnModalComponent_div_0_div_48_Template, 2, 1, "div", 29);
    \u0275\u0275elementStart(49, "div", 30)(50, "div", 31);
    \u0275\u0275element(51, "i", 32);
    \u0275\u0275elementStart(52, "div", 33)(53, "strong");
    \u0275\u0275text(54, "Dica:");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(55, "ul", 34)(56, "li");
    \u0275\u0275text(57, "Organize suas fases na ordem do seu funil de vendas");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(58, "li");
    \u0275\u0275text(59, "Use cores diferentes para facilitar a identifica\xE7\xE3o");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(60, "li");
    \u0275\u0275text(61, "Fases de ");
    \u0275\u0275elementStart(62, "strong");
    \u0275\u0275text(63, "Sucesso");
    \u0275\u0275elementEnd();
    \u0275\u0275text(64, " indicam leads convertidos");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(65, "li");
    \u0275\u0275text(66, "Fases de ");
    \u0275\u0275elementStart(67, "strong");
    \u0275\u0275text(68, "Fracasso");
    \u0275\u0275elementEnd();
    \u0275\u0275text(69, " indicam leads perdidos");
    \u0275\u0275elementEnd()()()()()();
    \u0275\u0275elementStart(70, "div", 35);
    \u0275\u0275template(71, ColumnModalComponent_div_0_button_71_Template, 3, 1, "button", 36)(72, ColumnModalComponent_div_0_div_72_Template, 1, 0, "div", 37);
    \u0275\u0275elementStart(73, "div", 38)(74, "button", 39);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function ColumnModalComponent_div_0_Template_button_click_74_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.hide());
    }, "ColumnModalComponent_div_0_Template_button_click_74_listener"));
    \u0275\u0275text(75, " Cancelar ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(76, "button", 40);
    \u0275\u0275template(77, ColumnModalComponent_div_0_div_77_Template, 1, 0, "div", 41);
    \u0275\u0275text(78);
    \u0275\u0275elementEnd()()()()()();
  }
  if (rf & 2) {
    let tmp_4_0;
    let tmp_9_0;
    let tmp_12_0;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", ctx_r1.isEditing ? "Editar Fase" : "Nova Fase", " ");
    \u0275\u0275advance();
    \u0275\u0275property("disabled", ctx_r1.isLoading);
    \u0275\u0275advance(2);
    \u0275\u0275property("formGroup", ctx_r1.columnForm);
    \u0275\u0275advance(7);
    \u0275\u0275classProp("border-red-500", ((tmp_4_0 = ctx_r1.columnForm.get("name")) == null ? null : tmp_4_0.invalid) && ((tmp_4_0 = ctx_r1.columnForm.get("name")) == null ? null : tmp_4_0.touched));
    \u0275\u0275property("disabled", ctx_r1.isLoading);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.getFieldError("name"));
    \u0275\u0275advance(5);
    \u0275\u0275property("ngForOf", ctx_r1.predefinedColors);
    \u0275\u0275advance(4);
    \u0275\u0275property("disabled", ctx_r1.isLoading);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate((tmp_9_0 = ctx_r1.columnForm.get("color")) == null ? null : tmp_9_0.value);
    \u0275\u0275advance(4);
    \u0275\u0275property("disabled", ctx_r1.isLoading);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.endStageTypes);
    \u0275\u0275advance(6);
    \u0275\u0275classProp("border-red-500", ((tmp_12_0 = ctx_r1.columnForm.get("slaDays")) == null ? null : tmp_12_0.invalid) && ((tmp_12_0 = ctx_r1.columnForm.get("slaDays")) == null ? null : tmp_12_0.touched));
    \u0275\u0275property("disabled", ctx_r1.isLoading);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.getFieldError("slaDays"));
    \u0275\u0275advance(5);
    \u0275\u0275property("disabled", ctx_r1.isLoading);
    \u0275\u0275advance(5);
    \u0275\u0275property("ngIf", ctx_r1.errorMessage);
    \u0275\u0275advance(23);
    \u0275\u0275property("ngIf", ctx_r1.isEditing);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.isEditing);
    \u0275\u0275advance(2);
    \u0275\u0275property("disabled", ctx_r1.isLoading);
    \u0275\u0275advance(2);
    \u0275\u0275property("disabled", ctx_r1.isLoading || !ctx_r1.columnForm.valid);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.isLoading);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.isLoading ? "Salvando..." : ctx_r1.isEditing ? "Atualizar Fase" : "Criar Fase", " ");
  }
}
__name(ColumnModalComponent_div_0_Template, "ColumnModalComponent_div_0_Template");
var _ColumnModalComponent = class _ColumnModalComponent {
  authService = inject(AuthService);
  firestoreService = inject(FirestoreService);
  fb = inject(FormBuilder);
  ownerId = "";
  boardId = "";
  columns = [];
  columnCreated = new EventEmitter();
  columnUpdated = new EventEmitter();
  columnDeleted = new EventEmitter();
  closeModal = new EventEmitter();
  isVisible = false;
  isEditing = false;
  isLoading = false;
  errorMessage = "";
  currentColumn = null;
  predefinedColors = [
    "#3B82F6",
    // Blue
    "#EF4444",
    // Red
    "#10B981",
    // Green
    "#F59E0B",
    // Amber
    "#8B5CF6",
    // Violet
    "#EC4899",
    // Pink
    "#6B7280",
    // Gray
    "#F97316",
    // Orange
    "#06B6D4",
    // Cyan
    "#84CC16",
    // Lime
    "#14B8A6",
    // Teal
    "#F43F5E",
    // Rose
    "#A855F7",
    // Purple
    "#EAB308",
    // Yellow
    "#059669",
    // Emerald
    "#DC2626"
    // Red-600
  ];
  columnForm = this.fb.group({
    name: ["", [Validators.required]],
    color: [this.predefinedColors[0]],
    // Usar primeira cor da paleta como padrão
    endStageType: ["none"],
    slaDays: [0, [Validators.min(0)]],
    isInitialPhase: [false]
  });
  endStageTypes = [
    { value: "none", label: "Nenhuma (fase normal)" },
    { value: "success", label: "Sucesso (lead convertido)" },
    { value: "fail", label: "Fracasso (lead perdido)" }
  ];
  showCreateModal() {
    this.isEditing = false;
    this.currentColumn = null;
    this.isVisible = true;
    this.resetForm();
  }
  showEditModal(column) {
    this.isEditing = true;
    this.currentColumn = column;
    this.isVisible = true;
    this.populateForm(column);
  }
  hide() {
    this.isVisible = false;
    this.resetForm();
    this.closeModal.emit();
  }
  resetForm() {
    const defaultColor = this.getNextAvailableColor();
    this.columnForm.reset({
      name: "",
      color: defaultColor,
      endStageType: "none",
      slaDays: 0,
      isInitialPhase: false
    });
    this.errorMessage = "";
    this.isLoading = false;
  }
  getNextAvailableColor() {
    const usedColors = this.columns.map((col) => col.color).filter((color) => color);
    for (const color of this.predefinedColors) {
      if (!usedColors.includes(color)) {
        return color;
      }
    }
    const colorIndex = this.columns.length % this.predefinedColors.length;
    return this.predefinedColors[colorIndex];
  }
  populateForm(column) {
    this.columnForm.patchValue({
      name: column.name,
      color: column.color || "#3B82F6",
      endStageType: column.endStageType || "none",
      slaDays: column.slaDays || 0,
      isInitialPhase: column.isInitialPhase || false
    });
  }
  saveColumn() {
    return __async(this, null, function* () {
      if (!this.columnForm.valid) {
        this.errorMessage = "Por favor, preencha todos os campos obrigat\xF3rios.";
        return;
      }
      this.isLoading = true;
      this.errorMessage = "";
      try {
        const formData = this.columnForm.value;
        const currentUser = this.authService.getCurrentUser();
        if (!currentUser) {
          throw new Error("Usu\xE1rio n\xE3o autenticado");
        }
        if (this.isEditing && this.currentColumn) {
          yield this.firestoreService.updateColumn(this.ownerId, this.boardId, this.currentColumn.id, {
            name: formData.name,
            color: formData.color,
            endStageType: formData.endStageType,
            slaDays: formData.slaDays,
            isInitialPhase: formData.isInitialPhase,
            updatedAt: /* @__PURE__ */ new Date()
          });
          if (formData.isInitialPhase) {
            yield this.firestoreService.unsetOtherInitialPhases(this.boardId, this.currentColumn.id);
          }
          this.columnUpdated.emit();
        } else {
          const nextOrder = Math.max(...this.columns.map((col) => col.order || 0), -1) + 1;
          const newColumn = {
            name: formData.name,
            color: formData.color,
            order: nextOrder,
            endStageType: formData.endStageType,
            slaDays: formData.slaDays,
            isInitialPhase: formData.isInitialPhase,
            boardId: this.boardId,
            companyId: "",
            // Será preenchido pelo FirestoreService
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          };
          const created = yield this.firestoreService.createColumn(this.ownerId, this.boardId, newColumn);
          if (formData.isInitialPhase && created?.id) {
            yield this.firestoreService.unsetOtherInitialPhases(this.boardId, created.id);
          }
          this.columnCreated.emit();
        }
        this.hide();
      } catch (error) {
        console.error("Erro ao salvar coluna:", error);
        this.errorMessage = "Erro ao salvar fase. Tente novamente.";
      } finally {
        this.isLoading = false;
      }
    });
  }
  onBackdropClick(event) {
    if (event.target === event.currentTarget) {
      this.hide();
    }
  }
  getFieldError(fieldName) {
    const control = this.columnForm.get(fieldName);
    if (control?.errors && control.touched) {
      if (control.errors["required"]) {
        return `${this.getFieldLabel(fieldName)} \xE9 obrigat\xF3rio`;
      }
    }
    return "";
  }
  getFieldLabel(fieldName) {
    const labels = {
      "name": "Nome da Fase",
      "color": "Cor",
      "endStageType": "Tipo de Finaliza\xE7\xE3o",
      "slaDays": "SLA (dias)"
    };
    return labels[fieldName] || fieldName;
  }
  deleteColumn() {
    return __async(this, null, function* () {
      if (!this.currentColumn || !this.currentColumn.id) {
        return;
      }
      const confirmed = confirm(`Deseja excluir a fase "${this.currentColumn.name}"? Esta a\xE7\xE3o n\xE3o pode ser desfeita.`);
      if (!confirmed) {
        return;
      }
      this.isLoading = true;
      this.errorMessage = "";
      try {
        yield this.firestoreService.deleteColumn(this.ownerId, this.boardId, this.currentColumn.id);
        this.columnDeleted.emit();
        this.hide();
      } catch (error) {
        console.error("Erro ao excluir coluna:", error);
        this.errorMessage = "Erro ao excluir fase. Tente novamente.";
      } finally {
        this.isLoading = false;
      }
    });
  }
};
__name(_ColumnModalComponent, "ColumnModalComponent");
__publicField(_ColumnModalComponent, "\u0275fac", /* @__PURE__ */ __name(function ColumnModalComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ColumnModalComponent)();
}, "ColumnModalComponent_Factory"));
__publicField(_ColumnModalComponent, "\u0275cmp", /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ColumnModalComponent, selectors: [["app-column-modal"]], inputs: { ownerId: "ownerId", boardId: "boardId", columns: "columns" }, outputs: { columnCreated: "columnCreated", columnUpdated: "columnUpdated", columnDeleted: "columnDeleted", closeModal: "closeModal" }, decls: 1, vars: 1, consts: [["class", "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", 3, "click", 4, "ngIf"], [1, "fixed", "inset-0", "bg-black", "bg-opacity-50", "flex", "items-center", "justify-center", "z-50", "p-4", 3, "click"], [1, "bg-white", "rounded-xl", "shadow-2xl", "w-full", "max-w-lg", "max-h-[90vh]", "overflow-y-auto"], [1, "flex", "justify-between", "items-center", "p-6", "border-b", "border-gray-200"], [1, "text-2xl", "font-bold", "text-gray-900"], [1, "text-gray-400", "hover:text-gray-600", "text-2xl", "font-bold", 3, "click", "disabled"], [1, "p-6", 3, "ngSubmit", "formGroup"], [1, "space-y-4"], [1, "form-group"], ["for", "name", 1, "block", "text-sm", "font-medium", "text-gray-700", "mb-1"], [1, "text-red-500"], ["type", "text", "id", "name", "formControlName", "name", "placeholder", "Digite o nome da fase", 1, "w-full", "p-3", "border", "border-gray-300", "rounded-lg", "focus:ring-2", "focus:ring-blue-500", "focus:border-blue-500", "transition-colors", 3, "disabled"], ["class", "text-red-500 text-sm mt-1", 4, "ngIf"], [1, "block", "text-sm", "font-medium", "text-gray-700", "mb-2"], [1, "grid", "grid-cols-8", "gap-2", "mb-3", "p-3", "bg-gray-50", "rounded-lg"], ["class", "color-swatch w-10 h-10 rounded-lg border-2 transition-all duration-200 hover:scale-105 hover:shadow-md relative cursor-pointer", 3, "style", "border-gray-800", "border-gray-300", "ring-2", "ring-blue-500", "title", "click", 4, "ngFor", "ngForOf"], [1, "flex", "items-center", "gap-2"], [1, "text-sm", "text-gray-600"], ["type", "color", "formControlName", "color", "title", "Escolher cor personalizada", 1, "w-12", "h-8", "border", "border-gray-300", "rounded", "cursor-pointer", 3, "disabled"], [1, "text-xs", "text-gray-500", "ml-1"], ["for", "endStageType", 1, "block", "text-sm", "font-medium", "text-gray-700", "mb-1"], ["id", "endStageType", "formControlName", "endStageType", 1, "w-full", "p-3", "border", "border-gray-300", "rounded-lg", "focus:ring-2", "focus:ring-blue-500", "focus:border-blue-500", "transition-colors", 3, "disabled"], [3, "value", 4, "ngFor", "ngForOf"], [1, "text-xs", "text-gray-500", "mt-1"], ["for", "slaDays", 1, "block", "text-sm", "font-medium", "text-gray-700", "mb-1"], ["type", "number", "id", "slaDays", "formControlName", "slaDays", "min", "0", "placeholder", "Ex: 3", 1, "w-full", "p-3", "border", "border-gray-300", "rounded-lg", "focus:ring-2", "focus:ring-blue-500", "focus:border-blue-500", "transition-colors", 3, "disabled"], [1, "flex", "items-center", "space-x-2"], ["type", "checkbox", "formControlName", "isInitialPhase", 1, "h-4", "w-4", "text-blue-600", "focus:ring-blue-500", "border-gray-300", "rounded", 3, "disabled"], [1, "text-sm", "font-medium", "text-gray-700"], ["class", "bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg", 4, "ngIf"], [1, "bg-blue-50", "border", "border-blue-200", "rounded-lg", "p-3"], [1, "flex", "items-start"], [1, "fas", "fa-info-circle", "text-blue-500", "mt-0.5", "mr-2"], [1, "text-sm", "text-blue-700"], [1, "mt-1", "ml-2", "list-disc"], [1, "flex", "justify-between", "mt-6", "pt-4", "border-t", "border-gray-200"], ["type", "button", "class", "px-4 py-2 text-red-700 bg-red-100 hover:bg-red-200 rounded-lg font-medium transition-colors flex items-center", 3, "disabled", "click", 4, "ngIf"], [4, "ngIf"], [1, "flex", "gap-3"], ["type", "button", 1, "px-4", "py-2", "text-gray-700", "bg-gray-200", "hover:bg-gray-300", "rounded-lg", "font-medium", "transition-colors", 3, "click", "disabled"], ["type", "submit", 1, "px-6", "py-2", "bg-blue-500", "hover:bg-blue-600", "disabled:bg-blue-300", "text-white", "rounded-lg", "font-medium", "transition-colors", "flex", "items-center", 3, "disabled"], ["class", "animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2", 4, "ngIf"], [1, "text-red-500", "text-sm", "mt-1"], [1, "color-swatch", "w-10", "h-10", "rounded-lg", "border-2", "transition-all", "duration-200", "hover:scale-105", "hover:shadow-md", "relative", "cursor-pointer", 3, "click", "title"], ["class", "absolute inset-0 flex items-center justify-center", 4, "ngIf"], [1, "absolute", "inset-0", "flex", "items-center", "justify-center"], [1, "fas", "fa-check", "text-white", "text-sm", "drop-shadow-md"], [3, "value"], [1, "bg-red-50", "border", "border-red-200", "text-red-700", "px-4", "py-3", "rounded-lg"], ["type", "button", 1, "px-4", "py-2", "text-red-700", "bg-red-100", "hover:bg-red-200", "rounded-lg", "font-medium", "transition-colors", "flex", "items-center", 3, "click", "disabled"], [1, "fas", "fa-trash", "mr-2"], [1, "animate-spin", "rounded-full", "h-4", "w-4", "border-b-2", "border-white", "mr-2"]], template: /* @__PURE__ */ __name(function ColumnModalComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, ColumnModalComponent_div_0_Template, 79, 24, "div", 0);
  }
  if (rf & 2) {
    \u0275\u0275property("ngIf", ctx.isVisible);
  }
}, "ColumnModalComponent_Template"), dependencies: [CommonModule, NgForOf, NgIf, FormsModule, \u0275NgNoValidate, NgSelectOption, \u0275NgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, NgControlStatus, NgControlStatusGroup, MinValidator, ReactiveFormsModule, FormGroupDirective, FormControlName], styles: [`

.fixed[_ngcontent-%COMP%] {
  animation: _ngcontent-%COMP%_fadeIn 0.2s ease-out;
}
.bg-white[_ngcontent-%COMP%] {
  animation: _ngcontent-%COMP%_slideUp 0.3s ease-out;
}
@keyframes _ngcontent-%COMP%_fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
@keyframes _ngcontent-%COMP%_slideUp {
  from {
    opacity: 0;
    transform: translateY(20px) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}
.form-group[_ngcontent-%COMP%] {
  position: relative;
}
input[_ngcontent-%COMP%]:focus, 
select[_ngcontent-%COMP%]:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}
.border-red-500[_ngcontent-%COMP%] {
  border-color: #ef4444 !important;
}
select[_ngcontent-%COMP%] {
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
  background-position: right 0.5rem center;
  background-repeat: no-repeat;
  background-size: 1.5em 1.5em;
  padding-right: 2.5rem;
}
.overflow-y-auto[_ngcontent-%COMP%]::-webkit-scrollbar {
  width: 6px;
}
.overflow-y-auto[_ngcontent-%COMP%]::-webkit-scrollbar-track {
  background: #f1f5f9;
}
.overflow-y-auto[_ngcontent-%COMP%]::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 3px;
}
.overflow-y-auto[_ngcontent-%COMP%]::-webkit-scrollbar-thumb:hover {
  background: #94a3b8;
}
.color-swatch[_ngcontent-%COMP%] {
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  background-clip: padding-box !important;
}
.color-swatch[_ngcontent-%COMP%]:hover {
  transform: scale(1.05);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}
.color-swatch[_ngcontent-%COMP%]:active {
  transform: scale(0.98);
}
.color-swatch[_ngcontent-%COMP%]   .fa-check[_ngcontent-%COMP%] {
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
}
.grid[_ngcontent-%COMP%]   .color-swatch[_ngcontent-%COMP%] {
  background: none !important;
}
input[type=color][_ngcontent-%COMP%] {
  appearance: none;
  border: none;
  cursor: pointer;
}
input[type=color][_ngcontent-%COMP%]::-webkit-color-swatch-wrapper {
  padding: 0;
  border: 1px solid #d1d5db;
  border-radius: 4px;
}
input[type=color][_ngcontent-%COMP%]::-webkit-color-swatch {
  border: none;
  border-radius: 3px;
}
input[type=color][_ngcontent-%COMP%]::-moz-color-swatch {
  border: none;
  border-radius: 3px;
}
/*# sourceMappingURL=column-modal.component.css.map */`] }));
var ColumnModalComponent = _ColumnModalComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnModalComponent, [{
    type: Component,
    args: [{ selector: "app-column-modal", standalone: true, imports: [CommonModule, FormsModule, ReactiveFormsModule], template: `<div *ngIf="isVisible" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" (click)="onBackdropClick($event)">
  <div class="bg-white rounded-xl shadow-2xl w-full max-w-lg max-h-[90vh] overflow-y-auto">
    <!-- Header -->
    <div class="flex justify-between items-center p-6 border-b border-gray-200">
      <h2 class="text-2xl font-bold text-gray-900">
        {{ isEditing ? 'Editar Fase' : 'Nova Fase' }}
      </h2>
      <button 
        (click)="hide()" 
        class="text-gray-400 hover:text-gray-600 text-2xl font-bold"
        [disabled]="isLoading">
        &times;
      </button>
    </div>

    <!-- Form -->
    <form [formGroup]="columnForm" (ngSubmit)="saveColumn()" class="p-6">
      <div class="space-y-4">
        <!-- Nome da Fase -->
        <div class="form-group">
          <label for="name" class="block text-sm font-medium text-gray-700 mb-1">
            Nome da Fase
            <span class="text-red-500">*</span>
          </label>
          <input 
            type="text"
            id="name"
            formControlName="name"
            class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors"
            [class.border-red-500]="columnForm.get('name')?.invalid && columnForm.get('name')?.touched"
            [disabled]="isLoading"
            placeholder="Digite o nome da fase">
          
          <div *ngIf="getFieldError('name')" class="text-red-500 text-sm mt-1">
            {{ getFieldError('name') }}
          </div>
        </div>

        <!-- Cor da Fase -->
        <div class="form-group">
          <label class="block text-sm font-medium text-gray-700 mb-2">
            Cor da Fase
          </label>
          
          <!-- Paleta de Cores Predefinidas -->
          <div class="grid grid-cols-8 gap-2 mb-3 p-3 bg-gray-50 rounded-lg">
            <div
              *ngFor="let color of predefinedColors; let i = index"
              class="color-swatch w-10 h-10 rounded-lg border-2 transition-all duration-200 hover:scale-105 hover:shadow-md relative cursor-pointer"
              [style]="'background-color: ' + color + ' !important;'"
              [class.border-gray-800]="columnForm.get('color')?.value === color"
              [class.border-gray-300]="columnForm.get('color')?.value !== color"
              [class.ring-2]="columnForm.get('color')?.value === color"
              [class.ring-blue-500]="columnForm.get('color')?.value === color"
              (click)="!isLoading && columnForm.patchValue({color: color})"
              [title]="color"
              [attr.data-color]="color"
              [attr.data-index]="i">
              
              <!-- Checkmark para cor selecionada -->
              <div *ngIf="columnForm.get('color')?.value === color" 
                   class="absolute inset-0 flex items-center justify-center">
                <i class="fas fa-check text-white text-sm drop-shadow-md"></i>
              </div>
              
            </div>
          </div>
          
          <!-- Seletor de Cor Customizada -->
          <div class="flex items-center gap-2">
            <label class="text-sm text-gray-600">Cor personalizada:</label>
            <input 
              type="color"
              formControlName="color"
              class="w-12 h-8 border border-gray-300 rounded cursor-pointer"
              [disabled]="isLoading"
              title="Escolher cor personalizada">
            <span class="text-xs text-gray-500 ml-1">{{ columnForm.get('color')?.value }}</span>
          </div>
        </div>

        <!-- Tipo de Finaliza\xE7\xE3o -->
        <div class="form-group">
          <label for="endStageType" class="block text-sm font-medium text-gray-700 mb-1">
            Tipo de Finaliza\xE7\xE3o
          </label>
          <select 
            id="endStageType"
            formControlName="endStageType"
            class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors"
            [disabled]="isLoading">
            <option *ngFor="let type of endStageTypes" [value]="type.value">
              {{ type.label }}
            </option>
          </select>
          <p class="text-xs text-gray-500 mt-1">
            Fases de finaliza\xE7\xE3o n\xE3o permitem que leads sejam movidos para outras fases.
          </p>
        </div>

        <!-- SLA em Dias -->
        <div class="form-group">
          <label for="slaDays" class="block text-sm font-medium text-gray-700 mb-1">
            SLA (dias)
          </label>
          <input 
            type="number"
            id="slaDays"
            formControlName="slaDays"
            min="0"
            class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors"
            [class.border-red-500]="columnForm.get('slaDays')?.invalid && columnForm.get('slaDays')?.touched"
            [disabled]="isLoading"
            placeholder="Ex: 3">
          
          <div *ngIf="getFieldError('slaDays')" class="text-red-500 text-sm mt-1">
            {{ getFieldError('slaDays') }}
          </div>
          <p class="text-xs text-gray-500 mt-1">
            Defina um prazo em dias para esta fase. Use 0 para desabilitar o SLA.
          </p>
        </div>

        <!-- Fase Inicial -->
        <div class="form-group">
          <label class="flex items-center space-x-2">
            <input 
              type="checkbox"
              formControlName="isInitialPhase"
              class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
              [disabled]="isLoading">
            <span class="text-sm font-medium text-gray-700">
              Esta \xE9 a fase inicial
            </span>
          </label>
          <p class="text-xs text-gray-500 mt-1">
            A fase inicial ser\xE1 usada automaticamente ao criar novos registros.
          </p>
        </div>

        <!-- Error Message -->
        <div *ngIf="errorMessage" class="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg">
          {{ errorMessage }}
        </div>

        <!-- Informa\xE7\xF5es Adicionais -->
        <div class="bg-blue-50 border border-blue-200 rounded-lg p-3">
          <div class="flex items-start">
            <i class="fas fa-info-circle text-blue-500 mt-0.5 mr-2"></i>
            <div class="text-sm text-blue-700">
              <strong>Dica:</strong>
              <ul class="mt-1 ml-2 list-disc">
                <li>Organize suas fases na ordem do seu funil de vendas</li>
                <li>Use cores diferentes para facilitar a identifica\xE7\xE3o</li>
                <li>Fases de <strong>Sucesso</strong> indicam leads convertidos</li>
                <li>Fases de <strong>Fracasso</strong> indicam leads perdidos</li>
              </ul>
            </div>
          </div>
        </div>
      </div>

      <!-- Actions -->
      <div class="flex justify-between mt-6 pt-4 border-t border-gray-200">
        <!-- Delete button (only when editing) -->
        <button 
          *ngIf="isEditing"
          type="button" 
          (click)="deleteColumn()"
          class="px-4 py-2 text-red-700 bg-red-100 hover:bg-red-200 rounded-lg font-medium transition-colors flex items-center"
          [disabled]="isLoading">
          <i class="fas fa-trash mr-2"></i>
          Excluir Fase
        </button>
        <div *ngIf="!isEditing"></div>
        
        <!-- Right side buttons -->
        <div class="flex gap-3">
          <button 
            type="button" 
            (click)="hide()"
            class="px-4 py-2 text-gray-700 bg-gray-200 hover:bg-gray-300 rounded-lg font-medium transition-colors"
            [disabled]="isLoading">
            Cancelar
          </button>
          
          <button 
            type="submit" 
            [disabled]="isLoading || !columnForm.valid"
            class="px-6 py-2 bg-blue-500 hover:bg-blue-600 disabled:bg-blue-300 text-white rounded-lg font-medium transition-colors flex items-center">
            <div *ngIf="isLoading" class="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2"></div>
            {{ isLoading ? 'Salvando...' : (isEditing ? 'Atualizar Fase' : 'Criar Fase') }}
          </button>
        </div>
      </div>
    </form>
  </div>
</div>`, styles: [`/* src/app/components/column-modal/column-modal.component.scss */
.fixed {
  animation: fadeIn 0.2s ease-out;
}
.bg-white {
  animation: slideUp 0.3s ease-out;
}
@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(20px) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}
.form-group {
  position: relative;
}
input:focus,
select:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}
.border-red-500 {
  border-color: #ef4444 !important;
}
select {
  background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
  background-position: right 0.5rem center;
  background-repeat: no-repeat;
  background-size: 1.5em 1.5em;
  padding-right: 2.5rem;
}
.overflow-y-auto::-webkit-scrollbar {
  width: 6px;
}
.overflow-y-auto::-webkit-scrollbar-track {
  background: #f1f5f9;
}
.overflow-y-auto::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 3px;
}
.overflow-y-auto::-webkit-scrollbar-thumb:hover {
  background: #94a3b8;
}
.color-swatch {
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  background-clip: padding-box !important;
}
.color-swatch:hover {
  transform: scale(1.05);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}
.color-swatch:active {
  transform: scale(0.98);
}
.color-swatch .fa-check {
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
}
.grid .color-swatch {
  background: none !important;
}
input[type=color] {
  appearance: none;
  border: none;
  cursor: pointer;
}
input[type=color]::-webkit-color-swatch-wrapper {
  padding: 0;
  border: 1px solid #d1d5db;
  border-radius: 4px;
}
input[type=color]::-webkit-color-swatch {
  border: none;
  border-radius: 3px;
}
input[type=color]::-moz-color-swatch {
  border: none;
  border-radius: 3px;
}
/*# sourceMappingURL=column-modal.component.css.map */
`] }]
  }], null, { ownerId: [{
    type: Input
  }], boardId: [{
    type: Input
  }], columns: [{
    type: Input
  }], columnCreated: [{
    type: Output
  }], columnUpdated: [{
    type: Output
  }], columnDeleted: [{
    type: Output
  }], closeModal: [{
    type: Output
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ColumnModalComponent, { className: "ColumnModalComponent", filePath: "src/app/components/column-modal/column-modal.component.ts", lineNumber: 14 });
})();

// src/app/components/visual-form-builder/visual-form-builder.ts
var _c03 = /* @__PURE__ */ __name(() => ["radio", "checkbox", "temperatura", "file"], "_c0");
var _c12 = /* @__PURE__ */ __name(() => ["text", "email", "tel", "number", "date", "time", "cnpj", "cpf"], "_c1");
var _c2 = /* @__PURE__ */ __name(() => ["Quente", "Morno", "Frio"], "_c2");
function VisualFormBuilderComponent_div_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 17);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function VisualFormBuilderComponent_div_6_Template_div_click_0_listener() {
      const fieldType_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.selectFieldType(fieldType_r2.value));
    }, "VisualFormBuilderComponent_div_6_Template_div_click_0_listener"));
    \u0275\u0275elementStart(1, "div", 18)(2, "div", 19);
    \u0275\u0275element(3, "i", 20);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "div")(5, "div", 21);
    \u0275\u0275text(6);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "div", 22);
    \u0275\u0275text(8);
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const fieldType_r2 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275classProp("selected", ctx_r2.selectedFieldType === fieldType_r2.value);
    \u0275\u0275advance(3);
    \u0275\u0275classMap(ctx_r2.getFieldTypeIcon(fieldType_r2.value));
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(fieldType_r2.label);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r2.getFieldTypeDescription(fieldType_r2.value));
  }
}
__name(VisualFormBuilderComponent_div_6_Template, "VisualFormBuilderComponent_div_6_Template");
function VisualFormBuilderComponent_form_12_div_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div")(1, "label", 24);
    \u0275\u0275text(2, " Placeholder ");
    \u0275\u0275elementEnd();
    \u0275\u0275element(3, "input", 45);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(3);
    \u0275\u0275property("placeholder", ctx_r2.getPlaceholderExample(ctx_r2.selectedFieldType));
  }
}
__name(VisualFormBuilderComponent_form_12_div_9_Template, "VisualFormBuilderComponent_form_12_div_9_Template");
function VisualFormBuilderComponent_form_12_div_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div")(1, "label", 24);
    \u0275\u0275text(2, " Configura\xE7\xF5es do Arquivo ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "label", 31)(4, "input", 46);
    \u0275\u0275listener("change", /* @__PURE__ */ __name(function VisualFormBuilderComponent_form_12_div_10_Template_input_change_4_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.fieldsForm.patchValue({ placeholder: $event.target.checked ? "multiple" : "" }));
    }, "VisualFormBuilderComponent_form_12_div_10_Template_input_change_4_listener"));
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "span", 33);
    \u0275\u0275text(6, "Permitir m\xFAltiplos arquivos");
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    let tmp_2_0;
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(4);
    \u0275\u0275property("checked", ((tmp_2_0 = ctx_r2.fieldsForm.get("placeholder")) == null ? null : tmp_2_0.value) === "multiple");
  }
}
__name(VisualFormBuilderComponent_form_12_div_10_Template, "VisualFormBuilderComponent_form_12_div_10_Template");
function VisualFormBuilderComponent_form_12_div_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div")(1, "label", 24);
    \u0275\u0275text(2, " Op\xE7\xF5es * ");
    \u0275\u0275elementEnd();
    \u0275\u0275element(3, "textarea", 47);
    \u0275\u0275elementStart(4, "div", 48);
    \u0275\u0275text(5, "Uma op\xE7\xE3o por linha");
    \u0275\u0275elementEnd()();
  }
}
__name(VisualFormBuilderComponent_form_12_div_11_Template, "VisualFormBuilderComponent_form_12_div_11_Template");
function VisualFormBuilderComponent_form_12_div_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 49)(1, "div", 50);
    \u0275\u0275element(2, "i", 51);
    \u0275\u0275elementStart(3, "div", 52)(4, "strong");
    \u0275\u0275text(5, "Campo Respons\xE1vel:");
    \u0275\u0275elementEnd();
    \u0275\u0275element(6, "br");
    \u0275\u0275text(7, " Exibe uma lista com os usu\xE1rios da empresa para sele\xE7\xE3o do respons\xE1vel pelo registro. ");
    \u0275\u0275elementEnd()()();
  }
}
__name(VisualFormBuilderComponent_form_12_div_12_Template, "VisualFormBuilderComponent_form_12_div_12_Template");
function VisualFormBuilderComponent_form_12_div_13_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 49)(1, "div", 50);
    \u0275\u0275element(2, "i", 51);
    \u0275\u0275elementStart(3, "div", 52)(4, "strong");
    \u0275\u0275text(5, "Campo Temperatura:");
    \u0275\u0275elementEnd();
    \u0275\u0275element(6, "br");
    \u0275\u0275text(7, " Este campo criar\xE1 automaticamente uma lista suspensa com: ");
    \u0275\u0275elementStart(8, "ul", 53)(9, "li");
    \u0275\u0275text(10, "\u{1F525} ");
    \u0275\u0275elementStart(11, "strong");
    \u0275\u0275text(12, "Quente");
    \u0275\u0275elementEnd();
    \u0275\u0275text(13, " - Para leads com alta probabilidade");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(14, "li");
    \u0275\u0275text(15, "\u{1F324}\uFE0F ");
    \u0275\u0275elementStart(16, "strong");
    \u0275\u0275text(17, "Morno");
    \u0275\u0275elementEnd();
    \u0275\u0275text(18, " - Para leads com m\xE9dia probabilidade");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(19, "li");
    \u0275\u0275text(20, "\u2744\uFE0F ");
    \u0275\u0275elementStart(21, "strong");
    \u0275\u0275text(22, "Frio");
    \u0275\u0275elementEnd();
    \u0275\u0275text(23, " - Para leads com baixa probabilidade");
    \u0275\u0275elementEnd()()()()();
  }
}
__name(VisualFormBuilderComponent_form_12_div_13_Template, "VisualFormBuilderComponent_form_12_div_13_Template");
function VisualFormBuilderComponent_form_12_div_49_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div")(1, "label", 24);
    \u0275\u0275text(2, " Nome na API (opcional) ");
    \u0275\u0275elementEnd();
    \u0275\u0275element(3, "input", 54);
    \u0275\u0275elementStart(4, "div", 48);
    \u0275\u0275text(5, "Deixe vazio para usar o nome do campo");
    \u0275\u0275elementEnd()();
  }
}
__name(VisualFormBuilderComponent_form_12_div_49_Template, "VisualFormBuilderComponent_form_12_div_49_Template");
function VisualFormBuilderComponent_form_12_button_53_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 55);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function VisualFormBuilderComponent_form_12_button_53_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.cancelEdit());
    }, "VisualFormBuilderComponent_form_12_button_53_Template_button_click_0_listener"));
    \u0275\u0275text(1, " Cancelar ");
    \u0275\u0275elementEnd();
  }
}
__name(VisualFormBuilderComponent_form_12_button_53_Template, "VisualFormBuilderComponent_form_12_button_53_Template");
function VisualFormBuilderComponent_form_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "form", 23)(1, "div")(2, "label", 24);
    \u0275\u0275text(3, " Nome do Campo * ");
    \u0275\u0275elementEnd();
    \u0275\u0275element(4, "input", 25);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "div")(6, "label", 24);
    \u0275\u0275text(7, " R\xF3tulo do Campo * ");
    \u0275\u0275elementEnd();
    \u0275\u0275element(8, "input", 26);
    \u0275\u0275elementEnd();
    \u0275\u0275template(9, VisualFormBuilderComponent_form_12_div_9_Template, 4, 1, "div", 27)(10, VisualFormBuilderComponent_form_12_div_10_Template, 7, 1, "div", 27)(11, VisualFormBuilderComponent_form_12_div_11_Template, 6, 0, "div", 27)(12, VisualFormBuilderComponent_form_12_div_12_Template, 8, 0, "div", 28)(13, VisualFormBuilderComponent_form_12_div_13_Template, 24, 0, "div", 28);
    \u0275\u0275elementStart(14, "div", 29)(15, "h4", 30);
    \u0275\u0275text(16, "Valida\xE7\xF5es");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(17, "label", 31);
    \u0275\u0275element(18, "input", 32);
    \u0275\u0275elementStart(19, "span", 33);
    \u0275\u0275text(20, "Campo obrigat\xF3rio");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(21, "div", 29)(22, "h4", 30);
    \u0275\u0275text(23, "Integra\xE7\xE3o API");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(24, "label", 31);
    \u0275\u0275element(25, "input", 34);
    \u0275\u0275elementStart(26, "span", 33);
    \u0275\u0275text(27, "Incluir este campo na API");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(28, "div", 35)(29, "p", 36);
    \u0275\u0275text(30, "Op\xE7\xF5es de Exibi\xE7\xE3o");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(31, "label", 31);
    \u0275\u0275element(32, "input", 37);
    \u0275\u0275elementStart(33, "span", 33);
    \u0275\u0275text(34, "Exibir no card do registro");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(35, "label", 31);
    \u0275\u0275element(36, "input", 38);
    \u0275\u0275elementStart(37, "span", 33);
    \u0275\u0275text(38, "Exibir em todas as fases");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(39, "label", 31);
    \u0275\u0275element(40, "input", 39);
    \u0275\u0275elementStart(41, "span", 33);
    \u0275\u0275text(42, "Dispon\xEDvel para filtros");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(43, "p", 40);
    \u0275\u0275text(44, " \u{1F4A1} Campos vis\xEDveis no card s\xE3o automaticamente vis\xEDveis em todas as fases ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(45, "label", 31);
    \u0275\u0275element(46, "input", 41);
    \u0275\u0275elementStart(47, "span", 33);
    \u0275\u0275text(48, "Obrigat\xF3rio para avan\xE7ar de fase");
    \u0275\u0275elementEnd()();
    \u0275\u0275template(49, VisualFormBuilderComponent_form_12_div_49_Template, 6, 0, "div", 27);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(50, "div", 42)(51, "button", 43);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function VisualFormBuilderComponent_form_12_Template_button_click_51_listener() {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.addField());
    }, "VisualFormBuilderComponent_form_12_Template_button_click_51_listener"));
    \u0275\u0275text(52);
    \u0275\u0275elementEnd();
    \u0275\u0275template(53, VisualFormBuilderComponent_form_12_button_53_Template, 2, 0, "button", 44);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    let tmp_7_0;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("formGroup", ctx_r2.fieldsForm);
    \u0275\u0275advance(9);
    \u0275\u0275property("ngIf", !\u0275\u0275pureFunction0(12, _c03).includes(ctx_r2.selectedFieldType));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.selectedFieldType === "file");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.selectedFieldType === "select" || ctx_r2.selectedFieldType === "radio");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.selectedFieldType === "responsavel");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.selectedFieldType === "temperatura");
    \u0275\u0275advance(36);
    \u0275\u0275property("ngIf", (tmp_7_0 = ctx_r2.fieldsForm.get("includeInApi")) == null ? null : tmp_7_0.value);
    \u0275\u0275advance(2);
    \u0275\u0275styleProp("background-color", ctx_r2.getPrimaryColor());
    \u0275\u0275property("disabled", ctx_r2.fieldsForm.invalid);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r2.editingIndex >= 0 ? "Atualizar Campo" : "Adicionar Campo", " ");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.editingIndex >= 0);
  }
}
__name(VisualFormBuilderComponent_form_12_Template, "VisualFormBuilderComponent_form_12_Template");
function VisualFormBuilderComponent_div_13_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 56);
    \u0275\u0275element(1, "i", 57);
    \u0275\u0275elementStart(2, "p", 58);
    \u0275\u0275text(3, "Selecione um tipo de campo \xE0 esquerda para come\xE7ar");
    \u0275\u0275elementEnd()();
  }
}
__name(VisualFormBuilderComponent_div_13_Template, "VisualFormBuilderComponent_div_13_Template");
function VisualFormBuilderComponent_div_18_button_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 66);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function VisualFormBuilderComponent_div_18_button_5_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r8);
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.showApiSchema());
    }, "VisualFormBuilderComponent_div_18_button_5_Template_button_click_0_listener"));
    \u0275\u0275element(1, "i", 67);
    \u0275\u0275elementStart(2, "span");
    \u0275\u0275text(3, "API");
    \u0275\u0275elementEnd()();
  }
}
__name(VisualFormBuilderComponent_div_18_button_5_Template, "VisualFormBuilderComponent_div_18_button_5_Template");
function VisualFormBuilderComponent_div_18_div_7_span_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 81);
    \u0275\u0275text(1, "*");
    \u0275\u0275elementEnd();
  }
}
__name(VisualFormBuilderComponent_div_18_div_7_span_7_Template, "VisualFormBuilderComponent_div_18_div_7_span_7_Template");
function VisualFormBuilderComponent_div_18_div_7_span_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 82);
    \u0275\u0275element(1, "i", 83);
    \u0275\u0275elementEnd();
  }
}
__name(VisualFormBuilderComponent_div_18_div_7_span_8_Template, "VisualFormBuilderComponent_div_18_div_7_span_8_Template");
function VisualFormBuilderComponent_div_18_div_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 68)(1, "div", 69)(2, "div", 70);
    \u0275\u0275element(3, "i", 71);
    \u0275\u0275elementEnd();
    \u0275\u0275element(4, "i", 72);
    \u0275\u0275elementStart(5, "span", 73);
    \u0275\u0275text(6);
    \u0275\u0275elementEnd();
    \u0275\u0275template(7, VisualFormBuilderComponent_div_18_div_7_span_7_Template, 2, 0, "span", 74)(8, VisualFormBuilderComponent_div_18_div_7_span_8_Template, 2, 0, "span", 75);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "div", 76)(10, "button", 77);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function VisualFormBuilderComponent_div_18_div_7_Template_button_click_10_listener() {
      const i_r10 = \u0275\u0275restoreView(_r9).index;
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.editField(i_r10));
    }, "VisualFormBuilderComponent_div_18_div_7_Template_button_click_10_listener"));
    \u0275\u0275element(11, "i", 78);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(12, "button", 79);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function VisualFormBuilderComponent_div_18_div_7_Template_button_click_12_listener() {
      const i_r10 = \u0275\u0275restoreView(_r9).index;
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.openRemoveField(i_r10));
    }, "VisualFormBuilderComponent_div_18_div_7_Template_button_click_12_listener"));
    \u0275\u0275element(13, "i", 80);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const field_r11 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(4);
    \u0275\u0275classMap(ctx_r2.getFieldTypeIcon(field_r11.type));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(field_r11.label);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r11.required);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r11.includeInApi !== false);
  }
}
__name(VisualFormBuilderComponent_div_18_div_7_Template, "VisualFormBuilderComponent_div_18_div_7_Template");
function VisualFormBuilderComponent_div_18_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 59)(1, "div", 60)(2, "div", 61)(3, "div", 62);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd();
    \u0275\u0275template(5, VisualFormBuilderComponent_div_18_button_5_Template, 4, 0, "button", 63);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "div", 64);
    \u0275\u0275listener("cdkDropListDropped", /* @__PURE__ */ __name(function VisualFormBuilderComponent_div_18_Template_div_cdkDropListDropped_6_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onDrop($event));
    }, "VisualFormBuilderComponent_div_18_Template_div_cdkDropListDropped_6_listener"));
    \u0275\u0275template(7, VisualFormBuilderComponent_div_18_div_7_Template, 14, 5, "div", 65);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" Campos (", ctx_r2.fields.length, ") ");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.fields.length > 0);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx_r2.fields);
  }
}
__name(VisualFormBuilderComponent_div_18_Template, "VisualFormBuilderComponent_div_18_Template");
function VisualFormBuilderComponent_div_20_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 84)(1, "div", 85);
    \u0275\u0275element(2, "i", 86);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "h4", 87);
    \u0275\u0275text(4, "Formul\xE1rio Vazio");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "p", 88);
    \u0275\u0275text(6, "Adicione campos \xE0 esquerda para ver a visualiza\xE7\xE3o aqui");
    \u0275\u0275elementEnd()();
  }
}
__name(VisualFormBuilderComponent_div_20_Template, "VisualFormBuilderComponent_div_20_Template");
function VisualFormBuilderComponent_div_21_div_5_span_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 102);
    \u0275\u0275text(1, "*");
    \u0275\u0275elementEnd();
  }
}
__name(VisualFormBuilderComponent_div_21_div_5_span_3_Template, "VisualFormBuilderComponent_div_21_div_5_span_3_Template");
function VisualFormBuilderComponent_div_21_div_5_input_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "input", 103);
  }
  if (rf & 2) {
    const field_r14 = \u0275\u0275nextContext().$implicit;
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275property("type", field_r14.type === "cnpj" || field_r14.type === "cpf" ? "text" : field_r14.type)("placeholder", field_r14.placeholder || ctx_r2.getPlaceholderExample(field_r14.type))("required", field_r14.required);
  }
}
__name(VisualFormBuilderComponent_div_21_div_5_input_4_Template, "VisualFormBuilderComponent_div_21_div_5_input_4_Template");
function VisualFormBuilderComponent_div_21_div_5_textarea_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "textarea", 104);
    \u0275\u0275text(1, "              ");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const field_r14 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("placeholder", field_r14.placeholder || "")("required", field_r14.required);
  }
}
__name(VisualFormBuilderComponent_div_21_div_5_textarea_5_Template, "VisualFormBuilderComponent_div_21_div_5_textarea_5_Template");
function VisualFormBuilderComponent_div_21_div_5_select_6_option_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "option", 108);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const option_r16 = ctx.$implicit;
    \u0275\u0275property("value", option_r16);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", option_r16, " ");
  }
}
__name(VisualFormBuilderComponent_div_21_div_5_select_6_option_3_Template, "VisualFormBuilderComponent_div_21_div_5_select_6_option_3_Template");
function VisualFormBuilderComponent_div_21_div_5_select_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "select", 105)(1, "option", 106);
    \u0275\u0275text(2, "Selecione uma op\xE7\xE3o");
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, VisualFormBuilderComponent_div_21_div_5_select_6_option_3_Template, 2, 2, "option", 107);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const field_r14 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("required", field_r14.required);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", field_r14.options);
  }
}
__name(VisualFormBuilderComponent_div_21_div_5_select_6_Template, "VisualFormBuilderComponent_div_21_div_5_select_6_Template");
function VisualFormBuilderComponent_div_21_div_5_select_7_option_3_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1, "\u{1F525}");
    \u0275\u0275elementEnd();
  }
}
__name(VisualFormBuilderComponent_div_21_div_5_select_7_option_3_span_2_Template, "VisualFormBuilderComponent_div_21_div_5_select_7_option_3_span_2_Template");
function VisualFormBuilderComponent_div_21_div_5_select_7_option_3_span_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1, "\u{1F324}\uFE0F");
    \u0275\u0275elementEnd();
  }
}
__name(VisualFormBuilderComponent_div_21_div_5_select_7_option_3_span_3_Template, "VisualFormBuilderComponent_div_21_div_5_select_7_option_3_span_3_Template");
function VisualFormBuilderComponent_div_21_div_5_select_7_option_3_span_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1, "\u2744\uFE0F");
    \u0275\u0275elementEnd();
  }
}
__name(VisualFormBuilderComponent_div_21_div_5_select_7_option_3_span_4_Template, "VisualFormBuilderComponent_div_21_div_5_select_7_option_3_span_4_Template");
function VisualFormBuilderComponent_div_21_div_5_select_7_option_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "option", 108);
    \u0275\u0275text(1);
    \u0275\u0275template(2, VisualFormBuilderComponent_div_21_div_5_select_7_option_3_span_2_Template, 2, 0, "span", 27)(3, VisualFormBuilderComponent_div_21_div_5_select_7_option_3_span_3_Template, 2, 0, "span", 27)(4, VisualFormBuilderComponent_div_21_div_5_select_7_option_3_span_4_Template, 2, 0, "span", 27);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const option_r17 = ctx.$implicit;
    \u0275\u0275property("value", option_r17);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" \u{1F321}\uFE0F ", option_r17, " ");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", option_r17 === "Quente");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", option_r17 === "Morno");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", option_r17 === "Frio");
  }
}
__name(VisualFormBuilderComponent_div_21_div_5_select_7_option_3_Template, "VisualFormBuilderComponent_div_21_div_5_select_7_option_3_Template");
function VisualFormBuilderComponent_div_21_div_5_select_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "select", 105)(1, "option", 106);
    \u0275\u0275text(2, "Selecione a temperatura");
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, VisualFormBuilderComponent_div_21_div_5_select_7_option_3_Template, 5, 5, "option", 107);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const field_r14 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("required", field_r14.required);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", field_r14.options || \u0275\u0275pureFunction0(2, _c2));
  }
}
__name(VisualFormBuilderComponent_div_21_div_5_select_7_Template, "VisualFormBuilderComponent_div_21_div_5_select_7_Template");
function VisualFormBuilderComponent_div_21_div_5_div_8_label_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "label", 111);
    \u0275\u0275element(1, "input", 112);
    \u0275\u0275elementStart(2, "span", 113);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const option_r18 = ctx.$implicit;
    const field_r14 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("name", field_r14.name + "_preview")("value", option_r18)("required", field_r14.required);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(option_r18);
  }
}
__name(VisualFormBuilderComponent_div_21_div_5_div_8_label_1_Template, "VisualFormBuilderComponent_div_21_div_5_div_8_label_1_Template");
function VisualFormBuilderComponent_div_21_div_5_div_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 109);
    \u0275\u0275template(1, VisualFormBuilderComponent_div_21_div_5_div_8_label_1_Template, 4, 4, "label", 110);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const field_r14 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", field_r14.options);
  }
}
__name(VisualFormBuilderComponent_div_21_div_5_div_8_Template, "VisualFormBuilderComponent_div_21_div_5_div_8_Template");
function VisualFormBuilderComponent_div_21_div_5_label_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "label", 111);
    \u0275\u0275element(1, "input", 114);
    \u0275\u0275elementStart(2, "span", 113);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const field_r14 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("required", field_r14.required);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(field_r14.placeholder || "Aceitar termos");
  }
}
__name(VisualFormBuilderComponent_div_21_div_5_label_9_Template, "VisualFormBuilderComponent_div_21_div_5_label_9_Template");
function VisualFormBuilderComponent_div_21_div_5_div_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275element(1, "input", 115);
    \u0275\u0275elementStart(2, "div", 48);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const field_r14 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("multiple", field_r14.placeholder === "multiple")("required", field_r14.required);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", field_r14.placeholder === "multiple" ? "M\xFAltiplos arquivos permitidos" : "Upload de arquivo", " ");
  }
}
__name(VisualFormBuilderComponent_div_21_div_5_div_10_Template, "VisualFormBuilderComponent_div_21_div_5_div_10_Template");
function VisualFormBuilderComponent_div_21_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 94);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function VisualFormBuilderComponent_div_21_div_5_Template_div_click_0_listener() {
      const ctx_r12 = \u0275\u0275restoreView(_r12);
      const field_r14 = ctx_r12.$implicit;
      const i_r15 = ctx_r12.index;
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.selectField(field_r14, i_r15));
    }, "VisualFormBuilderComponent_div_21_div_5_Template_div_click_0_listener"));
    \u0275\u0275elementStart(1, "label", 95);
    \u0275\u0275text(2);
    \u0275\u0275template(3, VisualFormBuilderComponent_div_21_div_5_span_3_Template, 2, 0, "span", 96);
    \u0275\u0275elementEnd();
    \u0275\u0275template(4, VisualFormBuilderComponent_div_21_div_5_input_4_Template, 1, 3, "input", 97)(5, VisualFormBuilderComponent_div_21_div_5_textarea_5_Template, 2, 2, "textarea", 98)(6, VisualFormBuilderComponent_div_21_div_5_select_6_Template, 4, 2, "select", 99)(7, VisualFormBuilderComponent_div_21_div_5_select_7_Template, 4, 3, "select", 99)(8, VisualFormBuilderComponent_div_21_div_5_div_8_Template, 2, 1, "div", 100)(9, VisualFormBuilderComponent_div_21_div_5_label_9_Template, 4, 2, "label", 101)(10, VisualFormBuilderComponent_div_21_div_5_div_10_Template, 4, 3, "div", 27);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const field_r14 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275classProp("bg-blue-50", ctx_r2.selectedField === field_r14)("border-blue-200", ctx_r2.selectedField === field_r14)("border", ctx_r2.selectedField === field_r14)("p-3", ctx_r2.selectedField === field_r14)("rounded", ctx_r2.selectedField === field_r14);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", field_r14.label, " ");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r14.required);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", \u0275\u0275pureFunction0(19, _c12).includes(field_r14.type));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r14.type === "textarea");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r14.type === "select");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r14.type === "temperatura");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r14.type === "radio");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r14.type === "checkbox");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r14.type === "file");
  }
}
__name(VisualFormBuilderComponent_div_21_div_5_Template, "VisualFormBuilderComponent_div_21_div_5_Template");
function VisualFormBuilderComponent_div_21_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 89)(1, "div", 90)(2, "h4", 91);
    \u0275\u0275text(3, "Pr\xE9-visualiza\xE7\xE3o");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "form", 92);
    \u0275\u0275template(5, VisualFormBuilderComponent_div_21_div_5_Template, 11, 20, "div", 93);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(5);
    \u0275\u0275property("ngForOf", ctx_r2.fields);
  }
}
__name(VisualFormBuilderComponent_div_21_Template, "VisualFormBuilderComponent_div_21_Template");
function VisualFormBuilderComponent_div_22_Template(rf, ctx) {
  if (rf & 1) {
    const _r19 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 116);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function VisualFormBuilderComponent_div_22_Template_div_click_0_listener() {
      \u0275\u0275restoreView(_r19);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.cancelRemoveField());
    }, "VisualFormBuilderComponent_div_22_Template_div_click_0_listener"));
    \u0275\u0275elementStart(1, "div", 117);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function VisualFormBuilderComponent_div_22_Template_div_click_1_listener($event) {
      \u0275\u0275restoreView(_r19);
      return \u0275\u0275resetView($event.stopPropagation());
    }, "VisualFormBuilderComponent_div_22_Template_div_click_1_listener"));
    \u0275\u0275elementStart(2, "h3", 118);
    \u0275\u0275text(3, "Remover campo");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "p", 119);
    \u0275\u0275text(5, "Tem certeza que deseja remover este campo do formul\xE1rio?");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "div", 120)(7, "button", 121);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function VisualFormBuilderComponent_div_22_Template_button_click_7_listener() {
      \u0275\u0275restoreView(_r19);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.cancelRemoveField());
    }, "VisualFormBuilderComponent_div_22_Template_button_click_7_listener"));
    \u0275\u0275text(8, "Cancelar");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "button", 122);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function VisualFormBuilderComponent_div_22_Template_button_click_9_listener() {
      \u0275\u0275restoreView(_r19);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.confirmRemoveField());
    }, "VisualFormBuilderComponent_div_22_Template_button_click_9_listener"));
    \u0275\u0275text(10, "Remover");
    \u0275\u0275elementEnd()()()();
  }
}
__name(VisualFormBuilderComponent_div_22_Template, "VisualFormBuilderComponent_div_22_Template");
var _VisualFormBuilderComponent = class _VisualFormBuilderComponent {
  fields = [];
  fieldsChanged = new EventEmitter();
  fb = inject(FormBuilder);
  subdomainService = inject(SubdomainService);
  fieldsForm;
  editingField = null;
  editingIndex = -1;
  selectedFieldType = "";
  selectedField = null;
  // Delete confirmation state
  showDeleteConfirm = false;
  fieldPendingDeleteIndex = -1;
  fieldTypes = [
    { value: "text", label: "Texto" },
    { value: "email", label: "E-mail" },
    { value: "tel", label: "Telefone" },
    { value: "number", label: "N\xFAmero" },
    { value: "cnpj", label: "CNPJ" },
    { value: "cpf", label: "CPF" },
    { value: "temperatura", label: "Temperatura" },
    { value: "responsavel", label: "Respons\xE1vel" },
    { value: "textarea", label: "\xC1rea de Texto" },
    { value: "select", label: "Lista Suspensa" },
    { value: "checkbox", label: "Checkbox" },
    { value: "radio", label: "Bot\xE3o de R\xE1dio" },
    { value: "date", label: "Data" },
    { value: "time", label: "Hora" },
    { value: "file", label: "Upload de Arquivo" }
  ];
  constructor() {
    this.fieldsForm = this.fb.group({
      name: ["", Validators.required],
      label: ["", Validators.required],
      type: ["text", Validators.required],
      required: [false],
      placeholder: [""],
      options: [""],
      includeInApi: [true],
      // Por padrão, incluir na API
      apiFieldName: [""],
      // Nome personalizado na API
      showInCard: [false],
      // Por padrão, não exibir no card
      requiredToAdvance: [false],
      showInAllPhases: [false],
      showInFilters: [false]
      // Por padrão, não exibir nos filtros
    });
    this.fieldsForm.get("showInCard")?.valueChanges.subscribe((showInCard) => {
      if (showInCard) {
        this.fieldsForm.patchValue({ showInAllPhases: true }, { emitEvent: false });
      }
    });
    this.fieldsForm.get("showInAllPhases")?.valueChanges.subscribe((showInAllPhases) => {
      if (!showInAllPhases) {
        this.fieldsForm.patchValue({ showInCard: false }, { emitEvent: false });
      }
    });
  }
  ngOnInit() {
    if (this.fields && this.fields.length > 0) {
      this.emitFieldsChange();
    }
  }
  // Open styled confirm modal
  openRemoveField(index) {
    this.fieldPendingDeleteIndex = index;
    this.showDeleteConfirm = true;
  }
  cancelRemoveField() {
    this.showDeleteConfirm = false;
    this.fieldPendingDeleteIndex = -1;
  }
  confirmRemoveField() {
    if (this.fieldPendingDeleteIndex < 0)
      return;
    this.removeField(this.fieldPendingDeleteIndex);
    this.cancelRemoveField();
  }
  // Perform removal (no prompt)
  removeField(index) {
    this.fields.splice(index, 1);
    if (this.selectedField === this.fields[index]) {
      this.selectedField = null;
      this.selectedFieldType = "";
    }
    this.emitFieldsChange();
  }
  moveFieldUp(index) {
    if (index > 0) {
      const temp = this.fields[index];
      this.fields[index] = this.fields[index - 1];
      this.fields[index - 1] = temp;
      this.updateFieldOrders();
      this.emitFieldsChange();
    }
  }
  moveFieldDown(index) {
    if (index < this.fields.length - 1) {
      const temp = this.fields[index];
      this.fields[index] = this.fields[index + 1];
      this.fields[index + 1] = temp;
      this.updateFieldOrders();
      this.emitFieldsChange();
    }
  }
  onDrop(event) {
    moveItemInArray(this.fields, event.previousIndex, event.currentIndex);
    this.updateFieldOrders();
    this.emitFieldsChange();
  }
  resetForm() {
    this.fieldsForm.reset({
      type: "text",
      required: false,
      includeInApi: true,
      showInCard: false,
      requiredToAdvance: false,
      showInAllPhases: false,
      showInFilters: false
    });
  }
  updateFieldOrders() {
    this.fields.forEach((field, index) => {
      field.order = index;
    });
  }
  emitFieldsChange() {
    console.log("\u{1F4E4} emitFieldsChange CHAMADO");
    console.log("\u{1F4E4} Total de campos:", this.fields?.length);
    console.log("\u{1F4E4} Campos atuais:", this.fields);
    this.fields?.forEach((field, index) => {
      console.log(`\u{1F4E4} Campo emitido ${index + 1}:`, {
        name: field.name,
        label: field.label,
        type: field.type,
        showInCard: field.showInCard,
        showInAllPhases: field.showInAllPhases,
        showInFilters: field.showInFilters,
        completeField: field
      });
    });
    this.fieldsChanged.emit([...this.fields]);
    console.log("\u{1F4E4} emitFieldsChange CONCLU\xCDDO - fieldsChanged.emit() executado");
  }
  // Método para obter tipo de campo formatado
  getFieldTypeLabel(type) {
    const fieldType = this.fieldTypes.find((ft) => ft.value === type);
    return fieldType ? fieldType.label : type;
  }
  // Novos métodos para o layout Form.io
  selectFieldType(type) {
    this.selectedFieldType = type;
    this.fieldsForm.patchValue({ type });
    if (!this.fieldsForm.get("name")?.value) {
      const baseName = type + (this.fields.length + 1);
      this.fieldsForm.patchValue({ name: baseName });
    }
  }
  selectField(field, index) {
    this.selectedField = field;
    this.editField(index);
  }
  getFieldTypeIcon(type) {
    const icons = {
      "text": "fas fa-font",
      "email": "fas fa-envelope",
      "tel": "fas fa-phone",
      "number": "fas fa-hashtag",
      "cnpj": "fas fa-building",
      "cpf": "fas fa-id-card",
      "temperatura": "fas fa-thermometer-half",
      "responsavel": "fas fa-user",
      "textarea": "fas fa-align-left",
      "select": "fas fa-list",
      "checkbox": "fas fa-check-square",
      "radio": "fas fa-dot-circle",
      "date": "fas fa-calendar",
      "time": "fas fa-clock",
      "file": "fas fa-upload"
    };
    return icons[type] || "fas fa-question";
  }
  getFieldTypeDescription(type) {
    const descriptions = {
      "text": "Campo de texto simples",
      "email": "Campo de e-mail com valida\xE7\xE3o",
      "tel": "Telefone com m\xE1scara DDD Brasil",
      "number": "Campo num\xE9rico",
      "cnpj": "CNPJ com m\xE1scara e valida\xE7\xE3o",
      "cpf": "CPF com m\xE1scara e valida\xE7\xE3o",
      "temperatura": "Lista suspensa (Quente, Morno, Frio)",
      "responsavel": "Lista de usu\xE1rios da empresa",
      "textarea": "\xC1rea de texto multilinha",
      "select": "Lista suspensa",
      "checkbox": "Caixa de sele\xE7\xE3o",
      "radio": "Bot\xF5es de sele\xE7\xE3o \xFAnica",
      "date": "Seletor de data",
      "time": "Seletor de hora",
      "file": "Upload de arquivos"
    };
    return descriptions[type] || "Campo personalizado";
  }
  addField() {
    console.log("\u2795 addField INICIADO");
    const formValue = this.fieldsForm.value;
    console.log("\u2795 Valores do formul\xE1rio:", formValue);
    if (!formValue.name || !formValue.label) {
      console.log("\u2795 ERRO: Nome e r\xF3tulo s\xE3o obrigat\xF3rios");
      alert("Nome e r\xF3tulo s\xE3o obrigat\xF3rios");
      return;
    }
    if (this.fields.some((f) => f.name === formValue.name && this.editingIndex === -1)) {
      console.log("\u2795 ERRO: J\xE1 existe um campo com este nome");
      alert("J\xE1 existe um campo com este nome");
      return;
    }
    const showInCard = formValue.showInCard || false;
    const showInAllPhases = showInCard ? true : formValue.showInAllPhases || false;
    console.log("\u2795 Configura\xE7\xF5es de visibilidade:", { showInCard, showInAllPhases });
    const newField = __spreadValues(__spreadValues({
      name: formValue.name,
      label: formValue.label,
      type: formValue.type || this.selectedFieldType,
      required: formValue.required || false,
      order: this.editingIndex >= 0 ? this.fields[this.editingIndex].order : this.fields.length,
      includeInApi: formValue.includeInApi !== false,
      // Default true
      showInCard,
      requiredToAdvance: formValue.requiredToAdvance || false,
      showInAllPhases,
      showInFilters: formValue.showInFilters || false
    }, formValue.placeholder && formValue.placeholder.trim() && { placeholder: formValue.placeholder.trim() }), formValue.apiFieldName && formValue.apiFieldName.trim() && { apiFieldName: formValue.apiFieldName.trim() });
    console.log("\u2795 Novo campo criado:", newField);
    if ((newField.type === "select" || newField.type === "radio") && formValue.options) {
      newField.options = formValue.options.split("\n").map((opt) => opt.trim()).filter((opt) => opt);
      console.log("\u2795 Op\xE7\xF5es processadas para select/radio:", newField.options);
    }
    if (newField.type === "temperatura") {
      newField.options = ["Quente", "Morno", "Frio"];
      console.log("\u2795 Op\xE7\xF5es auto-configuradas para temperatura:", newField.options);
    }
    console.log("\u2795 Campo final antes de adicionar:", newField);
    if (this.editingIndex >= 0) {
      console.log("\u2795 EDITANDO campo existente no \xEDndice:", this.editingIndex);
      this.fields[this.editingIndex] = newField;
      this.editingIndex = -1;
      this.selectedField = null;
    } else {
      console.log("\u2795 ADICIONANDO novo campo");
      console.log("\u2795 Array antes do push:", this.fields);
      this.fields.push(newField);
      console.log("\u2795 Array depois do push:", this.fields);
    }
    console.log("\u2795 Total de campos ap\xF3s opera\xE7\xE3o:", this.fields.length);
    this.resetForm();
    console.log("\u2795 Chamando emitFieldsChange...");
    this.emitFieldsChange();
    console.log("\u2795 addField CONCLU\xCDDO");
  }
  editField(index) {
    const field = this.fields[index];
    this.editingIndex = index;
    this.editingField = __spreadValues({}, field);
    this.selectedFieldType = field.type;
    this.selectedField = field;
    this.fieldsForm.patchValue({
      name: field.name,
      label: field.label,
      type: field.type,
      required: field.required,
      placeholder: field.placeholder || "",
      options: field.options ? field.options.join("\n") : "",
      includeInApi: field.includeInApi !== false,
      // Default true se não especificado
      apiFieldName: field.apiFieldName || "",
      showInCard: field.showInCard || false,
      // Default false se não especificado
      requiredToAdvance: field.requiredToAdvance || false,
      showInAllPhases: field.showInAllPhases || false,
      showInFilters: field.showInFilters || false
    });
  }
  cancelEdit() {
    this.editingIndex = -1;
    this.editingField = null;
    this.selectedField = null;
    this.selectedFieldType = "";
    this.resetForm();
  }
  getPrimaryColor() {
    const company = this.subdomainService.getCurrentCompany();
    return company?.primaryColor || company?.brandingConfig?.primaryColor || "#3B82F6";
  }
  getPlaceholderExample(type) {
    const examples = {
      "text": "Ex: Digite seu nome",
      "email": "Ex: usuario@exemplo.com",
      "tel": "Ex: (11) 99999-9999",
      "number": "Ex: 123",
      "cnpj": "Ex: 00.000.000/0000-00",
      "cpf": "Ex: 000.000.000-00",
      "textarea": "Ex: Digite suas observa\xE7\xF5es...",
      "date": "",
      "time": ""
    };
    return examples[type] || "Ex: Digite aqui";
  }
  // Gerar estrutura de dados para API baseada nos campos marcados
  generateApiSchema() {
    const apiFields = this.fields.filter((field) => field.includeInApi !== false);
    const schema = {
      fields: apiFields.map((field) => __spreadValues({
        name: field.apiFieldName || field.name,
        originalName: field.name,
        label: field.label,
        type: this.mapFieldTypeForApi(field.type),
        required: field.required,
        validation: this.getValidationRules(field)
      }, field.options && { options: field.options })),
      totalFields: apiFields.length,
      generatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    return schema;
  }
  // Mapear tipos de campo para tipos da API
  mapFieldTypeForApi(fieldType) {
    const typeMap = {
      "text": "string",
      "email": "email",
      "tel": "phone",
      "number": "number",
      "cnpj": "cnpj",
      "cpf": "cpf",
      "temperatura": "enum",
      "responsavel": "string",
      "textarea": "text",
      "select": "enum",
      "checkbox": "boolean",
      "radio": "enum",
      "date": "date",
      "time": "time",
      "file": "file"
    };
    return typeMap[fieldType] || "string";
  }
  // Obter regras de validação para a API
  getValidationRules(field) {
    const rules = {};
    if (field.required) {
      rules.required = true;
    }
    switch (field.type) {
      case "email":
        rules.format = "email";
        break;
      case "cnpj":
        rules.format = "cnpj";
        rules.mask = "00.000.000/0000-00";
        break;
      case "cpf":
        rules.format = "cpf";
        rules.mask = "000.000.000-00";
        break;
      case "tel":
        rules.format = "phone";
        rules.mask = "(00) 00000-0000";
        break;
      case "temperatura":
      case "select":
      case "radio":
        if (field.options) {
          rules.enum = field.options;
        }
        break;
      case "file":
        rules.type = "file";
        if (field.placeholder === "multiple") {
          rules.multiple = true;
        }
        break;
    }
    return rules;
  }
  // Mostrar schema da API no console e como alerta
  showApiSchema() {
    const schema = this.generateApiSchema();
    const jsonSchema = JSON.stringify(schema, null, 2);
    console.log("\u{1F4CB} Schema da API gerado:", schema);
    console.log("\u{1F4CB} JSON Schema:", jsonSchema);
    const summary = `
\u{1F4CB} Schema da API - Resumo:

\u2705 Campos na API: ${schema.totalFields}/${this.fields.length}
\u{1F4C5} Gerado em: ${(/* @__PURE__ */ new Date()).toLocaleString("pt-BR")}

\u{1F517} Campos inclu\xEDdos na API:
${schema.fields.map((f) => `\u2022 ${f.label} (${f.name}) - Tipo: ${f.type}${f.required ? " *" : ""}`).join("\n")}

\u{1F4CB} Schema completo salvo no console para c\xF3pia.
    `;
    alert(summary);
  }
};
__name(_VisualFormBuilderComponent, "VisualFormBuilderComponent");
__publicField(_VisualFormBuilderComponent, "\u0275fac", /* @__PURE__ */ __name(function VisualFormBuilderComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _VisualFormBuilderComponent)();
}, "VisualFormBuilderComponent_Factory"));
__publicField(_VisualFormBuilderComponent, "\u0275cmp", /* @__PURE__ */ \u0275\u0275defineComponent({ type: _VisualFormBuilderComponent, selectors: [["app-visual-form-builder"]], inputs: { fields: "fields" }, outputs: { fieldsChanged: "fieldsChanged" }, decls: 23, vars: 8, consts: [[1, "form-builder", "h-full", "flex", "bg-gray-50"], [1, "w-64", "bg-white", "border-r", "border-gray-200", "flex", "flex-col"], [1, "p-4", "border-b", "border-gray-200"], [1, "text-sm", "font-semibold", "text-gray-900", "uppercase", "tracking-wide"], [1, "flex-1", "p-3", "space-y-2", "overflow-y-auto"], ["class", "field-type-item p-3 border border-gray-300 rounded-lg cursor-pointer hover:border-blue-400 hover:bg-blue-50 transition-colors", 3, "selected", "click", 4, "ngFor", "ngForOf"], [1, "w-80", "bg-white", "border-r", "border-gray-200", "flex", "flex-col"], [1, "flex-1", "p-4", "overflow-y-auto"], ["class", "space-y-4", 3, "formGroup", 4, "ngIf"], ["class", "text-center py-8", 4, "ngIf"], [1, "flex-1", "bg-gray-50", "flex", "flex-col"], [1, "p-4", "bg-white", "border-b", "border-gray-200"], ["class", "bg-white border-b border-gray-200 flex-shrink-0", 4, "ngIf"], [1, "flex-1", "p-6", "overflow-y-auto"], ["class", "text-center py-16", 4, "ngIf"], ["class", "max-w-2xl mx-auto", 4, "ngIf"], ["class", "fixed inset-0 bg-black/50 flex items-center justify-center z-[60]", 3, "click", 4, "ngIf"], [1, "field-type-item", "p-3", "border", "border-gray-300", "rounded-lg", "cursor-pointer", "hover:border-blue-400", "hover:bg-blue-50", "transition-colors", 3, "click"], [1, "flex", "items-center", "space-x-3"], [1, "w-8", "h-8", "bg-gray-100", "rounded-md", "flex", "items-center", "justify-center"], [1, "text-gray-600", "text-sm"], [1, "text-sm", "font-medium", "text-gray-900"], [1, "text-xs", "text-gray-500"], [1, "space-y-4", 3, "formGroup"], [1, "block", "text-xs", "font-medium", "text-gray-700", "mb-2", "uppercase", "tracking-wide"], ["type", "text", "formControlName", "name", "placeholder", "Ex: nomeCompleto", 1, "w-full", "px-3", "py-2", "text-sm", "border", "border-gray-300", "rounded-md", "focus:ring-2", "focus:ring-blue-500", "focus:border-blue-500"], ["type", "text", "formControlName", "label", "placeholder", "Ex: Nome Completo", 1, "w-full", "px-3", "py-2", "text-sm", "border", "border-gray-300", "rounded-md", "focus:ring-2", "focus:ring-blue-500", "focus:border-blue-500"], [4, "ngIf"], ["class", "p-3 bg-blue-50 border border-blue-200 rounded-md", 4, "ngIf"], [1, "space-y-3"], [1, "text-xs", "font-medium", "text-gray-700", "uppercase", "tracking-wide"], [1, "flex", "items-center", "space-x-2"], ["type", "checkbox", "formControlName", "required", 1, "h-4", "w-4", "text-blue-600", "focus:ring-blue-500", "border-gray-300", "rounded"], [1, "text-sm", "text-gray-700"], ["type", "checkbox", "formControlName", "includeInApi", 1, "h-4", "w-4", "text-blue-600", "focus:ring-blue-500", "border-gray-300", "rounded"], [1, "bg-blue-50", "border", "border-blue-200", "rounded-md", "p-3", "space-y-2"], [1, "text-xs", "text-blue-700", "font-medium", "mb-2"], ["type", "checkbox", "formControlName", "showInCard", 1, "h-4", "w-4", "text-blue-600", "focus:ring-blue-500", "border-gray-300", "rounded"], ["type", "checkbox", "formControlName", "showInAllPhases", 1, "h-4", "w-4", "text-blue-600", "focus:ring-blue-500", "border-gray-300", "rounded"], ["type", "checkbox", "formControlName", "showInFilters", 1, "h-4", "w-4", "text-purple-600", "focus:ring-purple-500", "border-gray-300", "rounded"], [1, "text-xs", "text-blue-600", "italic"], ["type", "checkbox", "formControlName", "requiredToAdvance", 1, "h-4", "w-4", "text-blue-600", "focus:ring-blue-500", "border-gray-300", "rounded"], [1, "pt-4", "border-t", "border-gray-200", "space-y-3"], ["type", "button", 1, "w-full", "px-4", "py-2", "text-white", "text-sm", "rounded-lg", "disabled:opacity-50", "disabled:cursor-not-allowed", "transition-colors", 3, "click", "disabled"], ["type", "button", "class", "w-full px-4 py-2 border border-gray-300 text-gray-700 text-sm rounded-lg hover:bg-gray-50 transition-colors", 3, "click", 4, "ngIf"], ["type", "text", "formControlName", "placeholder", 1, "w-full", "px-3", "py-2", "text-sm", "border", "border-gray-300", "rounded-md", "focus:ring-2", "focus:ring-blue-500", "focus:border-blue-500", 3, "placeholder"], ["type", "checkbox", 1, "h-4", "w-4", "text-blue-600", "focus:ring-blue-500", "border-gray-300", "rounded", 3, "change", "checked"], ["formControlName", "options", "rows", "4", "placeholder", "Digite uma op\xE7\xE3o por linha:\nOp\xE7\xE3o 1\nOp\xE7\xE3o 2\nOp\xE7\xE3o 3", 1, "w-full", "px-3", "py-2", "text-sm", "border", "border-gray-300", "rounded-md", "focus:ring-2", "focus:ring-blue-500", "focus:border-blue-500"], [1, "text-xs", "text-gray-500", "mt-1"], [1, "p-3", "bg-blue-50", "border", "border-blue-200", "rounded-md"], [1, "flex", "items-start"], [1, "fas", "fa-info-circle", "text-blue-500", "mr-2", "mt-0.5"], [1, "text-sm", "text-blue-700"], [1, "mt-2", "space-y-1"], ["type", "text", "formControlName", "apiFieldName", "placeholder", "Se vazio, usar\xE1 o nome do campo", 1, "w-full", "px-3", "py-2", "text-sm", "border", "border-gray-300", "rounded-md", "focus:ring-2", "focus:ring-blue-500", "focus:border-blue-500"], ["type", "button", 1, "w-full", "px-4", "py-2", "border", "border-gray-300", "text-gray-700", "text-sm", "rounded-lg", "hover:bg-gray-50", "transition-colors", 3, "click"], [1, "text-center", "py-8"], [1, "fas", "fa-mouse-pointer", "text-gray-300", "text-3xl", "mb-3"], [1, "text-sm", "text-gray-500"], [1, "bg-white", "border-b", "border-gray-200", "flex-shrink-0"], [1, "px-4", "py-2"], [1, "flex", "items-center", "justify-between", "mb-2"], [1, "text-xs", "text-gray-500", "uppercase", "tracking-wide"], ["class", "text-xs text-blue-500 hover:text-blue-700 flex items-center space-x-1", "title", "Ver Schema da API", 3, "click", 4, "ngIf"], ["cdkDropList", "", 1, "space-y-1", "max-h-32", "overflow-y-auto", 3, "cdkDropListDropped"], ["cdkDrag", "", "class", "field-item flex items-center justify-between p-2 bg-gray-50 border border-gray-200 rounded text-xs hover:bg-gray-100 transition-colors", 4, "ngFor", "ngForOf"], ["title", "Ver Schema da API", 1, "text-xs", "text-blue-500", "hover:text-blue-700", "flex", "items-center", "space-x-1", 3, "click"], [1, "fas", "fa-code"], ["cdkDrag", "", 1, "field-item", "flex", "items-center", "justify-between", "p-2", "bg-gray-50", "border", "border-gray-200", "rounded", "text-xs", "hover:bg-gray-100", "transition-colors"], [1, "flex", "items-center", "space-x-2", "flex-1"], ["cdkDragHandle", "", 1, "cursor-move", "text-gray-400"], [1, "fas", "fa-grip-vertical"], [1, "text-gray-500"], [1, "font-medium", "text-gray-900", "truncate"], ["class", "text-red-500 text-xs", 4, "ngIf"], ["class", "text-blue-500 text-xs", "title", "Inclu\xEDdo na API", 4, "ngIf"], [1, "flex", "items-center", "space-x-1", "flex-shrink-0"], ["title", "Editar", 1, "p-1", "text-gray-400", "hover:text-blue-500", 3, "click"], [1, "fas", "fa-edit"], ["title", "Remover", 1, "p-1", "text-gray-400", "hover:text-red-500", 3, "click"], [1, "fas", "fa-trash"], [1, "text-red-500", "text-xs"], ["title", "Inclu\xEDdo na API", 1, "text-blue-500", "text-xs"], [1, "fas", "fa-plug"], [1, "text-center", "py-16"], [1, "w-16", "h-16", "bg-gray-200", "rounded-full", "mx-auto", "mb-4", "flex", "items-center", "justify-center"], [1, "fas", "fa-wpforms", "text-gray-400", "text-2xl"], [1, "text-lg", "font-medium", "text-gray-900", "mb-2"], [1, "text-gray-500", "mb-4"], [1, "max-w-2xl", "mx-auto"], [1, "bg-white", "rounded-lg", "shadow-sm", "border", "border-gray-200", "p-6"], [1, "text-lg", "font-semibold", "text-gray-900", "mb-6"], [1, "space-y-6"], ["class", "form-field", 3, "bg-blue-50", "border-blue-200", "border", "p-3", "rounded", "click", 4, "ngFor", "ngForOf"], [1, "form-field", 3, "click"], [1, "block", "text-sm", "font-medium", "text-gray-900", "mb-2"], ["class", "text-red-500 ml-1", 4, "ngIf"], ["disabled", "", "class", "w-full px-3 py-2 border border-gray-300 rounded-md text-gray-500 bg-gray-50", 3, "type", "placeholder", "required", 4, "ngIf"], ["disabled", "", "rows", "3", "class", "w-full px-3 py-2 border border-gray-300 rounded-md resize-none text-gray-500 bg-gray-50", 3, "placeholder", "required", 4, "ngIf"], ["disabled", "", "class", "w-full px-3 py-2 border border-gray-300 rounded-md text-gray-500 bg-gray-50", 3, "required", 4, "ngIf"], ["class", "space-y-2", 4, "ngIf"], ["class", "flex items-center", 4, "ngIf"], [1, "text-red-500", "ml-1"], ["disabled", "", 1, "w-full", "px-3", "py-2", "border", "border-gray-300", "rounded-md", "text-gray-500", "bg-gray-50", 3, "type", "placeholder", "required"], ["disabled", "", "rows", "3", 1, "w-full", "px-3", "py-2", "border", "border-gray-300", "rounded-md", "resize-none", "text-gray-500", "bg-gray-50", 3, "placeholder", "required"], ["disabled", "", 1, "w-full", "px-3", "py-2", "border", "border-gray-300", "rounded-md", "text-gray-500", "bg-gray-50", 3, "required"], ["value", ""], [3, "value", 4, "ngFor", "ngForOf"], [3, "value"], [1, "space-y-2"], ["class", "flex items-center", 4, "ngFor", "ngForOf"], [1, "flex", "items-center"], ["type", "radio", "disabled", "", 1, "mr-2", "text-gray-400", 3, "name", "value", "required"], [1, "text-gray-700"], ["type", "checkbox", "disabled", "", 1, "mr-2", "text-gray-400", 3, "required"], ["type", "file", "disabled", "", 1, "w-full", "px-3", "py-2", "border", "border-gray-300", "rounded-md", "text-gray-500", "bg-gray-50", 3, "multiple", "required"], [1, "fixed", "inset-0", "bg-black/50", "flex", "items-center", "justify-center", "z-[60]", 3, "click"], [1, "bg-white", "rounded-xl", "shadow-2xl", "w-full", "max-w-md", "p-6", 3, "click"], [1, "text-lg", "font-bold", "text-gray-900", "mb-2"], [1, "text-sm", "text-gray-600", "mb-6"], [1, "flex", "justify-end", "gap-3"], [1, "px-4", "py-2", "rounded-lg", "border", "border-gray-300", 3, "click"], [1, "px-4", "py-2", "rounded-lg", "bg-red-600", "text-white", 3, "click"]], template: /* @__PURE__ */ __name(function VisualFormBuilderComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "h3", 3);
    \u0275\u0275text(4, "Tipos de Campo");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(5, "div", 4);
    \u0275\u0275template(6, VisualFormBuilderComponent_div_6_Template, 9, 6, "div", 5);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(7, "div", 6)(8, "div", 2)(9, "h3", 3);
    \u0275\u0275text(10);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(11, "div", 7);
    \u0275\u0275template(12, VisualFormBuilderComponent_form_12_Template, 54, 13, "form", 8)(13, VisualFormBuilderComponent_div_13_Template, 4, 0, "div", 9);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(14, "div", 10)(15, "div", 11)(16, "h3", 3);
    \u0275\u0275text(17, " Visualiza\xE7\xE3o do Formul\xE1rio ");
    \u0275\u0275elementEnd()();
    \u0275\u0275template(18, VisualFormBuilderComponent_div_18_Template, 8, 3, "div", 12);
    \u0275\u0275elementStart(19, "div", 13);
    \u0275\u0275template(20, VisualFormBuilderComponent_div_20_Template, 7, 0, "div", 14)(21, VisualFormBuilderComponent_div_21_Template, 6, 1, "div", 15);
    \u0275\u0275elementEnd()();
    \u0275\u0275template(22, VisualFormBuilderComponent_div_22_Template, 11, 0, "div", 16);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance(6);
    \u0275\u0275property("ngForOf", ctx.fieldTypes);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", ctx.selectedField ? "Propriedades do Campo" : "Configura\xE7\xF5es", " ");
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx.selectedFieldType);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx.selectedFieldType);
    \u0275\u0275advance(5);
    \u0275\u0275property("ngIf", ctx.fields.length > 0);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx.fields.length === 0);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.fields.length > 0);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.showDeleteConfirm);
  }
}, "VisualFormBuilderComponent_Template"), dependencies: [CommonModule, NgForOf, NgIf, ReactiveFormsModule, \u0275NgNoValidate, NgSelectOption, \u0275NgSelectMultipleOption, DefaultValueAccessor, CheckboxControlValueAccessor, NgControlStatus, NgControlStatusGroup, FormGroupDirective, FormControlName, DragDropModule, CdkDropList, CdkDrag, CdkDragHandle], styles: ["\n\n.form-builder[_ngcontent-%COMP%] {\n  height: 600px;\n}\n.form-builder[_ngcontent-%COMP%]   .field-type-item[_ngcontent-%COMP%] {\n  transition: all 0.2s ease;\n}\n.form-builder[_ngcontent-%COMP%]   .field-type-item[_ngcontent-%COMP%]:hover {\n  transform: translateY(-1px);\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n}\n.form-builder[_ngcontent-%COMP%]   .field-type-item.selected[_ngcontent-%COMP%] {\n  border-color: #3B82F6;\n  background-color: #EBF4FF;\n  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);\n}\n.form-builder[_ngcontent-%COMP%]   .field-item[_ngcontent-%COMP%] {\n  transition: all 0.2s ease;\n}\n.form-builder[_ngcontent-%COMP%]   .field-item[_ngcontent-%COMP%]:hover {\n  background-color: #F3F4F6;\n  border-color: #D1D5DB;\n}\n.form-builder[_ngcontent-%COMP%]   .form-field[_ngcontent-%COMP%] {\n  transition: all 0.2s ease;\n  cursor: pointer;\n}\n.form-builder[_ngcontent-%COMP%]   .form-field[_ngcontent-%COMP%]:hover {\n  background-color: rgba(59, 130, 246, 0.02);\n}\n.form-builder[_ngcontent-%COMP%]   .form-field[_ngcontent-%COMP%]   label[_ngcontent-%COMP%] {\n  font-weight: 500;\n}\n.form-builder[_ngcontent-%COMP%]   .form-field[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]:disabled, \n.form-builder[_ngcontent-%COMP%]   .form-field[_ngcontent-%COMP%]   textarea[_ngcontent-%COMP%]:disabled, \n.form-builder[_ngcontent-%COMP%]   .form-field[_ngcontent-%COMP%]   select[_ngcontent-%COMP%]:disabled {\n  cursor: pointer;\n}\n.form-builder[_ngcontent-%COMP%]   .cdk-drag-preview[_ngcontent-%COMP%] {\n  box-sizing: border-box;\n  border-radius: 6px;\n  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);\n  background: white;\n  transform: rotate(5deg);\n}\n.form-builder[_ngcontent-%COMP%]   .cdk-drag-placeholder[_ngcontent-%COMP%] {\n  opacity: 0.4;\n  background: #E5E7EB;\n  border: 2px dashed #9CA3AF;\n}\n.form-builder[_ngcontent-%COMP%]   .cdk-drag-animating[_ngcontent-%COMP%] {\n  transition: transform 250ms cubic-bezier(0, 0, 0.2, 1);\n}\n.form-builder[_ngcontent-%COMP%]   .cdk-drop-list-dragging[_ngcontent-%COMP%]   .cdk-drag[_ngcontent-%COMP%]:not(.cdk-drag-placeholder) {\n  transition: transform 250ms cubic-bezier(0, 0, 0.2, 1);\n}\n.form-builder[_ngcontent-%COMP%]   .cdk-drag-handle[_ngcontent-%COMP%] {\n  transition: color 0.2s ease;\n}\n.form-builder[_ngcontent-%COMP%]   .cdk-drag-handle[_ngcontent-%COMP%]:hover {\n  color: #3B82F6 !important;\n}\n.form-builder[_ngcontent-%COMP%]   .panel-header[_ngcontent-%COMP%] {\n  background:\n    linear-gradient(\n      to right,\n      #F9FAFB,\n      #F3F4F6);\n}\n.form-builder[_ngcontent-%COMP%]   .overflow-y-auto[_ngcontent-%COMP%]::-webkit-scrollbar {\n  width: 4px;\n}\n.form-builder[_ngcontent-%COMP%]   .overflow-y-auto[_ngcontent-%COMP%]::-webkit-scrollbar-track {\n  background: #F1F5F9;\n}\n.form-builder[_ngcontent-%COMP%]   .overflow-y-auto[_ngcontent-%COMP%]::-webkit-scrollbar-thumb {\n  background: #CBD5E1;\n  border-radius: 2px;\n}\n.form-builder[_ngcontent-%COMP%]   .overflow-y-auto[_ngcontent-%COMP%]::-webkit-scrollbar-thumb:hover {\n  background: #94A3B8;\n}\nbutton[_ngcontent-%COMP%] {\n  transition: all 0.2s ease;\n}\nbutton[_ngcontent-%COMP%]:hover:not(:disabled) {\n  transform: translateY(-1px);\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n}\nbutton[_ngcontent-%COMP%]:active:not(:disabled) {\n  transform: translateY(0);\n}\n.selected-field[_ngcontent-%COMP%] {\n  animation: _ngcontent-%COMP%_pulse-blue 2s infinite;\n}\n@keyframes _ngcontent-%COMP%_pulse-blue {\n  0%, 100% {\n    box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4);\n  }\n  50% {\n    box-shadow: 0 0 0 8px rgba(59, 130, 246, 0);\n  }\n}\n@media (max-width: 1024px) {\n  .form-builder[_ngcontent-%COMP%]   .w-64[_ngcontent-%COMP%] {\n    width: 200px;\n  }\n  .form-builder[_ngcontent-%COMP%]   .w-80[_ngcontent-%COMP%] {\n    width: 240px;\n  }\n}\n@media (max-width: 768px) {\n  .form-builder[_ngcontent-%COMP%] {\n    flex-direction: column;\n    height: auto;\n  }\n  .form-builder[_ngcontent-%COMP%]   .w-64[_ngcontent-%COMP%], \n   .form-builder[_ngcontent-%COMP%]   .w-80[_ngcontent-%COMP%] {\n    width: 100%;\n    max-height: 300px;\n  }\n}\n/*# sourceMappingURL=visual-form-builder.css.map */"] }));
var VisualFormBuilderComponent = _VisualFormBuilderComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(VisualFormBuilderComponent, [{
    type: Component,
    args: [{ selector: "app-visual-form-builder", standalone: true, imports: [CommonModule, ReactiveFormsModule, DragDropModule], template: `<div class="form-builder h-full flex bg-gray-50">
  <!-- Painel Esquerdo - Tipos de Campo -->
  <div class="w-64 bg-white border-r border-gray-200 flex flex-col">
    <div class="p-4 border-b border-gray-200">
      <h3 class="text-sm font-semibold text-gray-900 uppercase tracking-wide">Tipos de Campo</h3>
    </div>
    
    <div class="flex-1 p-3 space-y-2 overflow-y-auto">
      <div 
        *ngFor="let fieldType of fieldTypes"
        class="field-type-item p-3 border border-gray-300 rounded-lg cursor-pointer hover:border-blue-400 hover:bg-blue-50 transition-colors"
        (click)="selectFieldType(fieldType.value)"
        [class.selected]="selectedFieldType === fieldType.value">
        
        <div class="flex items-center space-x-3">
          <div class="w-8 h-8 bg-gray-100 rounded-md flex items-center justify-center">
            <i [class]="getFieldTypeIcon(fieldType.value)" class="text-gray-600 text-sm"></i>
          </div>
          <div>
            <div class="text-sm font-medium text-gray-900">{{ fieldType.label }}</div>
            <div class="text-xs text-gray-500">{{ getFieldTypeDescription(fieldType.value) }}</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Painel Central - Configura\xE7\xF5es -->
  <div class="w-80 bg-white border-r border-gray-200 flex flex-col">
    <div class="p-4 border-b border-gray-200">
      <h3 class="text-sm font-semibold text-gray-900 uppercase tracking-wide">
        {{ selectedField ? 'Propriedades do Campo' : 'Configura\xE7\xF5es' }}
      </h3>
    </div>
    
    <div class="flex-1 p-4 overflow-y-auto">
      <!-- Formul\xE1rio de Configura\xE7\xE3o -->
      <form [formGroup]="fieldsForm" *ngIf="selectedFieldType" class="space-y-4">
        <!-- Nome do Campo -->
        <div>
          <label class="block text-xs font-medium text-gray-700 mb-2 uppercase tracking-wide">
            Nome do Campo *
          </label>
          <input
            type="text"
            formControlName="name"
            class="w-full px-3 py-2 text-sm border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
            placeholder="Ex: nomeCompleto">
        </div>

        <!-- R\xF3tulo do Campo -->
        <div>
          <label class="block text-xs font-medium text-gray-700 mb-2 uppercase tracking-wide">
            R\xF3tulo do Campo *
          </label>
          <input
            type="text"
            formControlName="label"
            class="w-full px-3 py-2 text-sm border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
            placeholder="Ex: Nome Completo">
        </div>

        <!-- Placeholder -->
        <div *ngIf="!['radio', 'checkbox', 'temperatura', 'file'].includes(selectedFieldType)">
          <label class="block text-xs font-medium text-gray-700 mb-2 uppercase tracking-wide">
            Placeholder
          </label>
          <input
            type="text"
            formControlName="placeholder"
            class="w-full px-3 py-2 text-sm border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
            [placeholder]="getPlaceholderExample(selectedFieldType)">
        </div>

        <!-- Configura\xE7\xE3o especial para arquivo -->
        <div *ngIf="selectedFieldType === 'file'">
          <label class="block text-xs font-medium text-gray-700 mb-2 uppercase tracking-wide">
            Configura\xE7\xF5es do Arquivo
          </label>
          <label class="flex items-center space-x-2">
            <input
              type="checkbox"
              [checked]="fieldsForm.get('placeholder')?.value === 'multiple'"
              (change)="fieldsForm.patchValue({placeholder: $any($event.target).checked ? 'multiple' : ''})"
              class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded">
            <span class="text-sm text-gray-700">Permitir m\xFAltiplos arquivos</span>
          </label>
        </div>

        <!-- Op\xE7\xF5es (para select e radio) -->
        <div *ngIf="selectedFieldType === 'select' || selectedFieldType === 'radio'">
          <label class="block text-xs font-medium text-gray-700 mb-2 uppercase tracking-wide">
            Op\xE7\xF5es *
          </label>
          <textarea
            formControlName="options"
            rows="4"
            class="w-full px-3 py-2 text-sm border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
            placeholder="Digite uma op\xE7\xE3o por linha:&#10;Op\xE7\xE3o 1&#10;Op\xE7\xE3o 2&#10;Op\xE7\xE3o 3"></textarea>
          <div class="text-xs text-gray-500 mt-1">Uma op\xE7\xE3o por linha</div>
        </div>

        <!-- Informa\xE7\xE3o sobre campo Respons\xE1vel -->
        <div *ngIf="selectedFieldType === 'responsavel'" class="p-3 bg-blue-50 border border-blue-200 rounded-md">
          <div class="flex items-start">
            <i class="fas fa-info-circle text-blue-500 mr-2 mt-0.5"></i>
            <div class="text-sm text-blue-700">
              <strong>Campo Respons\xE1vel:</strong><br>
              Exibe uma lista com os usu\xE1rios da empresa para sele\xE7\xE3o do respons\xE1vel pelo registro.
            </div>
          </div>
        </div>

        <!-- Informa\xE7\xE3o sobre campo temperatura -->
        <div *ngIf="selectedFieldType === 'temperatura'" class="p-3 bg-blue-50 border border-blue-200 rounded-md">
          <div class="flex items-start">
            <i class="fas fa-info-circle text-blue-500 mr-2 mt-0.5"></i>
            <div class="text-sm text-blue-700">
              <strong>Campo Temperatura:</strong><br>
              Este campo criar\xE1 automaticamente uma lista suspensa com:
              <ul class="mt-2 space-y-1">
                <li>\u{1F525} <strong>Quente</strong> - Para leads com alta probabilidade</li>
                <li>\u{1F324}\uFE0F <strong>Morno</strong> - Para leads com m\xE9dia probabilidade</li>
                <li>\u2744\uFE0F <strong>Frio</strong> - Para leads com baixa probabilidade</li>
              </ul>
            </div>
          </div>
        </div>

        <!-- Valida\xE7\xF5es -->
        <div class="space-y-3">
          <h4 class="text-xs font-medium text-gray-700 uppercase tracking-wide">Valida\xE7\xF5es</h4>
          
          <!-- Campo Obrigat\xF3rio -->
          <label class="flex items-center space-x-2">
            <input
              type="checkbox"
              formControlName="required"
              class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded">
            <span class="text-sm text-gray-700">Campo obrigat\xF3rio</span>
          </label>
        </div>

        <!-- Configura\xE7\xF5es de API -->
        <div class="space-y-3">
          <h4 class="text-xs font-medium text-gray-700 uppercase tracking-wide">Integra\xE7\xE3o API</h4>
          
          <!-- Incluir na API -->
          <label class="flex items-center space-x-2">
            <input
              type="checkbox"
              formControlName="includeInApi"
              class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded">
            <span class="text-sm text-gray-700">Incluir este campo na API</span>
          </label>
          
          <!-- Op\xE7\xF5es de Exibi\xE7\xE3o -->
          <div class="bg-blue-50 border border-blue-200 rounded-md p-3 space-y-2">
            <p class="text-xs text-blue-700 font-medium mb-2">Op\xE7\xF5es de Exibi\xE7\xE3o</p>
            
            <!-- Exibir no Card -->
            <label class="flex items-center space-x-2">
              <input
                type="checkbox"
                formControlName="showInCard"
                class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded">
              <span class="text-sm text-gray-700">Exibir no card do registro</span>
            </label>

            <!-- Exibir em todas as fases -->
            <label class="flex items-center space-x-2">
              <input
                type="checkbox"
                formControlName="showInAllPhases"
                class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded">
              <span class="text-sm text-gray-700">Exibir em todas as fases</span>
            </label>

            <!-- Exibir nos filtros -->
            <label class="flex items-center space-x-2">
              <input
                type="checkbox"
                formControlName="showInFilters"
                class="h-4 w-4 text-purple-600 focus:ring-purple-500 border-gray-300 rounded">
              <span class="text-sm text-gray-700">Dispon\xEDvel para filtros</span>
            </label>
            
            <p class="text-xs text-blue-600 italic">
              \u{1F4A1} Campos vis\xEDveis no card s\xE3o automaticamente vis\xEDveis em todas as fases
            </p>
          </div>

          <!-- Obrigat\xF3rio para avan\xE7ar de fase -->
          <label class="flex items-center space-x-2">
            <input
              type="checkbox"
              formControlName="requiredToAdvance"
              class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded">
            <span class="text-sm text-gray-700">Obrigat\xF3rio para avan\xE7ar de fase</span>
          </label>
          
          <!-- Nome do campo na API -->
          <div *ngIf="fieldsForm.get('includeInApi')?.value">
            <label class="block text-xs font-medium text-gray-700 mb-2 uppercase tracking-wide">
              Nome na API (opcional)
            </label>
            <input
              type="text"
              formControlName="apiFieldName"
              class="w-full px-3 py-2 text-sm border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
              placeholder="Se vazio, usar\xE1 o nome do campo">
            <div class="text-xs text-gray-500 mt-1">Deixe vazio para usar o nome do campo</div>
          </div>
        </div>

        <!-- Bot\xF5es de A\xE7\xE3o -->
        <div class="pt-4 border-t border-gray-200 space-y-3">
          <button
            type="button"
            (click)="addField()"
            [disabled]="fieldsForm.invalid"
            class="w-full px-4 py-2 text-white text-sm rounded-lg disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
            [style.background-color]="getPrimaryColor()">
            {{ editingIndex >= 0 ? 'Atualizar Campo' : 'Adicionar Campo' }}
          </button>
          
          <button
            type="button"
            *ngIf="editingIndex >= 0"
            (click)="cancelEdit()"
            class="w-full px-4 py-2 border border-gray-300 text-gray-700 text-sm rounded-lg hover:bg-gray-50 transition-colors">
            Cancelar
          </button>
        </div>
      </form>

      <!-- Ajuda quando nenhum tipo selecionado -->
      <div *ngIf="!selectedFieldType" class="text-center py-8">
        <i class="fas fa-mouse-pointer text-gray-300 text-3xl mb-3"></i>
        <p class="text-sm text-gray-500">Selecione um tipo de campo \xE0 esquerda para come\xE7ar</p>
      </div>
    </div>
  </div>

  <!-- Painel Direito - Visualiza\xE7\xE3o -->
  <div class="flex-1 bg-gray-50 flex flex-col">
    <div class="p-4 bg-white border-b border-gray-200">
      <h3 class="text-sm font-semibold text-gray-900 uppercase tracking-wide">
        Visualiza\xE7\xE3o do Formul\xE1rio
      </h3>
    </div>
    
    <!-- Lista de Campos Configurados -->
    <div class="bg-white border-b border-gray-200 flex-shrink-0" *ngIf="fields.length > 0">
      <div class="px-4 py-2">
        <div class="flex items-center justify-between mb-2">
          <div class="text-xs text-gray-500 uppercase tracking-wide">
            Campos ({{ fields.length }})
          </div>
          <button 
            *ngIf="fields.length > 0"
            (click)="showApiSchema()"
            class="text-xs text-blue-500 hover:text-blue-700 flex items-center space-x-1"
            title="Ver Schema da API">
            <i class="fas fa-code"></i>
            <span>API</span>
          </button>
        </div>
        
        <div cdkDropList (cdkDropListDropped)="onDrop($event)" class="space-y-1 max-h-32 overflow-y-auto">
          <div
            *ngFor="let field of fields; let i = index"
            cdkDrag
            class="field-item flex items-center justify-between p-2 bg-gray-50 border border-gray-200 rounded text-xs hover:bg-gray-100 transition-colors">
            
            <div class="flex items-center space-x-2 flex-1">
              <div cdkDragHandle class="cursor-move text-gray-400">
                <i class="fas fa-grip-vertical"></i>
              </div>
              <i [class]="getFieldTypeIcon(field.type)" class="text-gray-500"></i>
              <span class="font-medium text-gray-900 truncate">{{ field.label }}</span>
              <span *ngIf="field.required" class="text-red-500 text-xs">*</span>
              <span *ngIf="field.includeInApi !== false" class="text-blue-500 text-xs" title="Inclu\xEDdo na API">
                <i class="fas fa-plug"></i>
              </span>
            </div>

            <div class="flex items-center space-x-1 flex-shrink-0">
              <button
                (click)="editField(i)"
                class="p-1 text-gray-400 hover:text-blue-500"
                title="Editar">
                <i class="fas fa-edit"></i>
              </button>
              <button
                (click)="openRemoveField(i)"
                class="p-1 text-gray-400 hover:text-red-500"
                title="Remover">
                <i class="fas fa-trash"></i>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Preview do Formul\xE1rio -->
    <div class="flex-1 p-6 overflow-y-auto">
      <!-- Estado vazio -->
      <div *ngIf="fields.length === 0" class="text-center py-16">
        <div class="w-16 h-16 bg-gray-200 rounded-full mx-auto mb-4 flex items-center justify-center">
          <i class="fas fa-wpforms text-gray-400 text-2xl"></i>
        </div>
        <h4 class="text-lg font-medium text-gray-900 mb-2">Formul\xE1rio Vazio</h4>
        <p class="text-gray-500 mb-4">Adicione campos \xE0 esquerda para ver a visualiza\xE7\xE3o aqui</p>
      </div>

      <!-- Preview com campos -->
      <div *ngIf="fields.length > 0" class="max-w-2xl mx-auto">
        <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
          <h4 class="text-lg font-semibold text-gray-900 mb-6">Pr\xE9-visualiza\xE7\xE3o</h4>
          
          <form class="space-y-6">
            <div *ngFor="let field of fields; let i = index" class="form-field" 
                 [class.bg-blue-50]="selectedField === field"
                 [class.border-blue-200]="selectedField === field"
                 [class.border]="selectedField === field"
                 [class.p-3]="selectedField === field"
                 [class.rounded]="selectedField === field"
                 (click)="selectField(field, i)">
              
              <label class="block text-sm font-medium text-gray-900 mb-2">
                {{ field.label }}
                <span *ngIf="field.required" class="text-red-500 ml-1">*</span>
              </label>

              <!-- Input Text, Email, Tel, Number, CNPJ, CPF -->
              <input
                *ngIf="['text', 'email', 'tel', 'number', 'date', 'time', 'cnpj', 'cpf'].includes(field.type)"
                [type]="field.type === 'cnpj' || field.type === 'cpf' ? 'text' : field.type"
                [placeholder]="field.placeholder || getPlaceholderExample(field.type)"
                [required]="field.required"
                disabled
                class="w-full px-3 py-2 border border-gray-300 rounded-md text-gray-500 bg-gray-50">

              <!-- Textarea -->
              <textarea
                *ngIf="field.type === 'textarea'"
                [placeholder]="field.placeholder || ''"
                [required]="field.required"
                disabled
                rows="3"
                class="w-full px-3 py-2 border border-gray-300 rounded-md resize-none text-gray-500 bg-gray-50">
              </textarea>

              <!-- Select -->
              <select
                *ngIf="field.type === 'select'"
                [required]="field.required"
                disabled
                class="w-full px-3 py-2 border border-gray-300 rounded-md text-gray-500 bg-gray-50">
                <option value="">Selecione uma op\xE7\xE3o</option>
                <option *ngFor="let option of field.options" [value]="option">
                  {{ option }}
                </option>
              </select>

              <!-- Campo Temperatura -->
              <select
                *ngIf="field.type === 'temperatura'"
                [required]="field.required"
                disabled
                class="w-full px-3 py-2 border border-gray-300 rounded-md text-gray-500 bg-gray-50">
                <option value="">Selecione a temperatura</option>
                <option *ngFor="let option of (field.options || ['Quente', 'Morno', 'Frio'])" [value]="option">
                  \u{1F321}\uFE0F {{ option }}
                  <span *ngIf="option === 'Quente'">\u{1F525}</span>
                  <span *ngIf="option === 'Morno'">\u{1F324}\uFE0F</span>
                  <span *ngIf="option === 'Frio'">\u2744\uFE0F</span>
                </option>
              </select>

              <!-- Radio Buttons -->
              <div *ngIf="field.type === 'radio'" class="space-y-2">
                <label *ngFor="let option of field.options; let j = index" class="flex items-center">
                  <input
                    type="radio"
                    [name]="field.name + '_preview'"
                    [value]="option"
                    [required]="field.required"
                    disabled
                    class="mr-2 text-gray-400">
                  <span class="text-gray-700">{{ option }}</span>
                </label>
              </div>

              <!-- Checkbox -->
              <label *ngIf="field.type === 'checkbox'" class="flex items-center">
                <input
                  type="checkbox"
                  [required]="field.required"
                  disabled
                  class="mr-2 text-gray-400">
                <span class="text-gray-700">{{ field.placeholder || 'Aceitar termos' }}</span>
              </label>

              <!-- File Upload -->
              <div *ngIf="field.type === 'file'">
                <input
                  type="file"
                  [multiple]="field.placeholder === 'multiple'"
                  [required]="field.required"
                  disabled
                  class="w-full px-3 py-2 border border-gray-300 rounded-md text-gray-500 bg-gray-50">
                <div class="text-xs text-gray-500 mt-1">
                  {{ field.placeholder === 'multiple' ? 'M\xFAltiplos arquivos permitidos' : 'Upload de arquivo' }}
                </div>
              </div>
            </div>
          </form>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal de confirma\xE7\xE3o de remo\xE7\xE3o de campo -->
  <div *ngIf="showDeleteConfirm" class="fixed inset-0 bg-black/50 flex items-center justify-center z-[60]" (click)="cancelRemoveField()">
    <div class="bg-white rounded-xl shadow-2xl w-full max-w-md p-6" (click)="$event.stopPropagation()">
      <h3 class="text-lg font-bold text-gray-900 mb-2">Remover campo</h3>
      <p class="text-sm text-gray-600 mb-6">Tem certeza que deseja remover este campo do formul\xE1rio?</p>
      <div class="flex justify-end gap-3">
        <button class="px-4 py-2 rounded-lg border border-gray-300" (click)="cancelRemoveField()">Cancelar</button>
        <button class="px-4 py-2 rounded-lg bg-red-600 text-white" (click)="confirmRemoveField()">Remover</button>
      </div>
    </div>
  </div>
</div>`, styles: ["/* src/app/components/visual-form-builder/visual-form-builder.scss */\n.form-builder {\n  height: 600px;\n}\n.form-builder .field-type-item {\n  transition: all 0.2s ease;\n}\n.form-builder .field-type-item:hover {\n  transform: translateY(-1px);\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n}\n.form-builder .field-type-item.selected {\n  border-color: #3B82F6;\n  background-color: #EBF4FF;\n  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);\n}\n.form-builder .field-item {\n  transition: all 0.2s ease;\n}\n.form-builder .field-item:hover {\n  background-color: #F3F4F6;\n  border-color: #D1D5DB;\n}\n.form-builder .form-field {\n  transition: all 0.2s ease;\n  cursor: pointer;\n}\n.form-builder .form-field:hover {\n  background-color: rgba(59, 130, 246, 0.02);\n}\n.form-builder .form-field label {\n  font-weight: 500;\n}\n.form-builder .form-field input:disabled,\n.form-builder .form-field textarea:disabled,\n.form-builder .form-field select:disabled {\n  cursor: pointer;\n}\n.form-builder .cdk-drag-preview {\n  box-sizing: border-box;\n  border-radius: 6px;\n  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);\n  background: white;\n  transform: rotate(5deg);\n}\n.form-builder .cdk-drag-placeholder {\n  opacity: 0.4;\n  background: #E5E7EB;\n  border: 2px dashed #9CA3AF;\n}\n.form-builder .cdk-drag-animating {\n  transition: transform 250ms cubic-bezier(0, 0, 0.2, 1);\n}\n.form-builder .cdk-drop-list-dragging .cdk-drag:not(.cdk-drag-placeholder) {\n  transition: transform 250ms cubic-bezier(0, 0, 0.2, 1);\n}\n.form-builder .cdk-drag-handle {\n  transition: color 0.2s ease;\n}\n.form-builder .cdk-drag-handle:hover {\n  color: #3B82F6 !important;\n}\n.form-builder .panel-header {\n  background:\n    linear-gradient(\n      to right,\n      #F9FAFB,\n      #F3F4F6);\n}\n.form-builder .overflow-y-auto::-webkit-scrollbar {\n  width: 4px;\n}\n.form-builder .overflow-y-auto::-webkit-scrollbar-track {\n  background: #F1F5F9;\n}\n.form-builder .overflow-y-auto::-webkit-scrollbar-thumb {\n  background: #CBD5E1;\n  border-radius: 2px;\n}\n.form-builder .overflow-y-auto::-webkit-scrollbar-thumb:hover {\n  background: #94A3B8;\n}\nbutton {\n  transition: all 0.2s ease;\n}\nbutton:hover:not(:disabled) {\n  transform: translateY(-1px);\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n}\nbutton:active:not(:disabled) {\n  transform: translateY(0);\n}\n.selected-field {\n  animation: pulse-blue 2s infinite;\n}\n@keyframes pulse-blue {\n  0%, 100% {\n    box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4);\n  }\n  50% {\n    box-shadow: 0 0 0 8px rgba(59, 130, 246, 0);\n  }\n}\n@media (max-width: 1024px) {\n  .form-builder .w-64 {\n    width: 200px;\n  }\n  .form-builder .w-80 {\n    width: 240px;\n  }\n}\n@media (max-width: 768px) {\n  .form-builder {\n    flex-direction: column;\n    height: auto;\n  }\n  .form-builder .w-64,\n  .form-builder .w-80 {\n    width: 100%;\n    max-height: 300px;\n  }\n}\n/*# sourceMappingURL=visual-form-builder.css.map */\n"] }]
  }], () => [], { fields: [{
    type: Input
  }], fieldsChanged: [{
    type: Output
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(VisualFormBuilderComponent, { className: "VisualFormBuilderComponent", filePath: "src/app/components/visual-form-builder/visual-form-builder.ts", lineNumber: 30 });
})();

// src/app/components/phase-form-modal/phase-form-modal.component.ts
var _c04 = ["formBuilder"];
var _PhaseFormModalComponent = class _PhaseFormModalComponent {
  firestoreService = inject(FirestoreService);
  subdomainService = inject(SubdomainService);
  ownerId = "";
  boardId = "";
  formConfigSaved = new EventEmitter();
  closeModal = new EventEmitter();
  formBuilderComponent;
  isVisible = false;
  isSaving = false;
  currentColumn = null;
  currentConfig = null;
  formFields = [];
  showModal(column, existingConfig) {
    this.currentColumn = column;
    this.currentConfig = existingConfig;
    this.isVisible = true;
    if (existingConfig && existingConfig.fields) {
      this.formFields = existingConfig.fields.map((field) => {
        if (field.type === "temperatura" && (!field.options || field.options.length === 0)) {
          field.options = ["Quente", "Morno", "Frio"];
        }
        return __spreadProps(__spreadValues({}, field), {
          includeInApi: field.includeInApi !== false,
          // Default to true
          showInCard: field.showInCard || false,
          // Default to false
          requiredToAdvance: !!field.requiredToAdvance,
          showInAllPhases: !!field.showInAllPhases,
          order: field.order || 0
        });
      }).sort((a, b) => (a.order || 0) - (b.order || 0));
    } else {
      this.formFields = [];
    }
  }
  onFieldsChanged(fields) {
    this.formFields = fields;
  }
  saveFormConfig() {
    return __async(this, null, function* () {
      if (!this.currentColumn || !this.ownerId || !this.boardId) {
        console.error("Dados necess\xE1rios n\xE3o fornecidos");
        return;
      }
      this.isSaving = true;
      try {
        const config = {
          columnId: this.currentColumn.id,
          columnName: this.currentColumn.name,
          fields: this.formFields.map((field, index) => {
            const cleanField = {
              name: field.name || "",
              label: field.label || "",
              type: field.type || "text",
              required: field.required || false,
              order: index,
              includeInApi: field.includeInApi !== false,
              showInCard: field.showInCard || false,
              requiredToAdvance: !!field.requiredToAdvance,
              showInAllPhases: !!field.showInAllPhases,
              showInFilters: !!field.showInFilters
            };
            if (field.placeholder && field.placeholder.trim()) {
              cleanField.placeholder = field.placeholder.trim();
            }
            if (field.apiFieldName && field.apiFieldName.trim()) {
              cleanField.apiFieldName = field.apiFieldName.trim();
            }
            if (field.options && Array.isArray(field.options) && field.options.length > 0) {
              cleanField.options = field.options;
            }
            if (field.type === "temperatura" && (!field.options || field.options.length === 0)) {
              cleanField.options = ["Quente", "Morno", "Frio"];
            }
            return cleanField;
          }),
          createdAt: this.currentConfig ? this.currentConfig.createdAt : /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        if (this.currentConfig && this.currentConfig.id) {
          yield this.firestoreService.updatePhaseFormConfig(this.ownerId, this.boardId, this.currentConfig.id, config);
        } else {
          yield this.firestoreService.createPhaseFormConfig(this.ownerId, this.boardId, config);
        }
        console.log("\u2705 Configura\xE7\xE3o do formul\xE1rio salva com sucesso");
        this.formConfigSaved.emit();
        this.hideModal();
      } catch (error) {
        console.error("\u274C Erro ao salvar configura\xE7\xE3o do formul\xE1rio:", error);
        alert("Erro ao salvar configura\xE7\xE3o. Tente novamente.");
      } finally {
        this.isSaving = false;
      }
    });
  }
  hideModal() {
    this.isVisible = false;
    this.currentColumn = null;
    this.currentConfig = null;
    this.formFields = [];
  }
  onCloseModal() {
    this.hideModal();
    this.closeModal.emit();
  }
  getPrimaryColor() {
    const company = this.subdomainService.getCurrentCompany();
    return company?.primaryColor || company?.brandingConfig?.primaryColor || "#3B82F6";
  }
};
__name(_PhaseFormModalComponent, "PhaseFormModalComponent");
__publicField(_PhaseFormModalComponent, "\u0275fac", /* @__PURE__ */ __name(function PhaseFormModalComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _PhaseFormModalComponent)();
}, "PhaseFormModalComponent_Factory"));
__publicField(_PhaseFormModalComponent, "\u0275cmp", /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PhaseFormModalComponent, selectors: [["app-phase-form-modal"]], viewQuery: /* @__PURE__ */ __name(function PhaseFormModalComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(_c04, 5);
  }
  if (rf & 2) {
    let _t;
    \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.formBuilderComponent = _t.first);
  }
}, "PhaseFormModalComponent_Query"), inputs: { ownerId: "ownerId", boardId: "boardId" }, outputs: { formConfigSaved: "formConfigSaved", closeModal: "closeModal" }, decls: 14, vars: 8, consts: [["formBuilder", ""], [1, "fixed", "inset-0", "bg-black", "bg-opacity-50", "flex", "items-center", "justify-center", "z-50", 3, "click"], [1, "bg-white", "rounded-lg", "p-6", "w-full", "max-w-7xl", "max-h-[95vh]", "overflow-hidden", 3, "click"], [1, "flex", "justify-between", "items-center", "mb-4"], [1, "text-xl", "font-bold", "text-gray-800"], [1, "text-gray-500", "hover:text-gray-700", 3, "click"], [1, "fas", "fa-times", "text-xl"], [3, "fieldsChanged", "fields"], [1, "flex", "justify-end", "space-x-3", "mt-6", "pt-4", "border-t"], ["type", "button", 1, "px-4", "py-2", "border", "border-gray-300", "text-gray-700", "rounded-lg", "hover:bg-gray-50", "transition-colors", 3, "click"], ["type", "button", 1, "px-4", "py-2", "text-white", "rounded-lg", "transition-colors", "disabled:opacity-50", "disabled:cursor-not-allowed", 3, "click", "disabled"]], template: /* @__PURE__ */ __name(function PhaseFormModalComponent_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 1);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function PhaseFormModalComponent_Template_div_click_0_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onCloseModal());
    }, "PhaseFormModalComponent_Template_div_click_0_listener"));
    \u0275\u0275elementStart(1, "div", 2);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function PhaseFormModalComponent_Template_div_click_1_listener($event) {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView($event.stopPropagation());
    }, "PhaseFormModalComponent_Template_div_click_1_listener"));
    \u0275\u0275elementStart(2, "div", 3)(3, "h2", 4);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "button", 5);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function PhaseFormModalComponent_Template_button_click_5_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onCloseModal());
    }, "PhaseFormModalComponent_Template_button_click_5_listener"));
    \u0275\u0275element(6, "i", 6);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(7, "app-visual-form-builder", 7, 0);
    \u0275\u0275listener("fieldsChanged", /* @__PURE__ */ __name(function PhaseFormModalComponent_Template_app_visual_form_builder_fieldsChanged_7_listener($event) {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onFieldsChanged($event));
    }, "PhaseFormModalComponent_Template_app_visual_form_builder_fieldsChanged_7_listener"));
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "div", 8)(10, "button", 9);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function PhaseFormModalComponent_Template_button_click_10_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onCloseModal());
    }, "PhaseFormModalComponent_Template_button_click_10_listener"));
    \u0275\u0275text(11, " Cancelar ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(12, "button", 10);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function PhaseFormModalComponent_Template_button_click_12_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.saveFormConfig());
    }, "PhaseFormModalComponent_Template_button_click_12_listener"));
    \u0275\u0275text(13);
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    \u0275\u0275classProp("hidden", !ctx.isVisible);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" Configurar Formul\xE1rio da Fase: ", ctx.currentColumn == null ? null : ctx.currentColumn.name, " ");
    \u0275\u0275advance(3);
    \u0275\u0275property("fields", ctx.formFields);
    \u0275\u0275advance(5);
    \u0275\u0275styleProp("background-color", ctx.getPrimaryColor());
    \u0275\u0275property("disabled", ctx.isSaving);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx.isSaving ? "Salvando..." : "Salvar Configura\xE7\xE3o", " ");
  }
}, "PhaseFormModalComponent_Template"), dependencies: [CommonModule, ReactiveFormsModule, VisualFormBuilderComponent], styles: ["\n\n[_nghost-%COMP%] {\n  display: block;\n}\n/*# sourceMappingURL=phase-form-modal.component.css.map */"] }));
var PhaseFormModalComponent = _PhaseFormModalComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PhaseFormModalComponent, [{
    type: Component,
    args: [{ selector: "app-phase-form-modal", standalone: true, imports: [CommonModule, ReactiveFormsModule, VisualFormBuilderComponent], template: `
    <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" 
         [class.hidden]="!isVisible" (click)="onCloseModal()">
      <div class="bg-white rounded-lg p-6 w-full max-w-7xl max-h-[95vh] overflow-hidden" 
           (click)="$event.stopPropagation()">
        
        <div class="flex justify-between items-center mb-4">
          <h2 class="text-xl font-bold text-gray-800">
            Configurar Formul\xE1rio da Fase: {{ currentColumn?.name }}
          </h2>
          <button (click)="onCloseModal()" class="text-gray-500 hover:text-gray-700">
            <i class="fas fa-times text-xl"></i>
          </button>
        </div>

        <!-- Visual Form Builder -->
        <app-visual-form-builder
          #formBuilder
          [fields]="formFields"
          (fieldsChanged)="onFieldsChanged($event)">
        </app-visual-form-builder>

        <!-- Action Buttons -->
        <div class="flex justify-end space-x-3 mt-6 pt-4 border-t">
          <button
            type="button"
            (click)="onCloseModal()"
            class="px-4 py-2 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50 transition-colors">
            Cancelar
          </button>
          <button
            type="button"
            (click)="saveFormConfig()"
            [disabled]="isSaving"
            class="px-4 py-2 text-white rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
            [style.background-color]="getPrimaryColor()">
            {{ isSaving ? 'Salvando...' : 'Salvar Configura\xE7\xE3o' }}
          </button>
        </div>
      </div>
    </div>
  `, styles: ["/* angular:styles/component:scss;219558ef63f119a92210704329b58a3cdceaa4fb296db559e672f74512827dc7;/Users/geovanelopes/Documents/GitHub/kanban-angular-saas/src/app/components/phase-form-modal/phase-form-modal.component.ts */\n:host {\n  display: block;\n}\n/*# sourceMappingURL=phase-form-modal.component.css.map */\n"] }]
  }], null, { ownerId: [{
    type: Input
  }], boardId: [{
    type: Input
  }], formConfigSaved: [{
    type: Output
  }], closeModal: [{
    type: Output
  }], formBuilderComponent: [{
    type: ViewChild,
    args: ["formBuilder"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PhaseFormModalComponent, { className: "PhaseFormModalComponent", filePath: "src/app/components/phase-form-modal/phase-form-modal.component.ts", lineNumber: 60 });
})();

// src/app/components/lead-detail-modal/lead-detail-modal.component.ts
var _c05 = /* @__PURE__ */ __name(() => ({ standalone: true }), "_c0");
var _c13 = /* @__PURE__ */ __name(() => ["Quente", "Morno", "Frio"], "_c1");
var _c22 = /* @__PURE__ */ __name(() => [], "_c2");
function LeadDetailModalComponent_div_0_div_13_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 43)(1, "span", 44);
    \u0275\u0275text(2, "ID: ");
    \u0275\u0275elementStart(3, "span", 45);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(5, "button", 46);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function LeadDetailModalComponent_div_0_div_13_Template_button_click_5_listener() {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.copyLeadId());
    }, "LeadDetailModalComponent_div_0_div_13_Template_button_click_5_listener"));
    \u0275\u0275text(6, "Copiar");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(ctx_r1.currentLead == null ? null : ctx_r1.currentLead.id);
  }
}
__name(LeadDetailModalComponent_div_0_div_13_Template, "LeadDetailModalComponent_div_0_div_13_Template");
function LeadDetailModalComponent_div_0_div_15_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 47)(1, "div", 48);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "div", 49);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const field_r4 = ctx.$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(field_r4.label);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(field_r4.value);
  }
}
__name(LeadDetailModalComponent_div_0_div_15_Template, "LeadDetailModalComponent_div_0_div_15_Template");
function LeadDetailModalComponent_div_0_div_19_div_1_span_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 65);
    \u0275\u0275text(1, "ATUAL");
    \u0275\u0275elementEnd();
  }
}
__name(LeadDetailModalComponent_div_0_div_19_div_1_span_6_Template, "LeadDetailModalComponent_div_0_div_19_div_1_span_6_Template");
function LeadDetailModalComponent_div_0_div_19_div_1_div_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 60);
    \u0275\u0275element(1, "i", 66);
    \u0275\u0275elementStart(2, "span");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const phase_r5 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1("Sa\xEDda: ", phase_r5.exitedAt);
  }
}
__name(LeadDetailModalComponent_div_0_div_19_div_1_div_14_Template, "LeadDetailModalComponent_div_0_div_19_div_1_div_14_Template");
function LeadDetailModalComponent_div_0_div_19_div_1_div_19_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 67);
    \u0275\u0275element(1, "i", 68);
    \u0275\u0275elementEnd();
  }
}
__name(LeadDetailModalComponent_div_0_div_19_div_1_div_19_Template, "LeadDetailModalComponent_div_0_div_19_div_1_div_19_Template");
function LeadDetailModalComponent_div_0_div_19_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 52)(1, "div", 53)(2, "div", 54);
    \u0275\u0275element(3, "div", 55);
    \u0275\u0275elementStart(4, "span", 56);
    \u0275\u0275text(5);
    \u0275\u0275elementEnd();
    \u0275\u0275template(6, LeadDetailModalComponent_div_0_div_19_div_1_span_6_Template, 2, 0, "span", 57);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "span", 58);
    \u0275\u0275text(8);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(9, "div", 59)(10, "div", 60);
    \u0275\u0275element(11, "i", 61);
    \u0275\u0275elementStart(12, "span");
    \u0275\u0275text(13);
    \u0275\u0275elementEnd()();
    \u0275\u0275template(14, LeadDetailModalComponent_div_0_div_19_div_1_div_14_Template, 4, 1, "div", 62);
    \u0275\u0275elementStart(15, "div", 60);
    \u0275\u0275element(16, "i", 63);
    \u0275\u0275elementStart(17, "span");
    \u0275\u0275text(18);
    \u0275\u0275elementEnd()()();
    \u0275\u0275template(19, LeadDetailModalComponent_div_0_div_19_div_1_div_19_Template, 2, 0, "div", 64);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const phase_r5 = ctx.$implicit;
    const i_r6 = ctx.index;
    const last_r7 = ctx.last;
    \u0275\u0275styleProp("border-left-color", phase_r5.phaseColor);
    \u0275\u0275classProp("bg-blue-50", phase_r5.isCurrentPhase)("bg-gray-50", !phase_r5.isCurrentPhase);
    \u0275\u0275advance(3);
    \u0275\u0275styleProp("background-color", phase_r5.phaseColor);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(phase_r5.phaseName);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", phase_r5.isCurrentPhase);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1("#", i_r6 + 1);
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate1("Entrada: ", phase_r5.enteredAt);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", phase_r5.exitedAt !== "Atual");
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1("Dura\xE7\xE3o: ", phase_r5.duration);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !last_r7);
  }
}
__name(LeadDetailModalComponent_div_0_div_19_div_1_Template, "LeadDetailModalComponent_div_0_div_19_div_1_Template");
function LeadDetailModalComponent_div_0_div_19_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 50);
    \u0275\u0275template(1, LeadDetailModalComponent_div_0_div_19_div_1_Template, 20, 15, "div", 51);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.getPhaseHistoryItems());
  }
}
__name(LeadDetailModalComponent_div_0_div_19_Template, "LeadDetailModalComponent_div_0_div_19_Template");
function LeadDetailModalComponent_div_0_ng_template_20_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 69);
    \u0275\u0275element(1, "i", 70);
    \u0275\u0275elementStart(2, "div");
    \u0275\u0275text(3, "Nenhum hist\xF3rico de fases dispon\xEDvel");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "div", 71);
    \u0275\u0275text(5, "O hist\xF3rico ser\xE1 registrado quando o lead for movido entre as fases");
    \u0275\u0275elementEnd()();
  }
}
__name(LeadDetailModalComponent_div_0_ng_template_20_Template, "LeadDetailModalComponent_div_0_ng_template_20_Template");
function LeadDetailModalComponent_div_0_div_23_ng_container_4_span_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 85);
    \u0275\u0275text(1, "*");
    \u0275\u0275elementEnd();
  }
}
__name(LeadDetailModalComponent_div_0_div_23_ng_container_4_span_4_Template, "LeadDetailModalComponent_div_0_div_23_ng_container_4_span_4_Template");
function LeadDetailModalComponent_div_0_div_23_ng_container_4_input_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "input", 86);
  }
  if (rf & 2) {
    const field_r9 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("type", field_r9.type)("formControlName", field_r9.name)("placeholder", field_r9.placeholder || "");
  }
}
__name(LeadDetailModalComponent_div_0_div_23_ng_container_4_input_5_Template, "LeadDetailModalComponent_div_0_div_23_ng_container_4_input_5_Template");
function LeadDetailModalComponent_div_0_div_23_ng_container_4_textarea_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "textarea", 87);
    \u0275\u0275text(1, "                ");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const field_r9 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("formControlName", field_r9.name)("placeholder", field_r9.placeholder || "");
  }
}
__name(LeadDetailModalComponent_div_0_div_23_ng_container_4_textarea_6_Template, "LeadDetailModalComponent_div_0_div_23_ng_container_4_textarea_6_Template");
function LeadDetailModalComponent_div_0_div_23_ng_container_4_input_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "input", 88);
  }
  if (rf & 2) {
    const field_r9 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("formControlName", field_r9.name)("placeholder", field_r9.placeholder || "");
  }
}
__name(LeadDetailModalComponent_div_0_div_23_ng_container_4_input_7_Template, "LeadDetailModalComponent_div_0_div_23_ng_container_4_input_7_Template");
function LeadDetailModalComponent_div_0_div_23_ng_container_4_input_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "input", 89);
  }
  if (rf & 2) {
    const field_r9 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("formControlName", field_r9.name);
  }
}
__name(LeadDetailModalComponent_div_0_div_23_ng_container_4_input_8_Template, "LeadDetailModalComponent_div_0_div_23_ng_container_4_input_8_Template");
function LeadDetailModalComponent_div_0_div_23_ng_container_4_select_9_option_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "option", 93);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const option_r10 = ctx.$implicit;
    \u0275\u0275property("value", option_r10);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(option_r10);
  }
}
__name(LeadDetailModalComponent_div_0_div_23_ng_container_4_select_9_option_3_Template, "LeadDetailModalComponent_div_0_div_23_ng_container_4_select_9_option_3_Template");
function LeadDetailModalComponent_div_0_div_23_ng_container_4_select_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "select", 90)(1, "option", 91);
    \u0275\u0275text(2, "Selecione...");
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, LeadDetailModalComponent_div_0_div_23_ng_container_4_select_9_option_3_Template, 2, 2, "option", 92);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const field_r9 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("formControlName", field_r9.name);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", field_r9.type === "temperatura" && (!field_r9.options || field_r9.options.length === 0) ? \u0275\u0275pureFunction0(2, _c13) : field_r9.options);
  }
}
__name(LeadDetailModalComponent_div_0_div_23_ng_container_4_select_9_Template, "LeadDetailModalComponent_div_0_div_23_ng_container_4_select_9_Template");
function LeadDetailModalComponent_div_0_div_23_ng_container_4_div_10_label_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "label", 96);
    \u0275\u0275element(1, "input", 97);
    \u0275\u0275elementStart(2, "span");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const opt_r11 = ctx.$implicit;
    const field_r9 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("value", (opt_r11 == null ? null : opt_r11.value) ?? opt_r11)("formControlName", field_r9.name);
    \u0275\u0275attribute("name", field_r9.name);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate((opt_r11 == null ? null : opt_r11.label) ?? opt_r11);
  }
}
__name(LeadDetailModalComponent_div_0_div_23_ng_container_4_div_10_label_1_Template, "LeadDetailModalComponent_div_0_div_23_ng_container_4_div_10_label_1_Template");
function LeadDetailModalComponent_div_0_div_23_ng_container_4_div_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 94);
    \u0275\u0275template(1, LeadDetailModalComponent_div_0_div_23_ng_container_4_div_10_label_1_Template, 4, 4, "label", 95);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const field_r9 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", field_r9.options || \u0275\u0275pureFunction0(1, _c22));
  }
}
__name(LeadDetailModalComponent_div_0_div_23_ng_container_4_div_10_Template, "LeadDetailModalComponent_div_0_div_23_ng_container_4_div_10_Template");
function LeadDetailModalComponent_div_0_div_23_ng_container_4_select_11_option_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "option", 93);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const u_r12 = ctx.$implicit;
    \u0275\u0275property("value", u_r12.uid);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(u_r12.displayName || u_r12.email);
  }
}
__name(LeadDetailModalComponent_div_0_div_23_ng_container_4_select_11_option_3_Template, "LeadDetailModalComponent_div_0_div_23_ng_container_4_select_11_option_3_Template");
function LeadDetailModalComponent_div_0_div_23_ng_container_4_select_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "select", 90)(1, "option", 91);
    \u0275\u0275text(2, "Selecione o respons\xE1vel...");
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, LeadDetailModalComponent_div_0_div_23_ng_container_4_select_11_option_3_Template, 2, 2, "option", 92);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const field_r9 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("formControlName", field_r9.name);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", ctx_r1.users);
  }
}
__name(LeadDetailModalComponent_div_0_div_23_ng_container_4_select_11_Template, "LeadDetailModalComponent_div_0_div_23_ng_container_4_select_11_Template");
function LeadDetailModalComponent_div_0_div_23_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div", 76)(2, "label", 77);
    \u0275\u0275text(3);
    \u0275\u0275template(4, LeadDetailModalComponent_div_0_div_23_ng_container_4_span_4_Template, 2, 0, "span", 78);
    \u0275\u0275elementEnd();
    \u0275\u0275template(5, LeadDetailModalComponent_div_0_div_23_ng_container_4_input_5_Template, 1, 3, "input", 79)(6, LeadDetailModalComponent_div_0_div_23_ng_container_4_textarea_6_Template, 2, 2, "textarea", 80)(7, LeadDetailModalComponent_div_0_div_23_ng_container_4_input_7_Template, 1, 2, "input", 81)(8, LeadDetailModalComponent_div_0_div_23_ng_container_4_input_8_Template, 1, 1, "input", 82)(9, LeadDetailModalComponent_div_0_div_23_ng_container_4_select_9_Template, 4, 3, "select", 83)(10, LeadDetailModalComponent_div_0_div_23_ng_container_4_div_10_Template, 2, 2, "div", 84)(11, LeadDetailModalComponent_div_0_div_23_ng_container_4_select_11_Template, 4, 2, "select", 83);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const field_r9 = ctx.$implicit;
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", field_r9.label, " ");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r9.required);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r9.type === "text" || field_r9.type === "email" || field_r9.type === "tel" || field_r9.type === "url" || field_r9.type === "cpf" || field_r9.type === "cnpj");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r9.type === "textarea");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r9.type === "number");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r9.type === "date");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r9.type === "select" || field_r9.type === "temperatura");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r9.type === "radio");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r9.type === "responsavel");
  }
}
__name(LeadDetailModalComponent_div_0_div_23_ng_container_4_Template, "LeadDetailModalComponent_div_0_div_23_ng_container_4_Template");
function LeadDetailModalComponent_div_0_div_23_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 15)(1, "h3", 19);
    \u0275\u0275text(2, "Formul\xE1rio da Fase Atual");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "form", 72);
    \u0275\u0275listener("ngSubmit", /* @__PURE__ */ __name(function LeadDetailModalComponent_div_0_div_23_Template_form_ngSubmit_3_listener() {
      \u0275\u0275restoreView(_r8);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.saveChanges());
    }, "LeadDetailModalComponent_div_0_div_23_Template_form_ngSubmit_3_listener"));
    \u0275\u0275template(4, LeadDetailModalComponent_div_0_div_23_ng_container_4_Template, 12, 9, "ng-container", 73);
    \u0275\u0275elementStart(5, "div", 74)(6, "button", 75);
    \u0275\u0275text(7);
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(3);
    \u0275\u0275property("formGroup", ctx_r1.leadForm);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.currentFormFields);
    \u0275\u0275advance(2);
    \u0275\u0275property("disabled", ctx_r1.isSaving || ctx_r1.isLoading);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.isSaving ? "Salvando..." : "Salvar altera\xE7\xF5es", " ");
  }
}
__name(LeadDetailModalComponent_div_0_div_23_Template, "LeadDetailModalComponent_div_0_div_23_Template");
function LeadDetailModalComponent_div_0_ng_template_24_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 98);
    \u0275\u0275text(1, " Nenhum campo configurado para esta fase. ");
    \u0275\u0275elementEnd();
  }
}
__name(LeadDetailModalComponent_div_0_ng_template_24_Template, "LeadDetailModalComponent_div_0_ng_template_24_Template");
function LeadDetailModalComponent_div_0_div_35_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 99);
  }
}
__name(LeadDetailModalComponent_div_0_div_35_Template, "LeadDetailModalComponent_div_0_div_35_Template");
function LeadDetailModalComponent_div_0_span_43_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 100);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r1.attachmentPreview);
  }
}
__name(LeadDetailModalComponent_div_0_span_43_Template, "LeadDetailModalComponent_div_0_span_43_Template");
function LeadDetailModalComponent_div_0_button_48_Template(rf, ctx) {
  if (rf & 1) {
    const _r14 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 101);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function LeadDetailModalComponent_div_0_button_48_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r14);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.clearAttachment());
    }, "LeadDetailModalComponent_div_0_button_48_Template_button_click_0_listener"));
    \u0275\u0275text(1, "Limpar");
    \u0275\u0275elementEnd();
  }
}
__name(LeadDetailModalComponent_div_0_button_48_Template, "LeadDetailModalComponent_div_0_button_48_Template");
function LeadDetailModalComponent_div_0_div_53_div_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 109)(1, "a", 110);
    \u0275\u0275element(2, "i", 111);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const activity_r15 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("href", activity_r15.attachment.url, \u0275\u0275sanitizeUrl);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", activity_r15.attachment.name, " ");
  }
}
__name(LeadDetailModalComponent_div_0_div_53_div_8_Template, "LeadDetailModalComponent_div_0_div_53_div_8_Template");
function LeadDetailModalComponent_div_0_div_53_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 102)(1, "div", 103);
    \u0275\u0275element(2, "i", 104);
    \u0275\u0275elementStart(3, "span", 105);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "span", 106);
    \u0275\u0275text(6);
    \u0275\u0275elementEnd()();
    \u0275\u0275element(7, "div", 107);
    \u0275\u0275template(8, LeadDetailModalComponent_div_0_div_53_div_8_Template, 4, 2, "div", 108);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const activity_r15 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(2);
    \u0275\u0275classMap(ctx_r1.getActivityIcon(activity_r15.type));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(activity_r15.user);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r1.formatDateTime(activity_r15.timestamp));
    \u0275\u0275advance();
    \u0275\u0275property("innerHTML", activity_r15.text, \u0275\u0275sanitizeHtml);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", activity_r15.attachment);
  }
}
__name(LeadDetailModalComponent_div_0_div_53_Template, "LeadDetailModalComponent_div_0_div_53_Template");
function LeadDetailModalComponent_div_0_div_59_button_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r16 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 116);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function LeadDetailModalComponent_div_0_div_59_button_4_Template_button_click_0_listener() {
      const phase_r17 = \u0275\u0275restoreView(_r16).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.moveLead(phase_r17.id));
    }, "LeadDetailModalComponent_div_0_div_59_button_4_Template_button_click_0_listener"));
    \u0275\u0275element(1, "div", 117);
    \u0275\u0275elementStart(2, "span", 105);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const phase_r17 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("disabled", ctx_r1.isLoading);
    \u0275\u0275advance();
    \u0275\u0275styleProp("background-color", phase_r17.color);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(phase_r17.name);
  }
}
__name(LeadDetailModalComponent_div_0_div_59_button_4_Template, "LeadDetailModalComponent_div_0_div_59_button_4_Template");
function LeadDetailModalComponent_div_0_div_59_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 112)(1, "h4", 113);
    \u0275\u0275text(2, "\u{1F680} Avan\xE7ar para:");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "div", 114);
    \u0275\u0275template(4, LeadDetailModalComponent_div_0_div_59_button_4_Template, 4, 4, "button", 115);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(4);
    \u0275\u0275property("ngForOf", ctx_r1.getAdvancePhases());
  }
}
__name(LeadDetailModalComponent_div_0_div_59_Template, "LeadDetailModalComponent_div_0_div_59_Template");
function LeadDetailModalComponent_div_0_div_60_button_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r18 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 121);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function LeadDetailModalComponent_div_0_div_60_button_4_Template_button_click_0_listener() {
      const phase_r19 = \u0275\u0275restoreView(_r18).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.moveLead(phase_r19.id));
    }, "LeadDetailModalComponent_div_0_div_60_button_4_Template_button_click_0_listener"));
    \u0275\u0275element(1, "div", 122);
    \u0275\u0275elementStart(2, "span");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const phase_r19 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("disabled", ctx_r1.isLoading);
    \u0275\u0275advance();
    \u0275\u0275styleProp("background-color", phase_r19.color);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(phase_r19.name);
  }
}
__name(LeadDetailModalComponent_div_0_div_60_button_4_Template, "LeadDetailModalComponent_div_0_div_60_button_4_Template");
function LeadDetailModalComponent_div_0_div_60_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 112)(1, "h4", 118);
    \u0275\u0275text(2, "\u{1F504} Retornar para:");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "div", 119);
    \u0275\u0275template(4, LeadDetailModalComponent_div_0_div_60_button_4_Template, 4, 4, "button", 120);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(4);
    \u0275\u0275property("ngForOf", ctx_r1.getRetreatPhases());
  }
}
__name(LeadDetailModalComponent_div_0_div_60_Template, "LeadDetailModalComponent_div_0_div_60_Template");
function LeadDetailModalComponent_div_0_div_61_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1, " Para avan\xE7ar, preencha os campos obrigat\xF3rios da fase. ");
    \u0275\u0275elementContainerEnd();
  }
}
__name(LeadDetailModalComponent_div_0_div_61_ng_container_1_Template, "LeadDetailModalComponent_div_0_div_61_ng_container_1_Template");
function LeadDetailModalComponent_div_0_div_61_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0, "Lead em fase final. N\xE3o \xE9 poss\xEDvel movimentar.");
  }
}
__name(LeadDetailModalComponent_div_0_div_61_ng_template_2_Template, "LeadDetailModalComponent_div_0_div_61_ng_template_2_Template");
function LeadDetailModalComponent_div_0_div_61_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 123);
    \u0275\u0275template(1, LeadDetailModalComponent_div_0_div_61_ng_container_1_Template, 2, 0, "ng-container", 124)(2, LeadDetailModalComponent_div_0_div_61_ng_template_2_Template, 1, 0, "ng-template", null, 3, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const finalPhaseMsg_r20 = \u0275\u0275reference(3);
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.hasRequiredToAdvance())("ngIfElse", finalPhaseMsg_r20);
  }
}
__name(LeadDetailModalComponent_div_0_div_61_Template, "LeadDetailModalComponent_div_0_div_61_Template");
function LeadDetailModalComponent_div_0_div_65_Template(rf, ctx) {
  if (rf & 1) {
    const _r21 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 125)(1, "p", 126);
    \u0275\u0275text(2, "Compartilhe este link para permitir edi\xE7\xE3o externa:");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "div", 127);
    \u0275\u0275element(4, "input", 128);
    \u0275\u0275elementStart(5, "button", 129);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function LeadDetailModalComponent_div_0_div_65_Template_button_click_5_listener() {
      \u0275\u0275restoreView(_r21);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.copyPublicLink());
    }, "LeadDetailModalComponent_div_0_div_65_Template_button_click_5_listener"));
    \u0275\u0275element(6, "i", 130);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(4);
    \u0275\u0275property("value", ctx_r1.publicLink);
  }
}
__name(LeadDetailModalComponent_div_0_div_65_Template, "LeadDetailModalComponent_div_0_div_65_Template");
function LeadDetailModalComponent_div_0_div_66_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 131);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.errorMessage, " ");
  }
}
__name(LeadDetailModalComponent_div_0_div_66_Template, "LeadDetailModalComponent_div_0_div_66_Template");
function LeadDetailModalComponent_div_0_div_67_Template(rf, ctx) {
  if (rf & 1) {
    const _r22 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 132);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function LeadDetailModalComponent_div_0_div_67_Template_div_click_0_listener() {
      \u0275\u0275restoreView(_r22);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.cancelDelete());
    }, "LeadDetailModalComponent_div_0_div_67_Template_div_click_0_listener"));
    \u0275\u0275elementStart(1, "div", 133);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function LeadDetailModalComponent_div_0_div_67_Template_div_click_1_listener($event) {
      \u0275\u0275restoreView(_r22);
      return \u0275\u0275resetView($event.stopPropagation());
    }, "LeadDetailModalComponent_div_0_div_67_Template_div_click_1_listener"));
    \u0275\u0275elementStart(2, "h3", 134);
    \u0275\u0275text(3, "Confirmar exclus\xE3o");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "p", 135);
    \u0275\u0275text(5, "Esta a\xE7\xE3o n\xE3o pode ser desfeita. Deseja realmente apagar este registro?");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "div", 136)(7, "button", 137);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function LeadDetailModalComponent_div_0_div_67_Template_button_click_7_listener() {
      \u0275\u0275restoreView(_r22);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.cancelDelete());
    }, "LeadDetailModalComponent_div_0_div_67_Template_button_click_7_listener"));
    \u0275\u0275text(8, "Cancelar");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "button", 138);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function LeadDetailModalComponent_div_0_div_67_Template_button_click_9_listener() {
      \u0275\u0275restoreView(_r22);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.confirmDelete());
    }, "LeadDetailModalComponent_div_0_div_67_Template_button_click_9_listener"));
    \u0275\u0275text(10, "Apagar");
    \u0275\u0275elementEnd()()()();
  }
}
__name(LeadDetailModalComponent_div_0_div_67_Template, "LeadDetailModalComponent_div_0_div_67_Template");
function LeadDetailModalComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 5);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function LeadDetailModalComponent_div_0_Template_div_click_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onBackdropClick($event));
    }, "LeadDetailModalComponent_div_0_Template_div_click_0_listener"));
    \u0275\u0275elementStart(1, "div", 6)(2, "div", 7)(3, "h2", 8);
    \u0275\u0275text(4, "Dados");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "div", 9)(6, "button", 10);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function LeadDetailModalComponent_div_0_Template_button_click_6_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.openDeleteConfirm());
    }, "LeadDetailModalComponent_div_0_Template_button_click_6_listener"));
    \u0275\u0275element(7, "i", 11);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "button", 12);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function LeadDetailModalComponent_div_0_Template_button_click_8_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.hide());
    }, "LeadDetailModalComponent_div_0_Template_button_click_8_listener"));
    \u0275\u0275text(9, " \xD7 ");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(10, "div", 13)(11, "div", 14)(12, "div", 15);
    \u0275\u0275template(13, LeadDetailModalComponent_div_0_div_13_Template, 7, 1, "div", 16);
    \u0275\u0275elementStart(14, "div", 17);
    \u0275\u0275template(15, LeadDetailModalComponent_div_0_div_15_Template, 5, 2, "div", 18);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(16, "div", 15)(17, "h3", 19);
    \u0275\u0275text(18, "Hist\xF3rico de Fases");
    \u0275\u0275elementEnd();
    \u0275\u0275template(19, LeadDetailModalComponent_div_0_div_19_Template, 2, 1, "div", 20)(20, LeadDetailModalComponent_div_0_ng_template_20_Template, 6, 0, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(22, "div", 21);
    \u0275\u0275template(23, LeadDetailModalComponent_div_0_div_23_Template, 8, 4, "div", 22)(24, LeadDetailModalComponent_div_0_ng_template_24_Template, 2, 0, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementStart(26, "div")(27, "h3", 19);
    \u0275\u0275text(28, "Coment\xE1rios");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(29, "div", 17)(30, "div")(31, "textarea", 23);
    \u0275\u0275twoWayListener("ngModelChange", /* @__PURE__ */ __name(function LeadDetailModalComponent_div_0_Template_textarea_ngModelChange_31_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.commentText, $event) || (ctx_r1.commentText = $event);
      return \u0275\u0275resetView($event);
    }, "LeadDetailModalComponent_div_0_Template_textarea_ngModelChange_31_listener"));
    \u0275\u0275text(32, "              ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(33, "div", 24)(34, "button", 25);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function LeadDetailModalComponent_div_0_Template_button_click_34_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.addComment());
    }, "LeadDetailModalComponent_div_0_Template_button_click_34_listener"));
    \u0275\u0275template(35, LeadDetailModalComponent_div_0_div_35_Template, 1, 0, "div", 26);
    \u0275\u0275element(36, "i", 27);
    \u0275\u0275text(37);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(38, "div")(39, "div", 9)(40, "button", 28);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function LeadDetailModalComponent_div_0_Template_button_click_40_listener() {
      \u0275\u0275restoreView(_r1);
      const fileInput_r13 = \u0275\u0275reference(45);
      return \u0275\u0275resetView(fileInput_r13.click());
    }, "LeadDetailModalComponent_div_0_Template_button_click_40_listener"));
    \u0275\u0275element(41, "i", 29);
    \u0275\u0275text(42, "Selecionar arquivo ");
    \u0275\u0275elementEnd();
    \u0275\u0275template(43, LeadDetailModalComponent_div_0_span_43_Template, 2, 1, "span", 30);
    \u0275\u0275elementStart(44, "input", 31, 2);
    \u0275\u0275listener("change", /* @__PURE__ */ __name(function LeadDetailModalComponent_div_0_Template_input_change_44_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onFileSelected($event));
    }, "LeadDetailModalComponent_div_0_Template_input_change_44_listener"));
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(46, "button", 32);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function LeadDetailModalComponent_div_0_Template_button_click_46_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.uploadAttachment());
    }, "LeadDetailModalComponent_div_0_Template_button_click_46_listener"));
    \u0275\u0275text(47);
    \u0275\u0275elementEnd();
    \u0275\u0275template(48, LeadDetailModalComponent_div_0_button_48_Template, 2, 0, "button", 33);
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(49, "div", 34)(50, "h3", 19);
    \u0275\u0275text(51, "Atividades Recentes");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(52, "div", 35);
    \u0275\u0275template(53, LeadDetailModalComponent_div_0_div_53_Template, 9, 6, "div", 36);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(54, "div", 37)(55, "div")(56, "div", 15)(57, "h3", 19);
    \u0275\u0275text(58, "Mover registro");
    \u0275\u0275elementEnd();
    \u0275\u0275template(59, LeadDetailModalComponent_div_0_div_59_Template, 5, 1, "div", 38)(60, LeadDetailModalComponent_div_0_div_60_Template, 5, 1, "div", 38)(61, LeadDetailModalComponent_div_0_div_61_Template, 4, 2, "div", 39);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(62, "div", 15)(63, "h3", 19);
    \u0275\u0275text(64, "Link P\xFAblico");
    \u0275\u0275elementEnd();
    \u0275\u0275template(65, LeadDetailModalComponent_div_0_div_65_Template, 7, 1, "div", 40);
    \u0275\u0275elementEnd()();
    \u0275\u0275template(66, LeadDetailModalComponent_div_0_div_66_Template, 2, 1, "div", 41);
    \u0275\u0275elementEnd()()();
    \u0275\u0275template(67, LeadDetailModalComponent_div_0_div_67_Template, 11, 0, "div", 42);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const noPhaseHistory_r23 = \u0275\u0275reference(21);
    const noPhaseForm_r24 = \u0275\u0275reference(25);
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(6);
    \u0275\u0275property("disabled", ctx_r1.isLoading || ctx_r1.isSaving);
    \u0275\u0275advance(2);
    \u0275\u0275property("disabled", ctx_r1.isLoading);
    \u0275\u0275advance(5);
    \u0275\u0275property("ngIf", ctx_r1.currentLead == null ? null : ctx_r1.currentLead.id);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx_r1.getInitialFields());
    \u0275\u0275advance(4);
    \u0275\u0275property("ngIf", ctx_r1.getPhaseHistoryItems().length > 0)("ngIfElse", noPhaseHistory_r23);
    \u0275\u0275advance(4);
    \u0275\u0275property("ngIf", ctx_r1.formReady && (ctx_r1.currentFormFields && ctx_r1.currentFormFields.length > 0))("ngIfElse", noPhaseForm_r24);
    \u0275\u0275advance(8);
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.commentText);
    \u0275\u0275property("ngModelOptions", \u0275\u0275pureFunction0(24, _c05));
    \u0275\u0275advance(3);
    \u0275\u0275property("disabled", ctx_r1.isUploadingComment || !ctx_r1.commentText.trim());
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.isUploadingComment);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", ctx_r1.isUploadingComment ? "Enviando..." : "Enviar coment\xE1rio", " ");
    \u0275\u0275advance(6);
    \u0275\u0275property("ngIf", ctx_r1.attachmentPreview);
    \u0275\u0275advance(3);
    \u0275\u0275property("disabled", ctx_r1.isUploadingAttachment || !ctx_r1.selectedFile);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.isUploadingAttachment ? "Anexando..." : "Enviar anexo", " ");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.selectedFile);
    \u0275\u0275advance(5);
    \u0275\u0275property("ngForOf", ctx_r1.getActivityLog());
    \u0275\u0275advance(6);
    \u0275\u0275property("ngIf", ctx_r1.getAdvancePhases().length > 0);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.getRetreatPhases().length > 0);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.getAdvancePhases().length === 0 && ctx_r1.getRetreatPhases().length === 0);
    \u0275\u0275advance(4);
    \u0275\u0275property("ngIf", ctx_r1.publicLink);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.errorMessage);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.showDeleteConfirm);
  }
}
__name(LeadDetailModalComponent_div_0_Template, "LeadDetailModalComponent_div_0_Template");
var _LeadDetailModalComponent = class _LeadDetailModalComponent {
  authService = inject(AuthService);
  firestoreService = inject(FirestoreService);
  storageService = inject(StorageService);
  subdomainService = inject(SubdomainService);
  fb = inject(FormBuilder);
  ownerId = "";
  boardId = "";
  columns = [];
  users = [];
  leadUpdated = new EventEmitter();
  leadDeleted = new EventEmitter();
  closeModal = new EventEmitter();
  isVisible = false;
  isLoading = false;
  isSaving = false;
  errorMessage = "";
  currentLead = null;
  formReady = false;
  leadHistory = [];
  phaseHistory = {};
  // Fluxo de transições (permitidas)
  flowConfig = { allowed: {} };
  // Form para atualização do lead
  leadForm = this.fb.group({});
  // Sistema de comentários
  commentText = "";
  selectedFile = null;
  attachmentPreview = "";
  isUploadingComment = false;
  isUploadingAttachment = false;
  showDeleteConfirm = false;
  // Link público
  publicLink = "";
  unsubscribeHistory = null;
  // Configuração do formulário inicial (somente leitura)
  initialFormConfig = null;
  show(lead) {
    return __async(this, null, function* () {
      this.currentLead = lead;
      this.isVisible = true;
      this.resetForm();
      yield this.loadLeadData();
      try {
        const values = {};
        (this.currentFormFields || []).forEach((f) => {
          const key = f.apiFieldName || f.name;
          values[f.name] = this.getFieldValue(key) ?? "";
        });
        if (Object.keys(values).length) {
          this.leadForm.patchValue(values, { emitEvent: false });
        }
      } catch {
      }
      try {
        if (this.unsubscribeHistory) {
          this.unsubscribeHistory();
          this.unsubscribeHistory = null;
        }
        this.unsubscribeHistory = this.firestoreService.subscribeToLeadHistory(this.ownerId, this.boardId, this.currentLead.id, (items) => {
          this.leadHistory = items;
        });
      } catch {
      }
    });
  }
  hide() {
    this.isVisible = false;
    this.resetForm();
    if (this.unsubscribeHistory) {
      this.unsubscribeHistory();
      this.unsubscribeHistory = null;
    }
    this.closeModal.emit();
  }
  resetForm() {
    this.leadForm = this.fb.group({});
    this.commentText = "";
    this.selectedFile = null;
    this.attachmentPreview = "";
    this.errorMessage = "";
    this.publicLink = "";
    this.leadHistory = [];
    this.phaseHistory = {};
    this.formReady = false;
  }
  loadLeadData() {
    return __async(this, null, function* () {
      if (!this.currentLead)
        return;
      try {
        try {
          const latest = yield this.firestoreService.getLead(this.ownerId, this.boardId, this.currentLead.id);
          if (latest) {
            this.currentLead = latest;
          }
        } catch {
        }
        const history = yield this.firestoreService.getLeadHistory(this.ownerId, this.boardId, this.currentLead.id);
        this.leadHistory = history;
        this.phaseHistory = this.currentLead.phaseHistory || {};
        this.initialFormConfig = yield this.firestoreService.getInitialFormConfig(this.boardId);
        try {
          const phaseCfg = yield this.firestoreService.getPhaseFormConfig(this.ownerId, this.boardId, this.currentLead.columnId);
          this.currentFormFields = phaseCfg?.fields || [];
        } catch (e) {
          console.warn("Sem configura\xE7\xE3o da fase atual, tentando formul\xE1rio inicial como fallback.", e);
          this.currentFormFields = (this.initialFormConfig?.fields || []).map((f) => __spreadValues({}, f));
        }
        try {
          const cfg = yield this.firestoreService.getFlowConfig(this.boardId);
          this.flowConfig = cfg || { allowed: {} };
        } catch {
          this.flowConfig = { allowed: {} };
        }
        yield this.buildDynamicForm();
        this.formReady = true;
        this.generatePublicLink();
      } catch (error) {
        console.error("Erro ao carregar dados do lead:", error);
        this.errorMessage = "Erro ao carregar dados do lead.";
      }
    });
  }
  buildDynamicForm() {
    return __async(this, null, function* () {
      if (!this.currentLead)
        return;
      const formConfig = {};
      this.formReady = false;
      (this.currentFormFields || []).forEach((field) => {
        const key = field.apiFieldName || field.name;
        let currentValue = this.getFieldValue(key);
        if (currentValue === void 0 || currentValue === null || typeof currentValue === "string" && currentValue.trim() === "") {
          currentValue = this.getFieldValue(field.name);
        }
        if (field.type === "temperatura") {
          const options = field.options && field.options.length ? field.options : ["Quente", "Morno", "Frio"];
          if (typeof currentValue === "string") {
            const match = options.find((o) => o.toLowerCase() === currentValue.toLowerCase());
            currentValue = match || "";
          }
        }
        if (field.type === "responsavel") {
          const responsibleId = this.currentLead?.responsibleUserId || currentValue;
          formConfig[field.name] = [responsibleId ?? ""];
        } else {
          formConfig[field.name] = [currentValue ?? ""];
        }
      });
      this.leadForm = this.fb.group(formConfig);
      this.formReady = true;
    });
  }
  getCurrentColumn() {
    if (!this.currentLead)
      return null;
    return this.columns.find((col) => col.id === this.currentLead.columnId) || null;
  }
  getInitialColumn() {
    return this.columns.find((col) => col.order === 0) || null;
  }
  getInitialFields() {
    if (this.initialFormConfig?.fields?.length) {
      const sorted = this.initialFormConfig.fields.sort((a, b) => (a.order || 0) - (b.order || 0));
      return sorted.map((f) => ({
        name: f.apiFieldName || f.name,
        label: f.label || f.name || f.apiFieldName,
        value: this.getFieldValue(f.apiFieldName || f.name) ?? this.getFieldValue(f.name) ?? "N\xE3o informado"
      }));
    }
    return this.buildDedupedDisplayFields();
  }
  currentFormFields = [];
  hasRequiredToAdvance() {
    try {
      return Array.isArray(this.currentFormFields) && this.currentFormFields.some((f) => !!f?.requiredToAdvance);
    } catch {
      return false;
    }
  }
  getPhaseHistoryItems() {
    console.log("\u{1F4CA} Gerando hist\xF3rico de fases:", {
      leadId: this.currentLead?.id,
      phaseHistory: this.phaseHistory,
      phaseHistoryKeys: Object.keys(this.phaseHistory || {}),
      phaseHistoryLength: Object.keys(this.phaseHistory || {}).length,
      availableColumns: this.columns.map((c) => ({ id: c.id, name: c.name }))
    });
    const items = [];
    Object.values(this.phaseHistory).forEach((phase) => {
      const column = this.columns.find((col) => col.id === phase.phaseId);
      console.log("\u{1F4CA} Processando fase:", {
        phaseId: phase.phaseId,
        columnFound: !!column,
        columnName: column?.name,
        phase
      });
      if (column) {
        const enteredAt = phase.enteredAt?.toDate ? phase.enteredAt.toDate() : new Date(phase.enteredAt);
        const exitedAt = phase.exitedAt?.toDate ? phase.exitedAt.toDate() : phase.exitedAt ? new Date(phase.exitedAt) : null;
        let duration = "";
        if (phase.duration) {
          const days = Math.floor(phase.duration / (1e3 * 60 * 60 * 24));
          const hours = Math.floor(phase.duration % (1e3 * 60 * 60 * 24) / (1e3 * 60 * 60));
          if (days > 0) {
            duration = `${days}d ${hours}h`;
          } else {
            duration = `${hours}h`;
          }
        } else if (!exitedAt) {
          const now = /* @__PURE__ */ new Date();
          const elapsed = now.getTime() - enteredAt.getTime();
          const days = Math.floor(elapsed / (1e3 * 60 * 60 * 24));
          const hours = Math.floor(elapsed % (1e3 * 60 * 60 * 24) / (1e3 * 60 * 60));
          if (days > 0) {
            duration = `${days}d ${hours}h (em andamento)`;
          } else {
            duration = `${hours}h (em andamento)`;
          }
        }
        const item = {
          phaseName: column.name,
          phaseColor: column.color,
          enteredAt: enteredAt.toLocaleString("pt-BR"),
          exitedAt: exitedAt?.toLocaleString("pt-BR") || "Atual",
          duration: duration || "Em andamento",
          isCurrentPhase: !exitedAt && this.currentLead?.columnId === phase.phaseId
        };
        console.log("\u{1F4CA} Item de hist\xF3rico criado:", item);
        items.push(item);
      }
    });
    console.log("\u{1F4CA} Total de itens processados:", items.length);
    if (items.length === 0 && this.currentLead) {
      console.log("\u{1F4CA} Nenhum hist\xF3rico encontrado, criando fallback para fase atual");
      const currentColumn = this.getCurrentColumn();
      if (currentColumn) {
        const enteredAt = this.currentLead.movedToCurrentColumnAt?.toDate && this.currentLead.movedToCurrentColumnAt.toDate() || this.currentLead.movedToCurrentColumnAt || this.currentLead.createdAt?.toDate && this.currentLead.createdAt.toDate() || this.currentLead.createdAt || /* @__PURE__ */ new Date();
        const fallbackItem = {
          phaseName: currentColumn.name,
          phaseColor: currentColumn.color,
          enteredAt: (enteredAt instanceof Date ? enteredAt : new Date(enteredAt)).toLocaleString("pt-BR"),
          exitedAt: "Atual",
          duration: "Em andamento",
          isCurrentPhase: true
        };
        console.log("\u{1F4CA} Item fallback criado:", fallbackItem);
        items.push(fallbackItem);
      }
    }
    const sortedItems = items.sort((a, b) => new Date(a.enteredAt).getTime() - new Date(b.enteredAt).getTime());
    console.log("\u{1F4CA} Itens finais ordenados:", sortedItems);
    return sortedItems;
  }
  getActivityLog() {
    return this.leadHistory.sort((a, b) => {
      const dateA = a.timestamp?.toDate ? a.timestamp.toDate() : new Date(a.timestamp);
      const dateB = b.timestamp?.toDate ? b.timestamp.toDate() : new Date(b.timestamp);
      return dateB.getTime() - dateA.getTime();
    });
  }
  getAvailablePhases() {
    const currentColumn = this.getCurrentColumn();
    if (!currentColumn)
      return [];
    if (currentColumn.endStageType && currentColumn.endStageType !== "none") {
      return [];
    }
    return this.columns.filter((col) => col.id !== currentColumn.id);
  }
  getAdvancePhases() {
    const currentColumn = this.getCurrentColumn();
    if (!currentColumn)
      return [];
    if (currentColumn.endStageType && currentColumn.endStageType !== "none") {
      return [];
    }
    const missing = (this.currentFormFields || []).filter((f) => {
      if (!f.requiredToAdvance)
        return false;
      const key = f.apiFieldName || f.name;
      const val = this.leadForm.get(f.name)?.value ?? this.getFieldValue(key);
      return val === void 0 || val === null || `${val}`.trim() === "";
    });
    if (missing.length) {
      return [];
    }
    const allowed = this.flowConfig.allowed[currentColumn.id] || [];
    return this.columns.filter((col) => col.id !== currentColumn.id && col.order > currentColumn.order).filter((col) => allowed.includes(col.id)).sort((a, b) => a.order - b.order);
  }
  getRetreatPhases() {
    const currentColumn = this.getCurrentColumn();
    if (!currentColumn)
      return [];
    if (currentColumn.order === 0)
      return [];
    const allowed = this.flowConfig.allowed[currentColumn.id] || [];
    return this.columns.filter((col) => col.id !== currentColumn.id && col.order < currentColumn.order).filter((col) => allowed.includes(col.id)).sort((a, b) => b.order - a.order);
  }
  saveChanges() {
    return __async(this, null, function* () {
      if (!this.currentLead || !this.leadForm.valid)
        return;
      this.isSaving = true;
      this.errorMessage = "";
      try {
        const formData = this.leadForm.value;
        const mapped = __spreadValues({}, formData);
        (this.currentFormFields || []).forEach((f) => {
          if (f.apiFieldName && f.apiFieldName !== f.name && mapped.hasOwnProperty(f.name)) {
            mapped[f.apiFieldName] = mapped[f.name];
            delete mapped[f.name];
          }
        });
        const currentUser = this.authService.getCurrentUser();
        if (!currentUser) {
          throw new Error("Usu\xE1rio n\xE3o autenticado");
        }
        const updateData = {
          fields: __spreadValues(__spreadValues({}, this.currentLead.fields), mapped)
        };
        const respFieldDef = (this.currentFormFields || []).find((f) => f.type === "responsavel");
        const respFieldName = respFieldDef?.name;
        const newRespId = respFieldName ? formData[respFieldName] : formData.responsibleUserId;
        if (newRespId && newRespId !== this.currentLead.responsibleUserId) {
          const selectedUser = this.users.find((u) => u.uid === newRespId);
          updateData.responsibleUserId = newRespId;
          updateData.responsibleUserName = selectedUser?.displayName || "";
          updateData.responsibleUserEmail = selectedUser?.email || "";
          yield this.firestoreService.addLeadHistory(this.ownerId, this.boardId, this.currentLead.id, {
            type: "update",
            text: `Respons\xE1vel alterado para <strong>${selectedUser?.displayName || "Ningu\xE9m"}</strong>`,
            user: currentUser.displayName || currentUser.email
          });
        }
        try {
          const beforeFields = this.currentLead.fields || {};
          const changedKeys = Object.keys(mapped).filter((k) => `${beforeFields[k] ?? ""}` !== `${mapped[k] ?? ""}`);
          if (changedKeys.length) {
            const changesList = changedKeys.map((k) => {
              const label = (this.currentFormFields || []).find((f) => (f.apiFieldName || f.name) === k)?.label || this.humanizeKey(k);
              let beforeVal = beforeFields[k] ?? "";
              let afterVal = mapped[k] ?? "";
              const isResp = (this.currentFormFields || []).some((f) => (f.apiFieldName === k || f.name === k) && (f.type === "responsavel" || f.originalType === "responsavel"));
              if (isResp) {
                const beforeUser = this.users.find((u) => u.uid === beforeVal || u.email === beforeVal);
                const afterUser = this.users.find((u) => u.uid === afterVal || u.email === afterVal);
                beforeVal = beforeUser?.displayName || beforeVal;
                afterVal = afterUser?.displayName || afterVal;
              }
              return `<li><strong>${label}:</strong> "${beforeVal}" \u2192 "${afterVal}"</li>`;
            }).join("");
            yield this.firestoreService.addLeadHistory(this.ownerId, this.boardId, this.currentLead.id, {
              type: "update",
              text: `Formul\xE1rio da fase salvo:<ul class="list-disc ml-4">${changesList}</ul>`,
              user: currentUser.displayName || currentUser.email
            });
          }
        } catch {
        }
        yield this.firestoreService.updateLead(this.ownerId, this.boardId, this.currentLead.id, updateData);
        this.currentLead.fields = __spreadValues(__spreadValues({}, this.currentLead.fields || {}), mapped);
        const afterValues = {};
        (this.currentFormFields || []).forEach((f) => {
          const key = f.apiFieldName || f.name;
          afterValues[f.name] = mapped.hasOwnProperty(key) ? mapped[key] : this.getFieldValue(key) ?? "";
        });
        if (Object.keys(afterValues).length) {
          this.leadForm.patchValue(afterValues, { emitEvent: false });
        }
        this.leadUpdated.emit();
      } catch (error) {
        console.error("Erro ao salvar altera\xE7\xF5es:", error);
        this.errorMessage = "Erro ao salvar altera\xE7\xF5es. Tente novamente.";
      } finally {
        this.isSaving = false;
      }
    });
  }
  moveLead(targetColumnId) {
    return __async(this, null, function* () {
      if (!this.currentLead)
        return;
      this.isLoading = true;
      try {
        const oldColumn = this.getCurrentColumn();
        const newColumn = this.columns.find((col) => col.id === targetColumnId);
        const currentUser = this.authService.getCurrentUser();
        if (!oldColumn || !newColumn || !currentUser)
          return;
        const allowed = this.flowConfig.allowed[oldColumn.id] || [];
        if (!allowed.includes(targetColumnId)) {
          this.errorMessage = "Transi\xE7\xE3o n\xE3o permitida pelo fluxo.";
          return;
        }
        const now = /* @__PURE__ */ new Date();
        const phaseHistory = __spreadValues({}, this.phaseHistory);
        if (phaseHistory[oldColumn.id]) {
          const enteredAt = phaseHistory[oldColumn.id].enteredAt?.toDate() || /* @__PURE__ */ new Date();
          phaseHistory[oldColumn.id].exitedAt = now;
          phaseHistory[oldColumn.id].duration = now.getTime() - enteredAt.getTime();
        }
        phaseHistory[targetColumnId] = {
          phaseId: targetColumnId,
          enteredAt: now
        };
        yield this.firestoreService.moveLead(this.ownerId, this.boardId, this.currentLead.id, targetColumnId);
        yield this.firestoreService.addLeadHistory(this.ownerId, this.boardId, this.currentLead.id, {
          type: "move",
          text: `Moveu de <strong>${oldColumn.name}</strong> para <strong>${newColumn.name}</strong>`,
          user: currentUser.displayName || currentUser.email
        });
        yield this.firestoreService.updateLead(this.ownerId, this.boardId, this.currentLead.id, { phaseHistory });
        this.leadUpdated.emit();
        this.hide();
      } catch (error) {
        console.error("Erro ao mover lead:", error);
        this.errorMessage = "Erro ao mover lead. Tente novamente.";
      } finally {
        this.isLoading = false;
      }
    });
  }
  onFileSelected(event) {
    const file = event.target.files[0];
    if (file) {
      const maxSize = 10 * 1024 * 1024;
      if (file.size > maxSize) {
        this.errorMessage = "Arquivo muito grande. O tamanho m\xE1ximo \xE9 10MB.";
        event.target.value = "";
        return;
      }
      const allowedTypes = [
        "image/jpeg",
        "image/jpg",
        "image/png",
        "image/gif",
        "application/pdf",
        "application/msword",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        "text/plain",
        "application/zip",
        "application/x-rar-compressed"
      ];
      if (!allowedTypes.includes(file.type)) {
        this.errorMessage = "Tipo de arquivo n\xE3o permitido. Use: PDF, DOC, DOCX, JPG, PNG, GIF, TXT, ZIP, RAR.";
        event.target.value = "";
        return;
      }
      this.selectedFile = file;
      this.attachmentPreview = `\u{1F4CE} ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`;
      this.errorMessage = "";
    }
  }
  clearAttachment() {
    this.selectedFile = null;
    this.attachmentPreview = "";
  }
  addComment() {
    return __async(this, null, function* () {
      if (!this.currentLead || !this.commentText.trim() && !this.selectedFile) {
        this.errorMessage = "Digite um coment\xE1rio ou anexe um arquivo.";
        return;
      }
      this.isUploadingComment = true;
      this.errorMessage = "";
      try {
        const currentUser = this.authService.getCurrentUser();
        if (!currentUser) {
          throw new Error("Usu\xE1rio n\xE3o autenticado");
        }
        let attachment = null;
        if (this.selectedFile) {
          console.log("Iniciando upload do arquivo:", this.selectedFile.name);
          const filePath = `leads/${this.currentLead.id}/comments/${Date.now()}_${this.selectedFile.name}`;
          try {
            const downloadURL = yield this.storageService.uploadFile(this.selectedFile, filePath);
            console.log("Upload conclu\xEDdo:", downloadURL);
            attachment = {
              name: this.selectedFile.name,
              url: downloadURL,
              type: this.selectedFile.type,
              size: this.selectedFile.size
            };
          } catch (uploadError) {
            console.error("Erro no upload:", uploadError);
            throw new Error("Falha no upload do arquivo. Verifique sua conex\xE3o.");
          }
        }
        const historyData = {
          type: "comment",
          text: this.commentText.trim() || "Anexou um arquivo",
          user: currentUser.displayName || currentUser.email,
          timestamp: /* @__PURE__ */ new Date(),
          attachment
        };
        console.log("Adicionando ao hist\xF3rico:", historyData);
        yield this.firestoreService.addLeadHistory(this.ownerId, this.boardId, this.currentLead.id, historyData);
        console.log("Coment\xE1rio adicionado com sucesso");
        this.commentText = "";
        this.clearAttachment();
        yield this.loadLeadData();
      } catch (error) {
        console.error("Erro ao adicionar coment\xE1rio:", error);
        this.errorMessage = error.message || "Erro ao adicionar coment\xE1rio. Tente novamente.";
      } finally {
        this.isUploadingComment = false;
      }
    });
  }
  uploadAttachment() {
    return __async(this, null, function* () {
      if (!this.currentLead || !this.selectedFile)
        return;
      this.isUploadingAttachment = true;
      this.errorMessage = "";
      try {
        const currentUser = this.authService.getCurrentUser();
        if (!currentUser)
          throw new Error("Usu\xE1rio n\xE3o autenticado");
        const filePath = `leads/${this.currentLead.id}/attachments/${Date.now()}_${this.selectedFile.name}`;
        const downloadURL = yield this.storageService.uploadFile(this.selectedFile, filePath);
        yield this.firestoreService.addLeadHistory(this.ownerId, this.boardId, this.currentLead.id, {
          type: "comment",
          text: "Anexou um arquivo",
          user: currentUser.displayName || currentUser.email,
          timestamp: /* @__PURE__ */ new Date(),
          attachment: {
            name: this.selectedFile.name,
            url: downloadURL,
            type: this.selectedFile.type,
            size: this.selectedFile.size
          }
        });
        this.clearAttachment();
        yield this.loadLeadData();
      } catch (e) {
        this.errorMessage = e.message || "Erro ao anexar arquivo";
      } finally {
        this.isUploadingAttachment = false;
      }
    });
  }
  generatePublicLink() {
    if (!this.currentLead)
      return;
    const currentColumn = this.getCurrentColumn();
    if (!currentColumn)
      return;
    const company = this.subdomainService.getCurrentCompany();
    if (company) {
      const isDev = this.subdomainService.isDevelopment();
      if (isDev) {
        const baseUrl = this.subdomainService.getBaseUrl();
        this.publicLink = `${baseUrl}/form?subdomain=${company.subdomain}&companyId=${company.id}&userId=${this.ownerId}&boardId=${this.boardId}&leadId=${this.currentLead.id}&columnId=${currentColumn.id}`;
      } else {
        this.publicLink = `https://${company.subdomain}.taskboard.com.br/form?companyId=${company.id}&userId=${this.ownerId}&boardId=${this.boardId}&leadId=${this.currentLead.id}&columnId=${currentColumn.id}`;
      }
    }
  }
  copyPublicLink() {
    if (this.publicLink) {
      navigator.clipboard.writeText(this.publicLink);
    }
  }
  deleteLead() {
    return __async(this, null, function* () {
      if (!this.currentLead)
        return;
      this.isLoading = true;
      try {
        yield this.firestoreService.deleteLead(this.ownerId, this.boardId, this.currentLead.id);
        this.leadDeleted.emit();
        this.hide();
      } catch (error) {
        console.error("Erro ao excluir lead:", error);
        this.errorMessage = "Erro ao excluir lead. Tente novamente.";
      } finally {
        this.isLoading = false;
      }
    });
  }
  openDeleteConfirm() {
    this.showDeleteConfirm = true;
  }
  cancelDelete() {
    this.showDeleteConfirm = false;
  }
  confirmDelete() {
    return __async(this, null, function* () {
      yield this.deleteLead();
      this.showDeleteConfirm = false;
    });
  }
  onBackdropClick(event) {
    if (event.target === event.currentTarget) {
      this.hide();
    }
  }
  formatDateTime(timestamp) {
    const date = timestamp?.toDate ? timestamp.toDate() : new Date(timestamp);
    return date.toLocaleString("pt-BR");
  }
  getActivityIcon(type) {
    switch (type) {
      case "move":
        return "fas fa-arrow-right";
      case "comment":
        return "fas fa-comment";
      case "update":
        return "fas fa-edit";
      default:
        return "fas fa-info-circle";
    }
  }
  copyLeadId() {
    if (this.currentLead?.id) {
      navigator.clipboard.writeText(this.currentLead.id);
    }
  }
  isPlainObject(value) {
    return value && typeof value === "object" && !Array.isArray(value);
  }
  flattenObject(source, maxDepth = 3) {
    const out = {};
    if (!this.isPlainObject(source) || maxDepth < 0)
      return out;
    for (const [key, val] of Object.entries(source)) {
      if (this.isPlainObject(val) && maxDepth > 0) {
        const nested = this.flattenObject(val, maxDepth - 1);
        for (const [nk, nv] of Object.entries(nested)) {
          if (out[nk] === void 0)
            out[nk] = nv;
        }
      } else if (val !== void 0 && val !== null) {
        out[key] = val;
      }
    }
    return out;
  }
  collectLeadFields() {
    const base = this.currentLead?.fields || {};
    const containers = ["fields", "leadData", "data", "payload"];
    const merged = {};
    const candidates = [base];
    containers.forEach((k) => {
      if (this.isPlainObject(base[k]))
        candidates.push(base[k]);
    });
    if (this.isPlainObject(base.fields?.fields))
      candidates.push(base.fields.fields);
    for (const obj of candidates) {
      for (const [k, v] of Object.entries(obj)) {
        if (merged[k] === void 0 && v !== void 0 && v !== null && `${v}`.trim?.() !== "") {
          merged[k] = v;
        }
      }
    }
    const deep = this.flattenObject(base, 3);
    for (const [k, v] of Object.entries(deep)) {
      if (merged[k] === void 0 && v !== void 0 && v !== null && `${v}`.trim?.() !== "") {
        merged[k] = v;
      }
    }
    return merged;
  }
  getFieldValue(requestedName) {
    const fields = this.collectLeadFields();
    if (!requestedName)
      return void 0;
    const synonyms = {
      companyName: ["companyName", "empresa", "nomeEmpresa", "nameCompany", "company", "company_name", "empresa_nome", "nameComapny"],
      cnpj: ["cnpj", "cnpjCompany"],
      contactName: ["contactName", "name", "nome", "nomeLead", "nameLead", "leadName"],
      contactEmail: ["contactEmail", "email", "emailLead", "contatoEmail", "leadEmail"],
      contactPhone: ["contactPhone", "phone", "telefone", "celular", "phoneLead", "telefoneContato"],
      temperature: ["temperature", "temperatura", "qualificacao", "leadTemperature"]
    };
    const lowerMap = Object.keys(fields).reduce((acc, k) => {
      acc[k.toLowerCase()] = k;
      return acc;
    }, {});
    const req = requestedName.toLowerCase();
    const candidates = [requestedName];
    if (synonyms[requestedName]) {
      candidates.push(...synonyms[requestedName]);
    }
    for (const [canonical, aliases] of Object.entries(synonyms)) {
      if (canonical.toLowerCase() === req || aliases.some((a) => a.toLowerCase() === req)) {
        candidates.push(canonical, ...aliases);
      }
    }
    const visited = /* @__PURE__ */ new Set();
    for (const c of candidates) {
      const key = c.toLowerCase();
      if (visited.has(key))
        continue;
      visited.add(key);
      const original = lowerMap[key];
      if (original !== void 0) {
        const val = fields[original];
        if (val !== void 0 && val !== null && (typeof val !== "string" || val.trim() !== "")) {
          return val;
        }
      }
    }
    return void 0;
  }
  humanizeKey(key) {
    const withSpaces = key.replace(/_/g, " ").replace(/([a-z])([A-Z])/g, "$1 $2").replace(/\s+/g, " ").trim();
    return withSpaces.charAt(0).toUpperCase() + withSpaces.slice(1);
  }
  getLabelForOriginalKey(originalKey, canonicalKey) {
    const fieldsCfg = this.initialFormConfig?.fields || [];
    if (Array.isArray(fieldsCfg) && fieldsCfg.length) {
      const found = fieldsCfg.find((f) => {
        const apiName = (f.apiFieldName || "").toString();
        const name = (f.name || "").toString();
        return apiName === originalKey || name === originalKey || apiName === canonicalKey || name === canonicalKey;
      });
      if (found?.label)
        return found.label;
    }
    const humanOriginal = this.humanizeKey(originalKey);
    if (humanOriginal)
      return humanOriginal;
    return this.humanizeKey(canonicalKey);
  }
  buildDedupedDisplayFields() {
    const raw = this.collectLeadFields();
    const groups = {
      companyName: ["companyName", "empresa", "nomeEmpresa", "nameCompany", "company", "company_name", "empresa_nome", "nameComapny"],
      cnpj: ["cnpj", "cnpjCompany"],
      contactName: ["contactName", "name", "nome", "nomeLead", "nameLead", "leadName"],
      contactEmail: ["contactEmail", "email", "emailLead", "contatoEmail", "leadEmail"],
      contactPhone: ["contactPhone", "phone", "telefone", "celular", "phoneLead", "telefoneContato"],
      temperature: ["temperature", "temperatura", "qualificacao", "leadTemperature"]
    };
    const labelMap = {
      companyName: "Nome da empresa",
      cnpj: "CNPJ da empresa",
      contactName: "Nome do contato",
      contactEmail: "E-mail de contato",
      contactPhone: "Telefone",
      temperature: "Temperatura"
    };
    const lowerMap = Object.keys(raw).reduce((acc, k) => {
      acc[k.toLowerCase()] = k;
      return acc;
    }, {});
    const usedOriginalKeys = /* @__PURE__ */ new Set();
    const out = [];
    const pickFromAliases = /* @__PURE__ */ __name((aliases) => {
      for (const a of aliases) {
        const orig = lowerMap[a.toLowerCase()];
        if (orig && raw[orig] !== void 0 && raw[orig] !== null && `${raw[orig]}`.trim() !== "") {
          usedOriginalKeys.add(orig);
          return { key: orig, value: raw[orig] };
        }
      }
      return null;
    }, "pickFromAliases");
    const orderMap = { companyName: 1, cnpj: 2, contactName: 3, contactEmail: 4, contactPhone: 5, temperature: 6 };
    for (const canonical of Object.keys(groups)) {
      const found = pickFromAliases(groups[canonical]);
      if (found) {
        const label = this.getLabelForOriginalKey(found.key, canonical) || labelMap[canonical] || this.humanizeKey(canonical);
        out.push({ name: canonical, label, value: found.value, order: orderMap[canonical] || 999 });
      }
    }
    const aliasLowerSet = new Set(Object.values(groups).flat().map((k) => k.toLowerCase()));
    Object.keys(raw).forEach((orig) => {
      const isAlias = aliasLowerSet.has(orig.toLowerCase());
      if (!usedOriginalKeys.has(orig) && !isAlias) {
        out.push({ name: orig, label: this.humanizeKey(orig), value: raw[orig], order: 999 });
      }
    });
    return out.filter((item) => item.value !== void 0 && item.value !== null && `${item.value}`.trim() !== "").sort((a, b) => a.order - b.order || a.label.localeCompare(b.label)).map((_a) => {
      var _b = _a, { order } = _b, rest = __objRest(_b, ["order"]);
      return rest;
    });
  }
};
__name(_LeadDetailModalComponent, "LeadDetailModalComponent");
__publicField(_LeadDetailModalComponent, "\u0275fac", /* @__PURE__ */ __name(function LeadDetailModalComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _LeadDetailModalComponent)();
}, "LeadDetailModalComponent_Factory"));
__publicField(_LeadDetailModalComponent, "\u0275cmp", /* @__PURE__ */ \u0275\u0275defineComponent({ type: _LeadDetailModalComponent, selectors: [["app-lead-detail-modal"]], inputs: { ownerId: "ownerId", boardId: "boardId", columns: "columns", users: "users" }, outputs: { leadUpdated: "leadUpdated", leadDeleted: "leadDeleted", closeModal: "closeModal" }, decls: 1, vars: 1, consts: [["noPhaseHistory", ""], ["noPhaseForm", ""], ["fileInput", ""], ["finalPhaseMsg", ""], ["class", "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", 3, "click", 4, "ngIf"], [1, "fixed", "inset-0", "bg-black", "bg-opacity-50", "flex", "items-center", "justify-center", "z-50", "p-4", 3, "click"], [1, "bg-white", "rounded-xl", "shadow-2xl", "w-full", "max-w-7xl", "max-h-[95vh]", "overflow-hidden"], [1, "flex", "justify-between", "items-center", "p-6", "border-b", "border-gray-200"], [1, "text-2xl", "font-bold", "text-gray-900"], [1, "flex", "items-center", "gap-3"], ["title", "Apagar registro", 1, "text-red-500", "hover:text-red-600", "text-xl", 3, "click", "disabled"], [1, "fas", "fa-trash"], [1, "text-gray-400", "hover:text-gray-600", "text-2xl", "font-bold", 3, "click", "disabled"], [1, "grid", "grid-cols-12", "gap-6", "p-6", "max-h-[calc(95vh-120px)]", "overflow-y-auto"], [1, "col-span-12", "md:col-span-3", "border-r", "border-gray-200", "pr-6"], [1, "mb-8"], ["class", "mb-2 text-[11px] text-gray-400 flex items-center gap-2", 4, "ngIf"], [1, "space-y-4"], ["class", "text-sm", 4, "ngFor", "ngForOf"], [1, "font-bold", "text-lg", "mb-3", "text-gray-800"], ["class", "space-y-3", 4, "ngIf", "ngIfElse"], [1, "col-span-12", "md:col-span-6"], ["class", "mb-8", 4, "ngIf", "ngIfElse"], ["placeholder", "Escreva um coment\xE1rio...", "rows", "3", 1, "w-full", "p-3", "border", "border-gray-300", "rounded-lg", "focus:ring-2", "focus:ring-blue-500", "focus:border-blue-500", 3, "ngModelChange", "ngModel", "ngModelOptions"], [1, "flex", "justify-end", "mt-2"], [1, "btn-primary", "flex", "items-center", 3, "click", "disabled"], ["class", "animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2", 4, "ngIf"], [1, "fas", "fa-paper-plane", "mr-2"], ["type", "button", 1, "btn-secondary", "text-sm", 3, "click"], [1, "fas", "fa-paperclip", "mr-2"], ["class", "text-sm text-gray-600", 4, "ngIf"], ["type", "file", "accept", ".pdf,.doc,.docx,.jpg,.jpeg,.png,.gif,.txt,.zip,.rar", 1, "hidden", 3, "change"], [1, "btn-primary-outline", "text-sm", 3, "click", "disabled"], ["class", "text-gray-500 hover:text-gray-700 text-sm", 3, "click", 4, "ngIf"], [1, "mt-8"], [1, "space-y-3", "max-h-64", "overflow-y-auto"], ["class", "text-xs p-2 bg-gray-50 rounded", 4, "ngFor", "ngForOf"], [1, "col-span-12", "md:col-span-3", "border-l", "border-gray-200", "pl-6", "flex", "flex-col", "justify-between"], ["class", "mb-4", 4, "ngIf"], ["class", "text-gray-500 text-sm italic p-3 bg-gray-50 rounded-lg", 4, "ngIf"], ["class", "space-y-2", 4, "ngIf"], ["class", "bg-red-50 border border-red-200 text-red-700 px-3 py-2 rounded-lg text-sm mt-3", 4, "ngIf"], ["class", "fixed inset-0 bg-black/50 flex items-center justify-center z-[60]", 3, "click", 4, "ngIf"], [1, "mb-2", "text-[11px]", "text-gray-400", "flex", "items-center", "gap-2"], [1, "truncate"], [1, "select-all"], [1, "text-blue-500", "hover:text-blue-700", "text-xs", 3, "click"], [1, "text-sm"], [1, "text-gray-800", "font-semibold"], [1, "break-all"], [1, "space-y-3"], ["class", "relative text-xs p-3 rounded-lg border-l-4 transition-all hover:shadow-sm", 3, "border-left-color", "bg-blue-50", "bg-gray-50", 4, "ngFor", "ngForOf"], [1, "relative", "text-xs", "p-3", "rounded-lg", "border-l-4", "transition-all", "hover:shadow-sm"], [1, "flex", "items-center", "justify-between", "mb-2"], [1, "flex", "items-center", "gap-2"], [1, "w-3", "h-3", "rounded-full"], [1, "font-semibold", "text-gray-800"], ["class", "px-2 py-1 bg-blue-100 text-blue-800 rounded-full text-[10px] font-medium", 4, "ngIf"], [1, "text-gray-500", "text-[10px]"], [1, "space-y-1", "text-gray-600"], [1, "flex", "items-center", "gap-1"], [1, "fas", "fa-play", "text-green-500", "w-3"], ["class", "flex items-center gap-1", 4, "ngIf"], [1, "fas", "fa-clock", "text-blue-500", "w-3"], ["class", "absolute -bottom-2 left-1/2 transform -translate-x-1/2", 4, "ngIf"], [1, "px-2", "py-1", "bg-blue-100", "text-blue-800", "rounded-full", "text-[10px]", "font-medium"], [1, "fas", "fa-stop", "text-red-500", "w-3"], [1, "absolute", "-bottom-2", "left-1/2", "transform", "-translate-x-1/2"], [1, "fas", "fa-chevron-down", "text-gray-400", "text-xs"], [1, "text-sm", "text-gray-500", "bg-gray-50", "border", "border-gray-200", "rounded-lg", "p-4", "text-center"], [1, "fas", "fa-info-circle", "mb-2", "text-gray-400"], [1, "text-xs", "mt-1"], [1, "space-y-4", 3, "ngSubmit", "formGroup"], [4, "ngFor", "ngForOf"], [1, "flex", "justify-end", "pt-2"], ["type", "submit", 1, "btn-primary", 3, "disabled"], [1, "form-group"], [1, "block", "text-sm", "font-medium", "text-gray-700", "mb-1"], ["class", "text-red-500", 4, "ngIf"], ["class", "w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500", 3, "type", "formControlName", "placeholder", 4, "ngIf"], ["rows", "3", "class", "w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500", 3, "formControlName", "placeholder", 4, "ngIf"], ["type", "number", "class", "w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500", 3, "formControlName", "placeholder", 4, "ngIf"], ["type", "date", "class", "w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500", 3, "formControlName", 4, "ngIf"], ["class", "w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500", 3, "formControlName", 4, "ngIf"], ["class", "flex flex-wrap gap-4", 4, "ngIf"], [1, "text-red-500"], [1, "w-full", "p-3", "border", "border-gray-300", "rounded-lg", "focus:ring-2", "focus:ring-blue-500", "focus:border-blue-500", 3, "type", "formControlName", "placeholder"], ["rows", "3", 1, "w-full", "p-3", "border", "border-gray-300", "rounded-lg", "focus:ring-2", "focus:ring-blue-500", "focus:border-blue-500", 3, "formControlName", "placeholder"], ["type", "number", 1, "w-full", "p-3", "border", "border-gray-300", "rounded-lg", "focus:ring-2", "focus:ring-blue-500", "focus:border-blue-500", 3, "formControlName", "placeholder"], ["type", "date", 1, "w-full", "p-3", "border", "border-gray-300", "rounded-lg", "focus:ring-2", "focus:ring-blue-500", "focus:border-blue-500", 3, "formControlName"], [1, "w-full", "p-3", "border", "border-gray-300", "rounded-lg", "focus:ring-2", "focus:ring-blue-500", "focus:border-blue-500", 3, "formControlName"], ["value", ""], [3, "value", 4, "ngFor", "ngForOf"], [3, "value"], [1, "flex", "flex-wrap", "gap-4"], ["class", "inline-flex items-center gap-2 text-sm text-gray-700", 4, "ngFor", "ngForOf"], [1, "inline-flex", "items-center", "gap-2", "text-sm", "text-gray-700"], ["type", "radio", 1, "text-blue-600", "focus:ring-blue-500", 3, "value", "formControlName"], [1, "text-sm", "text-gray-500", "bg-gray-50", "border", "border-gray-200", "rounded-lg", "p-4"], [1, "animate-spin", "rounded-full", "h-4", "w-4", "border-b-2", "border-white", "mr-2"], [1, "text-sm", "text-gray-600"], [1, "text-gray-500", "hover:text-gray-700", "text-sm", 3, "click"], [1, "text-xs", "p-2", "bg-gray-50", "rounded"], [1, "flex", "items-center", "mb-1"], [1, "mr-2", "text-blue-500"], [1, "font-medium"], [1, "ml-auto", "text-gray-500"], [1, "text-gray-700", 3, "innerHTML"], ["class", "mt-2", 4, "ngIf"], [1, "mt-2"], ["target", "_blank", 1, "text-blue-600", "hover:underline", "flex", "items-center", 3, "href"], [1, "fas", "fa-paperclip", "mr-1"], [1, "mb-4"], [1, "text-sm", "font-semibold", "text-green-700", "mb-2"], [1, "grid", "grid-cols-1", "gap-2"], ["class", "text-left p-2 border border-green-200 rounded-md hover:bg-green-50 transition-colors flex items-center text-sm bg-white", 3, "disabled", "click", 4, "ngFor", "ngForOf"], [1, "text-left", "p-2", "border", "border-green-200", "rounded-md", "hover:bg-green-50", "transition-colors", "flex", "items-center", "text-sm", "bg-white", 3, "click", "disabled"], [1, "w-3", "h-3", "rounded-full", "mr-2"], [1, "text-sm", "font-medium", "text-orange-600", "mb-2"], [1, "grid", "grid-cols-1", "gap-1"], ["class", "text-left p-2 border border-orange-100 rounded-md hover:bg-orange-50 transition-colors flex items-center text-xs bg-orange-25 opacity-75", 3, "disabled", "click", 4, "ngFor", "ngForOf"], [1, "text-left", "p-2", "border", "border-orange-100", "rounded-md", "hover:bg-orange-50", "transition-colors", "flex", "items-center", "text-xs", "bg-orange-25", "opacity-75", 3, "click", "disabled"], [1, "w-2", "h-2", "rounded-full", "mr-2"], [1, "text-gray-500", "text-sm", "italic", "p-3", "bg-gray-50", "rounded-lg"], [4, "ngIf", "ngIfElse"], [1, "space-y-2"], [1, "text-xs", "text-gray-600"], [1, "flex"], ["type", "text", "readonly", "", 1, "flex-1", "p-2", "border", "border-gray-300", "rounded-l-lg", "bg-gray-50", "text-xs", 3, "value"], [1, "btn-primary", "rounded-l-none", "rounded-r-lg", "px-3", 3, "click"], [1, "fas", "fa-copy"], [1, "bg-red-50", "border", "border-red-200", "text-red-700", "px-3", "py-2", "rounded-lg", "text-sm", "mt-3"], [1, "fixed", "inset-0", "bg-black/50", "flex", "items-center", "justify-center", "z-[60]", 3, "click"], [1, "bg-white", "rounded-xl", "shadow-2xl", "w-full", "max-w-md", "p-6", 3, "click"], [1, "text-lg", "font-bold", "text-gray-900", "mb-2"], [1, "text-sm", "text-gray-600", "mb-6"], [1, "flex", "justify-end", "gap-3"], [1, "px-4", "py-2", "rounded-lg", "border", "border-gray-300", 3, "click"], [1, "px-4", "py-2", "rounded-lg", "bg-red-600", "text-white", 3, "click"]], template: /* @__PURE__ */ __name(function LeadDetailModalComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, LeadDetailModalComponent_div_0_Template, 68, 25, "div", 4);
  }
  if (rf & 2) {
    \u0275\u0275property("ngIf", ctx.isVisible);
  }
}, "LeadDetailModalComponent_Template"), dependencies: [CommonModule, NgForOf, NgIf, FormsModule, \u0275NgNoValidate, NgSelectOption, \u0275NgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, SelectControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, NgModel, ReactiveFormsModule, FormGroupDirective, FormControlName], styles: ['@charset "UTF-8";\n\n\n\n.btn-primary[_ngcontent-%COMP%] {\n  background-color: var(--primary-color);\n  color: #ffffff;\n  font-weight: 600;\n  padding: 0.5rem 1rem;\n  border-radius: 0.5rem;\n  transition: filter 0.2s ease, opacity 0.2s ease;\n}\n.btn-primary[_ngcontent-%COMP%]:hover {\n  filter: brightness(0.9);\n}\n.btn-primary[_ngcontent-%COMP%]:disabled {\n  opacity: 0.6;\n  cursor: not-allowed;\n}\n.btn-secondary[_ngcontent-%COMP%] {\n  background-color: #f1f5f9;\n  color: #334155;\n  font-weight: 600;\n  padding: 0.5rem 1rem;\n  border-radius: 0.5rem;\n  transition: background-color 0.2s ease;\n}\n.btn-secondary[_ngcontent-%COMP%]:hover {\n  background-color: #e2e8f0;\n}\n.btn-primary-outline[_ngcontent-%COMP%] {\n  background-color: transparent;\n  color: var(--primary-color);\n  font-weight: 600;\n  padding: 0.5rem 1rem;\n  border-radius: 0.5rem;\n  border: 1px solid var(--primary-color);\n  transition: all 0.2s ease;\n}\n.btn-primary-outline[_ngcontent-%COMP%]:hover {\n  background-color: rgba(59, 130, 246, 0.08);\n}\n.modal-body[_ngcontent-%COMP%] {\n  max-height: calc(95vh - 120px);\n}\n.form-group[_ngcontent-%COMP%] {\n  margin-bottom: 1rem;\n}\n.form-group[_ngcontent-%COMP%]   label[_ngcontent-%COMP%] {\n  font-weight: 500;\n  color: #374151;\n  margin-bottom: 0.25rem;\n}\n.form-group[_ngcontent-%COMP%]   input[_ngcontent-%COMP%], \n.form-group[_ngcontent-%COMP%]   textarea[_ngcontent-%COMP%], \n.form-group[_ngcontent-%COMP%]   select[_ngcontent-%COMP%] {\n  transition: border-color 0.2s ease, box-shadow 0.2s ease;\n}\n.form-group[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]:focus, \n.form-group[_ngcontent-%COMP%]   textarea[_ngcontent-%COMP%]:focus, \n.form-group[_ngcontent-%COMP%]   select[_ngcontent-%COMP%]:focus {\n  outline: none;\n  border-color: #3b82f6;\n  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);\n}\n.activity-item[_ngcontent-%COMP%] {\n  padding: 0.75rem;\n  background: #f9fafb;\n  border-radius: 0.5rem;\n  border-left: 3px solid #e5e7eb;\n}\n.phase-item[_ngcontent-%COMP%] {\n  padding: 0.5rem;\n  border-radius: 0.25rem;\n  border-left: 4px solid;\n}\n.phase-item.current[_ngcontent-%COMP%] {\n  background-color: #eff6ff;\n  border-left-color: #3b82f6;\n}\n.action-button[_ngcontent-%COMP%] {\n  transition: all 0.2s ease;\n  border: 1px solid #d1d5db;\n}\n.action-button[_ngcontent-%COMP%]:hover {\n  background-color: #f9fafb;\n  border-color: #9ca3af;\n}\n.public-link-container[_ngcontent-%COMP%] {\n  background: #f8fafc;\n  border: 1px solid #e2e8f0;\n  border-radius: 0.5rem;\n  padding: 1rem;\n}\n.attachment-preview[_ngcontent-%COMP%] {\n  background: #f1f5f9;\n  border: 1px solid #cbd5e1;\n  padding: 0.5rem;\n  border-radius: 0.375rem;\n  font-size: 0.875rem;\n  color: #475569;\n}\n.spinner[_ngcontent-%COMP%] {\n  animation: _ngcontent-%COMP%_spin 1s linear infinite;\n}\n@keyframes _ngcontent-%COMP%_spin {\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n}\n.modal-body[_ngcontent-%COMP%]::-webkit-scrollbar, \n.activity-log[_ngcontent-%COMP%]::-webkit-scrollbar {\n  width: 6px;\n}\n.modal-body[_ngcontent-%COMP%]::-webkit-scrollbar-track, \n.activity-log[_ngcontent-%COMP%]::-webkit-scrollbar-track {\n  background: #f1f1f1;\n  border-radius: 3px;\n}\n.modal-body[_ngcontent-%COMP%]::-webkit-scrollbar-thumb, \n.activity-log[_ngcontent-%COMP%]::-webkit-scrollbar-thumb {\n  background: #c1c1c1;\n  border-radius: 3px;\n}\n.modal-body[_ngcontent-%COMP%]::-webkit-scrollbar-thumb:hover, \n.activity-log[_ngcontent-%COMP%]::-webkit-scrollbar-thumb:hover {\n  background: #a8a8a8;\n}\n/*# sourceMappingURL=lead-detail-modal.component.css.map */'] }));
var LeadDetailModalComponent = _LeadDetailModalComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LeadDetailModalComponent, [{
    type: Component,
    args: [{ selector: "app-lead-detail-modal", standalone: true, imports: [CommonModule, FormsModule, ReactiveFormsModule], template: `<div *ngIf="isVisible" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" (click)="onBackdropClick($event)">
  <div class="bg-white rounded-xl shadow-2xl w-full max-w-7xl max-h-[95vh] overflow-hidden">
    <!-- Header -->
    <div class="flex justify-between items-center p-6 border-b border-gray-200">
      <h2 class="text-2xl font-bold text-gray-900">Dados</h2>
      <div class="flex items-center gap-3">
        <button 
          (click)="openDeleteConfirm()"
          class="text-red-500 hover:text-red-600 text-xl"
          title="Apagar registro"
          [disabled]="isLoading || isSaving">
          <i class="fas fa-trash"></i>
        </button>
        <button 
          (click)="hide()" 
          class="text-gray-400 hover:text-gray-600 text-2xl font-bold"
          [disabled]="isLoading">
          &times;
        </button>
      </div>
    </div>

    <!-- Modal Body -->
    <div class="grid grid-cols-12 gap-6 p-6 max-h-[calc(95vh-120px)] overflow-y-auto">
      
      <!-- Left Column: Lead Data -->
      <div class="col-span-12 md:col-span-3 border-r border-gray-200 pr-6">
        <!-- Dados -->
        <div class="mb-8">
          <div *ngIf="currentLead?.id" class="mb-2 text-[11px] text-gray-400 flex items-center gap-2">
            <span class="truncate">ID: <span class="select-all">{{ currentLead?.id }}</span></span>
            <button (click)="copyLeadId()" class="text-blue-500 hover:text-blue-700 text-xs">Copiar</button>
          </div>
          <div class="space-y-4">
            <div *ngFor="let field of getInitialFields()" class="text-sm">
              <div class="text-gray-800 font-semibold">{{ field.label }}</div>
              <div class="break-all">{{ field.value }}</div>
            </div>
          </div>
        </div>

        <!-- Hist\xF3rico de Fases -->
        <div class="mb-8">
          <h3 class="font-bold text-lg mb-3 text-gray-800">Hist\xF3rico de Fases</h3>
          <div *ngIf="getPhaseHistoryItems().length > 0; else noPhaseHistory" class="space-y-3">
            <div *ngFor="let phase of getPhaseHistoryItems(); let i = index; let last = last" 
                 class="relative text-xs p-3 rounded-lg border-l-4 transition-all hover:shadow-sm"
                 [style.border-left-color]="phase.phaseColor"
                 [class.bg-blue-50]="phase.isCurrentPhase"
                 [class.bg-gray-50]="!phase.isCurrentPhase">
              
              <!-- Indicador de posi\xE7\xE3o -->
              <div class="flex items-center justify-between mb-2">
                <div class="flex items-center gap-2">
                  <div class="w-3 h-3 rounded-full" [style.background-color]="phase.phaseColor"></div>
                  <span class="font-semibold text-gray-800">{{ phase.phaseName }}</span>
                  <span *ngIf="phase.isCurrentPhase" class="px-2 py-1 bg-blue-100 text-blue-800 rounded-full text-[10px] font-medium">ATUAL</span>
                </div>
                <span class="text-gray-500 text-[10px]">#{{ i + 1 }}</span>
              </div>

              <!-- Detalhes da fase -->
              <div class="space-y-1 text-gray-600">
                <div class="flex items-center gap-1">
                  <i class="fas fa-play text-green-500 w-3"></i>
                  <span>Entrada: {{ phase.enteredAt }}</span>
                </div>
                <div *ngIf="phase.exitedAt !== 'Atual'" class="flex items-center gap-1">
                  <i class="fas fa-stop text-red-500 w-3"></i>
                  <span>Sa\xEDda: {{ phase.exitedAt }}</span>
                </div>
                <div class="flex items-center gap-1">
                  <i class="fas fa-clock text-blue-500 w-3"></i>
                  <span>Dura\xE7\xE3o: {{ phase.duration }}</span>
                </div>
              </div>

              <!-- Seta para pr\xF3xima fase -->
              <div *ngIf="!last" class="absolute -bottom-2 left-1/2 transform -translate-x-1/2">
                <i class="fas fa-chevron-down text-gray-400 text-xs"></i>
              </div>
            </div>
          </div>
          
          <ng-template #noPhaseHistory>
            <div class="text-sm text-gray-500 bg-gray-50 border border-gray-200 rounded-lg p-4 text-center">
              <i class="fas fa-info-circle mb-2 text-gray-400"></i>
              <div>Nenhum hist\xF3rico de fases dispon\xEDvel</div>
              <div class="text-xs mt-1">O hist\xF3rico ser\xE1 registrado quando o lead for movido entre as fases</div>
            </div>
          </ng-template>
        </div>

        
      </div>

      <!-- Middle Column: Form and Comments -->
      <div class="col-span-12 md:col-span-6">
        <!-- Formul\xE1rio da Fase Atual -->
        <div class="mb-8" *ngIf="formReady && (currentFormFields && currentFormFields.length > 0); else noPhaseForm">
          <h3 class="font-bold text-lg mb-3 text-gray-800">Formul\xE1rio da Fase Atual</h3>
          <form [formGroup]="leadForm" class="space-y-4" (ngSubmit)="saveChanges()">
            <!-- Campos din\xE2micos da fase -->
            <ng-container *ngFor="let field of currentFormFields">
              <div class="form-group">
                <label class="block text-sm font-medium text-gray-700 mb-1">
                  {{ field.label }}
                  <span *ngIf="field.required" class="text-red-500">*</span>
                </label>
                
                <!-- Campo de texto -->
                <input 
                  *ngIf="field.type === 'text' || field.type === 'email' || field.type === 'tel' || field.type === 'url' || field.type === 'cpf' || field.type === 'cnpj'" 
                  [type]="field.type"
                  [formControlName]="field.name"
                  [placeholder]="field.placeholder || ''"
                  class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                
                <!-- Campo de textarea -->
                <textarea 
                  *ngIf="field.type === 'textarea'" 
                  [formControlName]="field.name"
                  [placeholder]="field.placeholder || ''"
                  rows="3"
                  class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                </textarea>
                
                <!-- Campo de n\xFAmero -->
                <input 
                  *ngIf="field.type === 'number'" 
                  type="number"
                  [formControlName]="field.name"
                  [placeholder]="field.placeholder || ''"
                  class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                
                <!-- Campo de data -->
                <input 
                  *ngIf="field.type === 'date'" 
                  type="date"
                  [formControlName]="field.name"
                  class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                
                <!-- Campo select -->
                <select 
                  *ngIf="field.type === 'select' || field.type === 'temperatura'" 
                  [formControlName]="field.name"
                  class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                  <option value="">Selecione...</option>
                  <option *ngFor="let option of (field.type === 'temperatura' && (!field.options || field.options.length === 0) ? ['Quente','Morno','Frio'] : field.options)" [value]="option">{{ option }}</option>
                </select>

                <!-- Campo Radio -->
                <div *ngIf="field.type === 'radio'" class="flex flex-wrap gap-4">
                  <label *ngFor="let opt of (field.options || [])" class="inline-flex items-center gap-2 text-sm text-gray-700">
                    <input
                      type="radio"
                      [attr.name]="field.name"
                      [value]="opt?.value ?? opt"
                      [formControlName]="field.name"
                      class="text-blue-600 focus:ring-blue-500" />
                    <span>{{ opt?.label ?? opt }}</span>
                  </label>
                </div>

                <!-- Campo Respons\xE1vel (lista de usu\xE1rios da empresa) -->
                <select
                  *ngIf="field.type === 'responsavel'"
                  [formControlName]="field.name"
                  class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                  <option value="">Selecione o respons\xE1vel...</option>
                  <option *ngFor="let u of users" [value]="u.uid">{{ u.displayName || u.email }}</option>
                </select>
              </div>
            </ng-container>
            <div class="flex justify-end pt-2">
              <button type="submit"
                      [disabled]="isSaving || isLoading"
                      class="btn-primary">
                {{ isSaving ? 'Salvando...' : 'Salvar altera\xE7\xF5es' }}
              </button>
            </div>
          </form>
        </div>
        <ng-template #noPhaseForm>
          <div class="text-sm text-gray-500 bg-gray-50 border border-gray-200 rounded-lg p-4">
            Nenhum campo configurado para esta fase.
          </div>
        </ng-template>

        <!-- Coment\xE1rios -->
        <div>
          <h3 class="font-bold text-lg mb-3 text-gray-800">Coment\xE1rios</h3>
          <div class="space-y-4">
            <!-- Coment\xE1rio -->
            <div>
              <textarea 
                [(ngModel)]="commentText"
                [ngModelOptions]="{standalone: true}"
                class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                placeholder="Escreva um coment\xE1rio..."
                rows="3">
              </textarea>
              <div class="flex justify-end mt-2">
                <button 
                  (click)="addComment()"
                  [disabled]="isUploadingComment || !commentText.trim()"
                  class="btn-primary flex items-center">
                  <div *ngIf="isUploadingComment" class="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2"></div>
                  <i class="fas fa-paper-plane mr-2"></i>
                  {{ isUploadingComment ? 'Enviando...' : 'Enviar coment\xE1rio' }}
                </button>
              </div>
            </div>

            <!-- Anexo -->
            <div>
              <div class="flex items-center gap-3">
                <button 
                  type="button" 
                  (click)="fileInput.click()"
                  class="btn-secondary text-sm">
                  <i class="fas fa-paperclip mr-2"></i>Selecionar arquivo
                </button>
                <span class="text-sm text-gray-600" *ngIf="attachmentPreview">{{ attachmentPreview }}</span>
                <input #fileInput type="file" class="hidden" (change)="onFileSelected($event)" accept=".pdf,.doc,.docx,.jpg,.jpeg,.png,.gif,.txt,.zip,.rar">
                <button 
                  (click)="uploadAttachment()"
                  [disabled]="isUploadingAttachment || !selectedFile"
                  class="btn-primary-outline text-sm">
                  {{ isUploadingAttachment ? 'Anexando...' : 'Enviar anexo' }}
                </button>
                <button *ngIf="selectedFile" (click)="clearAttachment()" class="text-gray-500 hover:text-gray-700 text-sm">Limpar</button>
              </div>
            </div>
          </div>
        </div>

        <!-- Atividades Recentes (movido para o centro, abaixo de anexos) -->
        <div class="mt-8">
          <h3 class="font-bold text-lg mb-3 text-gray-800">Atividades Recentes</h3>
          <div class="space-y-3 max-h-64 overflow-y-auto">
            <div *ngFor="let activity of getActivityLog()" class="text-xs p-2 bg-gray-50 rounded">
              <div class="flex items-center mb-1">
                <i [class]="getActivityIcon(activity.type)" class="mr-2 text-blue-500"></i>
                <span class="font-medium">{{ activity.user }}</span>
                <span class="ml-auto text-gray-500">{{ formatDateTime(activity.timestamp) }}</span>
              </div>
              <div [innerHTML]="activity.text" class="text-gray-700"></div>
              <div *ngIf="activity.attachment" class="mt-2">
                <a [href]="activity.attachment.url" target="_blank" class="text-blue-600 hover:underline flex items-center">
                  <i class="fas fa-paperclip mr-1"></i>
                  {{ activity.attachment.name }}
                </a>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Right Column: Actions -->
      <div class="col-span-12 md:col-span-3 border-l border-gray-200 pl-6 flex flex-col justify-between">
        <div>
          <!-- A\xE7\xF5es -->
          <div class="mb-8">
            <h3 class="font-bold text-lg mb-3 text-gray-800">Mover registro</h3>
            
            <!-- Fases de Avan\xE7o -->
            <div *ngIf="getAdvancePhases().length > 0" class="mb-4">
              <h4 class="text-sm font-semibold text-green-700 mb-2">\u{1F680} Avan\xE7ar para:</h4>
              <div class="grid grid-cols-1 gap-2">
                <button 
                  *ngFor="let phase of getAdvancePhases()" 
                  (click)="moveLead(phase.id!)"
                  [disabled]="isLoading"
                  class="text-left p-2 border border-green-200 rounded-md hover:bg-green-50 transition-colors flex items-center text-sm bg-white">
                  <div class="w-3 h-3 rounded-full mr-2" [style.background-color]="phase.color"></div>
                  <span class="font-medium">{{ phase.name }}</span>
                </button>
              </div>
            </div>

            <!-- Fases de Retrocesso -->
            <div *ngIf="getRetreatPhases().length > 0" class="mb-4">
              <h4 class="text-sm font-medium text-orange-600 mb-2">\u{1F504} Retornar para:</h4>
              <div class="grid grid-cols-1 gap-1">
                <button 
                  *ngFor="let phase of getRetreatPhases()" 
                  (click)="moveLead(phase.id!)"
                  [disabled]="isLoading"
                  class="text-left p-2 border border-orange-100 rounded-md hover:bg-orange-50 transition-colors flex items-center text-xs bg-orange-25 opacity-75">
                  <div class="w-2 h-2 rounded-full mr-2" [style.background-color]="phase.color"></div>
                  <span>{{ phase.name }}</span>
                </button>
              </div>
            </div>
            
            <div *ngIf="getAdvancePhases().length === 0 && getRetreatPhases().length === 0" class="text-gray-500 text-sm italic p-3 bg-gray-50 rounded-lg">
              <ng-container *ngIf="hasRequiredToAdvance(); else finalPhaseMsg">
                Para avan\xE7ar, preencha os campos obrigat\xF3rios da fase.
              </ng-container>
              <ng-template #finalPhaseMsg>Lead em fase final. N\xE3o \xE9 poss\xEDvel movimentar.</ng-template>
            </div>
          </div>

          <!-- Gerador de Link P\xFAblico -->
          <div class="mb-8">
            <h3 class="font-bold text-lg mb-3 text-gray-800">Link P\xFAblico</h3>
            <div *ngIf="publicLink" class="space-y-2">
              <p class="text-xs text-gray-600">Compartilhe este link para permitir edi\xE7\xE3o externa:</p>
              <div class="flex">
                <input 
                  type="text" 
                  [value]="publicLink" 
                  readonly 
                  class="flex-1 p-2 border border-gray-300 rounded-l-lg bg-gray-50 text-xs">
                <button 
                  (click)="copyPublicLink()"
                  class="btn-primary rounded-l-none rounded-r-lg px-3">
                  <i class="fas fa-copy"></i>
                </button>
              </div>
            </div>
          </div>
        </div>

        <!-- Mensagem de erro -->
        <div *ngIf="errorMessage" class="bg-red-50 border border-red-200 text-red-700 px-3 py-2 rounded-lg text-sm mt-3">
          {{ errorMessage }}
        </div>
      </div>
    </div>
  </div>

  <!-- Modal de confirma\xE7\xE3o de exclus\xE3o -->
  <div *ngIf="showDeleteConfirm" class="fixed inset-0 bg-black/50 flex items-center justify-center z-[60]" (click)="cancelDelete()">
    <div class="bg-white rounded-xl shadow-2xl w-full max-w-md p-6" (click)="$event.stopPropagation()">
      <h3 class="text-lg font-bold text-gray-900 mb-2">Confirmar exclus\xE3o</h3>
      <p class="text-sm text-gray-600 mb-6">Esta a\xE7\xE3o n\xE3o pode ser desfeita. Deseja realmente apagar este registro?</p>
      <div class="flex justify-end gap-3">
        <button class="px-4 py-2 rounded-lg border border-gray-300" (click)="cancelDelete()">Cancelar</button>
        <button class="px-4 py-2 rounded-lg bg-red-600 text-white" (click)="confirmDelete()">Apagar</button>
      </div>
    </div>
  </div>
</div>`, styles: ['@charset "UTF-8";\n\n/* src/app/components/lead-detail-modal/lead-detail-modal.component.scss */\n.btn-primary {\n  background-color: var(--primary-color);\n  color: #ffffff;\n  font-weight: 600;\n  padding: 0.5rem 1rem;\n  border-radius: 0.5rem;\n  transition: filter 0.2s ease, opacity 0.2s ease;\n}\n.btn-primary:hover {\n  filter: brightness(0.9);\n}\n.btn-primary:disabled {\n  opacity: 0.6;\n  cursor: not-allowed;\n}\n.btn-secondary {\n  background-color: #f1f5f9;\n  color: #334155;\n  font-weight: 600;\n  padding: 0.5rem 1rem;\n  border-radius: 0.5rem;\n  transition: background-color 0.2s ease;\n}\n.btn-secondary:hover {\n  background-color: #e2e8f0;\n}\n.btn-primary-outline {\n  background-color: transparent;\n  color: var(--primary-color);\n  font-weight: 600;\n  padding: 0.5rem 1rem;\n  border-radius: 0.5rem;\n  border: 1px solid var(--primary-color);\n  transition: all 0.2s ease;\n}\n.btn-primary-outline:hover {\n  background-color: rgba(59, 130, 246, 0.08);\n}\n.modal-body {\n  max-height: calc(95vh - 120px);\n}\n.form-group {\n  margin-bottom: 1rem;\n}\n.form-group label {\n  font-weight: 500;\n  color: #374151;\n  margin-bottom: 0.25rem;\n}\n.form-group input,\n.form-group textarea,\n.form-group select {\n  transition: border-color 0.2s ease, box-shadow 0.2s ease;\n}\n.form-group input:focus,\n.form-group textarea:focus,\n.form-group select:focus {\n  outline: none;\n  border-color: #3b82f6;\n  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);\n}\n.activity-item {\n  padding: 0.75rem;\n  background: #f9fafb;\n  border-radius: 0.5rem;\n  border-left: 3px solid #e5e7eb;\n}\n.phase-item {\n  padding: 0.5rem;\n  border-radius: 0.25rem;\n  border-left: 4px solid;\n}\n.phase-item.current {\n  background-color: #eff6ff;\n  border-left-color: #3b82f6;\n}\n.action-button {\n  transition: all 0.2s ease;\n  border: 1px solid #d1d5db;\n}\n.action-button:hover {\n  background-color: #f9fafb;\n  border-color: #9ca3af;\n}\n.public-link-container {\n  background: #f8fafc;\n  border: 1px solid #e2e8f0;\n  border-radius: 0.5rem;\n  padding: 1rem;\n}\n.attachment-preview {\n  background: #f1f5f9;\n  border: 1px solid #cbd5e1;\n  padding: 0.5rem;\n  border-radius: 0.375rem;\n  font-size: 0.875rem;\n  color: #475569;\n}\n.spinner {\n  animation: spin 1s linear infinite;\n}\n@keyframes spin {\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n}\n.modal-body::-webkit-scrollbar,\n.activity-log::-webkit-scrollbar {\n  width: 6px;\n}\n.modal-body::-webkit-scrollbar-track,\n.activity-log::-webkit-scrollbar-track {\n  background: #f1f1f1;\n  border-radius: 3px;\n}\n.modal-body::-webkit-scrollbar-thumb,\n.activity-log::-webkit-scrollbar-thumb {\n  background: #c1c1c1;\n  border-radius: 3px;\n}\n.modal-body::-webkit-scrollbar-thumb:hover,\n.activity-log::-webkit-scrollbar-thumb:hover {\n  background: #a8a8a8;\n}\n/*# sourceMappingURL=lead-detail-modal.component.css.map */\n'] }]
  }], null, { ownerId: [{
    type: Input
  }], boardId: [{
    type: Input
  }], columns: [{
    type: Input
  }], users: [{
    type: Input
  }], leadUpdated: [{
    type: Output
  }], leadDeleted: [{
    type: Output
  }], closeModal: [{
    type: Output
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(LeadDetailModalComponent, { className: "LeadDetailModalComponent", filePath: "src/app/components/lead-detail-modal/lead-detail-modal.component.ts", lineNumber: 39 });
})();

// node_modules/@tinymce/tinymce-angular/fesm2022/tinymce-tinymce-angular.mjs
var getTinymce = /* @__PURE__ */ __name(() => {
  const w = typeof window !== "undefined" ? window : void 0;
  return w && w.tinymce ? w.tinymce : null;
}, "getTinymce");
var _Events = class _Events {
  onBeforePaste = new EventEmitter();
  onBlur = new EventEmitter();
  onClick = new EventEmitter();
  onCompositionEnd = new EventEmitter();
  onCompositionStart = new EventEmitter();
  onCompositionUpdate = new EventEmitter();
  onContextMenu = new EventEmitter();
  onCopy = new EventEmitter();
  onCut = new EventEmitter();
  onDblclick = new EventEmitter();
  onDrag = new EventEmitter();
  onDragDrop = new EventEmitter();
  onDragEnd = new EventEmitter();
  onDragGesture = new EventEmitter();
  onDragOver = new EventEmitter();
  onDrop = new EventEmitter();
  onFocus = new EventEmitter();
  onFocusIn = new EventEmitter();
  onFocusOut = new EventEmitter();
  onKeyDown = new EventEmitter();
  onKeyPress = new EventEmitter();
  onKeyUp = new EventEmitter();
  onMouseDown = new EventEmitter();
  onMouseEnter = new EventEmitter();
  onMouseLeave = new EventEmitter();
  onMouseMove = new EventEmitter();
  onMouseOut = new EventEmitter();
  onMouseOver = new EventEmitter();
  onMouseUp = new EventEmitter();
  onPaste = new EventEmitter();
  onSelectionChange = new EventEmitter();
  onActivate = new EventEmitter();
  onAddUndo = new EventEmitter();
  onBeforeAddUndo = new EventEmitter();
  onBeforeExecCommand = new EventEmitter();
  onBeforeGetContent = new EventEmitter();
  onBeforeRenderUI = new EventEmitter();
  onBeforeSetContent = new EventEmitter();
  onChange = new EventEmitter();
  onClearUndos = new EventEmitter();
  onDeactivate = new EventEmitter();
  onDirty = new EventEmitter();
  onExecCommand = new EventEmitter();
  onGetContent = new EventEmitter();
  onHide = new EventEmitter();
  onInit = new EventEmitter();
  onInput = new EventEmitter();
  onInitNgModel = new EventEmitter();
  onLoadContent = new EventEmitter();
  onNodeChange = new EventEmitter();
  onPostProcess = new EventEmitter();
  onPostRender = new EventEmitter();
  onPreInit = new EventEmitter();
  onPreProcess = new EventEmitter();
  onProgressState = new EventEmitter();
  onRedo = new EventEmitter();
  onRemove = new EventEmitter();
  onReset = new EventEmitter();
  onResizeEditor = new EventEmitter();
  onSaveContent = new EventEmitter();
  onSetAttrib = new EventEmitter();
  onObjectResizeStart = new EventEmitter();
  onObjectResized = new EventEmitter();
  onObjectSelected = new EventEmitter();
  onSetContent = new EventEmitter();
  onShow = new EventEmitter();
  onSubmit = new EventEmitter();
  onUndo = new EventEmitter();
  onVisualAid = new EventEmitter();
};
__name(_Events, "Events");
__publicField(_Events, "\u0275fac", /* @__PURE__ */ __name(function Events_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _Events)();
}, "Events_Factory"));
__publicField(_Events, "\u0275dir", /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _Events,
  outputs: {
    onBeforePaste: "onBeforePaste",
    onBlur: "onBlur",
    onClick: "onClick",
    onCompositionEnd: "onCompositionEnd",
    onCompositionStart: "onCompositionStart",
    onCompositionUpdate: "onCompositionUpdate",
    onContextMenu: "onContextMenu",
    onCopy: "onCopy",
    onCut: "onCut",
    onDblclick: "onDblclick",
    onDrag: "onDrag",
    onDragDrop: "onDragDrop",
    onDragEnd: "onDragEnd",
    onDragGesture: "onDragGesture",
    onDragOver: "onDragOver",
    onDrop: "onDrop",
    onFocus: "onFocus",
    onFocusIn: "onFocusIn",
    onFocusOut: "onFocusOut",
    onKeyDown: "onKeyDown",
    onKeyPress: "onKeyPress",
    onKeyUp: "onKeyUp",
    onMouseDown: "onMouseDown",
    onMouseEnter: "onMouseEnter",
    onMouseLeave: "onMouseLeave",
    onMouseMove: "onMouseMove",
    onMouseOut: "onMouseOut",
    onMouseOver: "onMouseOver",
    onMouseUp: "onMouseUp",
    onPaste: "onPaste",
    onSelectionChange: "onSelectionChange",
    onActivate: "onActivate",
    onAddUndo: "onAddUndo",
    onBeforeAddUndo: "onBeforeAddUndo",
    onBeforeExecCommand: "onBeforeExecCommand",
    onBeforeGetContent: "onBeforeGetContent",
    onBeforeRenderUI: "onBeforeRenderUI",
    onBeforeSetContent: "onBeforeSetContent",
    onChange: "onChange",
    onClearUndos: "onClearUndos",
    onDeactivate: "onDeactivate",
    onDirty: "onDirty",
    onExecCommand: "onExecCommand",
    onGetContent: "onGetContent",
    onHide: "onHide",
    onInit: "onInit",
    onInput: "onInput",
    onInitNgModel: "onInitNgModel",
    onLoadContent: "onLoadContent",
    onNodeChange: "onNodeChange",
    onPostProcess: "onPostProcess",
    onPostRender: "onPostRender",
    onPreInit: "onPreInit",
    onPreProcess: "onPreProcess",
    onProgressState: "onProgressState",
    onRedo: "onRedo",
    onRemove: "onRemove",
    onReset: "onReset",
    onResizeEditor: "onResizeEditor",
    onSaveContent: "onSaveContent",
    onSetAttrib: "onSetAttrib",
    onObjectResizeStart: "onObjectResizeStart",
    onObjectResized: "onObjectResized",
    onObjectSelected: "onObjectSelected",
    onSetContent: "onSetContent",
    onShow: "onShow",
    onSubmit: "onSubmit",
    onUndo: "onUndo",
    onVisualAid: "onVisualAid"
  },
  standalone: false
}));
var Events = _Events;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Events, [{
    type: Directive
  }], null, {
    onBeforePaste: [{
      type: Output
    }],
    onBlur: [{
      type: Output
    }],
    onClick: [{
      type: Output
    }],
    onCompositionEnd: [{
      type: Output
    }],
    onCompositionStart: [{
      type: Output
    }],
    onCompositionUpdate: [{
      type: Output
    }],
    onContextMenu: [{
      type: Output
    }],
    onCopy: [{
      type: Output
    }],
    onCut: [{
      type: Output
    }],
    onDblclick: [{
      type: Output
    }],
    onDrag: [{
      type: Output
    }],
    onDragDrop: [{
      type: Output
    }],
    onDragEnd: [{
      type: Output
    }],
    onDragGesture: [{
      type: Output
    }],
    onDragOver: [{
      type: Output
    }],
    onDrop: [{
      type: Output
    }],
    onFocus: [{
      type: Output
    }],
    onFocusIn: [{
      type: Output
    }],
    onFocusOut: [{
      type: Output
    }],
    onKeyDown: [{
      type: Output
    }],
    onKeyPress: [{
      type: Output
    }],
    onKeyUp: [{
      type: Output
    }],
    onMouseDown: [{
      type: Output
    }],
    onMouseEnter: [{
      type: Output
    }],
    onMouseLeave: [{
      type: Output
    }],
    onMouseMove: [{
      type: Output
    }],
    onMouseOut: [{
      type: Output
    }],
    onMouseOver: [{
      type: Output
    }],
    onMouseUp: [{
      type: Output
    }],
    onPaste: [{
      type: Output
    }],
    onSelectionChange: [{
      type: Output
    }],
    onActivate: [{
      type: Output
    }],
    onAddUndo: [{
      type: Output
    }],
    onBeforeAddUndo: [{
      type: Output
    }],
    onBeforeExecCommand: [{
      type: Output
    }],
    onBeforeGetContent: [{
      type: Output
    }],
    onBeforeRenderUI: [{
      type: Output
    }],
    onBeforeSetContent: [{
      type: Output
    }],
    onChange: [{
      type: Output
    }],
    onClearUndos: [{
      type: Output
    }],
    onDeactivate: [{
      type: Output
    }],
    onDirty: [{
      type: Output
    }],
    onExecCommand: [{
      type: Output
    }],
    onGetContent: [{
      type: Output
    }],
    onHide: [{
      type: Output
    }],
    onInit: [{
      type: Output
    }],
    onInput: [{
      type: Output
    }],
    onInitNgModel: [{
      type: Output
    }],
    onLoadContent: [{
      type: Output
    }],
    onNodeChange: [{
      type: Output
    }],
    onPostProcess: [{
      type: Output
    }],
    onPostRender: [{
      type: Output
    }],
    onPreInit: [{
      type: Output
    }],
    onPreProcess: [{
      type: Output
    }],
    onProgressState: [{
      type: Output
    }],
    onRedo: [{
      type: Output
    }],
    onRemove: [{
      type: Output
    }],
    onReset: [{
      type: Output
    }],
    onResizeEditor: [{
      type: Output
    }],
    onSaveContent: [{
      type: Output
    }],
    onSetAttrib: [{
      type: Output
    }],
    onObjectResizeStart: [{
      type: Output
    }],
    onObjectResized: [{
      type: Output
    }],
    onObjectSelected: [{
      type: Output
    }],
    onSetContent: [{
      type: Output
    }],
    onShow: [{
      type: Output
    }],
    onSubmit: [{
      type: Output
    }],
    onUndo: [{
      type: Output
    }],
    onVisualAid: [{
      type: Output
    }]
  });
})();
var validEvents = ["onActivate", "onAddUndo", "onBeforeAddUndo", "onBeforeExecCommand", "onBeforeGetContent", "onBeforeRenderUI", "onBeforeSetContent", "onBeforePaste", "onBlur", "onChange", "onClearUndos", "onClick", "onCompositionEnd", "onCompositionStart", "onCompositionUpdate", "onContextMenu", "onCopy", "onCut", "onDblclick", "onDeactivate", "onDirty", "onDrag", "onDragDrop", "onDragEnd", "onDragGesture", "onDragOver", "onDrop", "onExecCommand", "onFocus", "onFocusIn", "onFocusOut", "onGetContent", "onHide", "onInit", "onInput", "onKeyDown", "onKeyPress", "onKeyUp", "onLoadContent", "onMouseDown", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseOut", "onMouseOver", "onMouseUp", "onNodeChange", "onObjectResizeStart", "onObjectResized", "onObjectSelected", "onPaste", "onPostProcess", "onPostRender", "onPreProcess", "onProgressState", "onRedo", "onRemove", "onReset", "onResizeEditor", "onSaveContent", "onSelectionChange", "onSetAttrib", "onSetContent", "onShow", "onSubmit", "onUndo", "onVisualAid"];
var listenTinyMCEEvent = /* @__PURE__ */ __name((editor, eventName, destroy$) => fromEvent(editor, eventName).pipe(takeUntil(destroy$)), "listenTinyMCEEvent");
var bindHandlers = /* @__PURE__ */ __name((ctx, editor, destroy$) => {
  const allowedEvents = getValidEvents(ctx);
  allowedEvents.forEach((eventName) => {
    const eventEmitter = ctx[eventName];
    listenTinyMCEEvent(editor, eventName.substring(2), destroy$).subscribe((event) => {
      if (isObserved(eventEmitter)) {
        ctx.ngZone.run(() => eventEmitter.emit({
          event,
          editor
        }));
      }
    });
  });
}, "bindHandlers");
var getValidEvents = /* @__PURE__ */ __name((ctx) => {
  const ignoredEvents = parseStringProperty(ctx.ignoreEvents, []);
  const allowedEvents = parseStringProperty(ctx.allowedEvents, validEvents).filter((event) => validEvents.includes(event) && !ignoredEvents.includes(event));
  return allowedEvents;
}, "getValidEvents");
var parseStringProperty = /* @__PURE__ */ __name((property, defaultValue) => {
  if (typeof property === "string") {
    return property.split(",").map((value) => value.trim());
  }
  if (Array.isArray(property)) {
    return property;
  }
  return defaultValue;
}, "parseStringProperty");
var unique = 0;
var uuid = /* @__PURE__ */ __name((prefix) => {
  const date = /* @__PURE__ */ new Date();
  const time = date.getTime();
  const random = Math.floor(Math.random() * 1e9);
  unique++;
  return prefix + "_" + random + unique + String(time);
}, "uuid");
var isTextarea = /* @__PURE__ */ __name((element) => typeof element !== "undefined" && element.tagName.toLowerCase() === "textarea", "isTextarea");
var normalizePluginArray = /* @__PURE__ */ __name((plugins) => {
  if (typeof plugins === "undefined" || plugins === "") {
    return [];
  }
  return Array.isArray(plugins) ? plugins : plugins.split(" ");
}, "normalizePluginArray");
var mergePlugins = /* @__PURE__ */ __name((initPlugins, inputPlugins) => normalizePluginArray(initPlugins).concat(normalizePluginArray(inputPlugins)), "mergePlugins");
var noop = /* @__PURE__ */ __name(() => {
}, "noop");
var isNullOrUndefined = /* @__PURE__ */ __name((value) => value === null || value === void 0, "isNullOrUndefined");
var isObserved = /* @__PURE__ */ __name((o) => (
  // RXJS is making the `observers` property internal in v8. So this is intended as a backwards compatible way of
  // checking if a subject has observers.
  o.observed || o.observers?.length > 0
), "isObserved");
var firstEmission = /* @__PURE__ */ __name(() => (source) => source.pipe(first(), map(() => void 0)), "firstEmission");
var CreateScriptLoader = /* @__PURE__ */ __name(() => {
  const params$ = new BehaviorSubject(null);
  const loaded$ = params$.pipe(
    filter(Boolean),
    switchMap(([doc, url]) => {
      const scriptTag = doc.createElement("script");
      scriptTag.referrerPolicy = "origin";
      scriptTag.type = "application/javascript";
      scriptTag.src = url;
      doc.head.appendChild(scriptTag);
      return fromEvent(scriptTag, "load").pipe(firstEmission());
    }),
    // Caretaker note: `loaded$` is a multicast observable since it's piped with `shareReplay`,
    // so if there're multiple editor components simultaneously on the page, they'll subscribe to the internal
    // `ReplaySubject`. The script will be loaded only once, and `ReplaySubject` will cache the result.
    shareReplay({
      bufferSize: 1,
      refCount: true
    })
  );
  return {
    load: /* @__PURE__ */ __name((...args) => {
      if (!params$.getValue()) {
        params$.next(args);
      }
      return loaded$;
    }, "load"),
    reinitialize: /* @__PURE__ */ __name(() => {
      params$.next(null);
    }, "reinitialize")
  };
}, "CreateScriptLoader");
var ScriptLoader = CreateScriptLoader();
var TINYMCE_SCRIPT_SRC = new InjectionToken("TINYMCE_SCRIPT_SRC");
var EDITOR_COMPONENT_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => EditorComponent),
  multi: true
};
var _EditorComponent = class _EditorComponent extends Events {
  cdRef;
  platformId;
  tinymceScriptSrc;
  cloudChannel = "7";
  apiKey = "no-api-key";
  licenseKey;
  init;
  id = "";
  initialValue;
  outputFormat;
  inline;
  tagName;
  plugins;
  toolbar;
  modelEvents = "change input undo redo";
  allowedEvents;
  ignoreEvents;
  set disabled(val) {
    this._disabled = val;
    if (this._editor && this._editor.initialized) {
      if (typeof this._editor.mode?.set === "function") {
        this._editor.mode.set(val ? "readonly" : "design");
      } else {
        this._editor.setMode(val ? "readonly" : "design");
      }
    }
  }
  get disabled() {
    return this._disabled;
  }
  get editor() {
    return this._editor;
  }
  ngZone;
  _elementRef;
  _element;
  _disabled;
  _editor;
  onTouchedCallback = noop;
  onChangeCallback;
  destroy$ = new Subject();
  constructor(elementRef, ngZone, cdRef, platformId, tinymceScriptSrc) {
    super();
    this.cdRef = cdRef;
    this.platformId = platformId;
    this.tinymceScriptSrc = tinymceScriptSrc;
    this._elementRef = elementRef;
    this.ngZone = ngZone;
  }
  writeValue(value) {
    if (this._editor && this._editor.initialized) {
      this._editor.setContent(isNullOrUndefined(value) ? "" : value);
    } else {
      this.initialValue = value === null ? void 0 : value;
    }
  }
  registerOnChange(fn) {
    this.onChangeCallback = fn;
  }
  registerOnTouched(fn) {
    this.onTouchedCallback = fn;
  }
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  ngAfterViewInit() {
    if (isPlatformBrowser(this.platformId)) {
      this.id = this.id || uuid("tiny-angular");
      this.inline = this.inline !== void 0 ? this.inline !== false : !!this.init?.inline;
      this.createElement();
      if (getTinymce() !== null) {
        this.initialise();
      } else if (this._element && this._element.ownerDocument) {
        ScriptLoader.load(this._element.ownerDocument, this.getScriptSrc()).pipe(takeUntil(this.destroy$)).subscribe(this.initialise);
      }
    }
  }
  ngOnDestroy() {
    this.destroy$.next();
    if (getTinymce() !== null) {
      getTinymce().remove(this._editor);
    }
  }
  createElement() {
    const tagName = typeof this.tagName === "string" ? this.tagName : "div";
    this._element = document.createElement(this.inline ? tagName : "textarea");
    if (this._element) {
      const existingElement = document.getElementById(this.id);
      if (existingElement && existingElement !== this._elementRef.nativeElement) {
        console.warn(`TinyMCE-Angular: an element with id [${this.id}] already exists. Editors with duplicate Id will not be able to mount`);
      }
      this._element.id = this.id;
      if (isTextarea(this._element)) {
        this._element.style.visibility = "hidden";
      }
      this._elementRef.nativeElement.appendChild(this._element);
    }
  }
  initialise = /* @__PURE__ */ __name(() => {
    const finalInit = __spreadProps(__spreadValues({}, this.init), {
      selector: void 0,
      target: this._element,
      inline: this.inline,
      readonly: this.disabled,
      license_key: this.licenseKey,
      plugins: mergePlugins(this.init && this.init.plugins, this.plugins),
      toolbar: this.toolbar || this.init && this.init.toolbar,
      setup: /* @__PURE__ */ __name((editor) => {
        this._editor = editor;
        listenTinyMCEEvent(editor, "init", this.destroy$).subscribe(() => {
          this.initEditor(editor);
        });
        bindHandlers(this, editor, this.destroy$);
        if (this.init && typeof this.init.setup === "function") {
          this.init.setup(editor);
        }
      }, "setup")
    });
    if (isTextarea(this._element)) {
      this._element.style.visibility = "";
    }
    this.ngZone.runOutsideAngular(() => {
      getTinymce().init(finalInit);
    });
  }, "initialise");
  getScriptSrc() {
    return isNullOrUndefined(this.tinymceScriptSrc) ? `https://cdn.tiny.cloud/1/${this.apiKey}/tinymce/${this.cloudChannel}/tinymce.min.js` : this.tinymceScriptSrc;
  }
  initEditor(editor) {
    listenTinyMCEEvent(editor, "blur", this.destroy$).subscribe(() => {
      this.cdRef.markForCheck();
      this.ngZone.run(() => this.onTouchedCallback());
    });
    listenTinyMCEEvent(editor, this.modelEvents, this.destroy$).subscribe(() => {
      this.cdRef.markForCheck();
      this.ngZone.run(() => this.emitOnChange(editor));
    });
    if (typeof this.initialValue === "string") {
      this.ngZone.run(() => {
        editor.setContent(this.initialValue);
        if (editor.getContent() !== this.initialValue) {
          this.emitOnChange(editor);
        }
        if (this.onInitNgModel !== void 0) {
          this.onInitNgModel.emit(editor);
        }
      });
    }
  }
  emitOnChange(editor) {
    if (this.onChangeCallback) {
      this.onChangeCallback(editor.getContent({
        format: this.outputFormat
      }));
    }
  }
};
__name(_EditorComponent, "EditorComponent");
__publicField(_EditorComponent, "\u0275fac", /* @__PURE__ */ __name(function EditorComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _EditorComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(PLATFORM_ID), \u0275\u0275directiveInject(TINYMCE_SCRIPT_SRC, 8));
}, "EditorComponent_Factory"));
__publicField(_EditorComponent, "\u0275cmp", /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _EditorComponent,
  selectors: [["editor"]],
  inputs: {
    cloudChannel: "cloudChannel",
    apiKey: "apiKey",
    licenseKey: "licenseKey",
    init: "init",
    id: "id",
    initialValue: "initialValue",
    outputFormat: "outputFormat",
    inline: "inline",
    tagName: "tagName",
    plugins: "plugins",
    toolbar: "toolbar",
    modelEvents: "modelEvents",
    allowedEvents: "allowedEvents",
    ignoreEvents: "ignoreEvents",
    disabled: "disabled"
  },
  features: [\u0275\u0275ProvidersFeature([EDITOR_COMPONENT_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: /* @__PURE__ */ __name(function EditorComponent_Template(rf, ctx) {
  }, "EditorComponent_Template"),
  dependencies: [CommonModule, FormsModule],
  styles: ["[_nghost-%COMP%]{display:block}"],
  changeDetection: 0
}));
var EditorComponent = _EditorComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EditorComponent, [{
    type: Component,
    args: [{
      selector: "editor",
      template: "",
      providers: [EDITOR_COMPONENT_VALUE_ACCESSOR],
      standalone: true,
      imports: [CommonModule, FormsModule],
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [":host{display:block}\n"]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NgZone
  }, {
    type: ChangeDetectorRef
  }, {
    type: Object,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [TINYMCE_SCRIPT_SRC]
    }]
  }], {
    cloudChannel: [{
      type: Input
    }],
    apiKey: [{
      type: Input
    }],
    licenseKey: [{
      type: Input
    }],
    init: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    initialValue: [{
      type: Input
    }],
    outputFormat: [{
      type: Input
    }],
    inline: [{
      type: Input
    }],
    tagName: [{
      type: Input
    }],
    plugins: [{
      type: Input
    }],
    toolbar: [{
      type: Input
    }],
    modelEvents: [{
      type: Input
    }],
    allowedEvents: [{
      type: Input
    }],
    ignoreEvents: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }]
  });
})();
var _EditorModule = class _EditorModule {
};
__name(_EditorModule, "EditorModule");
__publicField(_EditorModule, "\u0275fac", /* @__PURE__ */ __name(function EditorModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _EditorModule)();
}, "EditorModule_Factory"));
__publicField(_EditorModule, "\u0275mod", /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _EditorModule,
  imports: [EditorComponent],
  exports: [EditorComponent]
}));
__publicField(_EditorModule, "\u0275inj", /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [EditorComponent]
}));
var EditorModule = _EditorModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EditorModule, [{
    type: NgModule,
    args: [{
      imports: [EditorComponent],
      exports: [EditorComponent]
    }]
  }], null, null);
})();

// src/app/components/template-modal/template-modal.component.ts
function TemplateModalComponent_div_0_button_35_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 33);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function TemplateModalComponent_div_0_button_35_Template_button_click_0_listener() {
      const variable_r4 = \u0275\u0275restoreView(_r3).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.insertVariable(variable_r4.value));
    }, "TemplateModalComponent_div_0_button_35_Template_button_click_0_listener"));
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const variable_r4 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("disabled", ctx_r1.isLoading);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", variable_r4.value, " ");
  }
}
__name(TemplateModalComponent_div_0_button_35_Template, "TemplateModalComponent_div_0_button_35_Template");
function TemplateModalComponent_div_0_div_45_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 34);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.errorMessage, " ");
  }
}
__name(TemplateModalComponent_div_0_div_45_Template, "TemplateModalComponent_div_0_div_45_Template");
function TemplateModalComponent_div_0_div_50_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 35);
  }
}
__name(TemplateModalComponent_div_0_div_50_Template, "TemplateModalComponent_div_0_div_50_Template");
function TemplateModalComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 1);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function TemplateModalComponent_div_0_Template_div_click_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onBackdropClick($event));
    }, "TemplateModalComponent_div_0_Template_div_click_0_listener"));
    \u0275\u0275elementStart(1, "div", 2)(2, "div", 3)(3, "h2", 4);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "button", 5);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function TemplateModalComponent_div_0_Template_button_click_5_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.hide());
    }, "TemplateModalComponent_div_0_Template_button_click_5_listener"));
    \u0275\u0275text(6, " \xD7 ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(7, "form", 6);
    \u0275\u0275listener("ngSubmit", /* @__PURE__ */ __name(function TemplateModalComponent_div_0_Template_form_ngSubmit_7_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.saveTemplate());
    }, "TemplateModalComponent_div_0_Template_form_ngSubmit_7_listener"));
    \u0275\u0275elementStart(8, "div", 7)(9, "div", 8)(10, "label", 9);
    \u0275\u0275text(11, " Nome do Template ");
    \u0275\u0275elementStart(12, "span", 10);
    \u0275\u0275text(13, "*");
    \u0275\u0275elementEnd()();
    \u0275\u0275element(14, "input", 11);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(15, "div", 8)(16, "label", 12);
    \u0275\u0275text(17, " Destinat\xE1rios ");
    \u0275\u0275elementEnd();
    \u0275\u0275element(18, "input", 13);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(19, "div", 14)(20, "label", 15);
    \u0275\u0275text(21, " Assunto ");
    \u0275\u0275elementStart(22, "span", 10);
    \u0275\u0275text(23, "*");
    \u0275\u0275elementEnd()();
    \u0275\u0275element(24, "input", 16);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(25, "div", 17)(26, "div", 18)(27, "label", 19);
    \u0275\u0275text(28, " Corpo do Email ");
    \u0275\u0275elementStart(29, "span", 10);
    \u0275\u0275text(30, "*");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(31, "div", 20)(32, "p", 21);
    \u0275\u0275text(33, "Clique para inserir vari\xE1veis:");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(34, "div", 22);
    \u0275\u0275template(35, TemplateModalComponent_div_0_button_35_Template, 2, 2, "button", 23);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(36, "p", 24);
    \u0275\u0275text(37, " As vari\xE1veis ser\xE3o substitu\xEDdas automaticamente pelos dados reais do lead quando o email for enviado. ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(38, "div", 17)(39, "label", 25);
    \u0275\u0275text(40, " Corpo do E-mail ");
    \u0275\u0275elementStart(41, "span", 10);
    \u0275\u0275text(42, "*");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(43, "div", 26)(44, "editor", 27);
    \u0275\u0275listener("onInit", /* @__PURE__ */ __name(function TemplateModalComponent_div_0_Template_editor_onInit_44_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onEditorInit($event.editor));
    }, "TemplateModalComponent_div_0_Template_editor_onInit_44_listener"));
    \u0275\u0275elementEnd()()()();
    \u0275\u0275template(45, TemplateModalComponent_div_0_div_45_Template, 2, 1, "div", 28);
    \u0275\u0275elementStart(46, "div", 29)(47, "button", 30);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function TemplateModalComponent_div_0_Template_button_click_47_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.hide());
    }, "TemplateModalComponent_div_0_Template_button_click_47_listener"));
    \u0275\u0275text(48, " Cancelar ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(49, "button", 31);
    \u0275\u0275template(50, TemplateModalComponent_div_0_div_50_Template, 1, 0, "div", 32);
    \u0275\u0275text(51);
    \u0275\u0275elementEnd()()()()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", ctx_r1.isEditing ? "Editar Template" : "Criar Novo Template", " ");
    \u0275\u0275advance();
    \u0275\u0275property("disabled", ctx_r1.isLoading);
    \u0275\u0275advance(2);
    \u0275\u0275property("formGroup", ctx_r1.templateForm);
    \u0275\u0275advance(7);
    \u0275\u0275property("disabled", ctx_r1.isLoading);
    \u0275\u0275advance(4);
    \u0275\u0275property("placeholder", \u0275\u0275interpolate2("Ex: ", "{{", "contactEmail", "}}"))("disabled", ctx_r1.isLoading);
    \u0275\u0275advance(6);
    \u0275\u0275property("disabled", ctx_r1.isLoading);
    \u0275\u0275advance(11);
    \u0275\u0275property("ngForOf", ctx_r1.variables);
    \u0275\u0275advance(9);
    \u0275\u0275property("init", ctx_r1.tinymceConfig);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.errorMessage);
    \u0275\u0275advance(2);
    \u0275\u0275property("disabled", ctx_r1.isLoading);
    \u0275\u0275advance(2);
    \u0275\u0275property("disabled", ctx_r1.isLoading || !ctx_r1.templateForm.valid);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.isLoading);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.isLoading ? "Salvando..." : ctx_r1.isEditing ? "Atualizar Template" : "Criar Template", " ");
  }
}
__name(TemplateModalComponent_div_0_Template, "TemplateModalComponent_div_0_Template");
var _TemplateModalComponent = class _TemplateModalComponent {
  firestoreService = inject(FirestoreService);
  fb = inject(FormBuilder);
  ownerId = "";
  boardId = "";
  templateSaved = new EventEmitter();
  closeModal = new EventEmitter();
  isVisible = false;
  isEditing = false;
  isLoading = false;
  errorMessage = "";
  currentTemplate = null;
  tinymceEditor = null;
  // Configuração do TinyMCE
  tinymceConfig = {
    height: 400,
    menubar: false,
    plugins: [
      "advlist",
      "autolink",
      "lists",
      "link",
      "image",
      "charmap",
      "preview",
      "anchor",
      "searchreplace",
      "visualblocks",
      "code",
      "fullscreen",
      "insertdatetime",
      "media",
      "table",
      "help",
      "wordcount"
    ],
    toolbar: "undo redo | blocks | bold italic backcolor | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | removeformat | code | help",
    content_style: "body { font-family:Helvetica,Arial,sans-serif; font-size:14px }",
    placeholder: "Digite o conte\xFAdo do seu template de email aqui...",
    branding: false,
    code_dialog_width: 800,
    code_dialog_height: 600
  };
  templateForm = this.fb.group({
    name: ["", [Validators.required]],
    subject: ["", [Validators.required]],
    recipients: [""],
    body: ["", [Validators.required]]
  });
  variables = [];
  ngAfterViewInit() {
    console.log("Template modal inicializado");
  }
  // Método para inserir variáveis no TinyMCE na posição do cursor
  insertVariable(variable) {
    if (this.tinymceEditor) {
      try {
        this.tinymceEditor.insertContent(variable);
        this.tinymceEditor.focus();
        return;
      } catch (error) {
        console.warn("Falha ao inserir no TinyMCE, usando fallback:", error);
      }
    }
    const currentContent = this.templateForm.get("body")?.value || "";
    const newContent = currentContent + " " + variable;
    this.templateForm.patchValue({ body: newContent });
  }
  // Método chamado quando TinyMCE é inicializado
  onEditorInit(editor) {
    this.tinymceEditor = editor;
    console.log("TinyMCE Editor inicializado e pronto");
  }
  showCreateModal() {
    this.isEditing = false;
    this.currentTemplate = null;
    this.isVisible = true;
    this.resetForm();
    this.loadDynamicVariables();
  }
  showEditModal(template) {
    this.isEditing = true;
    this.currentTemplate = template;
    this.isVisible = true;
    this.populateForm(template);
    this.loadDynamicVariables();
  }
  hide() {
    this.isVisible = false;
    this.resetForm();
    this.closeModal.emit();
  }
  resetForm() {
    this.templateForm.reset({
      name: "",
      subject: "",
      recipients: "",
      body: ""
    });
    this.errorMessage = "";
    this.isLoading = false;
  }
  populateForm(template) {
    console.log("Carregando template:", template);
    this.templateForm.patchValue({
      name: template.name || "",
      subject: template.subject || "",
      recipients: template.recipients || "",
      body: template.body || ""
    });
    console.log("Template carregado:", template.body);
  }
  loadDynamicVariables() {
    return __async(this, null, function* () {
      try {
        const base = [
          { name: "Nome do Respons\xE1vel", value: "{{nomeResponsavel}}" },
          { name: "Email do Respons\xE1vel", value: "{{emailResponsavel}}" },
          { name: "Nome da Fase Atual", value: "{{currentPhaseName}}" },
          { name: "Data Atual", value: "{{currentDate}}" },
          { name: "Link do Registro", value: "{{leadLink}}" }
        ];
        const initial = yield this.firestoreService.getInitialFormConfig(this.boardId);
        const dynamic = [];
        const pushField = /* @__PURE__ */ __name((f) => {
          const key = f.apiFieldName?.trim() || f.name?.trim();
          if (!key)
            return;
          dynamic.push({ name: f.label || key, value: `{{${key}}}` });
        }, "pushField");
        if (initial?.fields && Array.isArray(initial.fields)) {
          initial.fields.forEach(pushField);
        }
        if (dynamic.length === 0) {
          dynamic.push({ name: "Nome", value: "{{name}}" }, { name: "Email", value: "{{email}}" }, { name: "Telefone", value: "{{phone}}" });
        }
        this.variables = [...dynamic, ...base];
      } catch {
        this.variables = [
          { name: "Nome", value: "{{name}}" },
          { name: "Email", value: "{{email}}" },
          { name: "Telefone", value: "{{phone}}" },
          { name: "Data Atual", value: "{{currentDate}}" }
        ];
      }
    });
  }
  saveTemplate() {
    return __async(this, null, function* () {
      if (!this.templateForm.valid) {
        this.errorMessage = "Por favor, preencha todos os campos obrigat\xF3rios.";
        return;
      }
      this.isLoading = true;
      this.errorMessage = "";
      try {
        const formData = this.templateForm.value;
        const templateData = {
          name: formData.name,
          subject: formData.subject,
          recipients: formData.recipients || "",
          body: formData.body || ""
        };
        if (this.isEditing && this.currentTemplate) {
          yield this.firestoreService.updateEmailTemplate(this.ownerId, this.boardId, this.currentTemplate.id, templateData);
        } else {
          yield this.firestoreService.createEmailTemplate(this.ownerId, this.boardId, templateData);
        }
        this.templateSaved.emit();
        this.hide();
      } catch (error) {
        console.error("Erro ao salvar template:", error);
        this.errorMessage = "Erro ao salvar template. Tente novamente.";
      } finally {
        this.isLoading = false;
      }
    });
  }
  onBackdropClick(event) {
    if (event.target === event.currentTarget) {
      this.hide();
    }
  }
};
__name(_TemplateModalComponent, "TemplateModalComponent");
__publicField(_TemplateModalComponent, "\u0275fac", /* @__PURE__ */ __name(function TemplateModalComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _TemplateModalComponent)();
}, "TemplateModalComponent_Factory"));
__publicField(_TemplateModalComponent, "\u0275cmp", /* @__PURE__ */ \u0275\u0275defineComponent({ type: _TemplateModalComponent, selectors: [["app-template-modal"]], inputs: { ownerId: "ownerId", boardId: "boardId" }, outputs: { templateSaved: "templateSaved", closeModal: "closeModal" }, features: [\u0275\u0275ProvidersFeature([
  { provide: TINYMCE_SCRIPT_SRC, useValue: "tinymce/tinymce.min.js" }
])], decls: 1, vars: 1, consts: [["class", "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", 3, "click", 4, "ngIf"], [1, "fixed", "inset-0", "bg-black", "bg-opacity-50", "flex", "items-center", "justify-center", "z-50", "p-4", 3, "click"], [1, "bg-white", "rounded-xl", "shadow-2xl", "w-full", "max-w-6xl", "max-h-[95vh]", "overflow-hidden"], [1, "flex", "justify-between", "items-center", "p-6", "border-b", "border-gray-200"], [1, "text-2xl", "font-bold", "text-gray-900"], [1, "text-gray-400", "hover:text-gray-600", "text-2xl", "font-bold", 3, "click", "disabled"], [1, "p-6", "max-h-[calc(95vh-120px)]", "overflow-y-auto", 3, "ngSubmit", "formGroup"], [1, "grid", "grid-cols-1", "md:grid-cols-2", "gap-4", "mb-4"], [1, "form-group"], ["for", "templateName", 1, "block", "text-sm", "font-medium", "text-gray-700", "mb-1"], [1, "text-red-500"], ["type", "text", "id", "templateName", "formControlName", "name", "placeholder", "Ex: Template de boas-vindas, email promocional, etc.", 1, "w-full", "p-3", "border", "border-gray-300", "rounded-lg", "focus:ring-2", "focus:ring-blue-500", "focus:border-blue-500", 3, "disabled"], ["for", "templateRecipients", 1, "block", "text-sm", "font-medium", "text-gray-700", "mb-1"], ["type", "text", "id", "templateRecipients", "formControlName", "recipients", 1, "w-full", "p-3", "border", "border-gray-300", "rounded-lg", "focus:ring-2", "focus:ring-blue-500", "focus:border-blue-500", 3, "disabled", "placeholder"], [1, "form-group", "mb-4"], ["for", "templateSubject", 1, "block", "text-sm", "font-medium", "text-gray-700", "mb-1"], ["type", "text", "id", "templateSubject", "formControlName", "subject", "placeholder", "Ex: Obrigado por entrar em contato", 1, "w-full", "p-3", "border", "border-gray-300", "rounded-lg", "focus:ring-2", "focus:ring-blue-500", "focus:border-blue-500", 3, "disabled"], [1, "mb-4"], [1, "flex", "justify-between", "items-center", "mb-2"], [1, "block", "text-sm", "font-medium", "text-gray-700"], [1, "bg-gray-50", "p-3", "rounded-md", "mb-3"], [1, "text-xs", "text-gray-600", "mb-2"], [1, "flex", "flex-wrap", "gap-1"], ["type", "button", "class", "variable-tag px-2 py-1 bg-blue-100 text-blue-800 text-xs rounded hover:bg-blue-200 transition-colors", 3, "disabled", "click", 4, "ngFor", "ngForOf"], [1, "text-xs", "text-gray-500", "mt-2"], [1, "block", "text-sm", "font-medium", "text-gray-700", "mb-2"], [1, "border", "border-gray-300", "rounded-lg", "overflow-hidden"], ["formControlName", "body", 3, "onInit", "init"], ["class", "mb-4 bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg", 4, "ngIf"], [1, "flex", "justify-end", "gap-3", "pt-4", "border-t", "border-gray-200"], ["type", "button", 1, "px-6", "py-3", "text-gray-700", "bg-gray-200", "hover:bg-gray-300", "rounded-lg", "font-medium", "transition-colors", 3, "click", "disabled"], ["type", "submit", 1, "px-6", "py-3", "bg-blue-500", "hover:bg-blue-600", "disabled:bg-blue-300", "text-white", "rounded-lg", "font-medium", "transition-colors", "flex", "items-center", 3, "disabled"], ["class", "animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2", 4, "ngIf"], ["type", "button", 1, "variable-tag", "px-2", "py-1", "bg-blue-100", "text-blue-800", "text-xs", "rounded", "hover:bg-blue-200", "transition-colors", 3, "click", "disabled"], [1, "mb-4", "bg-red-50", "border", "border-red-200", "text-red-700", "px-4", "py-3", "rounded-lg"], [1, "animate-spin", "rounded-full", "h-4", "w-4", "border-b-2", "border-white", "mr-2"]], template: /* @__PURE__ */ __name(function TemplateModalComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, TemplateModalComponent_div_0_Template, 52, 16, "div", 0);
  }
  if (rf & 2) {
    \u0275\u0275property("ngIf", ctx.isVisible);
  }
}, "TemplateModalComponent_Template"), dependencies: [CommonModule, NgForOf, NgIf, FormsModule, \u0275NgNoValidate, DefaultValueAccessor, NgControlStatus, NgControlStatusGroup, ReactiveFormsModule, FormGroupDirective, FormControlName, EditorModule, EditorComponent], styles: ["\n\n.form-group[_ngcontent-%COMP%] {\n  margin-bottom: 1rem;\n}\n.form-group[_ngcontent-%COMP%]   label[_ngcontent-%COMP%] {\n  font-weight: 500;\n  color: #374151;\n}\n.form-group[_ngcontent-%COMP%]   input[_ngcontent-%COMP%], \n.form-group[_ngcontent-%COMP%]   textarea[_ngcontent-%COMP%] {\n  transition: border-color 0.2s ease, box-shadow 0.2s ease;\n}\n.form-group[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]:focus, \n.form-group[_ngcontent-%COMP%]   textarea[_ngcontent-%COMP%]:focus {\n  outline: none;\n  border-color: #3b82f6;\n  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);\n}\n.variable-tag[_ngcontent-%COMP%] {\n  cursor: pointer;\n  -webkit-user-select: none;\n  user-select: none;\n}\n.variable-tag[_ngcontent-%COMP%]:hover {\n  transform: translateY(-1px);\n}\n[_nghost-%COMP%]     .ql-editor {\n  min-height: 300px;\n  font-size: 14px;\n  line-height: 1.6;\n}\n[_nghost-%COMP%]     .ql-toolbar {\n  border-top: 1px solid #d1d5db;\n  border-left: 1px solid #d1d5db;\n  border-right: 1px solid #d1d5db;\n  background-color: #f9fafb;\n}\n[_nghost-%COMP%]     .ql-container {\n  border-bottom: 1px solid #d1d5db;\n  border-left: 1px solid #d1d5db;\n  border-right: 1px solid #d1d5db;\n}\n[_nghost-%COMP%]     .ql-editor.ql-blank::before {\n  color: #9ca3af;\n  content: attr(data-placeholder);\n  font-style: italic;\n}\n.overflow-y-auto[_ngcontent-%COMP%]::-webkit-scrollbar {\n  width: 6px;\n}\n.overflow-y-auto[_ngcontent-%COMP%]::-webkit-scrollbar-track {\n  background: #f1f1f1;\n  border-radius: 3px;\n}\n.overflow-y-auto[_ngcontent-%COMP%]::-webkit-scrollbar-thumb {\n  background: #c1c1c1;\n  border-radius: 3px;\n}\n.overflow-y-auto[_ngcontent-%COMP%]::-webkit-scrollbar-thumb:hover {\n  background: #a8a8a8;\n}\n@keyframes _ngcontent-%COMP%_spin {\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n}\n.animate-spin[_ngcontent-%COMP%] {\n  animation: _ngcontent-%COMP%_spin 1s linear infinite;\n}\n/*# sourceMappingURL=template-modal.component.css.map */"] }));
var TemplateModalComponent = _TemplateModalComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TemplateModalComponent, [{
    type: Component,
    args: [{ selector: "app-template-modal", standalone: true, imports: [CommonModule, FormsModule, ReactiveFormsModule, EditorModule], providers: [
      { provide: TINYMCE_SCRIPT_SRC, useValue: "tinymce/tinymce.min.js" }
    ], template: `<div *ngIf="isVisible" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" (click)="onBackdropClick($event)">
  <div class="bg-white rounded-xl shadow-2xl w-full max-w-6xl max-h-[95vh] overflow-hidden">
    <!-- Header -->
    <div class="flex justify-between items-center p-6 border-b border-gray-200">
      <h2 class="text-2xl font-bold text-gray-900">
        {{ isEditing ? 'Editar Template' : 'Criar Novo Template' }}
      </h2>
      <button 
        (click)="hide()" 
        class="text-gray-400 hover:text-gray-600 text-2xl font-bold"
        [disabled]="isLoading">
        &times;
      </button>
    </div>

    <!-- Modal Body -->
    <form [formGroup]="templateForm" (ngSubmit)="saveTemplate()" class="p-6 max-h-[calc(95vh-120px)] overflow-y-auto">
      
      <!-- Campos b\xE1sicos -->
      <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
        <div class="form-group">
          <label for="templateName" class="block text-sm font-medium text-gray-700 mb-1">
            Nome do Template
            <span class="text-red-500">*</span>
          </label>
          <input 
            type="text"
            id="templateName"
            formControlName="name"
            class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
            [disabled]="isLoading"
            placeholder="Ex: Template de boas-vindas, email promocional, etc.">
        </div>
        
        <div class="form-group">
          <label for="templateRecipients" class="block text-sm font-medium text-gray-700 mb-1">
            Destinat\xE1rios
          </label>
          <input 
            type="text"
            id="templateRecipients"
            formControlName="recipients"
            class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
            [disabled]="isLoading"
            placeholder="Ex: {{'{{'}}contactEmail{{'}}'}}">
        </div>
      </div>

      <!-- Assunto -->
      <div class="form-group mb-4">
        <label for="templateSubject" class="block text-sm font-medium text-gray-700 mb-1">
          Assunto
          <span class="text-red-500">*</span>
        </label>
        <input 
          type="text"
          id="templateSubject"
          formControlName="subject"
          class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
          [disabled]="isLoading"
          placeholder="Ex: Obrigado por entrar em contato">
      </div>

      <!-- Editor de corpo -->
      <div class="mb-4">
        <div class="flex justify-between items-center mb-2">
          <label class="block text-sm font-medium text-gray-700">
            Corpo do Email
            <span class="text-red-500">*</span>
          </label>
        </div>

        <!-- Vari\xE1veis dispon\xEDveis -->
        <div class="bg-gray-50 p-3 rounded-md mb-3">
          <p class="text-xs text-gray-600 mb-2">Clique para inserir vari\xE1veis:</p>
          <div class="flex flex-wrap gap-1">
            <button
              *ngFor="let variable of variables"
              type="button"
              (click)="insertVariable(variable.value)"
              class="variable-tag px-2 py-1 bg-blue-100 text-blue-800 text-xs rounded hover:bg-blue-200 transition-colors"
              [disabled]="isLoading">
              {{ variable.value }}
            </button>
          </div>
          <p class="text-xs text-gray-500 mt-2">
            As vari\xE1veis ser\xE3o substitu\xEDdas automaticamente pelos dados reais do lead quando o email for enviado.
          </p>
        </div>

        <!-- Editor TinyMCE -->
        <div class="mb-4">
          <label class="block text-sm font-medium text-gray-700 mb-2">
            Corpo do E-mail
            <span class="text-red-500">*</span>
          </label>
          
          <div class="border border-gray-300 rounded-lg overflow-hidden">
            <editor
              [init]="tinymceConfig"
              formControlName="body"
              (onInit)="onEditorInit($event.editor)">
            </editor>
          </div>
        </div>
      </div>

      <!-- Mensagem de erro -->
      <div *ngIf="errorMessage" class="mb-4 bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg">
        {{ errorMessage }}
      </div>


      <!-- Bot\xF5es de a\xE7\xE3o -->
      <div class="flex justify-end gap-3 pt-4 border-t border-gray-200">
        <button 
          type="button" 
          (click)="hide()"
          class="px-6 py-3 text-gray-700 bg-gray-200 hover:bg-gray-300 rounded-lg font-medium transition-colors"
          [disabled]="isLoading">
          Cancelar
        </button>
        
        <button 
          type="submit" 
          [disabled]="isLoading || !templateForm.valid"
          class="px-6 py-3 bg-blue-500 hover:bg-blue-600 disabled:bg-blue-300 text-white rounded-lg font-medium transition-colors flex items-center">
          <div *ngIf="isLoading" class="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2"></div>
          {{ isLoading ? 'Salvando...' : (isEditing ? 'Atualizar Template' : 'Criar Template') }}
        </button>
      </div>
    </form>
  </div>
</div>`, styles: ["/* src/app/components/template-modal/template-modal.component.scss */\n.form-group {\n  margin-bottom: 1rem;\n}\n.form-group label {\n  font-weight: 500;\n  color: #374151;\n}\n.form-group input,\n.form-group textarea {\n  transition: border-color 0.2s ease, box-shadow 0.2s ease;\n}\n.form-group input:focus,\n.form-group textarea:focus {\n  outline: none;\n  border-color: #3b82f6;\n  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);\n}\n.variable-tag {\n  cursor: pointer;\n  -webkit-user-select: none;\n  user-select: none;\n}\n.variable-tag:hover {\n  transform: translateY(-1px);\n}\n:host ::ng-deep .ql-editor {\n  min-height: 300px;\n  font-size: 14px;\n  line-height: 1.6;\n}\n:host ::ng-deep .ql-toolbar {\n  border-top: 1px solid #d1d5db;\n  border-left: 1px solid #d1d5db;\n  border-right: 1px solid #d1d5db;\n  background-color: #f9fafb;\n}\n:host ::ng-deep .ql-container {\n  border-bottom: 1px solid #d1d5db;\n  border-left: 1px solid #d1d5db;\n  border-right: 1px solid #d1d5db;\n}\n:host ::ng-deep .ql-editor.ql-blank::before {\n  color: #9ca3af;\n  content: attr(data-placeholder);\n  font-style: italic;\n}\n.overflow-y-auto::-webkit-scrollbar {\n  width: 6px;\n}\n.overflow-y-auto::-webkit-scrollbar-track {\n  background: #f1f1f1;\n  border-radius: 3px;\n}\n.overflow-y-auto::-webkit-scrollbar-thumb {\n  background: #c1c1c1;\n  border-radius: 3px;\n}\n.overflow-y-auto::-webkit-scrollbar-thumb:hover {\n  background: #a8a8a8;\n}\n@keyframes spin {\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n}\n.animate-spin {\n  animation: spin 1s linear infinite;\n}\n/*# sourceMappingURL=template-modal.component.css.map */\n"] }]
  }], null, { ownerId: [{
    type: Input
  }], boardId: [{
    type: Input
  }], templateSaved: [{
    type: Output
  }], closeModal: [{
    type: Output
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(TemplateModalComponent, { className: "TemplateModalComponent", filePath: "src/app/components/template-modal/template-modal.component.ts", lineNumber: 17 });
})();

// src/app/components/automation-modal/automation-modal.ts
var _c06 = /* @__PURE__ */ __name(() => ({ standalone: true }), "_c0");
function AutomationModal_ng_container_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "option", 24);
    \u0275\u0275text(2, "Criar novo registro (apenas fase inicial)");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "option", 25);
    \u0275\u0275text(4, "Um card entrou na fase");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "option", 26);
    \u0275\u0275text(6, "Um card est\xE1 na fase por um tempo");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "option", 27);
    \u0275\u0275text(8, "Formul\xE1rio da fase n\xE3o respondido");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "option", 28);
    \u0275\u0275text(10, "SLA da fase venceu");
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
}
__name(AutomationModal_ng_container_12_Template, "AutomationModal_ng_container_12_Template");
function AutomationModal_ng_container_13_option_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "option", 24);
    \u0275\u0275text(1, "Criar novo registro (apenas fase inicial)");
    \u0275\u0275elementEnd();
  }
}
__name(AutomationModal_ng_container_13_option_1_Template, "AutomationModal_ng_container_13_option_1_Template");
function AutomationModal_ng_container_13_option_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "option", 25);
    \u0275\u0275text(1, "Um card entrou na fase");
    \u0275\u0275elementEnd();
  }
}
__name(AutomationModal_ng_container_13_option_2_Template, "AutomationModal_ng_container_13_option_2_Template");
function AutomationModal_ng_container_13_option_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "option", 26);
    \u0275\u0275text(1, "Um card est\xE1 na fase por um tempo");
    \u0275\u0275elementEnd();
  }
}
__name(AutomationModal_ng_container_13_option_3_Template, "AutomationModal_ng_container_13_option_3_Template");
function AutomationModal_ng_container_13_option_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "option", 27);
    \u0275\u0275text(1, "Formul\xE1rio da fase n\xE3o respondido");
    \u0275\u0275elementEnd();
  }
}
__name(AutomationModal_ng_container_13_option_4_Template, "AutomationModal_ng_container_13_option_4_Template");
function AutomationModal_ng_container_13_option_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "option", 28);
    \u0275\u0275text(1, "SLA da fase venceu");
    \u0275\u0275elementEnd();
  }
}
__name(AutomationModal_ng_container_13_option_5_Template, "AutomationModal_ng_container_13_option_5_Template");
function AutomationModal_ng_container_13_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, AutomationModal_ng_container_13_option_1_Template, 2, 0, "option", 29)(2, AutomationModal_ng_container_13_option_2_Template, 2, 0, "option", 30)(3, AutomationModal_ng_container_13_option_3_Template, 2, 0, "option", 31)(4, AutomationModal_ng_container_13_option_4_Template, 2, 0, "option", 32)(5, AutomationModal_ng_container_13_option_5_Template, 2, 0, "option", 33);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.allowedTriggerTypes.includes("new-lead-created"));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.allowedTriggerTypes.includes("card-enters-phase"));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.allowedTriggerTypes.includes("card-in-phase-for-time"));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.allowedTriggerTypes.includes("form-not-answered"));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.allowedTriggerTypes.includes("sla-overdue"));
  }
}
__name(AutomationModal_ng_container_13_Template, "AutomationModal_ng_container_13_Template");
function AutomationModal_ng_container_17_option_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "option", 36);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const phase_r3 = ctx.$implicit;
    \u0275\u0275property("value", phase_r3.id);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(phase_r3.name);
  }
}
__name(AutomationModal_ng_container_17_option_2_Template, "AutomationModal_ng_container_17_option_2_Template");
function AutomationModal_ng_container_17_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "select", 34);
    \u0275\u0275template(2, AutomationModal_ng_container_17_option_2_Template, 2, 2, "option", 35);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx_r1.phases);
  }
}
__name(AutomationModal_ng_container_17_Template, "AutomationModal_ng_container_17_Template");
function AutomationModal_ng_template_18_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 37);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.getFixedPhaseName(), " ");
  }
}
__name(AutomationModal_ng_template_18_Template, "AutomationModal_ng_template_18_Template");
function AutomationModal_label_21_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "label", 38);
    \u0275\u0275text(1, "Por (dias):");
    \u0275\u0275elementEnd();
  }
}
__name(AutomationModal_label_21_Template, "AutomationModal_label_21_Template");
function AutomationModal_label_22_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "label", 38);
    \u0275\u0275text(1, "Aguardar (dias):");
    \u0275\u0275elementEnd();
  }
}
__name(AutomationModal_label_22_Template, "AutomationModal_label_22_Template");
function AutomationModal_div_24_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 39);
    \u0275\u0275text(1, " Se, ap\xF3s esse prazo, nenhum campo do formul\xE1rio da fase tiver sido preenchido, a automa\xE7\xE3o ser\xE1 executada. ");
    \u0275\u0275elementEnd();
  }
}
__name(AutomationModal_div_24_Template, "AutomationModal_div_24_Template");
function AutomationModal_div_29_div_14_option_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "option", 36);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const template_r8 = ctx.$implicit;
    \u0275\u0275property("value", template_r8.id);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(template_r8.name);
  }
}
__name(AutomationModal_div_29_div_14_option_4_Template, "AutomationModal_div_29_div_14_option_4_Template");
function AutomationModal_div_29_div_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div")(1, "select", 51);
    \u0275\u0275twoWayListener("ngModelChange", /* @__PURE__ */ __name(function AutomationModal_div_29_div_14_Template_select_ngModelChange_1_listener($event) {
      \u0275\u0275restoreView(_r7);
      const action_r5 = \u0275\u0275nextContext().$implicit;
      \u0275\u0275twoWayBindingSet(action_r5.templateId, $event) || (action_r5.templateId = $event);
      return \u0275\u0275resetView($event);
    }, "AutomationModal_div_29_div_14_Template_select_ngModelChange_1_listener"));
    \u0275\u0275elementStart(2, "option", 52);
    \u0275\u0275text(3, "Selecione um template");
    \u0275\u0275elementEnd();
    \u0275\u0275template(4, AutomationModal_div_29_div_14_option_4_Template, 2, 2, "option", 35);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const action_r5 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275twoWayProperty("ngModel", action_r5.templateId);
    \u0275\u0275property("ngModelOptions", \u0275\u0275pureFunction0(3, _c06));
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", ctx_r1.emailTemplates);
  }
}
__name(AutomationModal_div_29_div_14_Template, "AutomationModal_div_29_div_14_Template");
function AutomationModal_div_29_div_15_option_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "option", 36);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const phase_r10 = ctx.$implicit;
    \u0275\u0275property("value", phase_r10.id);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(phase_r10.name);
  }
}
__name(AutomationModal_div_29_div_15_option_4_Template, "AutomationModal_div_29_div_15_option_4_Template");
function AutomationModal_div_29_div_15_div_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 39);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" Origem: ", ctx_r1.getFixedPhaseName(), " ");
  }
}
__name(AutomationModal_div_29_div_15_div_5_Template, "AutomationModal_div_29_div_15_div_5_Template");
function AutomationModal_div_29_div_15_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div")(1, "select", 51);
    \u0275\u0275twoWayListener("ngModelChange", /* @__PURE__ */ __name(function AutomationModal_div_29_div_15_Template_select_ngModelChange_1_listener($event) {
      \u0275\u0275restoreView(_r9);
      const action_r5 = \u0275\u0275nextContext().$implicit;
      \u0275\u0275twoWayBindingSet(action_r5.phaseId, $event) || (action_r5.phaseId = $event);
      return \u0275\u0275resetView($event);
    }, "AutomationModal_div_29_div_15_Template_select_ngModelChange_1_listener"));
    \u0275\u0275elementStart(2, "option", 52);
    \u0275\u0275text(3, "Selecione a fase de destino");
    \u0275\u0275elementEnd();
    \u0275\u0275template(4, AutomationModal_div_29_div_15_option_4_Template, 2, 2, "option", 35);
    \u0275\u0275elementEnd();
    \u0275\u0275template(5, AutomationModal_div_29_div_15_div_5_Template, 2, 1, "div", 16);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    let tmp_8_0;
    const action_r5 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275twoWayProperty("ngModel", action_r5.phaseId);
    \u0275\u0275property("ngModelOptions", \u0275\u0275pureFunction0(4, _c06));
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", ctx_r1.getAllowedPhasesForMoveAction());
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.fixedPhaseId || ((tmp_8_0 = ctx_r1.automationForm.get("triggerPhase")) == null ? null : tmp_8_0.value));
  }
}
__name(AutomationModal_div_29_div_15_Template, "AutomationModal_div_29_div_15_Template");
function AutomationModal_div_29_div_16_option_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "option", 36);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const user_r12 = ctx.$implicit;
    \u0275\u0275property("value", user_r12.id);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(user_r12.name);
  }
}
__name(AutomationModal_div_29_div_16_option_4_Template, "AutomationModal_div_29_div_16_option_4_Template");
function AutomationModal_div_29_div_16_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div")(1, "select", 51);
    \u0275\u0275twoWayListener("ngModelChange", /* @__PURE__ */ __name(function AutomationModal_div_29_div_16_Template_select_ngModelChange_1_listener($event) {
      \u0275\u0275restoreView(_r11);
      const action_r5 = \u0275\u0275nextContext().$implicit;
      \u0275\u0275twoWayBindingSet(action_r5.userId, $event) || (action_r5.userId = $event);
      return \u0275\u0275resetView($event);
    }, "AutomationModal_div_29_div_16_Template_select_ngModelChange_1_listener"));
    \u0275\u0275elementStart(2, "option", 52);
    \u0275\u0275text(3, "Selecione um usu\xE1rio");
    \u0275\u0275elementEnd();
    \u0275\u0275template(4, AutomationModal_div_29_div_16_option_4_Template, 2, 2, "option", 35);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const action_r5 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275twoWayProperty("ngModel", action_r5.userId);
    \u0275\u0275property("ngModelOptions", \u0275\u0275pureFunction0(3, _c06));
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", ctx_r1.users);
  }
}
__name(AutomationModal_div_29_div_16_Template, "AutomationModal_div_29_div_16_Template");
function AutomationModal_div_29_div_17_Template(rf, ctx) {
  if (rf & 1) {
    const _r13 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div")(1, "textarea", 53);
    \u0275\u0275twoWayListener("ngModelChange", /* @__PURE__ */ __name(function AutomationModal_div_29_div_17_Template_textarea_ngModelChange_1_listener($event) {
      \u0275\u0275restoreView(_r13);
      const action_r5 = \u0275\u0275nextContext().$implicit;
      \u0275\u0275twoWayBindingSet(action_r5.note, $event) || (action_r5.note = $event);
      return \u0275\u0275resetView($event);
    }, "AutomationModal_div_29_div_17_Template_textarea_ngModelChange_1_listener"));
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const action_r5 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275twoWayProperty("ngModel", action_r5.note);
    \u0275\u0275property("ngModelOptions", \u0275\u0275pureFunction0(2, _c06));
  }
}
__name(AutomationModal_div_29_div_17_Template, "AutomationModal_div_29_div_17_Template");
function AutomationModal_div_29_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 40)(1, "div", 41)(2, "select", 42);
    \u0275\u0275twoWayListener("ngModelChange", /* @__PURE__ */ __name(function AutomationModal_div_29_Template_select_ngModelChange_2_listener($event) {
      const action_r5 = \u0275\u0275restoreView(_r4).$implicit;
      \u0275\u0275twoWayBindingSet(action_r5.type, $event) || (action_r5.type = $event);
      return \u0275\u0275resetView($event);
    }, "AutomationModal_div_29_Template_select_ngModelChange_2_listener"));
    \u0275\u0275elementStart(3, "option", 43);
    \u0275\u0275text(4, "Enviar e-mail");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "option", 44);
    \u0275\u0275text(6, "Mover para fase");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "option", 45);
    \u0275\u0275text(8, "Atribuir usu\xE1rio");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "option", 46);
    \u0275\u0275text(10, "Adicionar nota");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(11, "button", 47);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function AutomationModal_div_29_Template_button_click_11_listener() {
      const i_r6 = \u0275\u0275restoreView(_r4).index;
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.removeAction(i_r6));
    }, "AutomationModal_div_29_Template_button_click_11_listener"));
    \u0275\u0275element(12, "i", 48);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(13, "div", 49);
    \u0275\u0275template(14, AutomationModal_div_29_div_14_Template, 5, 4, "div", 50)(15, AutomationModal_div_29_div_15_Template, 6, 5, "div", 50)(16, AutomationModal_div_29_div_16_Template, 5, 4, "div", 50)(17, AutomationModal_div_29_div_17_Template, 2, 3, "div", 50);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const action_r5 = ctx.$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275twoWayProperty("ngModel", action_r5.type);
    \u0275\u0275property("ngModelOptions", \u0275\u0275pureFunction0(7, _c06));
    \u0275\u0275advance(11);
    \u0275\u0275property("ngSwitch", action_r5.type);
    \u0275\u0275advance();
    \u0275\u0275property("ngSwitchCase", "send-email");
    \u0275\u0275advance();
    \u0275\u0275property("ngSwitchCase", "move-to-phase");
    \u0275\u0275advance();
    \u0275\u0275property("ngSwitchCase", "assign-user");
    \u0275\u0275advance();
    \u0275\u0275property("ngSwitchCase", "add-note");
  }
}
__name(AutomationModal_div_29_Template, "AutomationModal_div_29_Template");
var _AutomationModal = class _AutomationModal {
  fb;
  isVisible = false;
  automation = null;
  phases = [];
  emailTemplates = [];
  users = [];
  allowedTriggerTypes = null;
  // se null, usa padrão
  fixedPhaseId = null;
  allowedTransitions = {};
  closeModalEvent = new EventEmitter();
  saveAutomation = new EventEmitter();
  automationForm;
  modalTitle = "Criar Automa\xE7\xE3o";
  isEditing = false;
  showTriggerPhase = false;
  showTriggerTime = false;
  constructor(fb) {
    this.fb = fb;
    this.automationForm = this.createForm();
  }
  getFixedPhaseName() {
    if (!this.fixedPhaseId || !Array.isArray(this.phases))
      return "Fase selecionada";
    const found = this.phases.find((p) => p && p.id === this.fixedPhaseId);
    return found && found.name ? found.name : "Fase selecionada";
  }
  ngOnInit() {
    if (this.automation) {
      this.isEditing = true;
      this.modalTitle = "Editar Automa\xE7\xE3o";
      this.loadAutomationData();
    }
    if (this.fixedPhaseId) {
      this.automationForm.get("triggerPhase")?.setValue(this.fixedPhaseId);
    }
  }
  createForm() {
    return this.fb.group({
      id: [""],
      // Nome opcional (gera automático no submit caso vazio)
      name: [""],
      triggerType: ["new-lead-created", Validators.required],
      triggerPhase: [""],
      triggerDays: [1],
      actions: this.fb.array([])
    });
  }
  createActionGroup(existing) {
    const group = this.fb.group({
      type: ["send-email"],
      templateId: [""],
      phaseId: [""],
      userId: [""],
      note: [""]
    });
    if (existing) {
      group.patchValue(existing);
    }
    return group;
  }
  loadAutomationData() {
    if (this.automation) {
      this.automationForm.patchValue({
        id: this.automation.id,
        name: this.automation.name,
        triggerType: this.automation.triggerType,
        triggerPhase: this.automation.triggerPhase,
        triggerDays: this.automation.triggerDays
      });
      const actionsArray = this.automationForm.get("actions");
      actionsArray.clear();
      if (this.automation.actions) {
        this.automation.actions.forEach((action) => {
          actionsArray.push(this.createActionGroup(action));
        });
      }
      this.onTriggerTypeChange();
    }
  }
  onTriggerTypeChange() {
    const triggerType = this.automationForm.get("triggerType")?.value;
    this.showTriggerPhase = triggerType === "card-enters-phase" || triggerType === "card-in-phase-for-time" || triggerType === "form-not-answered" || triggerType === "sla-overdue";
    this.showTriggerTime = triggerType === "card-in-phase-for-time" || triggerType === "form-not-answered";
    const triggerPhaseCtrl = this.automationForm.get("triggerPhase");
    const triggerDaysCtrl = this.automationForm.get("triggerDays");
    if (this.showTriggerPhase) {
      triggerPhaseCtrl?.setValidators([Validators.required]);
      const currentVal = triggerPhaseCtrl?.value;
      const desired = this.fixedPhaseId || currentVal || this.phases && this.phases[0]?.id || "";
      if (desired)
        triggerPhaseCtrl?.setValue(desired);
    } else {
      triggerPhaseCtrl?.clearValidators();
      triggerPhaseCtrl?.setValue("");
    }
    triggerPhaseCtrl?.updateValueAndValidity({ emitEvent: false });
    if (this.showTriggerTime) {
      triggerDaysCtrl?.setValidators([Validators.required, Validators.min(1)]);
    } else {
      triggerDaysCtrl?.clearValidators();
      triggerDaysCtrl?.setValue(1);
    }
    triggerDaysCtrl?.updateValueAndValidity({ emitEvent: false });
  }
  // Lista de fases permitidas para a ação "mover para fase"
  getAllowedPhasesForMoveAction() {
    try {
      const fromPhaseId = this.fixedPhaseId || this.automationForm.get("triggerPhase")?.value || "";
      if (!fromPhaseId) {
        return [];
      }
      const allowedIds = this.allowedTransitions && this.allowedTransitions[fromPhaseId] || [];
      if (Array.isArray(allowedIds) && allowedIds.length > 0) {
        return (this.phases || []).filter((p) => allowedIds.includes(p.id));
      }
      return (this.phases || []).filter((p) => p.id !== fromPhaseId);
    } catch {
      return this.phases || [];
    }
  }
  get actionsFormArray() {
    return this.automationForm.get("actions");
  }
  addAction() {
    this.actionsFormArray.push(this.createActionGroup());
  }
  removeAction(index) {
    this.actionsFormArray.removeAt(index);
  }
  onSubmit() {
    if (this.automationForm.valid) {
      const formValue = this.automationForm.value;
      const automationData = __spreadProps(__spreadValues({}, formValue), {
        name: formValue.name || `Automa\xE7\xE3o ${this.getAutomationTypeName(formValue.triggerType)}`,
        actions: formValue.actions.filter((action) => this.isValidAction(action))
      });
      this.saveAutomation.emit(automationData);
      this.closeModal();
    }
  }
  isValidAction(action) {
    switch (action.type) {
      case "send-email":
        return !!action.templateId;
      case "move-to-phase":
        return !!action.phaseId;
      case "assign-user":
        return !!action.userId;
      case "add-note":
        return !!action.note && action.note.trim().length > 0;
      default:
        return false;
    }
  }
  canSubmit() {
    if (!this.automationForm.valid)
      return false;
    const actions = this.actionsFormArray?.value || [];
    return actions.some((a) => this.isValidAction(a));
  }
  getAutomationTypeName(triggerType) {
    const types = {
      "new-lead-created": "Criar novo registro (apenas fase inicial)",
      "card-enters-phase": "Um card entrou na fase",
      "card-in-phase-for-time": "Um card est\xE1 na fase por um tempo",
      "form-not-answered": "Formul\xE1rio da fase n\xE3o respondido",
      "sla-overdue": "SLA Vencido"
    };
    return types[triggerType] || "Sem Nome";
  }
  closeModal() {
    this.automationForm.reset();
    this.actionsFormArray.clear();
    this.isEditing = false;
    this.modalTitle = "Criar Automa\xE7\xE3o";
    this.showTriggerPhase = false;
    this.showTriggerTime = false;
    this.closeModalEvent.emit();
  }
};
__name(_AutomationModal, "AutomationModal");
__publicField(_AutomationModal, "\u0275fac", /* @__PURE__ */ __name(function AutomationModal_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _AutomationModal)(\u0275\u0275directiveInject(FormBuilder));
}, "AutomationModal_Factory"));
__publicField(_AutomationModal, "\u0275cmp", /* @__PURE__ */ \u0275\u0275defineComponent({ type: _AutomationModal, selectors: [["app-automation-modal"]], inputs: { isVisible: "isVisible", automation: "automation", phases: "phases", emailTemplates: "emailTemplates", users: "users", allowedTriggerTypes: "allowedTriggerTypes", fixedPhaseId: "fixedPhaseId", allowedTransitions: "allowedTransitions" }, outputs: { closeModalEvent: "closeModalEvent", saveAutomation: "saveAutomation" }, decls: 38, vars: 16, consts: [["fixedPhase", ""], [1, "modal-overlay", 3, "click"], [1, "modal-content", "modal-content-md", "p-6", 3, "click"], [1, "flex", "justify-between", "items-center", "mb-4"], [1, "text-2xl", "font-bold"], [1, "text-gray-500", "hover:text-gray-800", "text-2xl", 3, "click"], [1, "modal-body", "space-y-6", 3, "ngSubmit", "formGroup"], [1, "border", "rounded-lg", "p-4"], [1, "font-semibold", "text-md", "mb-3", "text-gray-700"], ["formControlName", "triggerType", 1, "w-full", "p-2", "border", "rounded-md", "mb-2", "bg-white", 3, "change"], [4, "ngIf"], ["for", "triggerPhase", 1, "text-sm", "font-medium", "text-gray-700"], [4, "ngIf", "ngIfElse"], [1, "mt-2"], ["for", "triggerDays", "class", "text-sm font-medium text-gray-700", 4, "ngIf"], ["type", "number", "formControlName", "triggerDays", "min", "1", "placeholder", "Ex: 3", 1, "w-full", "p-2", "border", "rounded-md", "mt-1"], ["class", "text-xs text-gray-500 mt-1", 4, "ngIf"], [1, "space-y-3"], ["class", "border rounded-lg p-3 bg-gray-50", 4, "ngFor", "ngForOf"], ["type", "button", 1, "mt-4", "bg-gray-200", "hover:bg-gray-300", "text-gray-700", "font-semibold", "py-2", "px-4", "rounded-lg", "text-sm", 3, "click"], [1, "fas", "fa-plus", "mr-2"], [1, "mt-6", "flex", "justify-end", "gap-4"], ["type", "button", 1, "bg-gray-200", "hover:bg-gray-300", "text-gray-800", "font-bold", "py-2", "px-4", "rounded-lg", 3, "click"], ["type", "submit", 1, "bg-blue-500", "hover:bg-blue-600", "text-white", "font-bold", "py-2", "px-4", "rounded-lg", "disabled:bg-gray-400", 3, "disabled"], ["value", "new-lead-created"], ["value", "card-enters-phase"], ["value", "card-in-phase-for-time"], ["value", "form-not-answered"], ["value", "sla-overdue"], ["value", "new-lead-created", 4, "ngIf"], ["value", "card-enters-phase", 4, "ngIf"], ["value", "card-in-phase-for-time", 4, "ngIf"], ["value", "form-not-answered", 4, "ngIf"], ["value", "sla-overdue", 4, "ngIf"], ["formControlName", "triggerPhase", 1, "w-full", "p-2", "border", "rounded-md", "mt-1", "bg-white"], [3, "value", 4, "ngFor", "ngForOf"], [3, "value"], [1, "mt-1", "p-2", "bg-gray-50", "border", "rounded", "text-sm"], ["for", "triggerDays", 1, "text-sm", "font-medium", "text-gray-700"], [1, "text-xs", "text-gray-500", "mt-1"], [1, "border", "rounded-lg", "p-3", "bg-gray-50"], [1, "flex", "justify-between", "items-start", "mb-2"], [1, "p-2", "border", "rounded-md", "bg-white", "flex-1", "mr-2", 3, "ngModelChange", "ngModel", "ngModelOptions"], ["value", "send-email"], ["value", "move-to-phase"], ["value", "assign-user"], ["value", "add-note"], ["type", "button", 1, "text-red-500", "hover:text-red-700", 3, "click"], [1, "fas", "fa-trash"], [1, "mt-2", 3, "ngSwitch"], [4, "ngSwitchCase"], [1, "w-full", "p-2", "border", "rounded-md", "bg-white", 3, "ngModelChange", "ngModel", "ngModelOptions"], ["value", ""], ["rows", "3", "placeholder", "Digite a nota...", 1, "w-full", "p-2", "border", "rounded-md", 3, "ngModelChange", "ngModel", "ngModelOptions"]], template: /* @__PURE__ */ __name(function AutomationModal_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 1);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function AutomationModal_Template_div_click_0_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.closeModal());
    }, "AutomationModal_Template_div_click_0_listener"));
    \u0275\u0275elementStart(1, "div", 2);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function AutomationModal_Template_div_click_1_listener($event) {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView($event.stopPropagation());
    }, "AutomationModal_Template_div_click_1_listener"));
    \u0275\u0275elementStart(2, "div", 3)(3, "h2", 4);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "button", 5);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function AutomationModal_Template_button_click_5_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.closeModal());
    }, "AutomationModal_Template_button_click_5_listener"));
    \u0275\u0275text(6, "\xD7");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(7, "form", 6);
    \u0275\u0275listener("ngSubmit", /* @__PURE__ */ __name(function AutomationModal_Template_form_ngSubmit_7_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onSubmit());
    }, "AutomationModal_Template_form_ngSubmit_7_listener"));
    \u0275\u0275elementStart(8, "div", 7)(9, "h3", 8);
    \u0275\u0275text(10, "Gatilho (Quando...)");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "select", 9);
    \u0275\u0275listener("change", /* @__PURE__ */ __name(function AutomationModal_Template_select_change_11_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onTriggerTypeChange());
    }, "AutomationModal_Template_select_change_11_listener"));
    \u0275\u0275template(12, AutomationModal_ng_container_12_Template, 11, 0, "ng-container", 10)(13, AutomationModal_ng_container_13_Template, 6, 5, "ng-container", 10);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(14, "div")(15, "label", 11);
    \u0275\u0275text(16, "Fase:");
    \u0275\u0275elementEnd();
    \u0275\u0275template(17, AutomationModal_ng_container_17_Template, 3, 1, "ng-container", 12)(18, AutomationModal_ng_template_18_Template, 2, 1, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(20, "div", 13);
    \u0275\u0275template(21, AutomationModal_label_21_Template, 2, 0, "label", 14)(22, AutomationModal_label_22_Template, 2, 0, "label", 14);
    \u0275\u0275element(23, "input", 15);
    \u0275\u0275template(24, AutomationModal_div_24_Template, 2, 0, "div", 16);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(25, "div", 7)(26, "h3", 8);
    \u0275\u0275text(27, "A\xE7\xF5es (Fa\xE7a isso...)");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(28, "div", 17);
    \u0275\u0275template(29, AutomationModal_div_29_Template, 18, 8, "div", 18);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(30, "button", 19);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function AutomationModal_Template_button_click_30_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.addAction());
    }, "AutomationModal_Template_button_click_30_listener"));
    \u0275\u0275element(31, "i", 20);
    \u0275\u0275text(32, "Adicionar A\xE7\xE3o ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(33, "div", 21)(34, "button", 22);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function AutomationModal_Template_button_click_34_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.closeModal());
    }, "AutomationModal_Template_button_click_34_listener"));
    \u0275\u0275text(35, "Cancelar");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(36, "button", 23);
    \u0275\u0275text(37);
    \u0275\u0275elementEnd()()()()();
  }
  if (rf & 2) {
    let tmp_9_0;
    let tmp_10_0;
    let tmp_11_0;
    let tmp_12_0;
    const fixedPhase_r14 = \u0275\u0275reference(19);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(ctx.modalTitle);
    \u0275\u0275advance(3);
    \u0275\u0275property("formGroup", ctx.automationForm);
    \u0275\u0275advance(5);
    \u0275\u0275property("ngIf", !ctx.allowedTriggerTypes);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.allowedTriggerTypes);
    \u0275\u0275advance();
    \u0275\u0275classProp("hidden", !ctx.showTriggerPhase);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", !ctx.fixedPhaseId)("ngIfElse", fixedPhase_r14);
    \u0275\u0275advance(3);
    \u0275\u0275classProp("hidden", !ctx.showTriggerTime);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ((tmp_9_0 = ctx.automationForm.get("triggerType")) == null ? null : tmp_9_0.value) === "card-in-phase-for-time");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ((tmp_10_0 = ctx.automationForm.get("triggerType")) == null ? null : tmp_10_0.value) === "form-not-answered");
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ((tmp_11_0 = ctx.automationForm.get("triggerType")) == null ? null : tmp_11_0.value) === "form-not-answered");
    \u0275\u0275advance(5);
    \u0275\u0275property("ngForOf", (tmp_12_0 = ctx.automationForm.get("actions")) == null ? null : tmp_12_0.value);
    \u0275\u0275advance(7);
    \u0275\u0275property("disabled", !ctx.canSubmit());
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx.isEditing ? "Atualizar" : "Salvar", " Automa\xE7\xE3o ");
  }
}, "AutomationModal_Template"), dependencies: [CommonModule, NgForOf, NgIf, NgSwitch, NgSwitchCase, ReactiveFormsModule, \u0275NgNoValidate, NgSelectOption, \u0275NgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, SelectControlValueAccessor, NgControlStatus, NgControlStatusGroup, MinValidator, FormGroupDirective, FormControlName, FormsModule, NgModel], styles: ["\n\n.modal-overlay[_ngcontent-%COMP%] {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background-color: rgba(0, 0, 0, 0.5);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  z-index: 1000;\n}\n.modal-content[_ngcontent-%COMP%] {\n  background: white;\n  border-radius: 8px;\n  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n  max-height: 90vh;\n  overflow-y: auto;\n}\n.modal-content-md[_ngcontent-%COMP%] {\n  width: 90%;\n  max-width: 600px;\n}\n.hidden[_ngcontent-%COMP%] {\n  display: none !important;\n}\nform[_ngcontent-%COMP%]   .border[_ngcontent-%COMP%] {\n  border: 1px solid #e5e7eb;\n}\nform[_ngcontent-%COMP%]   .rounded-lg[_ngcontent-%COMP%] {\n  border-radius: 8px;\n}\nform[_ngcontent-%COMP%]   .p-4[_ngcontent-%COMP%] {\n  padding: 1rem;\n}\nform[_ngcontent-%COMP%]   .p-6[_ngcontent-%COMP%] {\n  padding: 1.5rem;\n}\nform[_ngcontent-%COMP%]   .space-y-6[_ngcontent-%COMP%]    > *[_ngcontent-%COMP%]    + *[_ngcontent-%COMP%] {\n  margin-top: 1.5rem;\n}\nform[_ngcontent-%COMP%]   .space-y-3[_ngcontent-%COMP%]    > *[_ngcontent-%COMP%]    + *[_ngcontent-%COMP%] {\n  margin-top: 0.75rem;\n}\nform[_ngcontent-%COMP%]   select.w-full[_ngcontent-%COMP%], \nform[_ngcontent-%COMP%]   input.w-full[_ngcontent-%COMP%], \nform[_ngcontent-%COMP%]   textarea.w-full[_ngcontent-%COMP%] {\n  width: 100%;\n}\nform[_ngcontent-%COMP%]   select.p-2[_ngcontent-%COMP%], \nform[_ngcontent-%COMP%]   input.p-2[_ngcontent-%COMP%], \nform[_ngcontent-%COMP%]   textarea.p-2[_ngcontent-%COMP%] {\n  padding: 0.5rem;\n}\nform[_ngcontent-%COMP%]   select.border[_ngcontent-%COMP%], \nform[_ngcontent-%COMP%]   input.border[_ngcontent-%COMP%], \nform[_ngcontent-%COMP%]   textarea.border[_ngcontent-%COMP%] {\n  border: 1px solid #d1d5db;\n}\nform[_ngcontent-%COMP%]   select.rounded-md[_ngcontent-%COMP%], \nform[_ngcontent-%COMP%]   input.rounded-md[_ngcontent-%COMP%], \nform[_ngcontent-%COMP%]   textarea.rounded-md[_ngcontent-%COMP%] {\n  border-radius: 6px;\n}\nform[_ngcontent-%COMP%]   select.bg-white[_ngcontent-%COMP%], \nform[_ngcontent-%COMP%]   input.bg-white[_ngcontent-%COMP%], \nform[_ngcontent-%COMP%]   textarea.bg-white[_ngcontent-%COMP%] {\n  background-color: white;\n}\nform[_ngcontent-%COMP%]   select[_ngcontent-%COMP%]:focus, \nform[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]:focus, \nform[_ngcontent-%COMP%]   textarea[_ngcontent-%COMP%]:focus {\n  outline: none;\n  border-color: #3b82f6;\n  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);\n}\nform[_ngcontent-%COMP%]   button.bg-gray-200[_ngcontent-%COMP%] {\n  background-color: #e5e7eb;\n}\nform[_ngcontent-%COMP%]   button.hover\\\\[_ngcontent-%COMP%]:bg-gray-300:hover {\n  background-color: #d1d5db;\n}\nform[_ngcontent-%COMP%]   button.bg-blue-500[_ngcontent-%COMP%] {\n  background-color: #3b82f6;\n}\nform[_ngcontent-%COMP%]   button.hover\\\\[_ngcontent-%COMP%]:bg-blue-600:hover {\n  background-color: #2563eb;\n}\nform[_ngcontent-%COMP%]   button.text-gray-700[_ngcontent-%COMP%] {\n  color: #374151;\n}\nform[_ngcontent-%COMP%]   button.text-gray-800[_ngcontent-%COMP%] {\n  color: #1f2937;\n}\nform[_ngcontent-%COMP%]   button.text-white[_ngcontent-%COMP%] {\n  color: white;\n}\nform[_ngcontent-%COMP%]   button.font-semibold[_ngcontent-%COMP%] {\n  font-weight: 600;\n}\nform[_ngcontent-%COMP%]   button.font-bold[_ngcontent-%COMP%] {\n  font-weight: 700;\n}\nform[_ngcontent-%COMP%]   button.py-2[_ngcontent-%COMP%] {\n  padding-top: 0.5rem;\n  padding-bottom: 0.5rem;\n}\nform[_ngcontent-%COMP%]   button.px-4[_ngcontent-%COMP%] {\n  padding-left: 1rem;\n  padding-right: 1rem;\n}\nform[_ngcontent-%COMP%]   button.rounded-lg[_ngcontent-%COMP%] {\n  border-radius: 8px;\n}\nform[_ngcontent-%COMP%]   button.text-sm[_ngcontent-%COMP%] {\n  font-size: 0.875rem;\n}\nform[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\nform[_ngcontent-%COMP%]   button.disabled\\\\[_ngcontent-%COMP%]:bg-gray-400:disabled {\n  background-color: #9ca3af;\n}\n.text-red-500[_ngcontent-%COMP%] {\n  color: #ef4444;\n}\n.hover\\\\[_ngcontent-%COMP%]:text-red-700:hover {\n  color: #b91c1c;\n}\n.bg-gray-50[_ngcontent-%COMP%] {\n  background-color: #f9fafb;\n}\n.flex[_ngcontent-%COMP%] {\n  display: flex;\n}\n.justify-between[_ngcontent-%COMP%] {\n  justify-content: space-between;\n}\n.justify-end[_ngcontent-%COMP%] {\n  justify-content: flex-end;\n}\n.items-center[_ngcontent-%COMP%] {\n  align-items: center;\n}\n.items-start[_ngcontent-%COMP%] {\n  align-items: flex-start;\n}\n.mb-2[_ngcontent-%COMP%] {\n  margin-bottom: 0.5rem;\n}\n.mb-3[_ngcontent-%COMP%] {\n  margin-bottom: 0.75rem;\n}\n.mb-4[_ngcontent-%COMP%] {\n  margin-bottom: 1rem;\n}\n.mr-2[_ngcontent-%COMP%] {\n  margin-right: 0.5rem;\n}\n.mt-1[_ngcontent-%COMP%] {\n  margin-top: 0.25rem;\n}\n.mt-2[_ngcontent-%COMP%] {\n  margin-top: 0.5rem;\n}\n.mt-4[_ngcontent-%COMP%] {\n  margin-top: 1rem;\n}\n.mt-6[_ngcontent-%COMP%] {\n  margin-top: 1.5rem;\n}\n.gap-4[_ngcontent-%COMP%] {\n  gap: 1rem;\n}\n.flex-1[_ngcontent-%COMP%] {\n  flex: 1 1 0%;\n}\n.text-2xl[_ngcontent-%COMP%] {\n  font-size: 1.5rem;\n  line-height: 2rem;\n}\n.text-md[_ngcontent-%COMP%] {\n  font-size: 1rem;\n  line-height: 1.5rem;\n}\n.text-gray-500[_ngcontent-%COMP%] {\n  color: #6b7280;\n}\n.text-gray-700[_ngcontent-%COMP%] {\n  color: #374151;\n}\n.hover\\\\[_ngcontent-%COMP%]:text-gray-800:hover {\n  color: #1f2937;\n}\n/*# sourceMappingURL=automation-modal.css.map */"] }));
var AutomationModal = _AutomationModal;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AutomationModal, [{
    type: Component,
    args: [{ selector: "app-automation-modal", imports: [CommonModule, ReactiveFormsModule, FormsModule], template: `<div class="modal-overlay" (click)="closeModal()">
  <div class="modal-content modal-content-md p-6" (click)="$event.stopPropagation()">
    <div class="flex justify-between items-center mb-4">
      <h2 class="text-2xl font-bold">{{ modalTitle }}</h2>
      <button class="text-gray-500 hover:text-gray-800 text-2xl" (click)="closeModal()">&times;</button>
    </div>
    
    <form [formGroup]="automationForm" (ngSubmit)="onSubmit()" class="modal-body space-y-6">
      <div class="border rounded-lg p-4">
        <h3 class="font-semibold text-md mb-3 text-gray-700">Gatilho (Quando...)</h3>
        <select formControlName="triggerType" class="w-full p-2 border rounded-md mb-2 bg-white" (change)="onTriggerTypeChange()">
          <ng-container *ngIf="!allowedTriggerTypes">
            <option value="new-lead-created">Criar novo registro (apenas fase inicial)</option>
            <option value="card-enters-phase">Um card entrou na fase</option>
            <option value="card-in-phase-for-time">Um card est\xE1 na fase por um tempo</option>
            <option value="form-not-answered">Formul\xE1rio da fase n\xE3o respondido</option>
            <option value="sla-overdue">SLA da fase venceu</option>
          </ng-container>
          <ng-container *ngIf="allowedTriggerTypes">
            <option *ngIf="allowedTriggerTypes.includes('new-lead-created')" value="new-lead-created">Criar novo registro (apenas fase inicial)</option>
            <option *ngIf="allowedTriggerTypes.includes('card-enters-phase')" value="card-enters-phase">Um card entrou na fase</option>
            <option *ngIf="allowedTriggerTypes.includes('card-in-phase-for-time')" value="card-in-phase-for-time">Um card est\xE1 na fase por um tempo</option>
            <option *ngIf="allowedTriggerTypes.includes('form-not-answered')" value="form-not-answered">Formul\xE1rio da fase n\xE3o respondido</option>
            <option *ngIf="allowedTriggerTypes.includes('sla-overdue')" value="sla-overdue">SLA da fase venceu</option>
          </ng-container>
        </select>
        
        <div [class.hidden]="!showTriggerPhase">
          <label for="triggerPhase" class="text-sm font-medium text-gray-700">Fase:</label>
          <ng-container *ngIf="!fixedPhaseId; else fixedPhase">
            <select formControlName="triggerPhase" class="w-full p-2 border rounded-md mt-1 bg-white">
              <option *ngFor="let phase of phases" [value]="phase.id">{{ phase.name }}</option>
            </select>
          </ng-container>
          <ng-template #fixedPhase>
            <div class="mt-1 p-2 bg-gray-50 border rounded text-sm">
              {{ getFixedPhaseName() }}
            </div>
          </ng-template>
        </div>
        
        <div [class.hidden]="!showTriggerTime" class="mt-2">
          <label for="triggerDays" class="text-sm font-medium text-gray-700" *ngIf="automationForm.get('triggerType')?.value === 'card-in-phase-for-time'">Por (dias):</label>
          <label for="triggerDays" class="text-sm font-medium text-gray-700" *ngIf="automationForm.get('triggerType')?.value === 'form-not-answered'">Aguardar (dias):</label>
          <input type="number" formControlName="triggerDays" min="1" class="w-full p-2 border rounded-md mt-1" placeholder="Ex: 3">
          <div class="text-xs text-gray-500 mt-1" *ngIf="automationForm.get('triggerType')?.value === 'form-not-answered'">
            Se, ap\xF3s esse prazo, nenhum campo do formul\xE1rio da fase tiver sido preenchido, a automa\xE7\xE3o ser\xE1 executada.
          </div>
        </div>
      </div>

      <div class="border rounded-lg p-4">
        <h3 class="font-semibold text-md mb-3 text-gray-700">A\xE7\xF5es (Fa\xE7a isso...)</h3>
        <div class="space-y-3">
          <div *ngFor="let action of automationForm.get('actions')?.value; let i = index" class="border rounded-lg p-3 bg-gray-50">
            <div class="flex justify-between items-start mb-2">
              <select [(ngModel)]="action.type" [ngModelOptions]="{standalone: true}" class="p-2 border rounded-md bg-white flex-1 mr-2">
                <option value="send-email">Enviar e-mail</option>
                <option value="move-to-phase">Mover para fase</option>
                <option value="assign-user">Atribuir usu\xE1rio</option>
                <option value="add-note">Adicionar nota</option>
              </select>
              <button type="button" (click)="removeAction(i)" class="text-red-500 hover:text-red-700">
                <i class="fas fa-trash"></i>
              </button>
            </div>
            
            <div [ngSwitch]="action.type" class="mt-2">
              <div *ngSwitchCase="'send-email'">
                <select [(ngModel)]="action.templateId" [ngModelOptions]="{standalone: true}" class="w-full p-2 border rounded-md bg-white">
                  <option value="">Selecione um template</option>
                  <option *ngFor="let template of emailTemplates" [value]="template.id">{{ template.name }}</option>
                </select>
              </div>
              
              <div *ngSwitchCase="'move-to-phase'">
                <select [(ngModel)]="action.phaseId" [ngModelOptions]="{standalone: true}" class="w-full p-2 border rounded-md bg-white">
                  <option value="">Selecione a fase de destino</option>
                  <option *ngFor="let phase of getAllowedPhasesForMoveAction()" [value]="phase.id">{{ phase.name }}</option>
                </select>
                <div class="text-xs text-gray-500 mt-1" *ngIf="fixedPhaseId || automationForm.get('triggerPhase')?.value">
                  Origem: {{ getFixedPhaseName() }}
                </div>
              </div>
              
              <div *ngSwitchCase="'assign-user'">
                <select [(ngModel)]="action.userId" [ngModelOptions]="{standalone: true}" class="w-full p-2 border rounded-md bg-white">
                  <option value="">Selecione um usu\xE1rio</option>
                  <option *ngFor="let user of users" [value]="user.id">{{ user.name }}</option>
                </select>
              </div>
              
              <div *ngSwitchCase="'add-note'">
                <textarea [(ngModel)]="action.note" [ngModelOptions]="{standalone: true}" class="w-full p-2 border rounded-md" rows="3" placeholder="Digite a nota..."></textarea>
              </div>
            </div>
          </div>
        </div>
        
        <button type="button" (click)="addAction()" class="mt-4 bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2 px-4 rounded-lg text-sm">
          <i class="fas fa-plus mr-2"></i>Adicionar A\xE7\xE3o
        </button>
      </div>
      
      <div class="mt-6 flex justify-end gap-4">
        <button type="button" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg" (click)="closeModal()">Cancelar</button>
        <button type="submit" [disabled]="!canSubmit()" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg disabled:bg-gray-400">
          {{ isEditing ? 'Atualizar' : 'Salvar' }} Automa\xE7\xE3o
        </button>
      </div>
    </form>
  </div>
</div>
`, styles: ["/* src/app/components/automation-modal/automation-modal.scss */\n.modal-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background-color: rgba(0, 0, 0, 0.5);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  z-index: 1000;\n}\n.modal-content {\n  background: white;\n  border-radius: 8px;\n  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n  max-height: 90vh;\n  overflow-y: auto;\n}\n.modal-content-md {\n  width: 90%;\n  max-width: 600px;\n}\n.hidden {\n  display: none !important;\n}\nform .border {\n  border: 1px solid #e5e7eb;\n}\nform .rounded-lg {\n  border-radius: 8px;\n}\nform .p-4 {\n  padding: 1rem;\n}\nform .p-6 {\n  padding: 1.5rem;\n}\nform .space-y-6 > * + * {\n  margin-top: 1.5rem;\n}\nform .space-y-3 > * + * {\n  margin-top: 0.75rem;\n}\nform select.w-full,\nform input.w-full,\nform textarea.w-full {\n  width: 100%;\n}\nform select.p-2,\nform input.p-2,\nform textarea.p-2 {\n  padding: 0.5rem;\n}\nform select.border,\nform input.border,\nform textarea.border {\n  border: 1px solid #d1d5db;\n}\nform select.rounded-md,\nform input.rounded-md,\nform textarea.rounded-md {\n  border-radius: 6px;\n}\nform select.bg-white,\nform input.bg-white,\nform textarea.bg-white {\n  background-color: white;\n}\nform select:focus,\nform input:focus,\nform textarea:focus {\n  outline: none;\n  border-color: #3b82f6;\n  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);\n}\nform button.bg-gray-200 {\n  background-color: #e5e7eb;\n}\nform button.hover\\\\:bg-gray-300:hover {\n  background-color: #d1d5db;\n}\nform button.bg-blue-500 {\n  background-color: #3b82f6;\n}\nform button.hover\\\\:bg-blue-600:hover {\n  background-color: #2563eb;\n}\nform button.text-gray-700 {\n  color: #374151;\n}\nform button.text-gray-800 {\n  color: #1f2937;\n}\nform button.text-white {\n  color: white;\n}\nform button.font-semibold {\n  font-weight: 600;\n}\nform button.font-bold {\n  font-weight: 700;\n}\nform button.py-2 {\n  padding-top: 0.5rem;\n  padding-bottom: 0.5rem;\n}\nform button.px-4 {\n  padding-left: 1rem;\n  padding-right: 1rem;\n}\nform button.rounded-lg {\n  border-radius: 8px;\n}\nform button.text-sm {\n  font-size: 0.875rem;\n}\nform button:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\nform button.disabled\\\\:bg-gray-400:disabled {\n  background-color: #9ca3af;\n}\n.text-red-500 {\n  color: #ef4444;\n}\n.hover\\\\:text-red-700:hover {\n  color: #b91c1c;\n}\n.bg-gray-50 {\n  background-color: #f9fafb;\n}\n.flex {\n  display: flex;\n}\n.justify-between {\n  justify-content: space-between;\n}\n.justify-end {\n  justify-content: flex-end;\n}\n.items-center {\n  align-items: center;\n}\n.items-start {\n  align-items: flex-start;\n}\n.mb-2 {\n  margin-bottom: 0.5rem;\n}\n.mb-3 {\n  margin-bottom: 0.75rem;\n}\n.mb-4 {\n  margin-bottom: 1rem;\n}\n.mr-2 {\n  margin-right: 0.5rem;\n}\n.mt-1 {\n  margin-top: 0.25rem;\n}\n.mt-2 {\n  margin-top: 0.5rem;\n}\n.mt-4 {\n  margin-top: 1rem;\n}\n.mt-6 {\n  margin-top: 1.5rem;\n}\n.gap-4 {\n  gap: 1rem;\n}\n.flex-1 {\n  flex: 1 1 0%;\n}\n.text-2xl {\n  font-size: 1.5rem;\n  line-height: 2rem;\n}\n.text-md {\n  font-size: 1rem;\n  line-height: 1.5rem;\n}\n.text-gray-500 {\n  color: #6b7280;\n}\n.text-gray-700 {\n  color: #374151;\n}\n.hover\\\\:text-gray-800:hover {\n  color: #1f2937;\n}\n/*# sourceMappingURL=automation-modal.css.map */\n"] }]
  }], () => [{ type: FormBuilder }], { isVisible: [{
    type: Input
  }], automation: [{
    type: Input
  }], phases: [{
    type: Input
  }], emailTemplates: [{
    type: Input
  }], users: [{
    type: Input
  }], allowedTriggerTypes: [{
    type: Input
  }], fixedPhaseId: [{
    type: Input
  }], allowedTransitions: [{
    type: Input
  }], closeModalEvent: [{
    type: Output
  }], saveAutomation: [{
    type: Output
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(AutomationModal, { className: "AutomationModal", filePath: "src/app/components/automation-modal/automation-modal.ts", lineNumber: 11 });
})();

// src/app/components/automation-history-modal/automation-history-modal.ts
function AutomationHistoryModal_div_0_tr_20_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "tr")(1, "td", 14);
    \u0275\u0275element(2, "i", 15);
    \u0275\u0275text(3, "Carregando hist\xF3rico... ");
    \u0275\u0275elementEnd()();
  }
}
__name(AutomationHistoryModal_div_0_tr_20_Template, "AutomationHistoryModal_div_0_tr_20_Template");
function AutomationHistoryModal_div_0_tr_21_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "tr")(1, "td", 14);
    \u0275\u0275text(2, "Nenhuma execu\xE7\xE3o registrada.");
    \u0275\u0275elementEnd()();
  }
}
__name(AutomationHistoryModal_div_0_tr_21_Template, "AutomationHistoryModal_div_0_tr_21_Template");
function AutomationHistoryModal_div_0_tr_22_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "tr", 16)(1, "td", 17);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "td", 17);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "td", 17)(6, "span", 18);
    \u0275\u0275text(7);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(8, "td", 17);
    \u0275\u0275text(9);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r1.formatDate(item_r3.timestamp));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r1.getLeadName(item_r3.leadId));
    \u0275\u0275advance(2);
    \u0275\u0275classProp("bg-green-100", item_r3.status === "success")("text-green-800", item_r3.status === "success")("bg-red-100", item_r3.status === "error")("text-red-800", item_r3.status === "error")("bg-yellow-100", item_r3.status === "pending")("text-yellow-800", item_r3.status === "pending");
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.getStatusText(item_r3.status), " ");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(item_r3.text || item_r3.action || "A\xE7\xE3o executada");
  }
}
__name(AutomationHistoryModal_div_0_tr_22_Template, "AutomationHistoryModal_div_0_tr_22_Template");
function AutomationHistoryModal_div_0_div_23_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 19)(1, "button", 20);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function AutomationHistoryModal_div_0_div_23_Template_button_click_1_listener() {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.previousPage());
    }, "AutomationHistoryModal_div_0_div_23_Template_button_click_1_listener"));
    \u0275\u0275element(2, "i", 21);
    \u0275\u0275text(3, "Anterior ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "span", 22);
    \u0275\u0275text(5);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "button", 20);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function AutomationHistoryModal_div_0_div_23_Template_button_click_6_listener() {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.nextPage());
    }, "AutomationHistoryModal_div_0_div_23_Template_button_click_6_listener"));
    \u0275\u0275text(7, " Pr\xF3xima");
    \u0275\u0275element(8, "i", 23);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("disabled", ctx_r1.currentPage === 1);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate3(" P\xE1gina ", ctx_r1.currentPage, " de ", ctx_r1.totalPages, " (", ctx_r1.historyItems.length, " registros) ");
    \u0275\u0275advance();
    \u0275\u0275property("disabled", ctx_r1.currentPage === ctx_r1.totalPages);
  }
}
__name(AutomationHistoryModal_div_0_div_23_Template, "AutomationHistoryModal_div_0_div_23_Template");
function AutomationHistoryModal_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 1);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function AutomationHistoryModal_div_0_Template_div_click_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.closeModal());
    }, "AutomationHistoryModal_div_0_Template_div_click_0_listener"));
    \u0275\u0275elementStart(1, "div", 2);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function AutomationHistoryModal_div_0_Template_div_click_1_listener($event) {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView($event.stopPropagation());
    }, "AutomationHistoryModal_div_0_Template_div_click_1_listener"));
    \u0275\u0275elementStart(2, "div", 3)(3, "h2", 4);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "button", 5);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function AutomationHistoryModal_div_0_Template_button_click_5_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.closeModal());
    }, "AutomationHistoryModal_div_0_Template_button_click_5_listener"));
    \u0275\u0275text(6, "\xD7");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(7, "div", 6)(8, "table", 7)(9, "thead", 8)(10, "tr")(11, "th", 9);
    \u0275\u0275text(12, "Data");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(13, "th", 9);
    \u0275\u0275text(14, "Lead Afetado");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(15, "th", 9);
    \u0275\u0275text(16, "Status");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(17, "th", 9);
    \u0275\u0275text(18, "A\xE7\xE3o Executada");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(19, "tbody", 10);
    \u0275\u0275template(20, AutomationHistoryModal_div_0_tr_20_Template, 4, 0, "tr", 11)(21, AutomationHistoryModal_div_0_tr_21_Template, 3, 0, "tr", 11)(22, AutomationHistoryModal_div_0_tr_22_Template, 10, 16, "tr", 12);
    \u0275\u0275elementEnd()()();
    \u0275\u0275template(23, AutomationHistoryModal_div_0_div_23_Template, 9, 5, "div", 13);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1("Hist\xF3rico: ", ctx_r1.automationName);
    \u0275\u0275advance(16);
    \u0275\u0275property("ngIf", ctx_r1.isLoading);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.isLoading && ctx_r1.historyItems.length === 0);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.paginatedItems);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.totalPages > 1);
  }
}
__name(AutomationHistoryModal_div_0_Template, "AutomationHistoryModal_div_0_Template");
var _AutomationHistoryModal = class _AutomationHistoryModal {
  firestoreService = inject(FirestoreService);
  isVisible = false;
  automationId = "";
  automationName = "";
  ownerId = "";
  boardId = "";
  leads = [];
  closeModalEvent = new EventEmitter();
  historyItems = [];
  paginatedItems = [];
  isLoading = false;
  currentPage = 1;
  itemsPerPage = 10;
  totalPages = 0;
  subscription;
  ngOnInit() {
    if (this.isVisible && this.automationId) {
      this.loadHistory();
    }
  }
  ngOnDestroy() {
    this.unsubscribe();
  }
  ngOnChanges() {
    if (this.isVisible && this.automationId) {
      this.loadHistory();
    } else if (!this.isVisible) {
      this.unsubscribe();
    }
  }
  unsubscribe() {
    if (this.subscription) {
      this.subscription();
      this.subscription = void 0;
    }
  }
  loadHistory() {
    return __async(this, null, function* () {
      this.isLoading = true;
      this.unsubscribe();
      try {
        this.subscription = this.firestoreService.subscribeToAutomationHistory(this.ownerId, this.boardId, this.automationId, (historyData) => {
          this.historyItems = historyData.sort((a, b) => {
            const timeA = a.timestamp?.toMillis ? a.timestamp.toMillis() : 0;
            const timeB = b.timestamp?.toMillis ? b.timestamp.toMillis() : 0;
            return timeB - timeA;
          });
          this.currentPage = 1;
          this.updatePagination();
          this.isLoading = false;
        });
      } catch (error) {
        console.error("Erro ao carregar hist\xF3rico de automa\xE7\xE3o:", error);
        this.isLoading = false;
      }
    });
  }
  updatePagination() {
    this.totalPages = Math.ceil(this.historyItems.length / this.itemsPerPage);
    const startIndex = (this.currentPage - 1) * this.itemsPerPage;
    const endIndex = startIndex + this.itemsPerPage;
    this.paginatedItems = this.historyItems.slice(startIndex, endIndex);
  }
  previousPage() {
    if (this.currentPage > 1) {
      this.currentPage--;
      this.updatePagination();
    }
  }
  nextPage() {
    if (this.currentPage < this.totalPages) {
      this.currentPage++;
      this.updatePagination();
    }
  }
  getLeadName(leadId) {
    const lead = this.leads.find((l) => l.id === leadId);
    return lead ? lead.fields?.companyName || lead.fields?.title || "Lead sem nome" : "Lead removido";
  }
  formatDate(timestamp) {
    if (!timestamp)
      return "N/A";
    let date;
    if (timestamp.toDate) {
      date = timestamp.toDate();
    } else if (timestamp instanceof Date) {
      date = timestamp;
    } else {
      return "N/A";
    }
    return date.toLocaleString("pt-BR", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit"
    });
  }
  getStatusText(status) {
    const statusMap = {
      "success": "Sucesso",
      "error": "Erro",
      "pending": "Pendente",
      "scheduled": "Agendada"
    };
    return statusMap[status] || "Desconhecido";
  }
  closeModal() {
    this.unsubscribe();
    this.closeModalEvent.emit();
  }
};
__name(_AutomationHistoryModal, "AutomationHistoryModal");
__publicField(_AutomationHistoryModal, "\u0275fac", /* @__PURE__ */ __name(function AutomationHistoryModal_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _AutomationHistoryModal)();
}, "AutomationHistoryModal_Factory"));
__publicField(_AutomationHistoryModal, "\u0275cmp", /* @__PURE__ */ \u0275\u0275defineComponent({ type: _AutomationHistoryModal, selectors: [["app-automation-history-modal"]], inputs: { isVisible: "isVisible", automationId: "automationId", automationName: "automationName", ownerId: "ownerId", boardId: "boardId", leads: "leads" }, outputs: { closeModalEvent: "closeModalEvent" }, features: [\u0275\u0275NgOnChangesFeature], decls: 1, vars: 1, consts: [["class", "modal-overlay", 3, "click", 4, "ngIf"], [1, "modal-overlay", 3, "click"], [1, "modal-content", "modal-content-lg", "p-6", 3, "click"], [1, "flex", "justify-between", "items-center", "mb-4"], [1, "text-2xl", "font-bold"], [1, "text-gray-500", "hover:text-gray-800", "text-2xl", 3, "click"], [1, "overflow-x-auto"], [1, "min-w-full", "bg-white"], [1, "bg-gray-50"], [1, "text-left", "py-3", "px-4", "uppercase", "font-semibold", "text-sm", "text-gray-600"], [1, "text-gray-700", "divide-y", "divide-gray-200"], [4, "ngIf"], ["class", "hover:bg-gray-50", 4, "ngFor", "ngForOf"], ["class", "p-4 flex justify-between items-center", 4, "ngIf"], ["colspan", "4", 1, "text-center", "p-6", "text-gray-500"], [1, "fas", "fa-spinner", "fa-spin", "mr-2"], [1, "hover:bg-gray-50"], [1, "py-3", "px-4"], [1, "px-2", "py-1", "text-xs", "font-medium", "rounded-full"], [1, "p-4", "flex", "justify-between", "items-center"], [1, "bg-gray-200", "hover:bg-gray-300", "disabled:bg-gray-100", "disabled:text-gray-400", "text-gray-700", "font-medium", "py-2", "px-4", "rounded-lg", 3, "click", "disabled"], [1, "fas", "fa-chevron-left", "mr-1"], [1, "text-sm", "text-gray-600"], [1, "fas", "fa-chevron-right", "ml-1"]], template: /* @__PURE__ */ __name(function AutomationHistoryModal_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, AutomationHistoryModal_div_0_Template, 24, 5, "div", 0);
  }
  if (rf & 2) {
    \u0275\u0275property("ngIf", ctx.isVisible);
  }
}, "AutomationHistoryModal_Template"), dependencies: [CommonModule, NgForOf, NgIf], styles: ["\n\n.modal-overlay[_ngcontent-%COMP%] {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background-color: rgba(0, 0, 0, 0.5);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  z-index: 1000;\n}\n.modal-content[_ngcontent-%COMP%] {\n  background: white;\n  border-radius: 8px;\n  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n  max-height: 90vh;\n  overflow-y: auto;\n}\n.modal-content-lg[_ngcontent-%COMP%] {\n  width: 95%;\n  max-width: 900px;\n}\n.overflow-x-auto[_ngcontent-%COMP%] {\n  overflow-x: auto;\n}\ntable[_ngcontent-%COMP%] {\n  min-width: 100%;\n  background-color: white;\n}\nthead[_ngcontent-%COMP%] {\n  background-color: #f9fafb;\n}\nth[_ngcontent-%COMP%] {\n  text-align: left;\n  padding: 0.75rem 1rem;\n  text-transform: uppercase;\n  font-weight: 600;\n  font-size: 0.875rem;\n  color: #4b5563;\n}\ntd[_ngcontent-%COMP%] {\n  padding: 0.75rem 1rem;\n}\ntbody[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%] {\n  color: #374151;\n}\ntbody[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%]:not(:last-child) {\n  border-bottom: 1px solid #e5e7eb;\n}\ntbody[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%]:hover {\n  background-color: #f9fafb;\n}\n.text-center[_ngcontent-%COMP%] {\n  text-align: center;\n}\n.text-gray-500[_ngcontent-%COMP%] {\n  color: #6b7280;\n}\n.text-gray-600[_ngcontent-%COMP%] {\n  color: #4b5563;\n}\n.text-gray-700[_ngcontent-%COMP%] {\n  color: #374151;\n}\n.text-gray-800[_ngcontent-%COMP%] {\n  color: #1f2937;\n}\n.text-2xl[_ngcontent-%COMP%] {\n  font-size: 1.5rem;\n  line-height: 2rem;\n}\n.font-bold[_ngcontent-%COMP%] {\n  font-weight: 700;\n}\n.font-medium[_ngcontent-%COMP%] {\n  font-weight: 500;\n}\n.text-sm[_ngcontent-%COMP%] {\n  font-size: 0.875rem;\n}\n.text-xs[_ngcontent-%COMP%] {\n  font-size: 0.75rem;\n}\n.px-2[_ngcontent-%COMP%] {\n  padding-left: 0.5rem;\n  padding-right: 0.5rem;\n}\n.py-1[_ngcontent-%COMP%] {\n  padding-top: 0.25rem;\n  padding-bottom: 0.25rem;\n}\n.py-2[_ngcontent-%COMP%] {\n  padding-top: 0.5rem;\n  padding-bottom: 0.5rem;\n}\n.px-4[_ngcontent-%COMP%] {\n  padding-left: 1rem;\n  padding-right: 1rem;\n}\n.p-4[_ngcontent-%COMP%] {\n  padding: 1rem;\n}\n.p-6[_ngcontent-%COMP%] {\n  padding: 1.5rem;\n}\n.mb-4[_ngcontent-%COMP%] {\n  margin-bottom: 1rem;\n}\n.mr-1[_ngcontent-%COMP%] {\n  margin-right: 0.25rem;\n}\n.mr-2[_ngcontent-%COMP%] {\n  margin-right: 0.5rem;\n}\n.ml-1[_ngcontent-%COMP%] {\n  margin-left: 0.25rem;\n}\n.rounded-full[_ngcontent-%COMP%] {\n  border-radius: 9999px;\n}\n.rounded-lg[_ngcontent-%COMP%] {\n  border-radius: 0.5rem;\n}\n.bg-green-100[_ngcontent-%COMP%] {\n  background-color: #dcfce7;\n}\n.text-green-800[_ngcontent-%COMP%] {\n  color: #166534;\n}\n.bg-red-100[_ngcontent-%COMP%] {\n  background-color: #fee2e2;\n}\n.text-red-800[_ngcontent-%COMP%] {\n  color: #991b1b;\n}\n.bg-yellow-100[_ngcontent-%COMP%] {\n  background-color: #fef3c7;\n}\n.text-yellow-800[_ngcontent-%COMP%] {\n  color: #92400e;\n}\n.bg-gray-200[_ngcontent-%COMP%] {\n  background-color: #e5e7eb;\n}\n.bg-gray-100[_ngcontent-%COMP%] {\n  background-color: #f3f4f6;\n}\nbutton[_ngcontent-%COMP%]:hover.hover\\\\:bg-gray-300 {\n  background-color: #d1d5db;\n}\nbutton[_ngcontent-%COMP%]:hover.hover\\\\:text-gray-800 {\n  color: #1f2937;\n}\nbutton[_ngcontent-%COMP%]:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\nbutton[_ngcontent-%COMP%]:disabled.disabled\\\\:bg-gray-100 {\n  background-color: #f3f4f6;\n}\nbutton[_ngcontent-%COMP%]:disabled.disabled\\\\:text-gray-400 {\n  color: #9ca3af;\n}\n.flex[_ngcontent-%COMP%] {\n  display: flex;\n}\n.justify-between[_ngcontent-%COMP%] {\n  justify-content: space-between;\n}\n.items-center[_ngcontent-%COMP%] {\n  align-items: center;\n}\n.space-x-2[_ngcontent-%COMP%]    > *[_ngcontent-%COMP%]    + *[_ngcontent-%COMP%] {\n  margin-left: 0.5rem;\n}\n/*# sourceMappingURL=automation-history-modal.css.map */"] }));
var AutomationHistoryModal = _AutomationHistoryModal;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AutomationHistoryModal, [{
    type: Component,
    args: [{ selector: "app-automation-history-modal", imports: [CommonModule], template: `<div class="modal-overlay" *ngIf="isVisible" (click)="closeModal()">
  <div class="modal-content modal-content-lg p-6" (click)="$event.stopPropagation()">
    <div class="flex justify-between items-center mb-4">
      <h2 class="text-2xl font-bold">Hist\xF3rico: {{ automationName }}</h2>
      <button class="text-gray-500 hover:text-gray-800 text-2xl" (click)="closeModal()">&times;</button>
    </div>
    
    <div class="overflow-x-auto">
      <table class="min-w-full bg-white">
        <thead class="bg-gray-50">
          <tr>
            <th class="text-left py-3 px-4 uppercase font-semibold text-sm text-gray-600">Data</th>
            <th class="text-left py-3 px-4 uppercase font-semibold text-sm text-gray-600">Lead Afetado</th>
            <th class="text-left py-3 px-4 uppercase font-semibold text-sm text-gray-600">Status</th>
            <th class="text-left py-3 px-4 uppercase font-semibold text-sm text-gray-600">A\xE7\xE3o Executada</th>
          </tr>
        </thead>
        <tbody class="text-gray-700 divide-y divide-gray-200">
          <tr *ngIf="isLoading">
            <td colspan="4" class="text-center p-6 text-gray-500">
              <i class="fas fa-spinner fa-spin mr-2"></i>Carregando hist\xF3rico...
            </td>
          </tr>
          <tr *ngIf="!isLoading && historyItems.length === 0">
            <td colspan="4" class="text-center p-6 text-gray-500">Nenhuma execu\xE7\xE3o registrada.</td>
          </tr>
          <tr *ngFor="let item of paginatedItems" class="hover:bg-gray-50">
            <td class="py-3 px-4">{{ formatDate(item.timestamp) }}</td>
            <td class="py-3 px-4">{{ getLeadName(item.leadId) }}</td>
            <td class="py-3 px-4">
              <span 
                class="px-2 py-1 text-xs font-medium rounded-full"
                [class.bg-green-100]="item.status === 'success'"
                [class.text-green-800]="item.status === 'success'"
                [class.bg-red-100]="item.status === 'error'"
                [class.text-red-800]="item.status === 'error'"
                [class.bg-yellow-100]="item.status === 'pending'"
                [class.text-yellow-800]="item.status === 'pending'">
                {{ getStatusText(item.status) }}
              </span>
            </td>
            <td class="py-3 px-4">{{ item.text || item.action || 'A\xE7\xE3o executada' }}</td>
          </tr>
        </tbody>
      </table>
    </div>
    
    <!-- Pagina\xE7\xE3o -->
    <div *ngIf="totalPages > 1" class="p-4 flex justify-between items-center">
      <button 
        (click)="previousPage()" 
        [disabled]="currentPage === 1"
        class="bg-gray-200 hover:bg-gray-300 disabled:bg-gray-100 disabled:text-gray-400 text-gray-700 font-medium py-2 px-4 rounded-lg">
        <i class="fas fa-chevron-left mr-1"></i>Anterior
      </button>
      
      <span class="text-sm text-gray-600">
        P\xE1gina {{ currentPage }} de {{ totalPages }} ({{ historyItems.length }} registros)
      </span>
      
      <button 
        (click)="nextPage()" 
        [disabled]="currentPage === totalPages"
        class="bg-gray-200 hover:bg-gray-300 disabled:bg-gray-100 disabled:text-gray-400 text-gray-700 font-medium py-2 px-4 rounded-lg">
        Pr\xF3xima<i class="fas fa-chevron-right ml-1"></i>
      </button>
    </div>
  </div>
</div>
`, styles: ["/* src/app/components/automation-history-modal/automation-history-modal.scss */\n.modal-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background-color: rgba(0, 0, 0, 0.5);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  z-index: 1000;\n}\n.modal-content {\n  background: white;\n  border-radius: 8px;\n  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n  max-height: 90vh;\n  overflow-y: auto;\n}\n.modal-content-lg {\n  width: 95%;\n  max-width: 900px;\n}\n.overflow-x-auto {\n  overflow-x: auto;\n}\ntable {\n  min-width: 100%;\n  background-color: white;\n}\nthead {\n  background-color: #f9fafb;\n}\nth {\n  text-align: left;\n  padding: 0.75rem 1rem;\n  text-transform: uppercase;\n  font-weight: 600;\n  font-size: 0.875rem;\n  color: #4b5563;\n}\ntd {\n  padding: 0.75rem 1rem;\n}\ntbody tr {\n  color: #374151;\n}\ntbody tr:not(:last-child) {\n  border-bottom: 1px solid #e5e7eb;\n}\ntbody tr:hover {\n  background-color: #f9fafb;\n}\n.text-center {\n  text-align: center;\n}\n.text-gray-500 {\n  color: #6b7280;\n}\n.text-gray-600 {\n  color: #4b5563;\n}\n.text-gray-700 {\n  color: #374151;\n}\n.text-gray-800 {\n  color: #1f2937;\n}\n.text-2xl {\n  font-size: 1.5rem;\n  line-height: 2rem;\n}\n.font-bold {\n  font-weight: 700;\n}\n.font-medium {\n  font-weight: 500;\n}\n.text-sm {\n  font-size: 0.875rem;\n}\n.text-xs {\n  font-size: 0.75rem;\n}\n.px-2 {\n  padding-left: 0.5rem;\n  padding-right: 0.5rem;\n}\n.py-1 {\n  padding-top: 0.25rem;\n  padding-bottom: 0.25rem;\n}\n.py-2 {\n  padding-top: 0.5rem;\n  padding-bottom: 0.5rem;\n}\n.px-4 {\n  padding-left: 1rem;\n  padding-right: 1rem;\n}\n.p-4 {\n  padding: 1rem;\n}\n.p-6 {\n  padding: 1.5rem;\n}\n.mb-4 {\n  margin-bottom: 1rem;\n}\n.mr-1 {\n  margin-right: 0.25rem;\n}\n.mr-2 {\n  margin-right: 0.5rem;\n}\n.ml-1 {\n  margin-left: 0.25rem;\n}\n.rounded-full {\n  border-radius: 9999px;\n}\n.rounded-lg {\n  border-radius: 0.5rem;\n}\n.bg-green-100 {\n  background-color: #dcfce7;\n}\n.text-green-800 {\n  color: #166534;\n}\n.bg-red-100 {\n  background-color: #fee2e2;\n}\n.text-red-800 {\n  color: #991b1b;\n}\n.bg-yellow-100 {\n  background-color: #fef3c7;\n}\n.text-yellow-800 {\n  color: #92400e;\n}\n.bg-gray-200 {\n  background-color: #e5e7eb;\n}\n.bg-gray-100 {\n  background-color: #f3f4f6;\n}\nbutton:hover.hover\\\\:bg-gray-300 {\n  background-color: #d1d5db;\n}\nbutton:hover.hover\\\\:text-gray-800 {\n  color: #1f2937;\n}\nbutton:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\nbutton:disabled.disabled\\\\:bg-gray-100 {\n  background-color: #f3f4f6;\n}\nbutton:disabled.disabled\\\\:text-gray-400 {\n  color: #9ca3af;\n}\n.flex {\n  display: flex;\n}\n.justify-between {\n  justify-content: space-between;\n}\n.items-center {\n  align-items: center;\n}\n.space-x-2 > * + * {\n  margin-left: 0.5rem;\n}\n/*# sourceMappingURL=automation-history-modal.css.map */\n"] }]
  }], null, { isVisible: [{
    type: Input
  }], automationId: [{
    type: Input
  }], automationName: [{
    type: Input
  }], ownerId: [{
    type: Input
  }], boardId: [{
    type: Input
  }], leads: [{
    type: Input
  }], closeModalEvent: [{
    type: Output
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(AutomationHistoryModal, { className: "AutomationHistoryModal", filePath: "src/app/components/automation-history-modal/automation-history-modal.ts", lineNumber: 11 });
})();

// src/app/components/kanban/kanban.component.ts
var _c07 = ["flowScroller"];
var _c14 = /* @__PURE__ */ __name(() => [], "_c1");
var _c23 = /* @__PURE__ */ __name((a0, a1, a2) => ({ "bg-red-500": a0, "bg-yellow-500": a1, "bg-blue-500": a2 }), "_c2");
var _c3 = /* @__PURE__ */ __name(() => ({}), "_c3");
function KanbanComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 20);
    \u0275\u0275element(1, "div", 21);
    \u0275\u0275elementEnd();
  }
}
__name(KanbanComponent_div_1_Template, "KanbanComponent_div_1_Template");
function KanbanComponent_nav_2_div_6_span_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 39);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.getDynamicFilterCount() + (ctx_r1.filterOnlyMine ? 1 : 0), " ");
  }
}
__name(KanbanComponent_nav_2_div_6_span_5_Template, "KanbanComponent_nav_2_div_6_span_5_Template");
function KanbanComponent_nav_2_div_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 33)(1, "input", 34);
    \u0275\u0275twoWayListener("ngModelChange", /* @__PURE__ */ __name(function KanbanComponent_nav_2_div_6_Template_input_ngModelChange_1_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext(2);
      \u0275\u0275twoWayBindingSet(ctx_r1.filterQuery, $event) || (ctx_r1.filterQuery = $event);
      return \u0275\u0275resetView($event);
    }, "KanbanComponent_nav_2_div_6_Template_input_ngModelChange_1_listener"));
    \u0275\u0275listener("ngModelChange", /* @__PURE__ */ __name(function KanbanComponent_nav_2_div_6_Template_input_ngModelChange_1_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onFilterQueryChange($event));
    }, "KanbanComponent_nav_2_div_6_Template_input_ngModelChange_1_listener"));
    \u0275\u0275elementEnd();
    \u0275\u0275element(2, "i", 35);
    \u0275\u0275elementStart(3, "button", 36);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_nav_2_div_6_Template_button_click_3_listener() {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.toggleAdvancedFilters());
    }, "KanbanComponent_nav_2_div_6_Template_button_click_3_listener"));
    \u0275\u0275element(4, "i", 37);
    \u0275\u0275template(5, KanbanComponent_nav_2_div_6_span_5_Template, 2, 1, "span", 38);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.filterQuery);
    \u0275\u0275advance(2);
    \u0275\u0275classProp("text-blue-600", ctx_r1.showAdvancedFilters)("bg-blue-50", ctx_r1.showAdvancedFilters);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r1.hasActiveFilters());
  }
}
__name(KanbanComponent_nav_2_div_6_Template, "KanbanComponent_nav_2_div_6_Template");
function KanbanComponent_nav_2_button_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 40);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_nav_2_button_8_Template_button_click_0_listener() {
      const tab_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.switchTab(tab_r5.id));
    }, "KanbanComponent_nav_2_button_8_Template_button_click_0_listener"));
    \u0275\u0275element(1, "i");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const tab_r5 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classProp("border-blue-500", ctx_r1.activeTab === tab_r5.id)("text-blue-600", ctx_r1.activeTab === tab_r5.id)("border-transparent", ctx_r1.activeTab !== tab_r5.id)("text-gray-500", ctx_r1.activeTab !== tab_r5.id)("hover:text-gray-700", ctx_r1.activeTab !== tab_r5.id);
    \u0275\u0275advance();
    \u0275\u0275classMap(\u0275\u0275interpolate1("fas ", tab_r5.icon, " mr-2"));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", tab_r5.name, " ");
  }
}
__name(KanbanComponent_nav_2_button_8_Template, "KanbanComponent_nav_2_button_8_Template");
function KanbanComponent_nav_2_button_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 41);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_nav_2_button_10_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.clearFilters());
    }, "KanbanComponent_nav_2_button_10_Template_button_click_0_listener"));
    \u0275\u0275element(1, "i", 42);
    \u0275\u0275text(2, " Limpar ");
    \u0275\u0275elementEnd();
  }
}
__name(KanbanComponent_nav_2_button_10_Template, "KanbanComponent_nav_2_button_10_Template");
function KanbanComponent_nav_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "nav", 22)(1, "div", 23)(2, "div", 24)(3, "div", 25)(4, "button", 26);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_nav_2_Template_button_click_4_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.goToDashboard());
    }, "KanbanComponent_nav_2_Template_button_click_4_listener"));
    \u0275\u0275element(5, "i", 27);
    \u0275\u0275elementEnd();
    \u0275\u0275template(6, KanbanComponent_nav_2_div_6_Template, 6, 6, "div", 28);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(7, "div", 29);
    \u0275\u0275template(8, KanbanComponent_nav_2_button_8_Template, 3, 14, "button", 30);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "div", 31);
    \u0275\u0275template(10, KanbanComponent_nav_2_button_10_Template, 3, 0, "button", 32);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(6);
    \u0275\u0275property("ngIf", ctx_r1.activeTab === "kanban");
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx_r1.tabs);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r1.hasActiveFilters() && ctx_r1.activeTab === "kanban");
  }
}
__name(KanbanComponent_nav_2_Template, "KanbanComponent_nav_2_Template");
function KanbanComponent_div_3_div_12_div_3_input_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "input", 67);
    \u0275\u0275listener("input", /* @__PURE__ */ __name(function KanbanComponent_div_3_div_12_div_3_input_3_Template_input_input_0_listener($event) {
      \u0275\u0275restoreView(_r8);
      const field_r9 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.setDynamicFilter(field_r9.name, $event.target.value));
    }, "KanbanComponent_div_3_div_12_div_3_input_3_Template_input_input_0_listener"));
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const field_r9 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("type", field_r9.type === "number" ? "number" : "text")("value", ctx_r1.dynamicFilters[field_r9.name] || "")("placeholder", "Filtrar por " + field_r9.label.toLowerCase());
  }
}
__name(KanbanComponent_div_3_div_12_div_3_input_3_Template, "KanbanComponent_div_3_div_12_div_3_input_3_Template");
function KanbanComponent_div_3_div_12_div_3_input_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "input", 68);
    \u0275\u0275listener("input", /* @__PURE__ */ __name(function KanbanComponent_div_3_div_12_div_3_input_4_Template_input_input_0_listener($event) {
      \u0275\u0275restoreView(_r10);
      const field_r9 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.setDynamicFilter(field_r9.name, $event.target.value));
    }, "KanbanComponent_div_3_div_12_div_3_input_4_Template_input_input_0_listener"));
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const field_r9 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("value", ctx_r1.dynamicFilters[field_r9.name] || "");
  }
}
__name(KanbanComponent_div_3_div_12_div_3_input_4_Template, "KanbanComponent_div_3_div_12_div_3_input_4_Template");
function KanbanComponent_div_3_div_12_div_3_select_5_option_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "option", 72);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const option_r12 = ctx.$implicit;
    \u0275\u0275property("value", option_r12);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", option_r12, " ");
  }
}
__name(KanbanComponent_div_3_div_12_div_3_select_5_option_3_Template, "KanbanComponent_div_3_div_12_div_3_select_5_option_3_Template");
function KanbanComponent_div_3_div_12_div_3_select_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "select", 69);
    \u0275\u0275listener("change", /* @__PURE__ */ __name(function KanbanComponent_div_3_div_12_div_3_select_5_Template_select_change_0_listener($event) {
      \u0275\u0275restoreView(_r11);
      const field_r9 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.setDynamicFilter(field_r9.name, $event.target.value));
    }, "KanbanComponent_div_3_div_12_div_3_select_5_Template_select_change_0_listener"));
    \u0275\u0275elementStart(1, "option", 70);
    \u0275\u0275text(2, "Todos");
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, KanbanComponent_div_3_div_12_div_3_select_5_option_3_Template, 2, 2, "option", 71);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const field_r9 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("value", ctx_r1.dynamicFilters[field_r9.name] || "");
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", ctx_r1.getFieldOptions(field_r9));
  }
}
__name(KanbanComponent_div_3_div_12_div_3_select_5_Template, "KanbanComponent_div_3_div_12_div_3_select_5_Template");
function KanbanComponent_div_3_div_12_div_3_select_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r13 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "select", 69);
    \u0275\u0275listener("change", /* @__PURE__ */ __name(function KanbanComponent_div_3_div_12_div_3_select_6_Template_select_change_0_listener($event) {
      \u0275\u0275restoreView(_r13);
      const field_r9 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.setDynamicFilter(field_r9.name, $event.target.value));
    }, "KanbanComponent_div_3_div_12_div_3_select_6_Template_select_change_0_listener"));
    \u0275\u0275elementStart(1, "option", 70);
    \u0275\u0275text(2, "Todas as temperaturas");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "option", 73);
    \u0275\u0275text(4, "\u{1F525} Quente");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "option", 74);
    \u0275\u0275text(6, "\u{1F321}\uFE0F Morno");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "option", 75);
    \u0275\u0275text(8, "\u2744\uFE0F Frio");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const field_r9 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("value", ctx_r1.dynamicFilters[field_r9.name] || "");
  }
}
__name(KanbanComponent_div_3_div_12_div_3_select_6_Template, "KanbanComponent_div_3_div_12_div_3_select_6_Template");
function KanbanComponent_div_3_div_12_div_3_div_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r14 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 76)(1, "input", 77);
    \u0275\u0275listener("change", /* @__PURE__ */ __name(function KanbanComponent_div_3_div_12_div_3_div_7_Template_input_change_1_listener($event) {
      \u0275\u0275restoreView(_r14);
      const field_r9 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.setDynamicFilter(field_r9.name, $event.target.checked));
    }, "KanbanComponent_div_3_div_12_div_3_div_7_Template_input_change_1_listener"));
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "span", 78);
    \u0275\u0275text(3, "Apenas marcados");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const field_r9 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275property("checked", ctx_r1.dynamicFilters[field_r9.name] === true);
  }
}
__name(KanbanComponent_div_3_div_12_div_3_div_7_Template, "KanbanComponent_div_3_div_12_div_3_div_7_Template");
function KanbanComponent_div_3_div_12_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 61)(1, "label", 62);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, KanbanComponent_div_3_div_12_div_3_input_3_Template, 1, 3, "input", 63)(4, KanbanComponent_div_3_div_12_div_3_input_4_Template, 1, 1, "input", 64)(5, KanbanComponent_div_3_div_12_div_3_select_5_Template, 4, 2, "select", 65)(6, KanbanComponent_div_3_div_12_div_3_select_6_Template, 9, 1, "select", 65)(7, KanbanComponent_div_3_div_12_div_3_div_7_Template, 4, 1, "div", 66);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const field_r9 = ctx.$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", field_r9.label, " ");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r9.type === "text" || field_r9.type === "email" || field_r9.type === "tel" || field_r9.type === "number" || field_r9.type === "cnpj" || field_r9.type === "cpf");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r9.type === "date");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r9.type === "select" || field_r9.type === "radio");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r9.type === "temperatura");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r9.type === "checkbox");
  }
}
__name(KanbanComponent_div_3_div_12_div_3_Template, "KanbanComponent_div_3_div_12_div_3_Template");
function KanbanComponent_div_3_div_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 58)(1, "h4", 59);
    \u0275\u0275text(2, "Filtros Din\xE2micos");
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, KanbanComponent_div_3_div_12_div_3_Template, 8, 6, "div", 60);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", ctx_r1.availableFilterFields);
  }
}
__name(KanbanComponent_div_3_div_12_Template, "KanbanComponent_div_3_div_12_Template");
function KanbanComponent_div_3_div_13_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 79);
    \u0275\u0275element(1, "i", 80);
    \u0275\u0275elementStart(2, "p", 81);
    \u0275\u0275text(3, " Nenhum campo configurado para filtros.");
    \u0275\u0275element(4, "br");
    \u0275\u0275text(5, ' Configure campos com "Mostrar em filtros" ativado no formul\xE1rio. ');
    \u0275\u0275elementEnd()();
  }
}
__name(KanbanComponent_div_3_div_13_Template, "KanbanComponent_div_3_div_13_Template");
function KanbanComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 43)(1, "div", 44)(2, "div", 45)(3, "h3", 46);
    \u0275\u0275text(4, "Filtros Avan\xE7ados");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "button", 47);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_3_Template_button_click_5_listener() {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.toggleAdvancedFilters());
    }, "KanbanComponent_div_3_Template_button_click_5_listener"));
    \u0275\u0275element(6, "i", 48);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(7, "div", 49)(8, "label", 50)(9, "input", 51);
    \u0275\u0275twoWayListener("ngModelChange", /* @__PURE__ */ __name(function KanbanComponent_div_3_Template_input_ngModelChange_9_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.filterOnlyMine, $event) || (ctx_r1.filterOnlyMine = $event);
      return \u0275\u0275resetView($event);
    }, "KanbanComponent_div_3_Template_input_ngModelChange_9_listener"));
    \u0275\u0275listener("ngModelChange", /* @__PURE__ */ __name(function KanbanComponent_div_3_Template_input_ngModelChange_9_listener() {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.toggleOnlyMine());
    }, "KanbanComponent_div_3_Template_input_ngModelChange_9_listener"));
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(10, "span", 52);
    \u0275\u0275text(11, "Mostrar apenas meus registros");
    \u0275\u0275elementEnd()()();
    \u0275\u0275template(12, KanbanComponent_div_3_div_12_Template, 4, 1, "div", 53)(13, KanbanComponent_div_3_div_13_Template, 6, 0, "div", 54);
    \u0275\u0275elementStart(14, "div", 55)(15, "button", 56);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_3_Template_button_click_15_listener() {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.clearFilters());
    }, "KanbanComponent_div_3_Template_button_click_15_listener"));
    \u0275\u0275text(16, " Limpar ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(17, "button", 57);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_3_Template_button_click_17_listener() {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.toggleAdvancedFilters());
    }, "KanbanComponent_div_3_Template_button_click_17_listener"));
    \u0275\u0275text(18, " Aplicar ");
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(9);
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.filterOnlyMine);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", ctx_r1.availableFilterFields.length > 0);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.availableFilterFields.length === 0);
  }
}
__name(KanbanComponent_div_3_Template, "KanbanComponent_div_3_Template");
function KanbanComponent_div_4_div_1_span_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 94);
    \u0275\u0275element(1, "i", 95);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const column_r16 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1("", ctx_r1.getAutomationCount(column_r16.id), " ");
  }
}
__name(KanbanComponent_div_4_div_1_span_8_Template, "KanbanComponent_div_4_div_1_span_8_Template");
function KanbanComponent_div_4_div_1_div_10_div_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 109);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const lead_r18 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" CNPJ: ", ctx_r1.getCnpj(lead_r18), " ");
  }
}
__name(KanbanComponent_div_4_div_1_div_10_div_5_Template, "KanbanComponent_div_4_div_1_div_10_div_5_Template");
function KanbanComponent_div_4_div_1_div_10_div_7_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div")(1, "div", 111);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "div", 112);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const item_r19 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(item_r19.label);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(item_r19.value);
  }
}
__name(KanbanComponent_div_4_div_1_div_10_div_7_div_1_Template, "KanbanComponent_div_4_div_1_div_10_div_7_div_1_Template");
function KanbanComponent_div_4_div_1_div_10_div_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 110);
    \u0275\u0275template(1, KanbanComponent_div_4_div_1_div_10_div_7_div_1_Template, 5, 2, "div", 11);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r19 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", item_r19.type !== "temperatura");
  }
}
__name(KanbanComponent_div_4_div_1_div_10_div_7_Template, "KanbanComponent_div_4_div_1_div_10_div_7_Template");
function KanbanComponent_div_4_div_1_div_10_div_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 113)(1, "div", 114);
    \u0275\u0275element(2, "i", 115);
    \u0275\u0275elementStart(3, "span");
    \u0275\u0275text(4);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const lead_r18 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r1.getSlaStatus(lead_r18).colorClass);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx_r1.getSlaStatus(lead_r18).text);
  }
}
__name(KanbanComponent_div_4_div_1_div_10_div_8_Template, "KanbanComponent_div_4_div_1_div_10_div_8_Template");
function KanbanComponent_div_4_div_1_div_10_div_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 113)(1, "div", 114);
    \u0275\u0275element(2, "span", 116);
    \u0275\u0275elementStart(3, "span");
    \u0275\u0275text(4);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const temp_r20 = ctx.ngIf;
    \u0275\u0275advance(2);
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction3(2, _c23, temp_r20.value === "Quente", temp_r20.value === "Morno", temp_r20.value === "Frio"));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(temp_r20.value);
  }
}
__name(KanbanComponent_div_4_div_1_div_10_div_9_Template, "KanbanComponent_div_4_div_1_div_10_div_9_Template");
function KanbanComponent_div_4_div_1_div_10_div_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 87);
    \u0275\u0275element(1, "i", 117);
    \u0275\u0275elementStart(2, "span");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const c_r21 = ctx.ngIf;
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(c_r21 || 0);
  }
}
__name(KanbanComponent_div_4_div_1_div_10_div_12_Template, "KanbanComponent_div_4_div_1_div_10_div_12_Template");
function KanbanComponent_div_4_div_1_div_10_div_13_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 87);
    \u0275\u0275element(1, "i", 118);
    \u0275\u0275elementStart(2, "span");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const a_r22 = ctx.ngIf;
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(a_r22 || 0);
  }
}
__name(KanbanComponent_div_4_div_1_div_10_div_13_Template, "KanbanComponent_div_4_div_1_div_10_div_13_Template");
function KanbanComponent_div_4_div_1_div_10_div_18_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 119)(1, "p", 120);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const lead_r18 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", lead_r18.fields["description"], " ");
  }
}
__name(KanbanComponent_div_4_div_1_div_10_div_18_Template, "KanbanComponent_div_4_div_1_div_10_div_18_Template");
function KanbanComponent_div_4_div_1_div_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r17 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 96);
    \u0275\u0275listener("cdkDragStarted", /* @__PURE__ */ __name(function KanbanComponent_div_4_div_1_div_10_Template_div_cdkDragStarted_0_listener() {
      \u0275\u0275restoreView(_r17);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.onLeadDragStarted());
    }, "KanbanComponent_div_4_div_1_div_10_Template_div_cdkDragStarted_0_listener"))("cdkDragEnded", /* @__PURE__ */ __name(function KanbanComponent_div_4_div_1_div_10_Template_div_cdkDragEnded_0_listener() {
      \u0275\u0275restoreView(_r17);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.onLeadDragEnded());
    }, "KanbanComponent_div_4_div_1_div_10_Template_div_cdkDragEnded_0_listener"))("click", /* @__PURE__ */ __name(function KanbanComponent_div_4_div_1_div_10_Template_div_click_0_listener($event) {
      const lead_r18 = \u0275\u0275restoreView(_r17).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.onCardClick(lead_r18, $event));
    }, "KanbanComponent_div_4_div_1_div_10_Template_div_click_0_listener"));
    \u0275\u0275elementStart(1, "div", 97)(2, "div", 98)(3, "h4", 99);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd();
    \u0275\u0275template(5, KanbanComponent_div_4_div_1_div_10_div_5_Template, 2, 1, "div", 100);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(6, "div", 101);
    \u0275\u0275template(7, KanbanComponent_div_4_div_1_div_10_div_7_Template, 2, 1, "div", 102);
    \u0275\u0275elementEnd();
    \u0275\u0275template(8, KanbanComponent_div_4_div_1_div_10_div_8_Template, 5, 3, "div", 103)(9, KanbanComponent_div_4_div_1_div_10_div_9_Template, 5, 6, "div", 103);
    \u0275\u0275elementStart(10, "div", 86)(11, "div", 104);
    \u0275\u0275template(12, KanbanComponent_div_4_div_1_div_10_div_12_Template, 4, 1, "div", 105)(13, KanbanComponent_div_4_div_1_div_10_div_13_Template, 4, 1, "div", 105);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(14, "div", 106);
    \u0275\u0275element(15, "i", 107);
    \u0275\u0275elementStart(16, "span");
    \u0275\u0275text(17);
    \u0275\u0275elementEnd()()();
    \u0275\u0275template(18, KanbanComponent_div_4_div_1_div_10_div_18_Template, 3, 1, "div", 108);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const lead_r18 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275classMap(ctx_r1.getSlaStatus(lead_r18).borderClass || ctx_r1.getLeadPriorityClass(lead_r18));
    \u0275\u0275property("cdkDragDisabled", !ctx_r1.cardMoveEnabled)("cdkDragData", lead_r18.id);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", ctx_r1.getCompanyName(lead_r18), " ");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.getCnpj(lead_r18));
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx_r1.getCardFieldsForLead(lead_r18));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.getSlaStatus(lead_r18).text);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.getTemperatureGlobalItem(lead_r18));
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", lead_r18.historyCommentsCount);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", lead_r18.attachmentsCount);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(ctx_r1.formatDateTime(lead_r18.createdAt));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", lead_r18.fields == null ? null : lead_r18.fields["description"]);
  }
}
__name(KanbanComponent_div_4_div_1_div_10_Template, "KanbanComponent_div_4_div_1_div_10_Template");
function KanbanComponent_div_4_div_1_div_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 121);
    \u0275\u0275element(1, "i", 122);
    \u0275\u0275elementStart(2, "p", 123);
    \u0275\u0275text(3, "Nenhum registro nesta fase");
    \u0275\u0275elementEnd()();
  }
}
__name(KanbanComponent_div_4_div_1_div_11_Template, "KanbanComponent_div_4_div_1_div_11_Template");
function KanbanComponent_div_4_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r15 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 84)(1, "div", 85)(2, "div", 86)(3, "div", 87)(4, "h3", 88);
    \u0275\u0275text(5);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "span", 89);
    \u0275\u0275text(7);
    \u0275\u0275elementEnd();
    \u0275\u0275template(8, KanbanComponent_div_4_div_1_span_8_Template, 3, 1, "span", 90);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(9, "div", 91);
    \u0275\u0275listener("cdkDropListDropped", /* @__PURE__ */ __name(function KanbanComponent_div_4_div_1_Template_div_cdkDropListDropped_9_listener($event) {
      \u0275\u0275restoreView(_r15);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onLeadDrop($event));
    }, "KanbanComponent_div_4_div_1_Template_div_cdkDropListDropped_9_listener"));
    \u0275\u0275template(10, KanbanComponent_div_4_div_1_div_10_Template, 19, 13, "div", 92)(11, KanbanComponent_div_4_div_1_div_11_Template, 4, 0, "div", 93);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const column_r16 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275styleProp("background-color", "#e2e8f0");
    \u0275\u0275advance();
    \u0275\u0275styleProp("border-top-color", ctx_r1.getColumnBorderColor(column_r16));
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(column_r16.name);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", ctx_r1.getLeadsForColumn(column_r16.id).length, " ");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.getAutomationCount(column_r16.id) > 0);
    \u0275\u0275advance();
    \u0275\u0275property("id", "column-" + column_r16.id)("cdkDropListData", ctx_r1.displayedLeadsByColumn[column_r16.id] || \u0275\u0275pureFunction0(13, _c14))("cdkDropListConnectedTo", ctx_r1.getColumnConnectedTo());
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.displayedLeadsByColumn[column_r16.id] || \u0275\u0275pureFunction0(14, _c14))("ngForTrackBy", ctx_r1.trackByLeadId);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.getLeadsForColumn(column_r16.id).length === 0);
  }
}
__name(KanbanComponent_div_4_div_1_Template, "KanbanComponent_div_4_div_1_Template");
function KanbanComponent_div_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 82);
    \u0275\u0275template(1, KanbanComponent_div_4_div_1_Template, 12, 15, "div", 83);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.columns);
  }
}
__name(KanbanComponent_div_4_Template, "KanbanComponent_div_4_Template");
function KanbanComponent_button_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r23 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 124);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_button_5_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r23);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.showCreateLeadModal());
    }, "KanbanComponent_button_5_Template_button_click_0_listener"));
    \u0275\u0275element(1, "i", 125);
    \u0275\u0275text(2, " Novo registro ");
    \u0275\u0275elementEnd();
  }
}
__name(KanbanComponent_button_5_Template, "KanbanComponent_button_5_Template");
function KanbanComponent_div_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r24 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 126)(1, "div", 127)(2, "h2", 128);
    \u0275\u0275text(3, "Formul\xE1rio inicial do quadro");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "app-visual-form-builder", 129);
    \u0275\u0275listener("fieldsChanged", /* @__PURE__ */ __name(function KanbanComponent_div_6_Template_app_visual_form_builder_fieldsChanged_4_listener($event) {
      \u0275\u0275restoreView(_r24);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onInitialFieldsChanged($event));
    }, "KanbanComponent_div_6_Template_app_visual_form_builder_fieldsChanged_4_listener"));
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "div", 130)(6, "button", 131);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_6_Template_button_click_6_listener() {
      \u0275\u0275restoreView(_r24);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.saveInitialForm());
    }, "KanbanComponent_div_6_Template_button_click_6_listener"));
    \u0275\u0275text(7, " Salvar ");
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(4);
    \u0275\u0275property("fields", ctx_r1.initialFormFields);
    \u0275\u0275advance(2);
    \u0275\u0275styleProp("background-color", ctx_r1.getPrimaryColor());
  }
}
__name(KanbanComponent_div_6_Template, "KanbanComponent_div_6_Template");
function KanbanComponent_div_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 132)(1, "div", 133);
    \u0275\u0275element(2, "i", 134);
    \u0275\u0275elementStart(3, "h3", 135);
    \u0275\u0275text(4, "Nenhuma coluna encontrada");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "p", 136);
    \u0275\u0275text(6, " Este quadro ainda n\xE3o possui colunas configuradas. ");
    \u0275\u0275elementEnd()()();
  }
}
__name(KanbanComponent_div_7_Template, "KanbanComponent_div_7_Template");
function KanbanComponent_div_8_div_8_div_1_span_17_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275element(1, "i", 155);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const template_r27 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" Atualizado em ", ctx_r1.formatDate(template_r27.updatedAt), " ");
  }
}
__name(KanbanComponent_div_8_div_8_div_1_span_17_Template, "KanbanComponent_div_8_div_8_div_1_span_17_Template");
function KanbanComponent_div_8_div_8_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r26 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 145)(1, "div", 146)(2, "div", 147)(3, "h3", 148);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "p", 149)(6, "strong");
    \u0275\u0275text(7, "Assunto:");
    \u0275\u0275elementEnd();
    \u0275\u0275text(8);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "p", 150)(10, "strong");
    \u0275\u0275text(11, "Para:");
    \u0275\u0275elementEnd();
    \u0275\u0275text(12);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(13, "div", 151)(14, "span");
    \u0275\u0275element(15, "i", 152);
    \u0275\u0275text(16);
    \u0275\u0275elementEnd();
    \u0275\u0275template(17, KanbanComponent_div_8_div_8_div_1_span_17_Template, 3, 1, "span", 11);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(18, "div", 153)(19, "button", 154);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_8_div_8_div_1_Template_button_click_19_listener() {
      const template_r27 = \u0275\u0275restoreView(_r26).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.editTemplate(template_r27));
    }, "KanbanComponent_div_8_div_8_div_1_Template_button_click_19_listener"));
    \u0275\u0275element(20, "i", 155);
    \u0275\u0275text(21, " Editar ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(22, "button", 156);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_8_div_8_div_1_Template_button_click_22_listener() {
      const template_r27 = \u0275\u0275restoreView(_r26).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.deleteTemplate(template_r27));
    }, "KanbanComponent_div_8_div_8_div_1_Template_button_click_22_listener"));
    \u0275\u0275element(23, "i", 157);
    \u0275\u0275text(24, " Excluir ");
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const template_r27 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", template_r27.name || "Template sem nome", " ");
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", template_r27.subject || "Sem assunto", " ");
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", template_r27.recipients || "N\xE3o especificado", " ");
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" Criado em ", ctx_r1.formatDate(template_r27.createdAt), " ");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", template_r27.updatedAt);
  }
}
__name(KanbanComponent_div_8_div_8_div_1_Template, "KanbanComponent_div_8_div_8_div_1_Template");
function KanbanComponent_div_8_div_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 143);
    \u0275\u0275template(1, KanbanComponent_div_8_div_8_div_1_Template, 25, 5, "div", 144);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.emailTemplates);
  }
}
__name(KanbanComponent_div_8_div_8_Template, "KanbanComponent_div_8_div_8_Template");
function KanbanComponent_div_8_div_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 158)(1, "div", 159);
    \u0275\u0275element(2, "i", 160);
    \u0275\u0275elementStart(3, "h3", 161);
    \u0275\u0275text(4, "Nenhum template encontrado");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "p");
    \u0275\u0275text(6, "Crie templates personalizados para automa\xE7\xF5es de email");
    \u0275\u0275elementEnd()()();
  }
}
__name(KanbanComponent_div_8_div_9_Template, "KanbanComponent_div_8_div_9_Template");
function KanbanComponent_div_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r25 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 126)(1, "div", 127)(2, "div", 137)(3, "h2", 138);
    \u0275\u0275text(4, "Templates de Email");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "button", 139);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_8_Template_button_click_5_listener() {
      \u0275\u0275restoreView(_r25);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.createTemplate());
    }, "KanbanComponent_div_8_Template_button_click_5_listener"));
    \u0275\u0275element(6, "i", 140);
    \u0275\u0275text(7, " Novo Template ");
    \u0275\u0275elementEnd()();
    \u0275\u0275template(8, KanbanComponent_div_8_div_8_Template, 2, 1, "div", 141)(9, KanbanComponent_div_8_div_9_Template, 7, 0, "div", 142);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(8);
    \u0275\u0275property("ngIf", ctx_r1.emailTemplates.length > 0);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.emailTemplates.length === 0);
  }
}
__name(KanbanComponent_div_8_Template, "KanbanComponent_div_8_Template");
function KanbanComponent_div_9_div_8_div_1_span_23_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275element(1, "i", 174);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const automation_r30 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" \xDAltima execu\xE7\xE3o: ", ctx_r1.formatDate(automation_r30.lastExecuted), " ");
  }
}
__name(KanbanComponent_div_9_div_8_div_1_span_23_Template, "KanbanComponent_div_9_div_8_div_1_span_23_Template");
function KanbanComponent_div_9_div_8_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r29 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 145)(1, "div", 146)(2, "div", 147)(3, "div", 163)(4, "h3", 164);
    \u0275\u0275text(5);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "span", 165);
    \u0275\u0275text(7);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(8, "div", 166)(9, "p", 167);
    \u0275\u0275element(10, "i", 168);
    \u0275\u0275elementStart(11, "strong");
    \u0275\u0275text(12, "Gatilho:");
    \u0275\u0275elementEnd();
    \u0275\u0275text(13);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(14, "p", 167);
    \u0275\u0275element(15, "i", 169);
    \u0275\u0275elementStart(16, "strong");
    \u0275\u0275text(17, "A\xE7\xF5es:");
    \u0275\u0275elementEnd();
    \u0275\u0275text(18);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(19, "div", 151)(20, "span");
    \u0275\u0275element(21, "i", 152);
    \u0275\u0275text(22);
    \u0275\u0275elementEnd();
    \u0275\u0275template(23, KanbanComponent_div_9_div_8_div_1_span_23_Template, 3, 1, "span", 11);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(24, "div", 153)(25, "button", 170);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_9_div_8_div_1_Template_button_click_25_listener($event) {
      const automation_r30 = \u0275\u0275restoreView(_r29).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.showAutomationHistory(automation_r30, $event));
    }, "KanbanComponent_div_9_div_8_div_1_Template_button_click_25_listener"));
    \u0275\u0275element(26, "i", 171);
    \u0275\u0275text(27, " Hist\xF3rico ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(28, "button", 154);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_9_div_8_div_1_Template_button_click_28_listener($event) {
      const automation_r30 = \u0275\u0275restoreView(_r29).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.editAutomation(automation_r30, $event));
    }, "KanbanComponent_div_9_div_8_div_1_Template_button_click_28_listener"));
    \u0275\u0275element(29, "i", 155);
    \u0275\u0275text(30, " Editar ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(31, "button", 172);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_9_div_8_div_1_Template_button_click_31_listener() {
      const automation_r30 = \u0275\u0275restoreView(_r29).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.toggleAutomation(automation_r30));
    }, "KanbanComponent_div_9_div_8_div_1_Template_button_click_31_listener"));
    \u0275\u0275element(32, "i", 173);
    \u0275\u0275text(33);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(34, "button", 156);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_9_div_8_div_1_Template_button_click_34_listener($event) {
      const automation_r30 = \u0275\u0275restoreView(_r29).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.openDeleteAutomationConfirm(automation_r30, $event));
    }, "KanbanComponent_div_9_div_8_div_1_Template_button_click_34_listener"));
    \u0275\u0275element(35, "i", 157);
    \u0275\u0275text(36, " Excluir ");
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const automation_r30 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate1(" ", automation_r30.name, " ");
    \u0275\u0275advance();
    \u0275\u0275classProp("bg-green-100", automation_r30.active)("text-green-800", automation_r30.active)("bg-red-100", !automation_r30.active)("text-red-800", !automation_r30.active);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", automation_r30.active ? "Ativa" : "Inativa", " ");
    \u0275\u0275advance(6);
    \u0275\u0275textInterpolate1(" ", ctx_r1.getTriggerDescription(automation_r30.trigger), " ");
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate1(" ", ctx_r1.getActionsCount(automation_r30.actions), " a\xE7\xE3o(\xF5es) configurada(s) ");
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" Criada em ", ctx_r1.formatDate(automation_r30.createdAt), " ");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", automation_r30.lastExecuted);
    \u0275\u0275advance(8);
    \u0275\u0275classProp("text-red-600", automation_r30.active)("hover:text-red-800", automation_r30.active)("text-green-600", !automation_r30.active)("hover:text-green-800", !automation_r30.active);
    \u0275\u0275advance();
    \u0275\u0275classProp("fa-pause", automation_r30.active)("fa-play", !automation_r30.active);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", automation_r30.active ? "Pausar" : "Ativar", " ");
  }
}
__name(KanbanComponent_div_9_div_8_div_1_Template, "KanbanComponent_div_9_div_8_div_1_Template");
function KanbanComponent_div_9_div_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 143);
    \u0275\u0275template(1, KanbanComponent_div_9_div_8_div_1_Template, 37, 27, "div", 144);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.getValidAutomations());
  }
}
__name(KanbanComponent_div_9_div_8_Template, "KanbanComponent_div_9_div_8_Template");
function KanbanComponent_div_9_div_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 158)(1, "div", 159);
    \u0275\u0275element(2, "i", 175);
    \u0275\u0275elementStart(3, "h3", 161);
    \u0275\u0275text(4, "Nenhuma automa\xE7\xE3o encontrada");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "p");
    \u0275\u0275text(6, "Configure automa\xE7\xF5es para disparar a\xE7\xF5es quando leads mudarem de fase");
    \u0275\u0275elementEnd()()();
  }
}
__name(KanbanComponent_div_9_div_9_Template, "KanbanComponent_div_9_div_9_Template");
function KanbanComponent_div_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r28 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 126)(1, "div", 127)(2, "div", 137)(3, "h2", 138);
    \u0275\u0275text(4, "Automa\xE7\xF5es");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "button", 162);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_9_Template_button_click_5_listener($event) {
      \u0275\u0275restoreView(_r28);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.createAutomation($event));
    }, "KanbanComponent_div_9_Template_button_click_5_listener"));
    \u0275\u0275element(6, "i", 140);
    \u0275\u0275text(7, " Nova Automa\xE7\xE3o ");
    \u0275\u0275elementEnd()();
    \u0275\u0275template(8, KanbanComponent_div_9_div_8_Template, 2, 1, "div", 141)(9, KanbanComponent_div_9_div_9_Template, 7, 0, "div", 142);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(8);
    \u0275\u0275property("ngIf", ctx_r1.getValidAutomations().length > 0);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.getValidAutomations().length === 0);
  }
}
__name(KanbanComponent_div_9_Template, "KanbanComponent_div_9_Template");
function KanbanComponent_div_10_ng_container_16_button_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r34 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 202);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_10_ng_container_16_button_6_Template_button_click_0_listener($event) {
      \u0275\u0275restoreView(_r34);
      const i_r35 = \u0275\u0275nextContext().index;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.movePhaseUp(i_r35, $event));
    }, "KanbanComponent_div_10_ng_container_16_button_6_Template_button_click_0_listener"));
    \u0275\u0275element(1, "i", 203);
    \u0275\u0275elementEnd();
  }
}
__name(KanbanComponent_div_10_ng_container_16_button_6_Template, "KanbanComponent_div_10_ng_container_16_button_6_Template");
function KanbanComponent_div_10_ng_container_16_button_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r36 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 204);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_10_ng_container_16_button_7_Template_button_click_0_listener($event) {
      \u0275\u0275restoreView(_r36);
      const i_r35 = \u0275\u0275nextContext().index;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.movePhaseDown(i_r35, $event));
    }, "KanbanComponent_div_10_ng_container_16_button_7_Template_button_click_0_listener"));
    \u0275\u0275element(1, "i", 205);
    \u0275\u0275elementEnd();
  }
}
__name(KanbanComponent_div_10_ng_container_16_button_7_Template, "KanbanComponent_div_10_ng_container_16_button_7_Template");
function KanbanComponent_div_10_ng_container_16_div_10_div_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r37 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 210)(1, "span", 211);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "button", 212);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_10_ng_container_16_div_10_div_4_Template_button_click_3_listener($event) {
      const e_r38 = \u0275\u0275restoreView(_r37).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(4);
      ctx_r1.removeEdge(e_r38);
      return \u0275\u0275resetView($event.stopPropagation());
    }, "KanbanComponent_div_10_ng_container_16_div_10_div_4_Template_button_click_3_listener"));
    \u0275\u0275element(4, "i", 213);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    let tmp_10_0;
    const e_r38 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(4);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate2("", ctx_r1.getEdgeArrow(e_r38), " ", ((tmp_10_0 = ctx_r1.getColumnById(e_r38.toId)) == null ? null : tmp_10_0.name) || e_r38.toId);
  }
}
__name(KanbanComponent_div_10_ng_container_16_div_10_div_4_Template, "KanbanComponent_div_10_ng_container_16_div_10_div_4_Template");
function KanbanComponent_div_10_ng_container_16_div_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 206)(1, "div", 207);
    \u0275\u0275text(2, "Conex\xF5es:");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "div", 208);
    \u0275\u0275template(4, KanbanComponent_div_10_ng_container_16_div_10_div_4_Template, 5, 2, "div", 209);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const phaseId_r33 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(4);
    \u0275\u0275property("ngForOf", ctx_r1.getOutgoingConnections(phaseId_r33));
  }
}
__name(KanbanComponent_div_10_ng_container_16_div_10_Template, "KanbanComponent_div_10_ng_container_16_div_10_Template");
function KanbanComponent_div_10_ng_container_16_ng_template_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 214);
    \u0275\u0275text(1, "Sem conex\xF5es para esta fase");
    \u0275\u0275elementEnd();
  }
}
__name(KanbanComponent_div_10_ng_container_16_ng_template_11_Template, "KanbanComponent_div_10_ng_container_16_ng_template_11_Template");
function KanbanComponent_div_10_ng_container_16_button_18_Template(rf, ctx) {
  if (rf & 1) {
    const _r39 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 215);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_10_ng_container_16_button_18_Template_button_click_0_listener($event) {
      \u0275\u0275restoreView(_r39);
      const phaseId_r33 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      ctx_r1.beginEdge(phaseId_r33);
      return \u0275\u0275resetView($event.stopPropagation());
    }, "KanbanComponent_div_10_ng_container_16_button_18_Template_button_click_0_listener"));
    \u0275\u0275element(1, "i", 216);
    \u0275\u0275elementEnd();
  }
}
__name(KanbanComponent_div_10_ng_container_16_button_18_Template, "KanbanComponent_div_10_ng_container_16_button_18_Template");
function KanbanComponent_div_10_ng_container_16_button_19_Template(rf, ctx) {
  if (rf & 1) {
    const _r40 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 217);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_10_ng_container_16_button_19_Template_button_click_0_listener($event) {
      \u0275\u0275restoreView(_r40);
      const phaseId_r33 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      ctx_r1.completeEdge(phaseId_r33);
      return \u0275\u0275resetView($event.stopPropagation());
    }, "KanbanComponent_div_10_ng_container_16_button_19_Template_button_click_0_listener"));
    \u0275\u0275element(1, "i", 218);
    \u0275\u0275elementEnd();
  }
}
__name(KanbanComponent_div_10_ng_container_16_button_19_Template, "KanbanComponent_div_10_ng_container_16_button_19_Template");
function KanbanComponent_div_10_ng_container_16_Template(rf, ctx) {
  if (rf & 1) {
    const _r32 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div", 187);
    \u0275\u0275listener("cdkDragStarted", /* @__PURE__ */ __name(function KanbanComponent_div_10_ng_container_16_Template_div_cdkDragStarted_1_listener() {
      const phaseId_r33 = \u0275\u0275restoreView(_r32).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDragStarted(phaseId_r33));
    }, "KanbanComponent_div_10_ng_container_16_Template_div_cdkDragStarted_1_listener"))("cdkDragEnded", /* @__PURE__ */ __name(function KanbanComponent_div_10_ng_container_16_Template_div_cdkDragEnded_1_listener() {
      const phaseId_r33 = \u0275\u0275restoreView(_r32).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDragEnded(phaseId_r33));
    }, "KanbanComponent_div_10_ng_container_16_Template_div_cdkDragEnded_1_listener"))("click", /* @__PURE__ */ __name(function KanbanComponent_div_10_ng_container_16_Template_div_click_1_listener($event) {
      const phaseId_r33 = \u0275\u0275restoreView(_r32).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onPhaseCardClick(phaseId_r33, $event));
    }, "KanbanComponent_div_10_ng_container_16_Template_div_click_1_listener"));
    \u0275\u0275elementStart(2, "div", 188)(3, "div", 189);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "div", 177);
    \u0275\u0275template(6, KanbanComponent_div_10_ng_container_16_button_6_Template, 2, 0, "button", 190)(7, KanbanComponent_div_10_ng_container_16_button_7_Template, 2, 0, "button", 191);
    \u0275\u0275element(8, "i", 192);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(9, "div", 193);
    \u0275\u0275template(10, KanbanComponent_div_10_ng_container_16_div_10_Template, 5, 1, "div", 194)(11, KanbanComponent_div_10_ng_container_16_ng_template_11_Template, 2, 0, "ng-template", null, 2, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementStart(13, "div", 195)(14, "button", 196);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_10_ng_container_16_Template_button_click_14_listener($event) {
      const phaseId_r33 = \u0275\u0275restoreView(_r32).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      ctx_r1.showColumnForm(ctx_r1.getColumnById(phaseId_r33));
      return \u0275\u0275resetView($event.stopPropagation());
    }, "KanbanComponent_div_10_ng_container_16_Template_button_click_14_listener"));
    \u0275\u0275element(15, "i", 197);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(16, "button", 198);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_10_ng_container_16_Template_button_click_16_listener($event) {
      const phaseId_r33 = \u0275\u0275restoreView(_r32).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      ctx_r1.openPhaseAutomations(phaseId_r33);
      return \u0275\u0275resetView($event.stopPropagation());
    }, "KanbanComponent_div_10_ng_container_16_Template_button_click_16_listener"));
    \u0275\u0275element(17, "i", 199);
    \u0275\u0275elementEnd();
    \u0275\u0275template(18, KanbanComponent_div_10_ng_container_16_button_18_Template, 2, 0, "button", 200)(19, KanbanComponent_div_10_ng_container_16_button_19_Template, 2, 0, "button", 201);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    let tmp_7_0;
    let tmp_9_0;
    const phaseId_r33 = ctx.$implicit;
    const i_r35 = ctx.index;
    const noConnections_r41 = \u0275\u0275reference(12);
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275styleProp("--phase-color", ((tmp_7_0 = ctx_r1.getColumnById(phaseId_r33)) == null ? null : tmp_7_0.color) || "#94a3b8");
    \u0275\u0275attribute("id", "phase-" + phaseId_r33);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate((tmp_9_0 = ctx_r1.getColumnById(phaseId_r33)) == null ? null : tmp_9_0.name);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", i_r35 > 0);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", i_r35 < ctx_r1.flowOrder.length - 1);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", ctx_r1.hasOutgoingConnections(phaseId_r33))("ngIfElse", noConnections_r41);
    \u0275\u0275advance(8);
    \u0275\u0275property("ngIf", !ctx_r1.pendingFromId);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.pendingFromId && ctx_r1.pendingFromId !== phaseId_r33);
  }
}
__name(KanbanComponent_div_10_ng_container_16_Template, "KanbanComponent_div_10_ng_container_16_Template");
function KanbanComponent_div_10_div_20_div_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r43 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 227)(1, "div", 23)(2, "div")(3, "div", 228);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "div", 109);
    \u0275\u0275text(6);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(7, "div", 177)(8, "label", 229)(9, "input", 230);
    \u0275\u0275listener("change", /* @__PURE__ */ __name(function KanbanComponent_div_10_div_20_div_7_Template_input_change_9_listener() {
      const a_r44 = \u0275\u0275restoreView(_r43).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.toggleAutomation(a_r44));
    }, "KanbanComponent_div_10_div_20_div_7_Template_input_change_9_listener"));
    \u0275\u0275elementEnd();
    \u0275\u0275text(10, " Ativa ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "button", 231);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_10_div_20_div_7_Template_button_click_11_listener() {
      const a_r44 = \u0275\u0275restoreView(_r43).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.editAutomation(a_r44));
    }, "KanbanComponent_div_10_div_20_div_7_Template_button_click_11_listener"));
    \u0275\u0275text(12, "Editar");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(13, "button", 232);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_10_div_20_div_7_Template_button_click_13_listener($event) {
      const a_r44 = \u0275\u0275restoreView(_r43).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.openDeleteAutomationConfirm(a_r44, $event));
    }, "KanbanComponent_div_10_div_20_div_7_Template_button_click_13_listener"));
    \u0275\u0275text(14, "Excluir");
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const a_r44 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(a_r44.name || "Automa\xE7\xE3o sem nome");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1("Trigger: ", ctx_r1.getTriggerDescription(a_r44));
    \u0275\u0275advance(3);
    \u0275\u0275property("checked", a_r44.active);
  }
}
__name(KanbanComponent_div_10_div_20_div_7_Template, "KanbanComponent_div_10_div_20_div_7_Template");
function KanbanComponent_div_10_div_20_Template(rf, ctx) {
  if (rf & 1) {
    const _r42 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 219)(1, "div", 220)(2, "div", 221);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "button", 222);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_10_div_20_Template_button_click_4_listener() {
      \u0275\u0275restoreView(_r42);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.closePhaseAutomations());
    }, "KanbanComponent_div_10_div_20_Template_button_click_4_listener"));
    \u0275\u0275element(5, "i", 48);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(6, "div", 61);
    \u0275\u0275template(7, KanbanComponent_div_10_div_20_div_7_Template, 15, 3, "div", 223);
    \u0275\u0275elementStart(8, "div", 224)(9, "button", 225);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_10_div_20_Template_button_click_9_listener() {
      \u0275\u0275restoreView(_r42);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.createAutomationForPhase(ctx_r1.selectedPhaseIdForAutomations));
    }, "KanbanComponent_div_10_div_20_Template_button_click_9_listener"));
    \u0275\u0275element(10, "i", 226);
    \u0275\u0275text(11, " Nova automa\xE7\xE3o nesta fase ");
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    let tmp_4_0;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1("Automa\xE7\xF5es da fase: ", (tmp_4_0 = ctx_r1.getColumnById(ctx_r1.selectedPhaseIdForAutomations)) == null ? null : tmp_4_0.name);
    \u0275\u0275advance(4);
    \u0275\u0275property("ngForOf", ctx_r1.getAutomationsForPhase(ctx_r1.selectedPhaseIdForAutomations));
  }
}
__name(KanbanComponent_div_10_div_20_Template, "KanbanComponent_div_10_div_20_Template");
function KanbanComponent_div_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r31 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 126)(1, "div", 176)(2, "div", 137)(3, "h2", 138);
    \u0275\u0275text(4, "Fluxo de Transi\xE7\xF5es");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "div", 177)(6, "button", 178);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_10_Template_button_click_6_listener() {
      \u0275\u0275restoreView(_r31);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.showCreateColumnModal());
    }, "KanbanComponent_div_10_Template_button_click_6_listener"));
    \u0275\u0275element(7, "i", 140);
    \u0275\u0275text(8, " Nova Fase ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "button", 139);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_10_Template_button_click_9_listener() {
      \u0275\u0275restoreView(_r31);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.saveFlowConfig());
    }, "KanbanComponent_div_10_Template_button_click_9_listener"));
    \u0275\u0275element(10, "i", 179);
    \u0275\u0275text(11, " Salvar Fluxo ");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(12, "div", 180)(13, "div", 181, 0)(15, "div", 182);
    \u0275\u0275listener("cdkDropListDropped", /* @__PURE__ */ __name(function KanbanComponent_div_10_Template_div_cdkDropListDropped_15_listener($event) {
      \u0275\u0275restoreView(_r31);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onFlowReorder($event));
    }, "KanbanComponent_div_10_Template_div_cdkDropListDropped_15_listener"))("cdkDropListEntered", /* @__PURE__ */ __name(function KanbanComponent_div_10_Template_div_cdkDropListEntered_15_listener() {
      \u0275\u0275restoreView(_r31);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onDragEntered());
    }, "KanbanComponent_div_10_Template_div_cdkDropListEntered_15_listener"))("cdkDropListExited", /* @__PURE__ */ __name(function KanbanComponent_div_10_Template_div_cdkDropListExited_15_listener() {
      \u0275\u0275restoreView(_r31);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onDragExited());
    }, "KanbanComponent_div_10_Template_div_cdkDropListExited_15_listener"));
    \u0275\u0275template(16, KanbanComponent_div_10_ng_container_16_Template, 20, 10, "ng-container", 183);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(17, "div", 184, 1);
    \u0275\u0275listener("mousedown", /* @__PURE__ */ __name(function KanbanComponent_div_10_Template_div_mousedown_17_listener($event) {
      \u0275\u0275restoreView(_r31);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onFlowBarPointerDown($event));
    }, "KanbanComponent_div_10_Template_div_mousedown_17_listener"))("touchstart", /* @__PURE__ */ __name(function KanbanComponent_div_10_Template_div_touchstart_17_listener($event) {
      \u0275\u0275restoreView(_r31);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onFlowBarTouchStart($event));
    }, "KanbanComponent_div_10_Template_div_touchstart_17_listener"));
    \u0275\u0275element(19, "div", 185);
    \u0275\u0275elementEnd()();
    \u0275\u0275template(20, KanbanComponent_div_10_div_20_Template, 12, 2, "div", 186);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(15);
    \u0275\u0275property("cdkDropListData", ctx_r1.flowOrder);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.flowOrder);
    \u0275\u0275advance(3);
    \u0275\u0275styleProp("width", ctx_r1.flowThumbPercent, "%")("left", ctx_r1.flowThumbLeftPercent, "%");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.selectedPhaseIdForAutomations);
  }
}
__name(KanbanComponent_div_10_Template, "KanbanComponent_div_10_Template");
function KanbanComponent_div_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r45 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 233);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_11_Template_div_click_0_listener() {
      \u0275\u0275restoreView(_r45);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.cancelDeleteAutomation());
    }, "KanbanComponent_div_11_Template_div_click_0_listener"));
    \u0275\u0275elementStart(1, "div", 234);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_11_Template_div_click_1_listener($event) {
      \u0275\u0275restoreView(_r45);
      return \u0275\u0275resetView($event.stopPropagation());
    }, "KanbanComponent_div_11_Template_div_click_1_listener"));
    \u0275\u0275elementStart(2, "h3", 235);
    \u0275\u0275text(3, "Excluir automa\xE7\xE3o");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "p", 236);
    \u0275\u0275text(5, "Tem certeza que deseja excluir a automa\xE7\xE3o ");
    \u0275\u0275elementStart(6, "strong");
    \u0275\u0275text(7);
    \u0275\u0275elementEnd();
    \u0275\u0275text(8, "? Esta a\xE7\xE3o n\xE3o pode ser desfeita.");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "div", 237)(10, "button", 238);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_11_Template_button_click_10_listener() {
      \u0275\u0275restoreView(_r45);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.cancelDeleteAutomation());
    }, "KanbanComponent_div_11_Template_button_click_10_listener"));
    \u0275\u0275text(11, "Cancelar");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(12, "button", 239);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_11_Template_button_click_12_listener() {
      \u0275\u0275restoreView(_r45);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.confirmDeleteAutomation());
    }, "KanbanComponent_div_11_Template_button_click_12_listener"));
    \u0275\u0275text(13, "Excluir");
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(7);
    \u0275\u0275textInterpolate((ctx_r1.automationPendingDelete == null ? null : ctx_r1.automationPendingDelete.name) || "sem nome");
  }
}
__name(KanbanComponent_div_11_Template, "KanbanComponent_div_11_Template");
function KanbanComponent_div_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275element(1, "app-reports", 240);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("boardId", ctx_r1.boardId)("ownerId", ctx_r1.ownerId);
  }
}
__name(KanbanComponent_div_12_Template, "KanbanComponent_div_12_Template");
function KanbanComponent_div_13_button_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r47 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 40);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_13_button_12_Template_button_click_0_listener() {
      const status_r48 = \u0275\u0275restoreView(_r47).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.activeEmailStatus = status_r48.id);
    }, "KanbanComponent_div_13_button_12_Template_button_click_0_listener"));
    \u0275\u0275text(1);
    \u0275\u0275elementStart(2, "span", 89);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const status_r48 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classProp("border-blue-500", ctx_r1.activeEmailStatus === status_r48.id)("text-blue-600", ctx_r1.activeEmailStatus === status_r48.id)("border-transparent", ctx_r1.activeEmailStatus !== status_r48.id)("text-gray-500", ctx_r1.activeEmailStatus !== status_r48.id);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", status_r48.name, " ");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", status_r48.count, " ");
  }
}
__name(KanbanComponent_div_13_button_12_Template, "KanbanComponent_div_13_button_12_Template");
function KanbanComponent_div_13_div_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 159);
    \u0275\u0275element(1, "i", 250);
    \u0275\u0275elementStart(2, "h3", 161);
    \u0275\u0275text(3, "Nenhum email encontrado");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "p");
    \u0275\u0275text(5, "Emails enviados aparecer\xE3o aqui");
    \u0275\u0275elementEnd()();
  }
}
__name(KanbanComponent_div_13_div_14_Template, "KanbanComponent_div_13_div_14_Template");
function KanbanComponent_div_13_div_15_div_1_button_19_Template(rf, ctx) {
  if (rf & 1) {
    const _r51 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 264);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_13_div_15_div_1_button_19_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r51);
      const email_r50 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.retryEmail(email_r50));
    }, "KanbanComponent_div_13_div_15_div_1_button_19_Template_button_click_0_listener"));
    \u0275\u0275element(1, "i", 265);
    \u0275\u0275elementEnd();
  }
}
__name(KanbanComponent_div_13_div_15_div_1_button_19_Template, "KanbanComponent_div_13_div_15_div_1_button_19_Template");
function KanbanComponent_div_13_div_15_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r49 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 252)(1, "div", 86)(2, "div", 147)(3, "div", 25);
    \u0275\u0275element(4, "div", 253);
    \u0275\u0275elementStart(5, "h4", 254);
    \u0275\u0275text(6);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "span", 255);
    \u0275\u0275text(8);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(9, "div", 256)(10, "span");
    \u0275\u0275element(11, "i", 257);
    \u0275\u0275text(12);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(13, "span");
    \u0275\u0275element(14, "i", 258);
    \u0275\u0275text(15);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(16, "div", 76)(17, "button", 259);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_13_div_15_div_1_Template_button_click_17_listener() {
      const email_r50 = \u0275\u0275restoreView(_r49).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.viewEmail(email_r50));
    }, "KanbanComponent_div_13_div_15_div_1_Template_button_click_17_listener"));
    \u0275\u0275element(18, "i", 260);
    \u0275\u0275elementEnd();
    \u0275\u0275template(19, KanbanComponent_div_13_div_15_div_1_button_19_Template, 2, 0, "button", 261);
    \u0275\u0275elementStart(20, "button", 262);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_13_div_15_div_1_Template_button_click_20_listener($event) {
      const email_r50 = \u0275\u0275restoreView(_r49).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.openOutboxDeleteConfirm(email_r50, $event));
    }, "KanbanComponent_div_13_div_15_div_1_Template_button_click_20_listener"));
    \u0275\u0275element(21, "i", 263);
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const email_r50 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(4);
    \u0275\u0275classProp("bg-yellow-400", !email_r50.delivery || email_r50.delivery.state === "PENDING")("bg-green-400", (email_r50.delivery == null ? null : email_r50.delivery.state) === "SUCCESS")("bg-red-400", (email_r50.delivery == null ? null : email_r50.delivery.state) === "ERROR");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(email_r50.subject || "Sem assunto");
    \u0275\u0275advance();
    \u0275\u0275classProp("bg-yellow-100", !email_r50.delivery || email_r50.delivery.state === "PENDING")("text-yellow-800", !email_r50.delivery || email_r50.delivery.state === "PENDING")("bg-green-100", (email_r50.delivery == null ? null : email_r50.delivery.state) === "SUCCESS")("text-green-800", (email_r50.delivery == null ? null : email_r50.delivery.state) === "SUCCESS")("bg-red-100", (email_r50.delivery == null ? null : email_r50.delivery.state) === "ERROR")("text-red-800", (email_r50.delivery == null ? null : email_r50.delivery.state) === "ERROR");
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.getEmailStatusLabel(email_r50), " ");
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1("Para: ", email_r50.to);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx_r1.formatDateTime(ctx_r1.getEmailDisplayDate(email_r50)));
    \u0275\u0275advance(4);
    \u0275\u0275property("ngIf", (email_r50.delivery == null ? null : email_r50.delivery.state) === "ERROR" || !email_r50.delivery);
  }
}
__name(KanbanComponent_div_13_div_15_div_1_Template, "KanbanComponent_div_13_div_15_div_1_Template");
function KanbanComponent_div_13_div_15_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 58);
    \u0275\u0275template(1, KanbanComponent_div_13_div_15_div_1_Template, 22, 23, "div", 251);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.getFilteredEmails());
  }
}
__name(KanbanComponent_div_13_div_15_Template, "KanbanComponent_div_13_div_15_Template");
function KanbanComponent_div_13_Template(rf, ctx) {
  if (rf & 1) {
    const _r46 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 126)(1, "div", 241)(2, "div", 137)(3, "h2", 138);
    \u0275\u0275text(4, "Caixa de Sa\xEDda");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "div", 242)(6, "button", 243);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_13_Template_button_click_6_listener() {
      \u0275\u0275restoreView(_r46);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.clearOutbox());
    }, "KanbanComponent_div_13_Template_button_click_6_listener"));
    \u0275\u0275element(7, "i", 244);
    \u0275\u0275text(8, " Limpar ");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(9, "div", 245)(10, "div", 246)(11, "nav", 247);
    \u0275\u0275template(12, KanbanComponent_div_13_button_12_Template, 4, 10, "button", 248);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(13, "div", 44);
    \u0275\u0275template(14, KanbanComponent_div_13_div_14_Template, 6, 0, "div", 249)(15, KanbanComponent_div_13_div_15_Template, 2, 1, "div", 53);
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(12);
    \u0275\u0275property("ngForOf", ctx_r1.emailStatuses);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r1.getFilteredEmails().length === 0);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.getFilteredEmails().length > 0);
  }
}
__name(KanbanComponent_div_13_Template, "KanbanComponent_div_13_Template");
function KanbanComponent_div_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r52 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 233);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_14_Template_div_click_0_listener() {
      \u0275\u0275restoreView(_r52);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.cancelOutboxDelete());
    }, "KanbanComponent_div_14_Template_div_click_0_listener"));
    \u0275\u0275elementStart(1, "div", 234);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_14_Template_div_click_1_listener($event) {
      \u0275\u0275restoreView(_r52);
      return \u0275\u0275resetView($event.stopPropagation());
    }, "KanbanComponent_div_14_Template_div_click_1_listener"));
    \u0275\u0275elementStart(2, "h3", 235);
    \u0275\u0275text(3, "Excluir mensagem");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "p", 236);
    \u0275\u0275text(5, "Tem certeza que deseja excluir esta mensagem da Caixa de Sa\xEDda? Esta a\xE7\xE3o n\xE3o pode ser desfeita.");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "div", 237)(7, "button", 238);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_14_Template_button_click_7_listener() {
      \u0275\u0275restoreView(_r52);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.cancelOutboxDelete());
    }, "KanbanComponent_div_14_Template_button_click_7_listener"));
    \u0275\u0275text(8, "Cancelar");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "button", 239);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_14_Template_button_click_9_listener() {
      \u0275\u0275restoreView(_r52);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.confirmOutboxDelete());
    }, "KanbanComponent_div_14_Template_button_click_9_listener"));
    \u0275\u0275text(10, "Excluir");
    \u0275\u0275elementEnd()()()();
  }
}
__name(KanbanComponent_div_14_Template, "KanbanComponent_div_14_Template");
function KanbanComponent_div_15_Template(rf, ctx) {
  if (rf & 1) {
    const _r53 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 126)(1, "div", 127)(2, "div", 137)(3, "h2", 138);
    \u0275\u0275text(4, "Configura\xE7\xE3o da API");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "div", 76)(6, "span", 167);
    \u0275\u0275text(7, "Status:");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "span", 266);
    \u0275\u0275element(9, "i", 267);
    \u0275\u0275text(10, "Ativa ");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(11, "div", 268)(12, "div", 269)(13, "h3", 148);
    \u0275\u0275element(14, "i", 270);
    \u0275\u0275text(15, "Endpoint para Novos Leads ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(16, "p", 271);
    \u0275\u0275text(17, " Use este endpoint para enviar novos leads diretamente para o seu kanban via API REST. ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(18, "div", 272)(19, "div", 273)(20, "span", 274);
    \u0275\u0275text(21, "URL do Endpoint:");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(22, "button", 275);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_15_Template_button_click_22_listener() {
      \u0275\u0275restoreView(_r53);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.copyToClipboard(ctx_r1.apiEndpoint));
    }, "KanbanComponent_div_15_Template_button_click_22_listener"));
    \u0275\u0275element(23, "i", 276);
    \u0275\u0275text(24, "Copiar ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(25, "code", 277);
    \u0275\u0275text(26);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(27, "div", 269)(28, "h4", 278);
    \u0275\u0275element(29, "i", 279);
    \u0275\u0275text(30, "Token de Autentica\xE7\xE3o ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(31, "p", 149);
    \u0275\u0275text(32, " Inclua este token no header ");
    \u0275\u0275elementStart(33, "code", 280);
    \u0275\u0275text(34, "Authorization");
    \u0275\u0275elementEnd();
    \u0275\u0275text(35, " de suas requisi\xE7\xF5es. ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(36, "div", 272)(37, "div", 273)(38, "span", 274);
    \u0275\u0275text(39, "Bearer Token:");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(40, "button", 275);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_15_Template_button_click_40_listener() {
      \u0275\u0275restoreView(_r53);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.copyToClipboard(ctx_r1.apiToken));
    }, "KanbanComponent_div_15_Template_button_click_40_listener"));
    \u0275\u0275element(41, "i", 276);
    \u0275\u0275text(42, "Copiar ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(43, "code", 281);
    \u0275\u0275text(44);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(45, "div", 44)(46, "h4", 278);
    \u0275\u0275element(47, "i", 282);
    \u0275\u0275text(48, "Exemplo de Requisi\xE7\xE3o ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(49, "p", 149);
    \u0275\u0275text(50, " Exemplo de como enviar um novo lead via POST request: ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(51, "div", 283)(52, "pre", 123)(53, "code");
    \u0275\u0275text(54);
    \u0275\u0275elementEnd()()()()();
    \u0275\u0275elementStart(55, "div", 268)(56, "div", 269)(57, "h3", 148);
    \u0275\u0275element(58, "i", 284);
    \u0275\u0275text(59, "Webhooks (Em breve) ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(60, "p", 167);
    \u0275\u0275text(61, " Receba notifica\xE7\xF5es quando leads mudarem de fase, forem criados ou atualizados. ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(62, "div", 44)(63, "div", 285);
    \u0275\u0275element(64, "i", 286);
    \u0275\u0275elementStart(65, "h4", 287);
    \u0275\u0275text(66, "Funcionalidade em Desenvolvimento");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(67, "p", 123);
    \u0275\u0275text(68, "Webhooks estar\xE3o dispon\xEDveis em breve para integra\xE7\xE3o avan\xE7ada.");
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(69, "div", 288)(70, "h3", 289);
    \u0275\u0275element(71, "i", 290);
    \u0275\u0275text(72, "Documenta\xE7\xE3o da API ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(73, "div", 291)(74, "div", 292);
    \u0275\u0275element(75, "i", 293);
    \u0275\u0275elementStart(76, "div")(77, "strong");
    \u0275\u0275text(78, "M\xE9todo:");
    \u0275\u0275elementEnd();
    \u0275\u0275text(79, " POST para criar novos leads ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(80, "div", 292);
    \u0275\u0275element(81, "i", 293);
    \u0275\u0275elementStart(82, "div")(83, "strong");
    \u0275\u0275text(84, "Content-Type:");
    \u0275\u0275elementEnd();
    \u0275\u0275text(85, " application/json obrigat\xF3rio ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(86, "div", 292);
    \u0275\u0275element(87, "i", 293);
    \u0275\u0275elementStart(88, "div")(89, "strong");
    \u0275\u0275text(90, "Autentica\xE7\xE3o:");
    \u0275\u0275elementEnd();
    \u0275\u0275text(91, " Bearer token no header Authorization ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(92, "div", 292);
    \u0275\u0275element(93, "i", 293);
    \u0275\u0275elementStart(94, "div")(95, "strong");
    \u0275\u0275text(96, "Campos obrigat\xF3rios:");
    \u0275\u0275elementEnd();
    \u0275\u0275text(97, " companyName, contactName, contactEmail ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(98, "div", 292);
    \u0275\u0275element(99, "i", 293);
    \u0275\u0275elementStart(100, "div")(101, "strong");
    \u0275\u0275text(102, "Resposta de sucesso:");
    \u0275\u0275elementEnd();
    \u0275\u0275text(103, " Status 201 com dados do lead criado ");
    \u0275\u0275elementEnd()()()()()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(26);
    \u0275\u0275textInterpolate1(" ", ctx_r1.apiEndpoint, " ");
    \u0275\u0275advance(18);
    \u0275\u0275textInterpolate1(" ", ctx_r1.apiToken, " ");
    \u0275\u0275advance(10);
    \u0275\u0275textInterpolate3("POST ", ctx_r1.apiEndpoint, "\nContent-Type: application/json\nAuthorization: Bearer ", ctx_r1.apiToken, "\n\n", ctx_r1.apiExampleJson);
  }
}
__name(KanbanComponent_div_15_Template, "KanbanComponent_div_15_Template");
function KanbanComponent_div_16_span_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 314);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", (ctx_r1.filterOnlyMine ? 1 : 0) + ctx_r1.getActiveDynamicFiltersCount(), " ");
  }
}
__name(KanbanComponent_div_16_span_9_Template, "KanbanComponent_div_16_span_9_Template");
function KanbanComponent_div_16_button_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r55 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 315);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_16_button_10_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r55);
      const ctx_r1 = \u0275\u0275nextContext(2);
      ctx_r1.filterQuery = "";
      return \u0275\u0275resetView(ctx_r1.applyFilters());
    }, "KanbanComponent_div_16_button_10_Template_button_click_0_listener"));
    \u0275\u0275element(1, "i", 316);
    \u0275\u0275elementEnd();
  }
}
__name(KanbanComponent_div_16_button_10_Template, "KanbanComponent_div_16_button_10_Template");
function KanbanComponent_div_16_button_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r56 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 317);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_16_button_11_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r56);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.clearFilters());
    }, "KanbanComponent_div_16_button_11_Template_button_click_0_listener"));
    \u0275\u0275element(1, "i", 48);
    \u0275\u0275text(2, " Limpar ");
    \u0275\u0275elementEnd();
  }
}
__name(KanbanComponent_div_16_button_11_Template, "KanbanComponent_div_16_button_11_Template");
function KanbanComponent_div_16_div_12_div_8_input_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r58 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "input", 333);
    \u0275\u0275listener("input", /* @__PURE__ */ __name(function KanbanComponent_div_16_div_12_div_8_input_3_Template_input_input_0_listener($event) {
      \u0275\u0275restoreView(_r58);
      const field_r59 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.setDynamicFilter(field_r59.name, $event.target.value));
    }, "KanbanComponent_div_16_div_12_div_8_input_3_Template_input_input_0_listener"));
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const field_r59 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("placeholder", "Filtrar por " + field_r59.label.toLowerCase())("value", ctx_r1.getDynamicFilterValue(field_r59.name));
  }
}
__name(KanbanComponent_div_16_div_12_div_8_input_3_Template, "KanbanComponent_div_16_div_12_div_8_input_3_Template");
function KanbanComponent_div_16_div_12_div_8_input_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r60 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "input", 334);
    \u0275\u0275listener("input", /* @__PURE__ */ __name(function KanbanComponent_div_16_div_12_div_8_input_4_Template_input_input_0_listener($event) {
      \u0275\u0275restoreView(_r60);
      const field_r59 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.setDynamicFilter(field_r59.name, $event.target.value));
    }, "KanbanComponent_div_16_div_12_div_8_input_4_Template_input_input_0_listener"));
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const field_r59 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("placeholder", "Filtrar por " + field_r59.label.toLowerCase())("value", ctx_r1.getDynamicFilterValue(field_r59.name));
  }
}
__name(KanbanComponent_div_16_div_12_div_8_input_4_Template, "KanbanComponent_div_16_div_12_div_8_input_4_Template");
function KanbanComponent_div_16_div_12_div_8_input_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r61 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "input", 335);
    \u0275\u0275listener("change", /* @__PURE__ */ __name(function KanbanComponent_div_16_div_12_div_8_input_5_Template_input_change_0_listener($event) {
      \u0275\u0275restoreView(_r61);
      const field_r59 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.setDynamicFilter(field_r59.name, $event.target.value));
    }, "KanbanComponent_div_16_div_12_div_8_input_5_Template_input_change_0_listener"));
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const field_r59 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("value", ctx_r1.getDynamicFilterValue(field_r59.name));
  }
}
__name(KanbanComponent_div_16_div_12_div_8_input_5_Template, "KanbanComponent_div_16_div_12_div_8_input_5_Template");
function KanbanComponent_div_16_div_12_div_8_label_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r62 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "label", 336)(1, "input", 337);
    \u0275\u0275listener("change", /* @__PURE__ */ __name(function KanbanComponent_div_16_div_12_div_8_label_6_Template_input_change_1_listener($event) {
      \u0275\u0275restoreView(_r62);
      const field_r59 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.setDynamicFilter(field_r59.name, $event.target.checked));
    }, "KanbanComponent_div_16_div_12_div_8_label_6_Template_input_change_1_listener"));
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "span", 167);
    \u0275\u0275text(3, "Apenas marcados");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const field_r59 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275property("checked", ctx_r1.getDynamicFilterValue(field_r59.name));
  }
}
__name(KanbanComponent_div_16_div_12_div_8_label_6_Template, "KanbanComponent_div_16_div_12_div_8_label_6_Template");
function KanbanComponent_div_16_div_12_div_8_select_7_option_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "option", 72);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const option_r64 = ctx.$implicit;
    \u0275\u0275property("value", option_r64);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", option_r64, " ");
  }
}
__name(KanbanComponent_div_16_div_12_div_8_select_7_option_3_Template, "KanbanComponent_div_16_div_12_div_8_select_7_option_3_Template");
function KanbanComponent_div_16_div_12_div_8_select_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r63 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "select", 338);
    \u0275\u0275listener("change", /* @__PURE__ */ __name(function KanbanComponent_div_16_div_12_div_8_select_7_Template_select_change_0_listener($event) {
      \u0275\u0275restoreView(_r63);
      const field_r59 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.onDynamicFilterChange(field_r59.name, $event));
    }, "KanbanComponent_div_16_div_12_div_8_select_7_Template_select_change_0_listener"));
    \u0275\u0275elementStart(1, "option", 70);
    \u0275\u0275text(2, "Todos");
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, KanbanComponent_div_16_div_12_div_8_select_7_option_3_Template, 2, 2, "option", 71);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const field_r59 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("value", ctx_r1.getDynamicFilterValue(field_r59.name));
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", ctx_r1.getFieldOptions(field_r59));
  }
}
__name(KanbanComponent_div_16_div_12_div_8_select_7_Template, "KanbanComponent_div_16_div_12_div_8_select_7_Template");
function KanbanComponent_div_16_div_12_div_8_button_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r65 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 339);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_16_div_12_div_8_button_8_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r65);
      const field_r59 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.removeDynamicFilter(field_r59.name));
    }, "KanbanComponent_div_16_div_12_div_8_button_8_Template_button_click_0_listener"));
    \u0275\u0275element(1, "i", 316);
    \u0275\u0275elementEnd();
  }
}
__name(KanbanComponent_div_16_div_12_div_8_button_8_Template, "KanbanComponent_div_16_div_12_div_8_button_8_Template");
function KanbanComponent_div_16_div_12_div_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 325)(1, "label", 326);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, KanbanComponent_div_16_div_12_div_8_input_3_Template, 1, 2, "input", 327)(4, KanbanComponent_div_16_div_12_div_8_input_4_Template, 1, 2, "input", 328)(5, KanbanComponent_div_16_div_12_div_8_input_5_Template, 1, 1, "input", 329)(6, KanbanComponent_div_16_div_12_div_8_label_6_Template, 4, 1, "label", 330)(7, KanbanComponent_div_16_div_12_div_8_select_7_Template, 4, 2, "select", 331)(8, KanbanComponent_div_16_div_12_div_8_button_8_Template, 2, 0, "button", 332);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const field_r59 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", field_r59.label, " ");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r59.type === "text" || field_r59.type === "email" || field_r59.type === "tel");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r59.type === "number");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r59.type === "date");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r59.type === "checkbox");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", field_r59.type === "select" || field_r59.type === "radio" || field_r59.type === "temperatura");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.getDynamicFilterValue(field_r59.name));
  }
}
__name(KanbanComponent_div_16_div_12_div_8_Template, "KanbanComponent_div_16_div_12_div_8_Template");
function KanbanComponent_div_16_div_12_div_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 340);
    \u0275\u0275element(1, "i", 341);
    \u0275\u0275elementStart(2, "span");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1("", ctx_r1.getActiveDynamicFiltersCount(), " filtro(s) ativo(s) por campos");
  }
}
__name(KanbanComponent_div_16_div_12_div_9_Template, "KanbanComponent_div_16_div_12_div_9_Template");
function KanbanComponent_div_16_div_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r57 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 318)(1, "div", 86)(2, "h4", 319);
    \u0275\u0275element(3, "i", 320);
    \u0275\u0275text(4, " Filtros por Campos ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "button", 321);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_16_div_12_Template_button_click_5_listener() {
      \u0275\u0275restoreView(_r57);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.showAdvancedFilters = false);
    }, "KanbanComponent_div_16_div_12_Template_button_click_5_listener"));
    \u0275\u0275element(6, "i", 48);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(7, "div", 322);
    \u0275\u0275template(8, KanbanComponent_div_16_div_12_div_8_Template, 9, 7, "div", 323);
    \u0275\u0275elementEnd();
    \u0275\u0275template(9, KanbanComponent_div_16_div_12_div_9_Template, 4, 1, "div", 324);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(8);
    \u0275\u0275property("ngForOf", ctx_r1.availableFilterFields);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.getActiveDynamicFiltersCount() > 0);
  }
}
__name(KanbanComponent_div_16_div_12_Template, "KanbanComponent_div_16_div_12_Template");
function KanbanComponent_div_16_div_13_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 342);
    \u0275\u0275element(1, "i", 343);
    \u0275\u0275elementStart(2, "span");
    \u0275\u0275text(3, "Filtros ativos");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "span", 344);
    \u0275\u0275text(5);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate1(" ", (ctx_r1.filterQuery ? 1 : 0) + (ctx_r1.filterOnlyMine ? 1 : 0) + ctx_r1.getActiveDynamicFiltersCount(), " ");
  }
}
__name(KanbanComponent_div_16_div_13_Template, "KanbanComponent_div_16_div_13_Template");
function KanbanComponent_div_16_div_15_div_10_div_2_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 365);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const lead_r68 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(4);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.getLeadResponsibleName(lead_r68), " ");
  }
}
__name(KanbanComponent_div_16_div_15_div_10_div_2_div_3_Template, "KanbanComponent_div_16_div_15_div_10_div_2_div_3_Template");
function KanbanComponent_div_16_div_15_div_10_div_2_div_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 78)(1, "span", 366);
    \u0275\u0275text(2, "NOME DO CONTATO");
    \u0275\u0275elementEnd();
    \u0275\u0275element(3, "br");
    \u0275\u0275text(4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const lead_r68 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", lead_r68.fields["contactName"], " ");
  }
}
__name(KanbanComponent_div_16_div_15_div_10_div_2_div_4_Template, "KanbanComponent_div_16_div_15_div_10_div_2_div_4_Template");
function KanbanComponent_div_16_div_15_div_10_div_2_div_15_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 360);
    \u0275\u0275element(1, "i", 367);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const lead_r68 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(4);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", ctx_r1.getLeadDueDateLabel(lead_r68));
  }
}
__name(KanbanComponent_div_16_div_15_div_10_div_2_div_15_Template, "KanbanComponent_div_16_div_15_div_10_div_2_div_15_Template");
function KanbanComponent_div_16_div_15_div_10_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 355)(1, "div", 356);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, KanbanComponent_div_16_div_15_div_10_div_2_div_3_Template, 2, 1, "div", 357)(4, KanbanComponent_div_16_div_15_div_10_div_2_div_4_Template, 5, 1, "div", 358);
    \u0275\u0275elementStart(5, "div", 359)(6, "div", 360);
    \u0275\u0275element(7, "i", 361);
    \u0275\u0275text(8, " 1");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "div", 360);
    \u0275\u0275element(10, "i", 362);
    \u0275\u0275text(11);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(12, "div", 360);
    \u0275\u0275element(13, "i", 363);
    \u0275\u0275text(14);
    \u0275\u0275elementEnd();
    \u0275\u0275template(15, KanbanComponent_div_16_div_15_div_10_div_2_div_15_Template, 3, 1, "div", 364);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const lead_r68 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(4);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(lead_r68.fields["companyName"] || "Sem t\xEDtulo");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.getLeadResponsibleName(lead_r68));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", lead_r68.fields == null ? null : lead_r68.fields["contactName"]);
    \u0275\u0275advance(7);
    \u0275\u0275textInterpolate1(" ", ctx_r1.getDaysSince(lead_r68.createdAt), "d");
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", ctx_r1.getDaysSince(lead_r68.movedToCurrentColumnAt), "d");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.getLeadDueDateLabel(lead_r68));
  }
}
__name(KanbanComponent_div_16_div_15_div_10_div_2_Template, "KanbanComponent_div_16_div_15_div_10_div_2_Template");
function KanbanComponent_div_16_div_15_div_10_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 368);
    \u0275\u0275text(1, "Nenhum registro nesta fase");
    \u0275\u0275elementEnd();
  }
}
__name(KanbanComponent_div_16_div_15_div_10_div_3_Template, "KanbanComponent_div_16_div_15_div_10_div_3_Template");
function KanbanComponent_div_16_div_15_div_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 351)(1, "div", 352);
    \u0275\u0275template(2, KanbanComponent_div_16_div_15_div_10_div_2_Template, 16, 6, "div", 353)(3, KanbanComponent_div_16_div_15_div_10_div_3_Template, 2, 0, "div", 354);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const column_r67 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx_r1.getLeadsForColumn(column_r67.id));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.getLeadsForColumn(column_r67.id).length === 0);
  }
}
__name(KanbanComponent_div_16_div_15_div_10_Template, "KanbanComponent_div_16_div_15_div_10_Template");
function KanbanComponent_div_16_div_15_Template(rf, ctx) {
  if (rf & 1) {
    const _r66 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 345)(1, "button", 346);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_16_div_15_Template_button_click_1_listener() {
      const column_r67 = \u0275\u0275restoreView(_r66).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.toggleMobileColumn(column_r67.id));
    }, "KanbanComponent_div_16_div_15_Template_button_click_1_listener"));
    \u0275\u0275elementStart(2, "div", 325);
    \u0275\u0275element(3, "span", 347);
    \u0275\u0275elementStart(4, "div", 88);
    \u0275\u0275text(5);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(6, "div", 177)(7, "span", 348);
    \u0275\u0275text(8);
    \u0275\u0275elementEnd();
    \u0275\u0275element(9, "i", 349);
    \u0275\u0275elementEnd()();
    \u0275\u0275template(10, KanbanComponent_div_16_div_15_div_10_Template, 4, 2, "div", 350);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const column_r67 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(3);
    \u0275\u0275styleProp("background-color", column_r67.color || "#22c55e");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(column_r67.name);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx_r1.getLeadsForColumn(column_r67.id).length);
    \u0275\u0275advance();
    \u0275\u0275classProp("fa-chevron-down", !ctx_r1.isMobileColumnOpen(column_r67.id))("fa-chevron-up", ctx_r1.isMobileColumnOpen(column_r67.id));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.isMobileColumnOpen(column_r67.id));
  }
}
__name(KanbanComponent_div_16_div_15_Template, "KanbanComponent_div_16_div_15_Template");
function KanbanComponent_div_16_div_17_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 365);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const lead_r69 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.getLeadResponsibleName(lead_r69), " ");
  }
}
__name(KanbanComponent_div_16_div_17_div_3_Template, "KanbanComponent_div_16_div_17_div_3_Template");
function KanbanComponent_div_16_div_17_div_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 78)(1, "span", 366);
    \u0275\u0275text(2, "NOME DO CONTATO");
    \u0275\u0275elementEnd();
    \u0275\u0275element(3, "br");
    \u0275\u0275text(4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const lead_r69 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", lead_r69.fields["contactName"], " ");
  }
}
__name(KanbanComponent_div_16_div_17_div_4_Template, "KanbanComponent_div_16_div_17_div_4_Template");
function KanbanComponent_div_16_div_17_div_15_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 360);
    \u0275\u0275element(1, "i", 367);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const lead_r69 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", ctx_r1.getLeadDueDateLabel(lead_r69));
  }
}
__name(KanbanComponent_div_16_div_17_div_15_Template, "KanbanComponent_div_16_div_17_div_15_Template");
function KanbanComponent_div_16_div_17_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 369)(1, "div", 356);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, KanbanComponent_div_16_div_17_div_3_Template, 2, 1, "div", 357)(4, KanbanComponent_div_16_div_17_div_4_Template, 5, 1, "div", 358);
    \u0275\u0275elementStart(5, "div", 359)(6, "div", 360);
    \u0275\u0275element(7, "i", 361);
    \u0275\u0275text(8, " 1");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "div", 360);
    \u0275\u0275element(10, "i", 362);
    \u0275\u0275text(11);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(12, "div", 360);
    \u0275\u0275element(13, "i", 363);
    \u0275\u0275text(14);
    \u0275\u0275elementEnd();
    \u0275\u0275template(15, KanbanComponent_div_16_div_17_div_15_Template, 3, 1, "div", 364);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const lead_r69 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(lead_r69.fields["companyName"] || "Sem t\xEDtulo");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.getLeadResponsibleName(lead_r69));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", lead_r69.fields == null ? null : lead_r69.fields["contactName"]);
    \u0275\u0275advance(7);
    \u0275\u0275textInterpolate1(" ", ctx_r1.getDaysSince(lead_r69.createdAt), "d");
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", ctx_r1.getDaysSince(lead_r69.movedToCurrentColumnAt), "d");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.getLeadDueDateLabel(lead_r69));
  }
}
__name(KanbanComponent_div_16_div_17_Template, "KanbanComponent_div_16_div_17_Template");
function KanbanComponent_div_16_Template(rf, ctx) {
  if (rf & 1) {
    const _r54 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 294)(1, "div", 295)(2, "div", 33)(3, "div", 296)(4, "div", 297)(5, "input", 298);
    \u0275\u0275twoWayListener("ngModelChange", /* @__PURE__ */ __name(function KanbanComponent_div_16_Template_input_ngModelChange_5_listener($event) {
      \u0275\u0275restoreView(_r54);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.filterQuery, $event) || (ctx_r1.filterQuery = $event);
      return \u0275\u0275resetView($event);
    }, "KanbanComponent_div_16_Template_input_ngModelChange_5_listener"));
    \u0275\u0275listener("input", /* @__PURE__ */ __name(function KanbanComponent_div_16_Template_input_input_5_listener() {
      \u0275\u0275restoreView(_r54);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.applyFilters());
    }, "KanbanComponent_div_16_Template_input_input_5_listener"));
    \u0275\u0275elementEnd();
    \u0275\u0275element(6, "i", 299);
    \u0275\u0275elementStart(7, "button", 300);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_16_Template_button_click_7_listener() {
      \u0275\u0275restoreView(_r54);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.showAdvancedFilters = !ctx_r1.showAdvancedFilters);
    }, "KanbanComponent_div_16_Template_button_click_7_listener"));
    \u0275\u0275element(8, "i", 301);
    \u0275\u0275template(9, KanbanComponent_div_16_span_9_Template, 2, 1, "span", 302);
    \u0275\u0275elementEnd();
    \u0275\u0275template(10, KanbanComponent_div_16_button_10_Template, 2, 0, "button", 303);
    \u0275\u0275elementEnd();
    \u0275\u0275template(11, KanbanComponent_div_16_button_11_Template, 3, 0, "button", 304);
    \u0275\u0275elementEnd();
    \u0275\u0275template(12, KanbanComponent_div_16_div_12_Template, 10, 2, "div", 305)(13, KanbanComponent_div_16_div_13_Template, 6, 1, "div", 306);
    \u0275\u0275elementStart(14, "div", 61);
    \u0275\u0275template(15, KanbanComponent_div_16_div_15_Template, 11, 9, "div", 307);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(16, "div", 308);
    \u0275\u0275template(17, KanbanComponent_div_16_div_17_Template, 16, 6, "div", 309);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(18, "div", 310)(19, "button", 311);
    \u0275\u0275listener("click", /* @__PURE__ */ __name(function KanbanComponent_div_16_Template_button_click_19_listener() {
      \u0275\u0275restoreView(_r54);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.showCreateLeadModal());
    }, "KanbanComponent_div_16_Template_button_click_19_listener"));
    \u0275\u0275elementStart(20, "span", 312);
    \u0275\u0275element(21, "i", 313);
    \u0275\u0275elementEnd();
    \u0275\u0275text(22, " Novo lead ");
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(5);
    \u0275\u0275classProp("border-blue-300", ctx_r1.filterQuery)("bg-white", ctx_r1.filterQuery);
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.filterQuery);
    \u0275\u0275advance(2);
    \u0275\u0275classProp("bg-blue-50", ctx_r1.hasActiveFilters() || ctx_r1.showAdvancedFilters)("text-blue-600", ctx_r1.hasActiveFilters() || ctx_r1.showAdvancedFilters)("text-gray-400", !ctx_r1.hasActiveFilters() && !ctx_r1.showAdvancedFilters);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r1.getActiveDynamicFiltersCount() > 0 || ctx_r1.filterOnlyMine);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.filterQuery);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.hasActiveFilters());
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.showAdvancedFilters && ctx_r1.availableFilterFields.length > 0);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.hasActiveFilters());
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx_r1.columns);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx_r1.leads);
  }
}
__name(KanbanComponent_div_16_Template, "KanbanComponent_div_16_Template");
function KanbanComponent_app_automation_modal_22_Template(rf, ctx) {
  if (rf & 1) {
    const _r70 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "app-automation-modal", 370);
    \u0275\u0275listener("closeModalEvent", /* @__PURE__ */ __name(function KanbanComponent_app_automation_modal_22_Template_app_automation_modal_closeModalEvent_0_listener() {
      \u0275\u0275restoreView(_r70);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onCloseAutomationModal());
    }, "KanbanComponent_app_automation_modal_22_Template_app_automation_modal_closeModalEvent_0_listener"))("saveAutomation", /* @__PURE__ */ __name(function KanbanComponent_app_automation_modal_22_Template_app_automation_modal_saveAutomation_0_listener($event) {
      \u0275\u0275restoreView(_r70);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onSaveAutomation($event));
    }, "KanbanComponent_app_automation_modal_22_Template_app_automation_modal_saveAutomation_0_listener"));
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("isVisible", ctx_r1.showAutomationModal)("automation", ctx_r1.selectedAutomation)("phases", ctx_r1.columns)("allowedTriggerTypes", ctx_r1.selectedPhaseIdForAutomations ? ctx_r1.getAllowedTriggerTypesForPhase(ctx_r1.selectedPhaseIdForAutomations) : null)("fixedPhaseId", ctx_r1.selectedPhaseIdForAutomations || null)("allowedTransitions", ctx_r1.flowConfig.allowed || \u0275\u0275pureFunction0(8, _c3))("emailTemplates", ctx_r1.emailTemplates)("users", ctx_r1.users);
  }
}
__name(KanbanComponent_app_automation_modal_22_Template, "KanbanComponent_app_automation_modal_22_Template");
var _KanbanComponent = class _KanbanComponent {
  authService = inject(AuthService);
  firestoreService = inject(FirestoreService);
  subdomainService = inject(SubdomainService);
  automationService = inject(AutomationService);
  apiService = inject(ApiService);
  toast = inject(ToastService);
  route = inject(ActivatedRoute);
  router = inject(Router);
  ngZone = inject(NgZone);
  cdr = inject(ChangeDetectorRef);
  leadModal;
  columnModal;
  phaseFormModal;
  leadDetailModal;
  templateModal;
  automationModal;
  flowScrollerRef;
  flowThumbPercent = 10;
  flowThumbLeftPercent = 0;
  isDraggingFlowBar = false;
  isManualReorder = false;
  board = null;
  columns = [];
  leads = [];
  isDraggingLead = false;
  // Arrays estáveis por coluna para drag & drop e render
  displayedLeadsByColumn = {};
  // Ordem local por coluna (ids) – persistido em localStorage por board
  leadOrderByColumn = {};
  // Controle de mover cards
  cardMoveEnabled = true;
  currentUser = null;
  boardId = "";
  ownerId = "";
  // Campos configurados para exibir no card por fase
  phaseCardFields = {};
  subscriptions = [];
  isLoading = true;
  // Abas
  activeTab = "kanban";
  tabs = [
    { id: "kanban", name: "Kanban", icon: "fa-columns" },
    { id: "initial-form", name: "Formul\xE1rio inicial", icon: "fa-list" },
    { id: "flow", name: "Fluxo", icon: "fa-project-diagram" },
    { id: "reports", name: "Relat\xF3rios", icon: "fa-chart-bar" },
    { id: "outbox", name: "Caixa de Sa\xEDda", icon: "fa-paper-plane" },
    { id: "templates", name: "Templates", icon: "fa-envelope" },
    { id: "api", name: "API", icon: "fa-code" }
  ];
  // API Configuration
  apiEndpoint = "";
  apiToken = "KzB47@p!qR9$tW2m&e*J";
  timeAutomationIntervalId = null;
  ngOnInit() {
    this.currentUser = this.authService.getCurrentUser();
    this.boardId = this.route.snapshot.paramMap.get("boardId") || "";
    try {
      localStorage.setItem("last-board-id", this.boardId);
    } catch {
    }
    this.ownerId = this.route.snapshot.queryParamMap.get("ownerId") || this.currentUser?.uid || "";
    const company = this.subdomainService.getCurrentCompany();
    if (company) {
      this.firestoreService.setCompanyContext(company);
    } else {
      console.warn("Empresa n\xE3o encontrada no contexto");
    }
    if (this.currentUser && this.boardId && this.ownerId) {
      this.loadFilterState();
      this.loadBoardData();
      this.subscribeToRealtimeUpdates();
      this.initializeApiEndpoint();
      this.loadInitialForm();
      this.loadFlowConfig();
      try {
        this.timeAutomationIntervalId = setInterval(() => __async(this, null, function* () {
          try {
            if (this.leads && this.leads.length > 0 && this.columns && this.columns.length > 0) {
              yield this.automationService.processTimeBasedAutomations(this.leads, this.columns, this.boardId, this.ownerId);
            }
          } catch (error) {
            console.warn("Erro nas automa\xE7\xF5es de tempo:", error);
          }
        }), 6e4);
      } catch (error) {
        console.error("Erro ao configurar automa\xE7\xF5es de tempo:", error);
      }
    } else {
      console.error("Par\xE2metros faltando:", { currentUser: !!this.currentUser, boardId: this.boardId, ownerId: this.ownerId });
    }
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
    if (this.timeAutomationIntervalId) {
      try {
        clearInterval(this.timeAutomationIntervalId);
      } catch {
      }
      this.timeAutomationIntervalId = null;
    }
  }
  initializeApiEndpoint() {
    const company = this.subdomainService.getCurrentCompany();
    const companyId = company?.id || "{COMPANY_ID}";
    this.apiEndpoint = this.apiService.getLeadIntakeUrl(companyId, this.boardId);
  }
  getFunctionsPort() {
    const storedPort = localStorage.getItem("firebase-functions-port");
    if (storedPort) {
      return parseInt(storedPort, 10);
    }
    try {
      const firebaseConfig = window.__FIREBASE_DEFAULTS__;
      if (firebaseConfig?.emulatorHosts?.functions) {
        const functionsHost = firebaseConfig.emulatorHosts.functions;
        const portMatch = functionsHost.match(/:(\d+)$/);
        if (portMatch) {
          return parseInt(portMatch[1], 10);
        }
      }
    } catch (error) {
    }
    return 3001;
  }
  // Company logo methods
  hasCompanyLogo() {
    const company = this.subdomainService.getCurrentCompany();
    if (company?.brandingConfig?.logo && company.brandingConfig.logo.trim() !== "") {
      return true;
    }
    if (company?.subdomain === "gobuyer") {
      return true;
    }
    return false;
  }
  getCompanyLogo() {
    const company = this.subdomainService.getCurrentCompany();
    if (company?.brandingConfig?.logo && company.brandingConfig.logo.trim() !== "") {
      return company.brandingConfig.logo;
    }
    if (company?.subdomain === "gobuyer") {
      return "https://apps.gobuyer.com.br/sso/assets/images/logos/logo-gobuyer.png";
    }
    return "";
  }
  getPrimaryColor() {
    const company = this.subdomainService.getCurrentCompany();
    return company?.brandingConfig?.primaryColor || "#3B82F6";
  }
  getCompanyInitials() {
    const company = this.subdomainService.getCurrentCompany();
    const name = company?.name || "Task Board";
    if (!name || name === "Task Board")
      return "TB";
    const words = name.split(" ").filter((word) => word.length > 0);
    if (words.length === 1) {
      return words[0].charAt(0).toUpperCase();
    } else if (words.length >= 2) {
      return words[0].charAt(0).toUpperCase() + words[1].charAt(0).toUpperCase();
    }
    return "TB";
  }
  loadBoardData() {
    return __async(this, null, function* () {
      try {
        yield this.loadUsers();
        yield this.debugFirestoreCollections();
        this.isLoading = false;
      } catch (error) {
        console.error("Erro ao carregar dados do quadro:", error);
        this.isLoading = false;
      }
    });
  }
  debugFirestoreCollections() {
    return __async(this, null, function* () {
      try {
        const templates = yield this.firestoreService.getEmailTemplates(this.ownerId, this.boardId);
        const automations = yield this.firestoreService.getAutomations(this.ownerId, this.boardId);
        try {
          const alternativeTemplates = yield this.firestoreService.getEmailTemplates("", this.boardId);
        } catch (error) {
        }
      } catch (error) {
        console.error("Erro no debug das cole\xE7\xF5es:", error);
      }
    });
  }
  loadUsers() {
    return __async(this, null, function* () {
      try {
        this.users = [
          {
            uid: this.currentUser?.uid,
            displayName: this.currentUser?.displayName,
            email: this.currentUser?.email
          }
        ];
      } catch (error) {
        console.error("Erro ao carregar usu\xE1rios:", error);
      }
    });
  }
  subscribeToRealtimeUpdates() {
    const columnsUnsub = this.firestoreService.subscribeToColumns(this.ownerId, this.boardId, (columns) => {
      this.columns = columns;
      this.loadCardFieldConfigs();
      this.loadAllPhaseFormConfigs();
      try {
        this.syncFlowOrderWithColumns();
      } catch {
      }
    });
    this.subscriptions.push({ unsubscribe: columnsUnsub });
    const leadsUnsub = this.firestoreService.subscribeToLeads(this.ownerId, this.boardId, (leads) => __async(this, null, function* () {
      const currentById = /* @__PURE__ */ Object.create(null);
      for (const l of leads)
        currentById[l.id] = l;
      if (!this._leadsStreamInitialized) {
        this._lastLeadsById = currentById;
        this._leadsStreamInitialized = true;
      } else {
        const newLeads = [];
        const moved = [];
        const prev = this._lastLeadsById || {};
        for (const [id, lead] of Object.entries(currentById)) {
          const prevLead = prev[id];
          if (!prevLead) {
            newLeads.push(lead);
          } else if (prevLead.columnId !== lead.columnId) {
            moved.push({ lead, from: prevLead.columnId, to: lead.columnId });
          }
        }
        this._lastLeadsById = currentById;
        try {
          for (const nl of newLeads) {
            try {
              yield this.automationService.processNewLeadAutomations(nl, this.boardId, this.ownerId);
            } catch (e) {
              console.warn("Falha ao processar automa\xE7\xE3o de novo lead:", e);
            }
          }
          for (const mv of moved) {
            try {
              yield this.automationService.processPhaseChangeAutomations(mv.lead, mv.to, mv.from, this.boardId, this.ownerId);
            } catch (e) {
              console.warn("Falha ao processar automa\xE7\xE3o de mudan\xE7a de fase:", e);
            }
          }
        } catch {
        }
      }
      this.leads = leads.map((l) => __spreadProps(__spreadValues({}, l), {
        historyCommentsCount: l.historyCommentsCount ?? 0,
        attachmentsCount: l.attachmentsCount ?? 0
      }));
      this.isLoading = false;
      this.ensureLeadOrderLoaded();
      this.rebuildDisplayedLeads();
    }));
    this.subscriptions.push({ unsubscribe: leadsUnsub });
    const outboxUnsub = this.firestoreService.subscribeToOutboxEmails(this.ownerId, this.boardId, (emails) => {
      this.outboxEmails = emails;
      this.updateEmailStatusCounts();
    });
    this.subscriptions.push({ unsubscribe: outboxUnsub });
    const templatesUnsub = this.firestoreService.subscribeToEmailTemplates(this.ownerId, this.boardId, (templates) => {
      this.emailTemplates = templates;
    });
    this.subscriptions.push({ unsubscribe: templatesUnsub });
    const automationsUnsub = this.firestoreService.subscribeToAutomations(this.ownerId, this.boardId, (automations) => {
      if (automations && automations.length > 0) {
      } else {
      }
      this.automations = automations || [];
      this.cleanupInvalidAutomations();
    });
    this.subscriptions.push({ unsubscribe: automationsUnsub });
  }
  loadCardFieldConfigs() {
    return __async(this, null, function* () {
      try {
        const map2 = {};
        for (const col of this.columns) {
          try {
            const cfg = yield this.firestoreService.getPhaseFormConfig(this.ownerId, this.boardId, col.id);
            const fields = cfg?.fields || [];
            const filteredFields = fields.filter((f) => !!f?.showInCard || !!f?.showInAllPhases);
            map2[col.id] = filteredFields.sort((a, b) => (a.order || 0) - (b.order || 0));
          } catch (error) {
            map2[col.id] = [];
          }
        }
        this.phaseCardFields = map2;
      } catch {
        this.phaseCardFields = {};
      }
    });
  }
  isPlainObject(value) {
    return value && typeof value === "object" && !Array.isArray(value);
  }
  flattenObject(source, maxDepth = 3) {
    const out = {};
    if (!this.isPlainObject(source) || maxDepth < 0)
      return out;
    for (const [key, val] of Object.entries(source)) {
      if (this.isPlainObject(val) && maxDepth > 0) {
        const nested = this.flattenObject(val, maxDepth - 1);
        for (const [nk, nv] of Object.entries(nested)) {
          if (out[nk] === void 0)
            out[nk] = nv;
        }
      } else if (val !== void 0 && val !== null) {
        out[key] = val;
      }
    }
    return out;
  }
  collectLeadFields(lead) {
    const base = lead.fields || {};
    const containers = ["fields", "leadData", "data", "payload"];
    const merged = {};
    const candidates = [base];
    containers.forEach((k) => {
      if (this.isPlainObject(base[k]))
        candidates.push(base[k]);
    });
    if (this.isPlainObject(base.fields?.fields))
      candidates.push(base.fields.fields);
    for (const obj of candidates) {
      for (const [k, v] of Object.entries(obj)) {
        if (merged[k] === void 0 && v !== void 0 && v !== null && `${v}`.trim?.() !== "")
          merged[k] = v;
      }
    }
    const deep = this.flattenObject(base, 3);
    for (const [k, v] of Object.entries(deep)) {
      if (merged[k] === void 0 && v !== void 0 && v !== null && `${v}`.trim?.() !== "")
        merged[k] = v;
    }
    return merged;
  }
  readFieldValue(lead, key, labelHint) {
    const fields = this.collectLeadFields(lead);
    if (!key && !labelHint)
      return void 0;
    const candidates = [];
    if (key)
      candidates.push(key);
    const synonymsGroup = {
      companyName: ["companyName", "empresa", "nomeEmpresa", "nameCompany", "company", "company_name", "empresa_nome", "nameComapny"],
      contactName: ["contactName", "name", "nome", "nomeLead", "nameLead", "leadName"],
      contactEmail: ["contactEmail", "email", "emailLead", "contatoEmail", "leadEmail"],
      contactPhone: ["contactPhone", "phone", "telefone", "celular", "phoneLead", "telefoneContato"],
      cnpj: ["cnpj", "cnpjCompany", "cnpjEmpresa", "companyCnpj"]
    };
    const keyLower = (key || "").toLowerCase();
    Object.values(synonymsGroup).forEach((group) => {
      if (group.some((g) => g.toLowerCase() === keyLower)) {
        group.forEach((k) => {
          if (!candidates.includes(k))
            candidates.push(k);
        });
      }
    });
    const hint = (labelHint || "").toLowerCase();
    const labelMapHints = [
      { words: ["empresa"], groupKey: "companyName" },
      { words: ["contato", "nome do contato", "respons\xE1vel", "responsavel"], groupKey: "contactName" },
      { words: ["email", "e-mail"], groupKey: "contactEmail" },
      { words: ["telefone", "celular", "whatsapp", "whats"], groupKey: "contactPhone" },
      { words: ["cnpj"], groupKey: "cnpj" }
    ];
    for (const m of labelMapHints) {
      if (m.words.some((w) => hint.includes(w))) {
        synonymsGroup[m.groupKey].forEach((k) => {
          if (!candidates.includes(k))
            candidates.push(k);
        });
      }
    }
    const lowerMap = Object.keys(fields).reduce((acc, k) => {
      acc[k.toLowerCase()] = k;
      return acc;
    }, {});
    const normalize = /* @__PURE__ */ __name((s) => s.toLowerCase().replace(/[^a-z0-9]/g, ""), "normalize");
    const normalizedMap = Object.keys(fields).reduce((acc, k) => {
      acc[normalize(k)] = k;
      return acc;
    }, {});
    const visited = /* @__PURE__ */ new Set();
    for (const k of candidates) {
      const lk = k.toLowerCase();
      if (visited.has(lk))
        continue;
      visited.add(lk);
      const original = lowerMap[lk] || normalizedMap[normalize(k)] || k;
      const v = fields[original];
      if (v !== void 0 && v !== null && `${v}`.trim?.() !== "")
        return v;
    }
    return void 0;
  }
  loadAllPhaseFormConfigs() {
    return __async(this, null, function* () {
      for (const column of this.columns) {
        try {
          const config = yield this.firestoreService.getPhaseFormConfig(this.ownerId, this.boardId, column.id);
          if (config?.fields) {
            this.phaseFormConfigs[column.id] = config;
          }
        } catch (e) {
        }
      }
      this.loadAvailableFilterFields();
    });
  }
  getAllFieldsForDisplay() {
    const initialFields = [];
    const phaseFields = [];
    (this.initialFormFields || []).forEach((f) => {
      const showInCard = f?.showInCard;
      const showInAllPhases = f?.showInAllPhases;
      if (f.name === "nameContact" || f.name === "emailContact") {
        return;
      }
      if (showInCard === true || showInAllPhases === true) {
        initialFields.push(f);
      }
    });
    Object.values(this.phaseFormConfigs).forEach((config) => {
      if (config?.fields) {
        config.fields.forEach((f) => {
          if (f?.showInAllPhases === true) {
            phaseFields.push(f);
          }
        });
      }
    });
    const allFields = [...initialFields, ...phaseFields];
    const uniqueFields = allFields.filter((field, index, array) => array.findIndex((f) => f.name === field.name) === index);
    return uniqueFields;
  }
  getCardFieldsForLead(lead) {
    const allFieldsForDisplay = this.getAllFieldsForDisplay();
    const currentPhaseFields = [];
    if (lead.columnId && this.phaseFormConfigs[lead.columnId]) {
      const phaseConfig = this.phaseFormConfigs[lead.columnId];
      if (phaseConfig?.fields) {
        phaseConfig.fields.forEach((f) => {
          if (f?.showInCard === true) {
            currentPhaseFields.push(f);
          }
        });
      }
    }
    const allFields = [...allFieldsForDisplay, ...currentPhaseFields];
    const uniqueFields = allFields.filter((field, index, array) => array.findIndex((f) => f.name === field.name) === index);
    const fieldsToShow = uniqueFields.sort((a, b) => (a.order || 0) - (b.order || 0));
    console.log(`\u{1F0CF} Debug Card Fields - Lead ${lead.id} (Column: ${lead.columnId})`, {
      globalFields: allFieldsForDisplay.length,
      currentPhaseFields: currentPhaseFields.length,
      totalUnique: uniqueFields.length,
      fieldsToShow: fieldsToShow.map((f) => ({
        name: f.name,
        label: f.label,
        showInCard: f.showInCard,
        showInAllPhases: f.showInAllPhases
      }))
    });
    const out = [];
    const isTitleField = /* @__PURE__ */ __name((f) => {
      const key = (f.apiFieldName || f.name || "").toLowerCase();
      const lbl = (f.label || f.name || "").toLowerCase();
      const norm = /* @__PURE__ */ __name((s) => s.replace(/[^a-z0-9]/g, ""), "norm");
      const companyGroup = ["companyname", "empresa", "nomeempresa", "namecompany", "company", "company_name", "empresa_nome", "namecomapny"];
      const cnpjGroup = ["cnpj", "cnpjcompany", "cnpjempresa", "companycnpj"];
      const k = norm(key);
      const l = norm(lbl);
      return companyGroup.includes(k) || companyGroup.includes(l) || cnpjGroup.includes(k) || cnpjGroup.includes(l);
    }, "isTitleField");
    for (const f of fieldsToShow) {
      const isTitle = isTitleField(f);
      const value = this.readFieldValue(lead, f.apiFieldName || f.name, f.label || f.name);
      const hasValue = value !== void 0 && value !== null && `${value}`.trim() !== "";
      if (!isTitle && hasValue) {
        const item = { label: f.label || f.name || f.apiFieldName, value, type: (f.type || "").toLowerCase() };
        out.push(item);
      }
    }
    return out;
  }
  // Exibir temperatura em todas as fases quando marcada em qualquer config
  getTemperatureGlobalItem(lead) {
    try {
      const allSources = [
        // Campos do formulário inicial
        ...this.initialFormFields || [],
        // Campos da fase atual
        ...this.phaseCardFields[lead.columnId] || []
      ];
      Object.values(this.phaseFormConfigs).forEach((config) => {
        if (config?.fields) {
          config.fields.forEach((f) => {
            if (f?.showInAllPhases === true) {
              allSources.push(f);
            }
          });
        }
      });
      console.log("\u{1F321}\uFE0F Debug Temperature Search:", {
        leadId: lead.id,
        columnId: lead.columnId,
        totalSources: allSources.length,
        temperatureFields: allSources.filter((f) => (f.type || "").toLowerCase() === "temperatura")
      });
      const tempField = allSources.find((f) => {
        const isTemperatura = (f.type || "").toLowerCase() === "temperatura";
        const hasVisibilityFlag = f.showInCard || f.showInAllPhases;
        return isTemperatura && hasVisibilityFlag;
      });
      if (!tempField) {
        console.log("\u{1F321}\uFE0F No temperature field found with visibility flags");
        return null;
      }
      console.log("\u{1F321}\uFE0F Found temperature field:", {
        name: tempField.name,
        label: tempField.label,
        showInCard: tempField.showInCard,
        showInAllPhases: tempField.showInAllPhases
      });
      const val = this.readFieldValue(lead, tempField.apiFieldName || tempField.name, tempField.label || tempField.name);
      if (val === void 0 || val === null || `${val}`.trim() === "") {
        console.log("\u{1F321}\uFE0F Temperature field has no value");
        return null;
      }
      const result = { label: tempField.label || "Temperatura", value: val };
      console.log("\u{1F321}\uFE0F Temperature result:", result);
      return result;
    } catch (error) {
      console.error("\u{1F321}\uFE0F getTemperatureGlobalItem error:", error);
      return null;
    }
  }
  // Recupera o item de temperatura apenas se estiver marcado para exibir no card
  getTemperatureCardItem(lead) {
    try {
      const items = this.getCardFieldsForLead(lead);
      const temp = items.find((i) => (i.type || "").toLowerCase() === "temperatura");
      return temp ? { label: temp.label, value: temp.value } : null;
    } catch {
      return null;
    }
  }
  getLeadsForColumn(columnId) {
    const all = this.leads.filter((lead) => lead.columnId === columnId);
    const filtered = all.filter((lead) => this.leadMatchesFilters ? this.leadMatchesFilters(lead) : true);
    const order = this.leadOrderByColumn[columnId] || [];
    return filtered.sort((a, b) => order.indexOf(a.id) - order.indexOf(b.id) || 0);
  }
  getColumnConnectedTo() {
    return this.columns.map((col) => `column-${col.id}`);
  }
  onLeadDrop(event) {
    return __async(this, null, function* () {
      this.isDraggingLead = false;
      const leadId = event.item.data;
      const targetColumnId = event.container.id.replace("column-", "");
      const previousColumnId = event.previousContainer.id.replace("column-", "");
      if (event.previousContainer === event.container) {
        moveItemInArray(event.container.data, event.previousIndex, event.currentIndex);
        const visibleIds = event.container.data.map((l) => l.id);
        const currentOrder = this.leadOrderByColumn[targetColumnId] || [];
        const remaining = currentOrder.filter((id) => !visibleIds.includes(id));
        this.leadOrderByColumn[targetColumnId] = [...visibleIds, ...remaining];
        this.saveLeadOrder();
        return;
      } else {
        transferArrayItem(event.previousContainer.data, event.container.data, event.previousIndex, event.currentIndex);
        const lead = this.leads.find((l) => l.id === leadId);
        try {
          const missing = yield this.getRequiredToAdvanceMissing(lead, previousColumnId);
          if (missing.length > 0) {
            transferArrayItem(event.container.data, event.previousContainer.data, event.currentIndex, event.previousIndex);
            this.toast.error(`Preencha os campos obrigat\xF3rios para avan\xE7ar: ${missing.join(", ")}`);
            return;
          }
        } catch {
        }
        const allowedFrom = this.flowConfig.allowed[previousColumnId] || [];
        if (!allowedFrom.includes(targetColumnId)) {
          transferArrayItem(event.container.data, event.previousContainer.data, event.currentIndex, event.previousIndex);
          this.toast.error("Transi\xE7\xE3o n\xE3o permitida pelo fluxo.");
          return;
        }
        try {
          yield this.firestoreService.moveLead(this.ownerId, this.boardId, leadId, targetColumnId);
          const targetVisibleIds = event.container.data.map((l) => l.id);
          const sourceVisibleIds = event.previousContainer.data.map((l) => l.id);
          const sourceOrder = this.leadOrderByColumn[previousColumnId] || [];
          const targetOrder = this.leadOrderByColumn[targetColumnId] || [];
          const leadIdStr = String(leadId);
          const sourceRemaining = sourceOrder.filter((id) => id !== leadIdStr);
          const targetRemaining = targetOrder.filter((id) => !targetVisibleIds.includes(id) && id !== leadIdStr);
          this.leadOrderByColumn[previousColumnId] = [...sourceVisibleIds, ...sourceRemaining.filter((id) => !sourceVisibleIds.includes(id))];
          this.leadOrderByColumn[targetColumnId] = [...targetVisibleIds, ...targetRemaining];
          this.saveLeadOrder();
          try {
            if (lead) {
              const now = /* @__PURE__ */ new Date();
              const phaseHistory = __spreadValues({}, lead.phaseHistory || {});
              if (phaseHistory[previousColumnId]) {
                const enteredAt = phaseHistory[previousColumnId].enteredAt?.toDate && phaseHistory[previousColumnId].enteredAt.toDate() || new Date(phaseHistory[previousColumnId].enteredAt || now);
                phaseHistory[previousColumnId].exitedAt = now;
                phaseHistory[previousColumnId].duration = now.getTime() - enteredAt.getTime();
              }
              phaseHistory[targetColumnId] = {
                phaseId: targetColumnId,
                enteredAt: now
              };
              yield this.firestoreService.updateLead(this.ownerId, this.boardId, lead.id, { phaseHistory });
            }
          } catch {
          }
        } catch (error) {
          console.error("Erro ao mover lead:", error);
          this.subscribeToRealtimeUpdates();
        }
      }
    });
  }
  // Verifica campos requiredToAdvance não preenchidos da fase sourceColumnId do lead
  getRequiredToAdvanceMissing(lead, sourceColumnId) {
    return __async(this, null, function* () {
      try {
        const colId = sourceColumnId || lead.columnId;
        const cfg = yield this.firestoreService.getPhaseFormConfig(this.ownerId, this.boardId, colId);
        const fields = cfg?.fields || [];
        const required = fields.filter((f) => !!f?.requiredToAdvance);
        const missing = [];
        for (const f of required) {
          const key = f.apiFieldName || f.name;
          const value = this.readFieldValue(lead, key, f.label || f.name);
          const empty = value === void 0 || value === null || typeof value === "string" && value.trim() === "";
          if (empty)
            missing.push(f.label || f.name || key);
        }
        return missing;
      } catch {
        return [];
      }
    });
  }
  // trackBy para manter estabilidade dos itens
  trackByLeadId(index, lead) {
    return lead.id;
  }
  ensureLeadOrderLoaded() {
    const key = `lead-order-${this.boardId}`;
    try {
      const raw = localStorage.getItem(key);
      if (raw) {
        this.leadOrderByColumn = JSON.parse(raw) || {};
      }
    } catch {
    }
  }
  saveLeadOrder() {
    const key = `lead-order-${this.boardId}`;
    try {
      localStorage.setItem(key, JSON.stringify(this.leadOrderByColumn));
    } catch {
    }
  }
  rebuildDisplayedLeads() {
    const map2 = {};
    for (const col of this.columns) {
      const all = this.leads.filter((l) => l.columnId === col.id);
      const filtered = all.filter((l) => this.leadMatchesFilters ? this.leadMatchesFilters(l) : true);
      const order = this.leadOrderByColumn[col.id] || [];
      const withKnown = filtered.filter((l) => order.includes(l.id)).sort((a, b) => order.indexOf(a.id) - order.indexOf(b.id));
      const without = filtered.filter((l) => !order.includes(l.id));
      map2[col.id] = [...withKnown, ...without];
      if (!this.leadOrderByColumn[col.id]) {
        this.leadOrderByColumn[col.id] = map2[col.id].map((l) => l.id);
      }
    }
    this.displayedLeadsByColumn = map2;
    this.saveLeadOrder();
  }
  logout() {
    return __async(this, null, function* () {
      const result = yield this.authService.logout();
      if (result.success) {
        this.router.navigate(["/login"]);
      }
    });
  }
  goToDashboard() {
    this.router.navigate(["/dashboard"]);
  }
  formatDate(timestamp) {
    if (!timestamp) {
      console.log("formatDate: timestamp is null/undefined");
      return "Data n\xE3o dispon\xEDvel";
    }
    try {
      if (timestamp.seconds) {
        return new Date(timestamp.seconds * 1e3).toLocaleDateString("pt-BR");
      }
      if (timestamp.toDate) {
        return timestamp.toDate().toLocaleDateString("pt-BR");
      }
      if (timestamp instanceof Date) {
        return timestamp.toLocaleDateString("pt-BR");
      }
      return new Date(timestamp).toLocaleDateString("pt-BR");
    } catch (error) {
      return "Data inv\xE1lida";
    }
  }
  // Data e hora (pt-BR) – aceita Timestamp do Firestore, Date, string ou number
  formatDateTime(timestamp) {
    if (!timestamp) {
      return "\u2014";
    }
    try {
      if (timestamp.seconds) {
        return new Date(timestamp.seconds * 1e3).toLocaleString("pt-BR");
      }
      if (timestamp.toDate) {
        return timestamp.toDate().toLocaleString("pt-BR");
      }
      if (timestamp instanceof Date) {
        return timestamp.toLocaleString("pt-BR");
      }
      return new Date(timestamp).toLocaleString("pt-BR");
    } catch {
      return "\u2014";
    }
  }
  // Para a Caixa de Saída: priorizar hora de envio (delivery.endTime) e cair para createdAt
  getEmailDisplayDate(email) {
    const sent = email?.delivery?.endTime;
    if (sent)
      return sent;
    return email?.createdAt || null;
  }
  getColumnBorderColor(column) {
    return column.color || "#e5e7eb";
  }
  getLeadPriorityClass(lead) {
    const temperature = lead.fields?.["temperature"];
    if (temperature === "quente")
      return "border-l-red-500";
    if (temperature === "morno")
      return "border-l-yellow-500";
    return "border-l-transparent";
  }
  getLeadInitials(lead) {
    const name = lead.fields?.["companyName"] || lead.fields?.["contactName"] || "";
    return name.split(" ").map((word) => word.charAt(0)).join("").substring(0, 2).toUpperCase();
  }
  getCompanyName(lead) {
    const val = this.readFieldValue(lead, "companyName");
    return val !== void 0 && val !== null && `${val}`.trim() !== "" ? `${val}` : "Empresa n\xE3o informada";
  }
  getCnpj(lead) {
    const val = this.readFieldValue(lead, "cnpj", "CNPJ");
    if (val === void 0 || val === null)
      return null;
    const s = `${val}`.trim();
    return s ? s : null;
  }
  showCreateLeadModal() {
    this.leadModal.showCreateModal();
  }
  showEditLeadModal(lead) {
    this.leadModal.showEditModal(lead);
  }
  showLeadDetailModal(lead) {
    this.leadDetailModal.show(lead);
  }
  onCardClick(lead, evt) {
    if (this.isDraggingLead)
      return;
    this.showLeadDetailModal(lead);
  }
  onLeadDragStarted() {
    this.isDraggingLead = true;
  }
  onLeadDragEnded() {
    setTimeout(() => {
      this.isDraggingLead = false;
    }, 0);
  }
  toggleCardMove() {
    this.cardMoveEnabled = !this.cardMoveEnabled;
    if (!this.cardMoveEnabled)
      this.isDraggingLead = false;
  }
  onWindowMouseUpForCards() {
    this.isDraggingLead = false;
  }
  onWindowTouchEndForCards() {
    this.isDraggingLead = false;
  }
  onLeadCreated() {
    return __async(this, null, function* () {
      console.log("Novo lead criado!");
    });
  }
  onLeadUpdated() {
    console.log("Lead atualizado!");
  }
  onLeadDeleted() {
    console.log("Lead exclu\xEDdo!");
  }
  switchTab(tabId) {
    this.activeTab = tabId;
  }
  getActiveLeads() {
    return this.leads.filter((lead) => {
      const column = this.columns.find((col) => col.id === lead.columnId);
      return column && (!column.endStageType || column.endStageType === "none");
    });
  }
  // Propriedades para Caixa de Saída
  outboxEmails = [];
  activeEmailStatus = "all";
  emailStatuses = [
    { id: "all", name: "Todos", count: 0 },
    { id: "scheduled", name: "Agendados", count: 0 },
    { id: "success", name: "Enviados", count: 0 },
    { id: "error", name: "Com Erro", count: 0 }
  ];
  // Propriedades para Templates
  emailTemplates = [];
  // Propriedades para Automações
  automations = [];
  _leadsStreamInitialized = false;
  _lastLeadsById = {};
  // Formulário inicial (aba nova)
  initialFormFields = [];
  phaseFormConfigs = {};
  apiExampleJson = "";
  // Fluxo (transitions) config
  flowConfig = { allowed: {} };
  // Novo layout do fluxo: ordem horizontal e toggles adjacentes
  flowOrder = [];
  flowTogglesByPhase = {};
  // Editor manual de conexões
  flowEdges = [];
  connectMode = false;
  pendingFromId = null;
  loadFlowConfig() {
    return __async(this, null, function* () {
      try {
        const cfg = yield this.firestoreService.getFlowConfig(this.boardId);
        this.flowConfig = cfg || { allowed: {} };
        const currentColumnOrder = [...this.columns].sort((a, b) => (a.order || 0) - (b.order || 0)).map((c) => c.id);
        if (!this.isManualReorder) {
          this.flowOrder = currentColumnOrder;
        } else {
        }
        this.flowTogglesByPhase = {};
        for (let i = 0; i < this.flowOrder.length; i++) {
          const id = this.flowOrder[i];
          const prevId = this.flowOrder[i - 1];
          const nextId = this.flowOrder[i + 1];
          const allowedFrom = this.flowConfig.allowed[id] || [];
          this.flowTogglesByPhase[id] = {
            allowNext: !!(nextId && allowedFrom.includes(nextId)),
            allowPrev: !!(prevId && allowedFrom.includes(prevId))
          };
        }
        const edges = [];
        const allowed = this.flowConfig.allowed || {};
        Object.keys(allowed).forEach((fromId) => {
          (allowed[fromId] || []).forEach((toId) => edges.push({ fromId, toId }));
        });
        this.flowEdges = edges;
      } catch {
        this.flowConfig = { allowed: {} };
        if (!this.isManualReorder) {
          this.flowOrder = [...this.columns].sort((a, b) => (a.order || 0) - (b.order || 0)).map((c) => c.id);
        }
      }
    });
  }
  saveFlowConfig() {
    return __async(this, null, function* () {
      try {
        const normalizeId = /* @__PURE__ */ __name((v) => typeof v === "string" ? v.trim() : String(v || "").trim(), "normalizeId");
        const allowed = {};
        for (const edge of this.flowEdges || []) {
          const fromId = normalizeId(edge.fromId);
          const toId = normalizeId(edge.toId);
          if (!fromId || !toId)
            continue;
          if (!allowed[fromId])
            allowed[fromId] = [];
          if (!allowed[fromId].includes(toId))
            allowed[fromId].push(toId);
        }
        const validIds = new Set(this.columns.map((c) => c.id));
        Object.keys(allowed).forEach((fromId) => {
          if (!validIds.has(fromId))
            delete allowed[fromId];
          else
            allowed[fromId] = (allowed[fromId] || []).filter((toId) => validIds.has(toId));
        });
        const orderClean = (this.flowOrder || []).map(normalizeId).filter((id) => validIds.has(id));
        this.flowConfig = { allowed };
        yield this.firestoreService.saveFlowConfig(this.boardId, { allowed, order: orderClean });
        this.toast.success("Fluxo salvo.");
      } catch (error) {
        console.error("Erro ao salvar fluxo", { error });
        const message = error?.message || "Erro ao salvar fluxo.";
        this.toast.error(message);
      }
    });
  }
  // Novo método para salvar o estado atual das conexões (sem reconstruir)
  saveCurrentFlowConfig() {
    return __async(this, null, function* () {
      try {
        console.log("\u{1F4BE} Salvando configura\xE7\xE3o atual do fluxo:", {
          allowed: this.flowConfig.allowed,
          order: this.flowOrder
        });
        const normalizeId = /* @__PURE__ */ __name((v) => typeof v === "string" ? v.trim() : String(v || "").trim(), "normalizeId");
        const validIds = new Set(this.columns.map((c) => c.id));
        const cleanedAllowed = {};
        Object.entries(this.flowConfig.allowed || {}).forEach(([fromId, toIds]) => {
          const cleanFromId = normalizeId(fromId);
          if (validIds.has(cleanFromId)) {
            cleanedAllowed[cleanFromId] = (toIds || []).map((id) => normalizeId(id)).filter((id) => validIds.has(id));
          }
        });
        const orderClean = (this.flowOrder || []).map(normalizeId).filter((id) => validIds.has(id));
        yield this.firestoreService.saveFlowConfig(this.boardId, {
          allowed: cleanedAllowed,
          order: orderClean
        });
        console.log("\u2705 Configura\xE7\xE3o do fluxo salva com sucesso");
      } catch (error) {
        console.error("\u274C Erro ao salvar configura\xE7\xE3o do fluxo:", error);
        throw error;
      }
    });
  }
  // Flow helpers (UI)
  getAllowedTargets(fromId) {
    const ids = this.flowConfig.allowed[fromId] || [];
    return this.columns.filter((c) => ids.includes(c.id));
  }
  getAvailableTargets(fromId) {
    const ids = this.flowConfig.allowed[fromId] || [];
    return this.columns.filter((c) => c.id !== fromId && !ids.includes(c.id));
  }
  onFlowDropToAllowed(fromId, event) {
    return __async(this, null, function* () {
      const dropped = event.item.data;
      const list = this.flowConfig.allowed[fromId] || (this.flowConfig.allowed[fromId] = []);
      if (!list.includes(dropped.id)) {
        console.log("\u2795 Adicionando conex\xE3o:", {
          from: this.getColumnById(fromId)?.name,
          to: dropped.name,
          beforeAdd: [...list]
        });
        list.push(dropped.id);
        console.log("\u2795 Ap\xF3s adi\xE7\xE3o:", {
          newList: [...list]
        });
        try {
          yield this.saveCurrentFlowConfig();
          console.log("\u2705 Configura\xE7\xE3o salva ap\xF3s adi\xE7\xE3o da conex\xE3o");
        } catch (error) {
          console.error("\u274C Erro ao salvar configura\xE7\xE3o ap\xF3s adi\xE7\xE3o:", error);
        }
      }
    });
  }
  onFlowDropToAvailable(fromId, event) {
    return __async(this, null, function* () {
      const dropped = event.item.data;
      const list = this.flowConfig.allowed[fromId] || [];
      console.log("\u{1F5D1}\uFE0F Removendo conex\xE3o:", {
        from: this.getColumnById(fromId)?.name,
        to: dropped.name,
        beforeRemoval: [...list],
        droppedId: dropped.id
      });
      this.flowConfig.allowed[fromId] = list.filter((id) => id !== dropped.id);
      console.log("\u{1F5D1}\uFE0F Ap\xF3s remo\xE7\xE3o:", {
        newList: [...this.flowConfig.allowed[fromId]]
      });
      try {
        yield this.saveCurrentFlowConfig();
        console.log("\u2705 Configura\xE7\xE3o salva ap\xF3s remo\xE7\xE3o da conex\xE3o");
      } catch (error) {
        console.error("\u274C Erro ao salvar configura\xE7\xE3o ap\xF3s remo\xE7\xE3o:", error);
      }
    });
  }
  // Reordenação horizontal dos cartões de fases no editor de fluxo
  onFlowReorder(event) {
    return __async(this, null, function* () {
      console.log("\u{1F3AF} onFlowReorder CHAMADO!", {
        previousIndex: event.previousIndex,
        currentIndex: event.currentIndex,
        isEqual: event.previousIndex === event.currentIndex,
        movedPhaseId: this.flowOrder[event.previousIndex],
        allPhases: this.flowOrder.map((id, index) => ({ index, id, name: this.getColumnById(id)?.name })),
        containerData: event.container.data,
        previousContainer: event.previousContainer.data
      });
      if (event.previousIndex === event.currentIndex) {
        console.log("\u274C onFlowReorder - Movimento aparentemente para o mesmo \xEDndice");
        console.log("\u26A0\uFE0F Vamos investigar se realmente \xE9 o mesmo local...");
        const containerIds = event.container.data;
        const previousContainerIds = event.previousContainer.data;
        console.log("\u{1F50D} Container atual:", containerIds);
        console.log("\u{1F50D} Container anterior:", previousContainerIds);
        console.log("\u{1F50D} Fases com nomes:", containerIds.map((id, index) => `${index}: ${this.getColumnById(id)?.name}`));
        if (event.container !== event.previousContainer || JSON.stringify(containerIds) !== JSON.stringify(previousContainerIds)) {
          console.log("\u2705 Detectada mudan\xE7a real, continuando reordena\xE7\xE3o...");
        } else {
          console.log("\u274C Nenhuma mudan\xE7a real detectada");
          console.log("\u{1F4A1} Tentativa: Vou tentar for\xE7ar o movimento manualmente...");
          console.log("\u26A0\uFE0F FOR\xC7ANDO movimento para testar...");
        }
      }
      this.isManualReorder = true;
      console.log("\u{1F504} Flow Reorder - Iniciando reordena\xE7\xE3o", {
        from: event.previousIndex,
        to: event.currentIndex,
        previousOrder: [...this.flowOrder],
        movedColumnId: this.flowOrder[event.previousIndex],
        targetPosition: event.currentIndex
      });
      const originalOrder = [...this.flowOrder];
      moveItemInArray(this.flowOrder, event.previousIndex, event.currentIndex);
      console.log("\u{1F504} Flow Reorder - flowOrder imediatamente ap\xF3s moveItemInArray:", [...this.flowOrder]);
      this.cdr.detectChanges();
      console.log("\u{1F504} Flow Reorder - DOM atualizado, ordem visual deve refletir:", [...this.flowOrder]);
      console.log("\u{1F504} Flow Reorder - Nova ordem local:", {
        newOrder: [...this.flowOrder],
        changes: this.flowOrder.map((id, index) => {
          const originalIndex = originalOrder.indexOf(id);
          return { id, from: originalIndex, to: index, changed: originalIndex !== index };
        })
      });
      try {
        const updatePromises = this.flowOrder.map((columnId, newIndex) => __async(this, null, function* () {
          const column = this.columns.find((c) => c.id === columnId);
          const originalIndex = originalOrder.indexOf(columnId);
          if (column && originalIndex !== newIndex) {
            console.log(`\u{1F504} Atualizando coluna "${column.name}" - posi\xE7\xE3o: ${originalIndex} \u2192 ${newIndex}`);
            yield this.firestoreService.updateColumn(this.ownerId, this.boardId, columnId, { order: newIndex });
            column.order = newIndex;
          }
        }));
        yield Promise.all(updatePromises);
        this.columns.sort((a, b) => (a.order || 0) - (b.order || 0));
        console.log("\u2705 Flow Reorder - Reordena\xE7\xE3o salva com sucesso", {
          finalOrder: this.columns.map((c) => ({ id: c.id, name: c.name, order: c.order }))
        });
        console.log("\u2705 Flow Reorder - Aguardando para resetar flag isManualReorder");
        setTimeout(() => {
          console.log("\u{1F504} Flow Reorder - Resetando flag isManualReorder para false");
          this.isManualReorder = false;
        }, 500);
      } catch (error) {
        console.error("\u274C Flow Reorder - Erro ao salvar nova ordem:", error);
        this.flowOrder = originalOrder;
        this.isManualReorder = false;
        alert("Erro ao reordenar fases. Tente novamente.");
      }
    });
  }
  syncFlowOrderWithColumns() {
    if (this.isManualReorder) {
      console.log("\u{1F504} syncFlowOrderWithColumns - Pulando sincroniza\xE7\xE3o durante reordena\xE7\xE3o manual");
      return;
    }
    const sortedIds = [...this.columns].sort((a, b) => (a.order || 0) - (b.order || 0)).map((c) => c.id);
    if (!Array.isArray(this.flowOrder) || this.flowOrder.length === 0) {
      this.flowOrder = sortedIds;
      return;
    }
    const flowOrderMatchesColumnOrder = this.flowOrder.every((id, index) => sortedIds[index] === id);
    if (flowOrderMatchesColumnOrder) {
      console.log("\u{1F504} syncFlowOrderWithColumns - FlowOrder j\xE1 est\xE1 sincronizado, n\xE3o alterando");
      return;
    }
    const existing = new Set(this.flowOrder);
    const validIds = new Set(sortedIds);
    this.flowOrder = this.flowOrder.filter((id) => validIds.has(id));
    for (const id of sortedIds) {
      if (!existing.has(id)) {
        const phaseName = this.getColumnById(id)?.name || "Nome n\xE3o encontrado";
        this.flowOrder.push(id);
        console.log(`\u{1F504} syncFlowOrderWithColumns - Adicionada nova fase: ${id} (${phaseName})`);
      }
    }
    if (this.flowOrder.length !== existing.size) {
      console.log("\u{1F504} syncFlowOrderWithColumns - For\xE7ando atualiza\xE7\xE3o visual ap\xF3s mudan\xE7as");
      this.cdr.detectChanges();
    }
    console.log("\u{1F504} syncFlowOrderWithColumns - Sincroniza\xE7\xE3o conclu\xEDda", {
      finalFlowOrder: [...this.flowOrder]
    });
  }
  // Fluxo: scroll helpers
  scrollFlowBy(delta) {
    try {
      const el = this.flowScrollerRef?.nativeElement;
      if (el)
        el.scrollBy({ left: delta, behavior: "smooth" });
    } catch {
    }
  }
  // Atualiza o tamanho e posição do thumb customizado
  updateFlowThumb() {
    try {
      const el = this.flowScrollerRef?.nativeElement;
      if (!el)
        return;
      const total = el.scrollWidth;
      const viewport = el.clientWidth;
      const scrollLeft = el.scrollLeft;
      const percent = Math.max(5, Math.min(100, viewport / total * 100));
      const left = Math.max(0, Math.min(100 - percent, scrollLeft / (total - viewport) * 100));
      this.flowThumbPercent = percent;
      this.flowThumbLeftPercent = isFinite(left) ? left : 0;
      this.cdr.markForCheck();
    } catch {
    }
  }
  onWindowResizeFlow() {
    this.updateFlowThumb();
  }
  ngAfterViewInit() {
    setTimeout(() => this.updateFlowThumb(), 0);
    try {
      const el = this.flowScrollerRef?.nativeElement;
      if (el) {
        this.ngZone.runOutsideAngular(() => {
          el.addEventListener("scroll", () => {
            this.ngZone.run(() => this.updateFlowThumb());
          }, { passive: true });
        });
      }
    } catch {
    }
  }
  // Click/drag na barra personalizada
  onFlowBarPointerDown(evt) {
    evt.preventDefault();
    const el = this.flowScrollerRef?.nativeElement;
    const bar = evt.currentTarget;
    if (!el || !bar)
      return;
    const rect = bar.getBoundingClientRect();
    const moveTo = /* @__PURE__ */ __name((clientX) => {
      const ratio = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
      el.scrollLeft = (el.scrollWidth - el.clientWidth) * ratio;
      this.updateFlowThumb();
    }, "moveTo");
    moveTo(evt.clientX);
    this.isDraggingFlowBar = true;
    const onMove = /* @__PURE__ */ __name((e) => moveTo(e.clientX), "onMove");
    const onUp = /* @__PURE__ */ __name(() => {
      this.isDraggingFlowBar = false;
      window.removeEventListener("mousemove", onMove);
      window.removeEventListener("mouseup", onUp);
    }, "onUp");
    this.ngZone.runOutsideAngular(() => {
      window.addEventListener("mousemove", onMove, { passive: true });
      window.addEventListener("mouseup", onUp, { once: true });
    });
  }
  onFlowBarTouchStart(evt) {
    const el = this.flowScrollerRef?.nativeElement;
    const bar = evt.currentTarget;
    if (!el || !bar || evt.touches.length === 0)
      return;
    const rect = bar.getBoundingClientRect();
    const moveTo = /* @__PURE__ */ __name((clientX) => {
      const ratio = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
      el.scrollLeft = (el.scrollWidth - el.clientWidth) * ratio;
      this.updateFlowThumb();
    }, "moveTo");
    moveTo(evt.touches[0].clientX);
    const onMove = /* @__PURE__ */ __name((e) => {
      if (e.touches.length > 0)
        moveTo(e.touches[0].clientX);
    }, "onMove");
    const onEnd = /* @__PURE__ */ __name(() => {
      window.removeEventListener("touchmove", onMove);
      window.removeEventListener("touchend", onEnd);
    }, "onEnd");
    this.ngZone.runOutsideAngular(() => {
      window.addEventListener("touchmove", onMove, { passive: true });
      window.addEventListener("touchend", onEnd, { once: true });
    });
  }
  toggleConnectMode() {
    this.connectMode = !this.connectMode;
    this.pendingFromId = null;
  }
  beginEdge(fromId) {
    this.pendingFromId = fromId;
  }
  completeEdge(toId) {
    if (!this.pendingFromId)
      return;
    const fromId = this.pendingFromId;
    if (fromId !== toId && !this.flowEdges.some((e) => e.fromId === fromId && e.toId === toId)) {
      this.flowEdges.push({ fromId, toId });
    }
    this.pendingFromId = null;
  }
  removeEdge(edge) {
    this.flowEdges = this.flowEdges.filter((e) => !(e.fromId === edge.fromId && e.toId === edge.toId));
  }
  // Helpers para template (evitam funções inline no HTML)
  hasOutgoingConnections(phaseId) {
    return Array.isArray(this.flowEdges) && this.flowEdges.some((e) => e.fromId === phaseId);
  }
  getOutgoingConnections(phaseId) {
    return (this.flowEdges || []).filter((e) => e.fromId === phaseId);
  }
  getEdgeArrow(edge) {
    const from = this.columns.find((c) => c.id === edge.fromId);
    const to = this.columns.find((c) => c.id === edge.toId);
    if (!from || !to)
      return "\u2192";
    return to.order > from.order ? "\u2192" : "\u2190";
  }
  // legacy handlers removed (no-op to satisfy template references if any remain)
  onFlowMouseMove(evt) {
  }
  startConnect(fromId, evt) {
  }
  endConnect(toId, evt) {
  }
  cancelConnect() {
  }
  getNodeById(id) {
    return { id, name: "", x: 0, y: 0 };
  }
  buildCurvePath(fromId, toId) {
    const a = this.getNodeById(fromId);
    const b = this.getNodeById(toId);
    if (!a || !b)
      return "";
    const startX = a.x + 120;
    const startY = a.y + 30;
    const endX = b.x;
    const endY = b.y + 30;
    const dx = Math.max(40, Math.abs(endX - startX) * 0.5);
    const c1x = startX + dx, c1y = startY;
    const c2x = endX - dx, c2y = endY;
    return `M ${startX},${startY} C ${c1x},${c1y} ${c2x},${c2y} ${endX},${endY}`;
  }
  buildTempCurve() {
    return "";
  }
  getEdgeColor(fromId, toId) {
    const from = this.columns.find((c) => c.id === fromId);
    const to = this.columns.find((c) => c.id === toId);
    if (!from || !to)
      return "#9CA3AF";
    return to.order > from.order ? "#16a34a" : "#ea580c";
  }
  getEdgeMarker(fromId, toId) {
    const from = this.columns.find((c) => c.id === fromId);
    const to = this.columns.find((c) => c.id === toId);
    if (!from || !to)
      return "";
    return to.order > from.order ? "url(#arrow-green)" : "url(#arrow-orange)";
  }
  onNodeDragStart(node, evt) {
  }
  onFlowMouseUp(evt) {
  }
  onWindowMouseUp(evt) {
  }
  onWindowTouchEnd(evt) {
  }
  onNodeMouseEnter(node) {
  }
  onNodeMouseLeave(node) {
  }
  autoAlignFlow() {
    this.toast.success("Fluxo alinhado");
  }
  toggleFlowMove() {
  }
  getColumnById(columnId) {
    return this.columns.find((c) => c.id === columnId);
  }
  // Quantidade de automações ativas associadas a uma fase
  getAutomationCount(columnId) {
    try {
      const isInitial = this.isInitialPhaseId(columnId);
      return (this.automations || []).filter((a) => {
        const active = a?.active !== false;
        if (!active)
          return false;
        const trigger = a?.trigger || {};
        const type = a?.triggerType ?? trigger.type;
        const phase = a?.triggerPhase ?? trigger.phase;
        if (type === "new-lead-created") {
          if (!phase)
            return isInitial;
          return phase === columnId;
        }
        return phase === columnId;
      }).length;
    } catch {
      return 0;
    }
  }
  isInitialPhaseId(phaseId) {
    const col = this.getColumnById(phaseId);
    if (!col)
      return false;
    const minOrder = Math.min(...this.columns.map((c) => c.order || 0));
    return !!col.isInitialPhase || (col.order || 0) === minOrder;
  }
  getAllowedTriggerTypesForPhase(phaseId) {
    const base = ["new-lead-created", "card-enters-phase", "card-in-phase-for-time", "form-not-answered", "sla-overdue"];
    return base;
  }
  // Automações por fase (na aba Fluxo)
  selectedPhaseIdForAutomations = null;
  openPhaseAutomations(phaseId) {
    this.selectedPhaseIdForAutomations = phaseId;
  }
  closePhaseAutomations() {
    this.selectedPhaseIdForAutomations = null;
  }
  getAutomationsForPhase(phaseId) {
    return (this.automations || []).filter((a) => {
      const trigger = a?.trigger || {};
      const type = a?.triggerType ?? trigger.type;
      const phase = a?.triggerPhase ?? trigger.phase;
      if (type === "new-lead-created") {
        if (!phase)
          return this.isInitialPhaseId(phaseId);
        return phase === phaseId;
      }
      return phase === phaseId;
    });
  }
  createAutomationForPhase(phaseId) {
    const defaultType = this.isInitialPhaseId(phaseId) ? "new-lead-created" : "card-enters-phase";
    this.selectedAutomation = {
      name: "Automa\xE7\xE3o da fase",
      active: true,
      trigger: { type: defaultType, phase: phaseId },
      triggerType: defaultType,
      triggerPhase: phaseId,
      actions: []
    };
    this.showAutomationModal = true;
  }
  loadInitialForm() {
    return __async(this, null, function* () {
      try {
        const cfg = yield this.firestoreService.getInitialFormConfig(this.boardId);
        this.initialFormFields = cfg?.fields || [];
        const tempFields = this.initialFormFields.filter((f) => f.type === "temperatura" || f.name?.toLowerCase().includes("temp"));
        this.buildApiExampleFromFields();
        this.loadAvailableFilterFields();
      } catch (error) {
        this.initialFormFields = [];
        this.buildApiExampleFromFields();
      }
    });
  }
  saveInitialForm() {
    return __async(this, null, function* () {
      try {
        console.log("\u{1F4BE} saveInitialForm INICIADO");
        console.log("\u{1F4BE} this.initialFormFields antes de salvar:", this.initialFormFields);
        this.initialFormFields?.forEach((field, index) => {
          console.log(`\u{1F4BE} Campo ${index + 1} a ser salvo:`, {
            name: field.name,
            type: field.type,
            showInFilters: field.showInFilters,
            hasShowInFilters: "showInFilters" in field,
            completeField: field
          });
        });
        const dataToSave = { fields: this.initialFormFields };
        console.log("\u{1F4BE} Dados que ser\xE3o enviados ao Firestore:", dataToSave);
        yield this.firestoreService.saveInitialFormConfig(this.boardId, dataToSave);
        console.log("\u{1F4BE} Recarregando filtros ap\xF3s salvar formul\xE1rio inicial...");
        this.loadAvailableFilterFields();
        this.toast.success("Formul\xE1rio inicial salvo.");
      } catch (error) {
        console.error("\u{1F4BE} saveInitialForm ERRO:", error);
        this.toast.error("Erro ao salvar formul\xE1rio inicial.");
      }
    });
  }
  onInitialFieldsChanged(fields) {
    console.log("\u{1F504} onInitialFieldsChanged CHAMADO com:", fields);
    fields.forEach((field, index) => {
      console.log(`\u{1F504} Campo recebido ${index + 1}:`, {
        name: field.name,
        label: field.label,
        type: field.type,
        showInFilters: field.showInFilters,
        completeField: field
      });
    });
    this.initialFormFields = fields;
    console.log("\u{1F504} Recarregando filtros ap\xF3s mudan\xE7a de campos...");
    this.loadAvailableFilterFields();
    this.buildApiExampleFromFields();
  }
  buildApiExampleFromFields() {
    const body = {};
    for (const field of this.initialFormFields || []) {
      const key = field.apiFieldName && field.apiFieldName.trim() ? field.apiFieldName.trim() : field.name || "campo";
      body[key] = this.getSampleForField(field);
    }
    this.apiExampleJson = JSON.stringify(body, null, 2);
  }
  getSampleForField(field) {
    const type = (field.type || "text").toLowerCase();
    if (type === "email")
      return "email@exemplo.com";
    if (type === "tel" || type === "phone")
      return "(11) 99999-9999";
    if (type === "number")
      return 123;
    if (type === "select" && Array.isArray(field.options) && field.options.length)
      return field.options[0];
    if (type === "temperatura")
      return "Quente";
    if (type === "textarea")
      return "Texto livre";
    return "Valor de exemplo";
  }
  // Configuração de formulário da fase permanece no menu/ícone da própria fase via modal
  // Lista de usuários para o modal de detalhes
  users = [];
  // Estado para acordeão mobile
  expandedMobileColumnId = null;
  toggleMobileColumn(columnId) {
    this.expandedMobileColumnId = this.expandedMobileColumnId === columnId ? null : columnId;
  }
  isMobileColumnOpen(columnId) {
    return this.expandedMobileColumnId === columnId;
  }
  // Filtros
  filterQuery = "";
  filterOnlyMine = false;
  // Novos filtros dinâmicos baseados em campos do formulário
  dynamicFilters = {};
  availableFilterFields = [];
  showAdvancedFilters = false;
  toggleOnlyMine() {
    this.filterOnlyMine = !this.filterOnlyMine;
    this.applyFilters();
  }
  clearFilters() {
    this.filterQuery = "";
    this.filterOnlyMine = false;
    this.dynamicFilters = {};
    this.applyFilters();
  }
  // Migrar campos existentes para incluir showInFilters
  migrateFieldsToIncludeShowInFilters() {
    console.log("\u{1F527} Migrando campos para incluir showInFilters...");
    if (this.initialFormFields) {
      let needsMigration = false;
      this.initialFormFields.forEach((field) => {
        if (!("showInFilters" in field)) {
          field.showInFilters = false;
          needsMigration = true;
          console.log(`\u{1F527} Adicionado showInFilters: false ao campo ${field.name} (campo antigo)`);
        } else {
          console.log(`\u2705 Campo ${field.name} j\xE1 tem showInFilters: ${field.showInFilters}`);
        }
      });
      if (needsMigration) {
        console.log("\u{1F527} Alguns campos do formul\xE1rio inicial foram migrados em mem\xF3ria");
      } else {
        console.log("\u2705 Todos os campos do formul\xE1rio inicial j\xE1 t\xEAm showInFilters");
      }
    }
    Object.entries(this.phaseFormConfigs || {}).forEach(([phaseId, config]) => {
      if (config?.fields) {
        let needsMigration = false;
        config.fields.forEach((field) => {
          if (!("showInFilters" in field)) {
            field.showInFilters = false;
            needsMigration = true;
            console.log(`\u{1F527} Adicionado showInFilters: false ao campo ${field.name} da fase ${phaseId} (campo antigo)`);
          } else {
            console.log(`\u2705 Campo ${field.name} da fase ${phaseId} j\xE1 tem showInFilters: ${field.showInFilters}`);
          }
        });
        if (needsMigration) {
          console.log(`\u{1F527} Alguns campos da fase ${phaseId} foram migrados em mem\xF3ria`);
        } else {
          console.log(`\u2705 Todos os campos da fase ${phaseId} j\xE1 t\xEAm showInFilters`);
        }
      }
    });
  }
  // Carregar campos disponíveis para filtro
  loadAvailableFilterFields() {
    console.log("\u{1F50D} loadAvailableFilterFields INICIADO");
    console.log("\u{1F50D} initialFormFields:", this.initialFormFields);
    console.log("\u{1F50D} phaseFormConfigs:", this.phaseFormConfigs);
    this.migrateFieldsToIncludeShowInFilters();
    const allFields = [];
    if (this.initialFormFields) {
      console.log("\u{1F50D} Processando campos do formul\xE1rio inicial...");
      this.initialFormFields.forEach((field, index) => {
        console.log(`\u{1F50D} Campo inicial ${index + 1}:`, field);
        console.log(`\u{1F50D} Campo inicial ${index + 1} - Detalhes:`, {
          name: field.name,
          type: field.type,
          showInFilters: field.showInFilters,
          hasShowInFilters: "showInFilters" in field,
          keys: Object.keys(field)
        });
        if (field.name && field.type && field.showInFilters) {
          const filterField = {
            name: field.name,
            label: field.label || field.name,
            type: field.type,
            source: "initial"
          };
          allFields.push(filterField);
          console.log("\u2705 Campo adicionado aos filtros:", filterField);
        } else {
          console.log("\u274C Campo N\xC3O adicionado aos filtros (falta name, type ou showInFilters = false)");
        }
      });
    } else {
      console.log("\u26A0\uFE0F Nenhum initialFormFields encontrado");
    }
    console.log("\u{1F50D} Processando campos das fases...");
    Object.entries(this.phaseFormConfigs || {}).forEach(([phaseId, config]) => {
      console.log(`\u{1F50D} Fase ${phaseId}:`, config);
      if (config?.fields) {
        config.fields.forEach((field, index) => {
          console.log(`\u{1F50D} Campo da fase ${phaseId} - ${index + 1}:`, field);
          console.log(`\u{1F50D} Campo da fase ${phaseId} - ${index + 1} - Detalhes:`, {
            name: field.name,
            type: field.type,
            showInFilters: field.showInFilters,
            hasShowInFilters: "showInFilters" in field,
            keys: Object.keys(field)
          });
          if (field.name && field.type && field.showInFilters && !allFields.find((f) => f.name === field.name)) {
            const filterField = {
              name: field.name,
              label: field.label || field.name,
              type: field.type,
              source: "phase",
              phaseId
            };
            allFields.push(filterField);
            console.log("\u2705 Campo da fase adicionado aos filtros:", filterField);
          } else {
            console.log("\u274C Campo da fase N\xC3O adicionado (falta name, type, showInFilters = false, ou j\xE1 existe)");
          }
        });
      }
    });
    console.log("\u{1F50D} Todos os campos coletados:", allFields);
    this.availableFilterFields = allFields.filter((field) => {
      const supportedTypes = ["text", "email", "select", "radio", "checkbox", "date", "number", "tel", "cnpj", "cpf", "temperatura"];
      const isSupported = supportedTypes.includes(field.type.toLowerCase());
      console.log(`\u{1F50D} Campo ${field.name} (${field.type}) - Suportado: ${isSupported}`);
      return isSupported;
    });
    console.log("\u{1F50D} Campos filtrados finais (availableFilterFields):", this.availableFilterFields);
    console.log("\u{1F50D} availableFilterFields.length:", this.availableFilterFields.length);
    console.log("\u{1F50D} showAdvancedFilters:", this.showAdvancedFilters);
  }
  // Obter opções disponíveis para um campo
  getFieldOptions(field) {
    if (field.type === "select" || field.type === "radio") {
      const originalField = this.findOriginalField(field.name, field.source);
      if (originalField && originalField.options && Array.isArray(originalField.options)) {
        return originalField.options;
      }
    }
    if (field.type === "temperatura") {
      const originalField = this.findOriginalField(field.name, field.source);
      if (originalField && originalField.options && Array.isArray(originalField.options)) {
        return originalField.options;
      }
      return ["Quente", "Morno", "Frio"];
    }
    return this.getUniqueValuesFromLeads(field.name);
  }
  // Encontrar campo original baseado no nome e fonte
  findOriginalField(fieldName, source) {
    if (source === "initial") {
      return this.initialFormFields?.find((f) => f.name === fieldName);
    } else if (source === "phase") {
      for (const config of Object.values(this.phaseFormConfigs || {})) {
        const field = config?.fields?.find((f) => f.name === fieldName);
        if (field)
          return field;
      }
    }
    return null;
  }
  // Buscar valores únicos de um campo nos leads
  getUniqueValuesFromLeads(fieldName) {
    const values = /* @__PURE__ */ new Set();
    this.leads.forEach((lead) => {
      const value = this.getLeadFieldValue(lead, fieldName);
      if (value != null && value !== "") {
        values.add(String(value));
      }
    });
    return Array.from(values).sort();
  }
  leadMatchesFilters(lead) {
    if (this.filterOnlyMine) {
      const currentUserEmail = this.currentUser?.email;
      const currentUserId = this.currentUser?.uid;
      const leadResponsibleEmail = lead.responsibleUserEmail;
      const leadResponsibleId = lead.responsibleUserId;
      const isAssignedToMe = currentUserEmail && leadResponsibleEmail && leadResponsibleEmail.toLowerCase() === currentUserEmail.toLowerCase() || currentUserId && leadResponsibleId && leadResponsibleId === currentUserId;
      if (!isAssignedToMe)
        return false;
    }
    if (this.filterQuery && this.filterQuery.trim()) {
      const q = this.filterQuery.toLowerCase().trim();
      const fields = lead.fields || {};
      const searchableFields = [
        // Fixed lead properties
        lead.responsibleUserName,
        lead.responsibleUserEmail
      ];
      if (fields && typeof fields === "object") {
        Object.values(fields).forEach((value) => {
          if (value != null && value !== "") {
            searchableFields.push(String(value));
          }
        });
      }
      if (lead.phaseHistory && typeof lead.phaseHistory === "object") {
        Object.values(lead.phaseHistory).forEach((phaseData) => {
          if (phaseData && typeof phaseData === "object") {
            Object.values(phaseData).forEach((value) => {
              if (value != null && value !== "") {
                searchableFields.push(String(value));
              }
            });
          }
        });
      }
      const haystack = searchableFields.filter((field) => field != null && field !== "").map((field) => String(field).toLowerCase()).join(" ");
      const queryWords = q.split(" ").filter((word) => word.length > 0);
      const matchesAll = queryWords.every((word) => haystack.includes(word));
      if (!matchesAll)
        return false;
    }
    for (const [fieldName, filterValue] of Object.entries(this.dynamicFilters)) {
      if (!filterValue || filterValue === "")
        continue;
      const leadValue = this.getLeadFieldValue(lead, fieldName);
      if (leadValue === void 0 || leadValue === null || leadValue === "") {
        return false;
      }
      const field = this.availableFilterFields.find((f) => f.name === fieldName);
      if (!field)
        continue;
      if (!this.matchesDynamicFilter(leadValue, filterValue, field.type)) {
        return false;
      }
    }
    return true;
  }
  // Obter valor de um campo específico do lead
  getLeadFieldValue(lead, fieldName) {
    if (!lead || !fieldName)
      return void 0;
    if (lead.fields && lead.fields[fieldName] !== void 0) {
      return lead.fields[fieldName];
    }
    if (lead.phaseHistory) {
      for (const [phaseId, phaseData] of Object.entries(lead.phaseHistory)) {
        if (phaseData && typeof phaseData === "object" && phaseData[fieldName] !== void 0) {
          return phaseData[fieldName];
        }
      }
    }
    const leadAsAny = lead;
    if (leadAsAny[fieldName] !== void 0) {
      return leadAsAny[fieldName];
    }
    return void 0;
  }
  // Verificar se um valor corresponde ao filtro dinâmico
  matchesDynamicFilter(leadValue, filterValue, fieldType) {
    if (!leadValue && !filterValue)
      return true;
    if (!leadValue || !filterValue)
      return false;
    const leadStr = String(leadValue).toLowerCase();
    const filterStr = String(filterValue).toLowerCase();
    switch (fieldType.toLowerCase()) {
      case "text":
      case "email":
      case "tel":
        return leadStr.includes(filterStr);
      case "select":
      case "radio":
        return leadStr === filterStr;
      case "checkbox":
        return filterValue === true ? leadValue === true || leadValue === "true" || leadValue === "on" : true;
      case "number":
        const leadNum = parseFloat(leadValue);
        const filterNum = parseFloat(filterValue);
        return !isNaN(leadNum) && !isNaN(filterNum) && leadNum === filterNum;
      case "date":
        try {
          const leadDate = new Date(leadValue).toDateString();
          const filterDate = new Date(filterValue).toDateString();
          return leadDate === filterDate;
        } catch {
          return false;
        }
      default:
        return leadStr.includes(filterStr);
    }
  }
  /**
   * Apply filters and update the displayed leads
   */
  applyFilters() {
    this.rebuildDisplayedLeads();
    this.cdr.detectChanges();
    this.saveFilterState();
  }
  /**
   * Save filter state to localStorage
   */
  saveFilterState() {
    if (!this.boardId)
      return;
    try {
      const filterState = {
        filterQuery: this.filterQuery,
        filterOnlyMine: this.filterOnlyMine,
        dynamicFilters: this.dynamicFilters
      };
      localStorage.setItem(`kanban-filters-${this.boardId}`, JSON.stringify(filterState));
    } catch (error) {
      console.warn("Could not save filter state to localStorage:", error);
    }
  }
  /**
   * Load filter state from localStorage
   */
  loadFilterState() {
    if (!this.boardId)
      return;
    try {
      const saved = localStorage.getItem(`kanban-filters-${this.boardId}`);
      if (saved) {
        const filterState = JSON.parse(saved);
        this.filterQuery = filterState.filterQuery || "";
        this.filterOnlyMine = filterState.filterOnlyMine || false;
        this.dynamicFilters = filterState.dynamicFilters || {};
      }
    } catch (error) {
      console.warn("Could not load filter state from localStorage:", error);
    }
  }
  /**
   * Check if any filters are active
   */
  hasActiveFilters() {
    const hasDynamicFilters = Object.keys(this.dynamicFilters).some((key) => this.dynamicFilters[key] && this.dynamicFilters[key] !== "");
    return !!(this.filterQuery || this.filterOnlyMine || hasDynamicFilters);
  }
  // Métodos para filtros dinâmicos
  setDynamicFilter(fieldName, value) {
    if (value === null || value === void 0 || value === "") {
      delete this.dynamicFilters[fieldName];
    } else {
      this.dynamicFilters[fieldName] = value;
    }
    this.applyFilters();
  }
  onDynamicFilterChange(fieldName, event) {
    const value = event.target.value;
    this.setDynamicFilter(fieldName, value);
  }
  getDynamicFilterValue(fieldName) {
    return this.dynamicFilters[fieldName] || "";
  }
  removeDynamicFilter(fieldName) {
    delete this.dynamicFilters[fieldName];
    this.applyFilters();
  }
  getActiveDynamicFiltersCount() {
    return Object.keys(this.dynamicFilters).filter((key) => this.dynamicFilters[key] && this.dynamicFilters[key] !== "").length;
  }
  // (mantido apenas a versão acima)
  // Métodos para Caixa de Saída
  updateEmailStatusCounts() {
    const statusCounts = {
      all: this.outboxEmails.length,
      scheduled: this.outboxEmails.filter((email) => !email.delivery || email.delivery.state === "PENDING").length,
      success: this.outboxEmails.filter((email) => email.delivery?.state === "SUCCESS").length,
      error: this.outboxEmails.filter((email) => email.delivery?.state === "ERROR").length
    };
    this.emailStatuses = [
      { id: "all", name: "Todos", count: statusCounts.all },
      { id: "scheduled", name: "Na Fila", count: statusCounts.scheduled },
      { id: "success", name: "Enviados", count: statusCounts.success },
      { id: "error", name: "Com Erro", count: statusCounts.error }
    ];
  }
  getFilteredEmails() {
    if (this.activeEmailStatus === "all") {
      return this.outboxEmails;
    }
    return this.outboxEmails.filter((email) => {
      switch (this.activeEmailStatus) {
        case "scheduled":
          return !email.delivery || email.delivery.state === "PENDING";
        case "success":
          return email.delivery?.state === "SUCCESS";
        case "error":
          return email.delivery?.state === "ERROR";
        default:
          return false;
      }
    });
  }
  getEmailStatusLabel(email) {
    if (!email.delivery) {
      return "Na Fila";
    }
    switch (email.delivery.state) {
      case "SUCCESS":
        return "Enviado";
      case "ERROR":
        return "Erro";
      case "PENDING":
        return "Na Fila";
      default:
        return email.delivery.state || "Desconhecido";
    }
  }
  viewEmail(email) {
    const sentAt = email.delivery?.endTime ? new Date(email.delivery.endTime.seconds * 1e3).toLocaleString("pt-BR") : "---";
    const createdAt = email.createdAt ? new Date(email.createdAt.seconds * 1e3).toLocaleString("pt-BR") : "---";
    alert(`Visualizar Email:

Para: ${email.to || "N\xE3o especificado"}
Assunto: ${email.subject || "Sem assunto"}
Status: ${this.getEmailStatusLabel(email)}
Criado em: ${createdAt}
Enviado em: ${sentAt}

Conte\xFAdo:
${email.html || email.text || "Sem conte\xFAdo dispon\xEDvel"}`);
  }
  retryEmail(email) {
    return __async(this, null, function* () {
      try {
        yield this.firestoreService.updateOutboxEmail(this.ownerId, this.boardId, email.id, {
          status: "scheduled",
          scheduledAt: /* @__PURE__ */ new Date(),
          retryCount: (email.retryCount || 0) + 1
        });
        console.log("Email reagendado para reenvio");
        try {
          this.toast.success("Email reagendado para reenvio.");
        } catch {
        }
      } catch (error) {
        console.error("Erro ao reenviar email:", error);
        try {
          this.toast.error("Erro ao reenviar email. Tente novamente.");
        } catch {
        }
      }
    });
  }
  // Outbox delete confirmation modal
  showOutboxDeleteConfirm = false;
  emailPendingDelete = null;
  openOutboxDeleteConfirm(email, event) {
    if (event) {
      event.preventDefault();
      event.stopPropagation();
    }
    this.emailPendingDelete = email;
    this.showOutboxDeleteConfirm = true;
  }
  cancelOutboxDelete() {
    this.showOutboxDeleteConfirm = false;
    this.emailPendingDelete = null;
  }
  confirmOutboxDelete() {
    return __async(this, null, function* () {
      if (!this.emailPendingDelete)
        return;
      try {
        const email = this.emailPendingDelete;
        yield this.firestoreService.deleteOutboxEmail(this.ownerId, this.boardId, email.id);
        console.log("Email exclu\xEDdo com sucesso");
        try {
          this.toast.success("Mensagem exclu\xEDda.");
        } catch {
        }
      } catch (error) {
        console.error("Erro ao excluir email:", error);
        try {
          this.toast.error("Erro ao excluir mensagem. Tente novamente.");
        } catch {
        }
      } finally {
        this.cancelOutboxDelete();
      }
    });
  }
  // Métodos para gerenciar colunas
  showCreateColumnModal() {
    this.columnModal.showCreateModal();
  }
  editColumn(column) {
    this.columnModal.showEditModal(column);
  }
  onPhaseCardClick(phaseId, evt) {
    const col = this.getColumnById(phaseId);
    if (col) {
      this.editColumn(col);
    }
  }
  deleteColumn(column) {
    return __async(this, null, function* () {
      if (confirm(`Tem certeza que deseja excluir a fase "${column.name}"? Esta a\xE7\xE3o n\xE3o pode ser desfeita.`)) {
        try {
          yield this.firestoreService.deleteColumn(this.ownerId, this.boardId, column.id);
          console.log("Fase exclu\xEDda com sucesso");
        } catch (error) {
          console.error("Erro ao excluir fase:", error);
          alert("Erro ao excluir fase. Tente novamente.");
        }
      }
    });
  }
  onColumnCreated() {
    console.log("Nova fase criada!");
  }
  onColumnUpdated() {
    console.log("Fase atualizada!");
  }
  onColumnDeleted() {
    console.log("Fase exclu\xEDda!");
    try {
      this.syncFlowOrderWithColumns();
      this.updateFlowThumb();
    } catch {
    }
  }
  // Métodos para debugging de drag
  onDragEntered() {
    console.log("\u{1F504} Drag entered flow area");
  }
  onDragExited() {
    console.log("\u{1F504} Drag exited flow area");
  }
  onDragStarted(phaseId) {
    const phaseName = this.getColumnById(phaseId)?.name;
    const currentIndex = this.flowOrder.indexOf(phaseId);
    console.log("\u{1F504} Drag started for phase:", phaseName, "at index:", currentIndex);
  }
  onDragEnded(phaseId) {
    console.log("\u{1F504} Drag ended for phase:", this.getColumnById(phaseId)?.name);
  }
  // Funções de reordenação com botões
  movePhaseUp(currentIndex, event) {
    return __async(this, null, function* () {
      event.stopPropagation();
      if (currentIndex <= 0)
        return;
      console.log("\u2B05\uFE0F Movendo fase para esquerda:", {
        from: currentIndex,
        to: currentIndex - 1,
        phaseName: this.getColumnById(this.flowOrder[currentIndex])?.name
      });
      yield this.movePhase(currentIndex, currentIndex - 1);
    });
  }
  movePhaseDown(currentIndex, event) {
    return __async(this, null, function* () {
      event.stopPropagation();
      if (currentIndex >= this.flowOrder.length - 1)
        return;
      console.log("\u27A1\uFE0F Movendo fase para direita:", {
        from: currentIndex,
        to: currentIndex + 1,
        phaseName: this.getColumnById(this.flowOrder[currentIndex])?.name
      });
      yield this.movePhase(currentIndex, currentIndex + 1);
    });
  }
  movePhase(fromIndex, toIndex) {
    return __async(this, null, function* () {
      this.isManualReorder = true;
      const originalOrder = [...this.flowOrder];
      const movedPhase = this.flowOrder.splice(fromIndex, 1)[0];
      this.flowOrder.splice(toIndex, 0, movedPhase);
      console.log("\u{1F504} Movimento executado:", {
        originalOrder: originalOrder.map((id, i) => `${i}: ${this.getColumnById(id)?.name}`),
        newOrder: this.flowOrder.map((id, i) => `${i}: ${this.getColumnById(id)?.name}`)
      });
      this.cdr.detectChanges();
      try {
        const updatePromises = this.flowOrder.map((columnId, newIndex) => __async(this, null, function* () {
          const column = this.columns.find((c) => c.id === columnId);
          if (column && column.order !== newIndex) {
            console.log(`\u{1F4BE} Salvando ${column.name} na posi\xE7\xE3o ${newIndex}`);
            yield this.firestoreService.updateColumn(this.ownerId, this.boardId, columnId, { order: newIndex });
            column.order = newIndex;
          }
        }));
        yield Promise.all(updatePromises);
        console.log("\u2705 Reordena\xE7\xE3o salva com sucesso!");
        setTimeout(() => {
          this.isManualReorder = false;
        }, 500);
      } catch (error) {
        console.error("\u274C Erro ao salvar reordena\xE7\xE3o:", error);
        this.flowOrder = originalOrder;
        this.isManualReorder = false;
        this.cdr.detectChanges();
      }
    });
  }
  showColumnForm(column) {
    return __async(this, null, function* () {
      try {
        const existingConfig = yield this.firestoreService.getPhaseFormConfig(this.ownerId, this.boardId, column.id);
        this.phaseFormModal.showModal(column, existingConfig || void 0);
      } catch (error) {
        console.error("Erro ao carregar configura\xE7\xE3o do formul\xE1rio:", error);
        this.phaseFormModal.showModal(column, void 0);
      }
    });
  }
  onPhaseFormConfigSaved() {
    console.log("Configura\xE7\xE3o de formul\xE1rio salva! Recarregando campos de card por fase...");
    this.loadCardFieldConfigs();
    try {
      this.toast.success("Configura\xE7\xE3o salva. Cards atualizados.");
    } catch {
    }
  }
  // Métodos para SLA
  getSlaStatus(lead) {
    const column = this.columns.find((col) => col.id === lead.columnId);
    if (!column || !column.slaDays || column.slaDays <= 0 || !lead.movedToCurrentColumnAt) {
      return { status: "none", text: "", colorClass: "", borderClass: "" };
    }
    const movedDate = lead.movedToCurrentColumnAt.seconds ? new Date(lead.movedToCurrentColumnAt.seconds * 1e3) : new Date(lead.movedToCurrentColumnAt);
    const now = /* @__PURE__ */ new Date();
    const slaDeadline = new Date(movedDate.getTime() + column.slaDays * 24 * 60 * 60 * 1e3);
    const diffMillis = slaDeadline.getTime() - now.getTime();
    const diffDays = diffMillis / (1e3 * 60 * 60 * 24);
    if (diffDays < 0) {
      const overdueDays = Math.abs(Math.floor(diffDays));
      return {
        status: "overdue",
        text: `Atrasado ${overdueDays}d`,
        colorClass: "text-red-600",
        borderClass: "border-l-red-500"
      };
    } else if (diffDays < column.slaDays * 0.25) {
      const remainingHours = Math.ceil(diffMillis / (1e3 * 60 * 60));
      return {
        status: "at-risk",
        text: `${remainingHours}h restantes`,
        colorClass: "text-yellow-600",
        borderClass: "border-l-yellow-500"
      };
    } else {
      const remainingDays = Math.ceil(diffDays);
      return {
        status: "ok",
        text: `${remainingDays}d restantes`,
        colorClass: "text-green-600",
        borderClass: "border-l-green-500"
      };
    }
  }
  getLeadStatusColor(lead) {
    const temperature = lead.fields?.["temperature"];
    if (temperature === "quente")
      return "bg-red-100 text-red-800";
    if (temperature === "morno")
      return "bg-yellow-100 text-yellow-800";
    return "bg-blue-100 text-blue-800";
  }
  // Cor do ícone de temperatura para valores dinâmicos (ex.: 'Quente', 'Morno', 'Frio')
  getTemperatureColorClass(value) {
    const norm = /* @__PURE__ */ __name((v) => v.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, ""), "norm");
    const s = norm(String(value || ""));
    if (s.includes("quente") || s.includes("hot"))
      return "text-red-600";
    if (s.includes("morno") || s.includes("morna") || s.includes("warm"))
      return "text-yellow-600";
    if (s.includes("frio") || s.includes("fria") || s.includes("cold"))
      return "text-blue-600";
    return "text-blue-600";
  }
  // Helpers para layout mobile
  getDaysSince(dateLike) {
    if (!dateLike)
      return 0;
    let d;
    if (dateLike.seconds)
      d = new Date(dateLike.seconds * 1e3);
    else if (dateLike.toDate)
      d = dateLike.toDate();
    else if (dateLike instanceof Date)
      d = dateLike;
    else
      d = new Date(dateLike);
    const diffMs = Date.now() - d.getTime();
    return Math.max(0, Math.floor(diffMs / (1e3 * 60 * 60 * 24)));
  }
  getLeadResponsibleName(lead) {
    return (lead.responsibleUserName || lead.responsibleUserEmail || "").toString();
  }
  getLeadDueDateLabel(lead) {
    const due = lead.fields?.dueDate || lead.dueDate;
    if (!due)
      return null;
    try {
      if (due.seconds)
        return new Date(due.seconds * 1e3).toLocaleDateString("pt-BR");
      if (due.toDate)
        return due.toDate().toLocaleDateString("pt-BR");
      const d = new Date(due);
      return isNaN(d.getTime()) ? null : d.toLocaleDateString("pt-BR");
    } catch {
      return null;
    }
  }
  // Métodos para Templates e Automações
  getTriggerDescription(automationOrTrigger) {
    if (!automationOrTrigger)
      return "N\xE3o especificado";
    const trigger = automationOrTrigger.trigger ? automationOrTrigger.trigger : automationOrTrigger;
    const descriptions = {
      "new-lead-created": "Quando um novo lead \xE9 criado",
      "card-enters-phase": "Quando lead entra em uma fase",
      "card-in-phase-for-time": "Quando lead fica muito tempo na fase",
      "form-not-answered": "Quando formul\xE1rio n\xE3o \xE9 respondido",
      "sla-overdue": "Quando SLA da fase vence"
    };
    const type = trigger.type || automationOrTrigger.triggerType;
    let description = descriptions[type] || type || "N\xE3o especificado";
    const phaseId = trigger.phase || automationOrTrigger.triggerPhase;
    if (phaseId && this.columns.length > 0) {
      const column = this.columns.find((col) => col.id === phaseId);
      if (column)
        description += ` (${column.name})`;
    }
    const days = trigger.days || automationOrTrigger.triggerDays;
    if (days)
      description += ` (${days} dias)`;
    return description;
  }
  toggleAutomationStatus(automationId, currentStatus) {
    return __async(this, null, function* () {
      try {
        yield this.firestoreService.updateAutomation(this.ownerId, this.boardId, automationId, { active: !currentStatus });
      } catch (error) {
        console.error("Erro ao alterar status da automa\xE7\xE3o:", error);
      }
    });
  }
  // Modal de exclusão de automação
  showAutomationDeleteConfirm = false;
  automationPendingDelete = null;
  openDeleteAutomationConfirm(automation, event) {
    if (event) {
      event.preventDefault();
      event.stopPropagation();
    }
    this.automationPendingDelete = automation;
    this.showAutomationDeleteConfirm = true;
  }
  cancelDeleteAutomation() {
    this.showAutomationDeleteConfirm = false;
    this.automationPendingDelete = null;
  }
  confirmDeleteAutomation() {
    return __async(this, null, function* () {
      if (!this.automationPendingDelete)
        return;
      try {
        const pending = this.automationPendingDelete;
        const autoId = pending?.id || pending?.docId || (pending?.path ? String(pending.path).split("/").pop() : null);
        if (!autoId) {
          console.error("Automa\xE7\xE3o sem id para exclus\xE3o:", pending);
          this.toast.error("N\xE3o foi poss\xEDvel identificar esta automa\xE7\xE3o. Atualize a p\xE1gina e tente novamente.");
          return;
        }
        yield this.firestoreService.deleteAutomation(this.ownerId, this.boardId, autoId);
        this.toast.success("Automa\xE7\xE3o exclu\xEDda.");
      } catch (error) {
        console.error("Erro ao excluir automa\xE7\xE3o:", error);
        this.toast.error("Erro ao excluir automa\xE7\xE3o.");
      } finally {
        this.cancelDeleteAutomation();
      }
    });
  }
  toggleAutomation(automation) {
    this.toggleAutomationStatus(automation.id, automation.active);
  }
  getActionsCount(actions) {
    return actions ? actions.length : 0;
  }
  getValidAutomations() {
    return this.automations.filter((automation) => automation && automation.name && automation.name.trim() !== "" && automation.name !== "Automa\xE7\xE3o sem nome");
  }
  cleanupInvalidAutomations() {
    return __async(this, null, function* () {
      const invalidAutomations = this.automations.filter((automation) => !automation || !automation.name || automation.name.trim() === "" || automation.name === "Automa\xE7\xE3o sem nome");
      if (invalidAutomations.length > 0) {
        for (const invalidAutomation of invalidAutomations) {
          if (invalidAutomation.id) {
            try {
              yield this.firestoreService.deleteAutomation(this.ownerId, this.boardId, invalidAutomation.id);
            } catch (error) {
              console.error("Erro ao remover automa\xE7\xE3o inv\xE1lida:", error);
            }
          }
        }
      }
    });
  }
  // Métodos para Templates
  createTemplate() {
    this.templateModal.showCreateModal();
  }
  editTemplate(template) {
    this.templateModal.showEditModal(template);
  }
  deleteTemplate(template) {
    return __async(this, null, function* () {
      if (confirm("Tem certeza que deseja excluir este template?")) {
        try {
          yield this.firestoreService.deleteEmailTemplate(this.ownerId, this.boardId, template.id);
          console.log("Template exclu\xEDdo com sucesso!");
        } catch (error) {
          console.error("Erro ao excluir template:", error);
        }
      }
    });
  }
  onTemplateSaved() {
  }
  // Variáveis para o modal de automação
  showAutomationModal = false;
  selectedAutomation = null;
  // Variáveis para o modal de histórico
  showHistoryModal = false;
  selectedAutomationForHistory = null;
  // Métodos para Automações
  createAutomation(event) {
    if (event) {
      event.preventDefault();
      event.stopPropagation();
    }
    console.log("=== BOT\xC3O NOVA AUTOMA\xC7\xC3O CLICADO ===");
    this.selectedAutomation = null;
    this.showAutomationModal = true;
  }
  editAutomation(automation, event) {
    if (event) {
      event.preventDefault();
      event.stopPropagation();
    }
    this.selectedAutomation = JSON.parse(JSON.stringify(automation));
    this.showAutomationModal = true;
  }
  onCloseAutomationModal() {
    this.showAutomationModal = false;
    this.selectedAutomation = null;
  }
  onSaveAutomation(automationData) {
    return __async(this, null, function* () {
      try {
        const sanitize = /* @__PURE__ */ __name((obj) => {
          const out = {};
          Object.keys(obj || {}).forEach((k) => {
            const v = obj[k];
            if (v !== void 0)
              out[k] = v;
          });
          return out;
        }, "sanitize");
        const payload = sanitize(__spreadValues({}, automationData));
        delete payload.id;
        if (Array.isArray(payload.actions)) {
          payload.actions = payload.actions.map((a) => sanitize(a));
        }
        if (automationData.id) {
          yield this.firestoreService.updateAutomation(this.ownerId, this.boardId, automationData.id, payload);
        } else {
          yield this.firestoreService.createAutomation(this.ownerId, this.boardId, payload);
        }
        this.toast.success("Automa\xE7\xE3o salva com sucesso.");
        this.onCloseAutomationModal();
      } catch (error) {
        console.error("Erro ao salvar automa\xE7\xE3o:", error);
        this.toast.error("Erro ao salvar automa\xE7\xE3o. Tente novamente.");
      }
    });
  }
  showAutomationHistory(automation, event) {
    if (event) {
      event.preventDefault();
      event.stopPropagation();
    }
    this.selectedAutomationForHistory = automation;
    this.showHistoryModal = true;
  }
  onCloseHistoryModal() {
    this.showHistoryModal = false;
    this.selectedAutomationForHistory = null;
  }
  // Outbox Methods
  clearOutbox() {
    return __async(this, null, function* () {
      if (confirm("Deseja excluir todos os emails da caixa de sa\xEDda? Esta a\xE7\xE3o n\xE3o pode ser desfeita.")) {
        try {
          yield this.firestoreService.clearOutboxEmails(this.ownerId, this.boardId);
          console.log("\u2705 Caixa de sa\xEDda limpa com sucesso");
        } catch (error) {
          console.error("\u274C Erro ao limpar caixa de sa\xEDda:", error);
          alert("Erro ao limpar caixa de sa\xEDda. Tente novamente.");
        }
      }
    });
  }
  // Filter Methods
  onFilterQueryChange(query) {
    this.filterQuery = query;
    this.applyFilters();
  }
  toggleAdvancedFilters() {
    this.showAdvancedFilters = !this.showAdvancedFilters;
  }
  getDynamicFilterCount() {
    return Object.keys(this.dynamicFilters).filter((key) => this.dynamicFilters[key] && this.dynamicFilters[key] !== "").length;
  }
  // API Methods
  copyToClipboard(text) {
    navigator.clipboard.writeText(text).then(() => {
      console.log("Texto copiado:", text);
    }).catch((err) => {
      console.error("Erro ao copiar texto:", err);
    });
  }
};
__name(_KanbanComponent, "KanbanComponent");
__publicField(_KanbanComponent, "\u0275fac", /* @__PURE__ */ __name(function KanbanComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _KanbanComponent)();
}, "KanbanComponent_Factory"));
__publicField(_KanbanComponent, "\u0275cmp", /* @__PURE__ */ \u0275\u0275defineComponent({ type: _KanbanComponent, selectors: [["app-kanban"]], viewQuery: /* @__PURE__ */ __name(function KanbanComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(LeadModalComponent, 5);
    \u0275\u0275viewQuery(ColumnModalComponent, 5);
    \u0275\u0275viewQuery(PhaseFormModalComponent, 5);
    \u0275\u0275viewQuery(LeadDetailModalComponent, 5);
    \u0275\u0275viewQuery(TemplateModalComponent, 5);
    \u0275\u0275viewQuery(AutomationModal, 5);
    \u0275\u0275viewQuery(_c07, 5);
  }
  if (rf & 2) {
    let _t;
    \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.leadModal = _t.first);
    \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.columnModal = _t.first);
    \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.phaseFormModal = _t.first);
    \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.leadDetailModal = _t.first);
    \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.templateModal = _t.first);
    \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.automationModal = _t.first);
    \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.flowScrollerRef = _t.first);
  }
}, "KanbanComponent_Query"), hostBindings: /* @__PURE__ */ __name(function KanbanComponent_HostBindings(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275listener("mouseup", /* @__PURE__ */ __name(function KanbanComponent_mouseup_HostBindingHandler($event) {
      return ctx.onWindowMouseUp($event);
    }, "KanbanComponent_mouseup_HostBindingHandler"), \u0275\u0275resolveWindow)("touchend", /* @__PURE__ */ __name(function KanbanComponent_touchend_HostBindingHandler($event) {
      return ctx.onWindowTouchEnd($event);
    }, "KanbanComponent_touchend_HostBindingHandler"), \u0275\u0275resolveWindow)("resize", /* @__PURE__ */ __name(function KanbanComponent_resize_HostBindingHandler() {
      return ctx.onWindowResizeFlow();
    }, "KanbanComponent_resize_HostBindingHandler"), \u0275\u0275resolveWindow);
  }
}, "KanbanComponent_HostBindings"), decls: 24, vars: 37, consts: [["flowScroller", ""], ["flowCustomBar", ""], ["noConnections", ""], ["class", "flex justify-center items-center py-20", 4, "ngIf"], ["class", "bg-white px-4 md:px-8 border-b border-gray-200 sticky top-0 z-30", 4, "ngIf"], ["class", "fixed top-20 left-4 w-full max-w-lg bg-white rounded-xl shadow-xl border border-gray-200 z-[9999]", 4, "ngIf"], ["class", "kanban-board desktop-board", 4, "ngIf"], ["class", "fixed left-4 bottom-4 z-40 bg-green-500 hover:bg-green-600 text-white px-4 py-3 rounded-full shadow-lg flex items-center gap-2", 3, "click", 4, "ngIf"], ["class", "p-4 md:p-8", 4, "ngIf"], ["class", "text-center py-20", 4, "ngIf"], ["class", "fixed inset-0 bg-black/50 flex items-center justify-center z-[60]", 3, "click", 4, "ngIf"], [4, "ngIf"], ["class", "mobile-board", 4, "ngIf"], [3, "leadCreated", "leadUpdated", "closeModal", "ownerId", "boardId", "columns"], [3, "columnCreated", "columnUpdated", "columnDeleted", "closeModal", "ownerId", "boardId", "columns"], [3, "formConfigSaved", "closeModal", "ownerId", "boardId"], [3, "leadUpdated", "leadDeleted", "closeModal", "ownerId", "boardId", "columns", "users"], [3, "templateSaved", "closeModal", "ownerId", "boardId"], [3, "isVisible", "automation", "phases", "allowedTriggerTypes", "fixedPhaseId", "allowedTransitions", "emailTemplates", "users", "closeModalEvent", "saveAutomation", 4, "ngIf"], [3, "closeModalEvent", "isVisible", "automationId", "automationName", "ownerId", "boardId", "leads"], [1, "flex", "justify-center", "items-center", "py-20"], [1, "animate-spin", "rounded-full", "h-12", "w-12", "border-b-2", "border-blue-500"], [1, "bg-white", "px-4", "md:px-8", "border-b", "border-gray-200", "sticky", "top-0", "z-30"], [1, "flex", "justify-between", "items-center"], [1, "flex", "items-center", "space-x-4"], [1, "flex", "items-center", "space-x-3"], [1, "text-gray-500", "hover:text-gray-700", "p-1", "rounded", "hover:bg-gray-100", "transition-colors", 3, "click"], [1, "fas", "fa-arrow-left"], ["class", "relative", 4, "ngIf"], [1, "hidden", "md:flex", "space-x-8"], ["class", "py-4 px-1 border-b-2 font-medium text-sm transition-colors duration-200", 3, "border-blue-500", "text-blue-600", "border-transparent", "text-gray-500", "hover:text-gray-700", "click", 4, "ngFor", "ngForOf"], [1, "hidden", "md:flex", "items-center", "space-x-2"], ["class", "px-2 py-1 bg-red-100 hover:bg-red-200 text-red-700 border border-red-300 rounded text-xs transition-colors", 3, "click", 4, "ngIf"], [1, "relative"], ["type", "text", "placeholder", "Pesquisar...", 1, "w-64", "pl-8", "pr-10", "py-1.5", "text-sm", "border", "border-gray-300", "rounded-md", "focus:ring-2", "focus:ring-blue-500", "focus:border-transparent", 3, "ngModelChange", "ngModel"], [1, "fas", "fa-search", "absolute", "left-2.5", "top-1/2", "transform", "-translate-y-1/2", "text-gray-400", "text-xs"], [1, "absolute", "right-2", "top-1/2", "transform", "-translate-y-1/2", "p-1", "hover:bg-gray-100", "rounded", "transition-colors", 3, "click"], [1, "fas", "fa-filter", "text-xs"], ["class", "absolute -top-1 -right-1 bg-blue-500 text-white text-xs rounded-full w-3 h-3 flex items-center justify-center", "style", "font-size: 8px;", 4, "ngIf"], [1, "absolute", "-top-1", "-right-1", "bg-blue-500", "text-white", "text-xs", "rounded-full", "w-3", "h-3", "flex", "items-center", "justify-center", 2, "font-size", "8px"], [1, "py-4", "px-1", "border-b-2", "font-medium", "text-sm", "transition-colors", "duration-200", 3, "click"], [1, "px-2", "py-1", "bg-red-100", "hover:bg-red-200", "text-red-700", "border", "border-red-300", "rounded", "text-xs", "transition-colors", 3, "click"], [1, "fas", "fa-times", "mr-1"], [1, "fixed", "top-20", "left-4", "w-full", "max-w-lg", "bg-white", "rounded-xl", "shadow-xl", "border", "border-gray-200", "z-[9999]"], [1, "p-6"], [1, "flex", "items-center", "justify-between", "mb-4"], [1, "text-lg", "font-semibold", "text-gray-900"], [1, "text-gray-400", "hover:text-gray-600", 3, "click"], [1, "fas", "fa-times"], [1, "mb-6", "p-3", "bg-gray-50", "rounded-lg"], [1, "flex", "items-center", "space-x-2", "cursor-pointer"], ["type", "checkbox", 1, "rounded", "border-gray-300", "text-blue-600", "focus:ring-blue-500", 3, "ngModelChange", "ngModel"], [1, "text-sm", "text-gray-700", "font-medium"], ["class", "space-y-4", 4, "ngIf"], ["class", "text-center py-6", 4, "ngIf"], [1, "flex", "justify-end", "space-x-3", "mt-6", "pt-4", "border-t", "border-gray-200"], [1, "px-4", "py-2", "text-gray-600", "bg-gray-100", "hover:bg-gray-200", "rounded-lg", "transition-colors", 3, "click"], [1, "px-4", "py-2", "bg-blue-600", "hover:bg-blue-700", "text-white", "rounded-lg", "transition-colors", 3, "click"], [1, "space-y-4"], [1, "text-sm", "font-medium", "text-gray-700", "mb-3"], ["class", "space-y-2", 4, "ngFor", "ngForOf"], [1, "space-y-2"], [1, "block", "text-sm", "font-medium", "text-gray-700"], ["class", "w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent", 3, "type", "value", "placeholder", "input", 4, "ngIf"], ["type", "date", "class", "w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent", 3, "value", "input", 4, "ngIf"], ["class", "w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent", 3, "value", "change", 4, "ngIf"], ["class", "flex items-center space-x-2", 4, "ngIf"], [1, "w-full", "px-3", "py-2", "border", "border-gray-300", "rounded-md", "focus:ring-2", "focus:ring-blue-500", "focus:border-transparent", 3, "input", "type", "value", "placeholder"], ["type", "date", 1, "w-full", "px-3", "py-2", "border", "border-gray-300", "rounded-md", "focus:ring-2", "focus:ring-blue-500", "focus:border-transparent", 3, "input", "value"], [1, "w-full", "px-3", "py-2", "border", "border-gray-300", "rounded-md", "focus:ring-2", "focus:ring-blue-500", "focus:border-transparent", 3, "change", "value"], ["value", ""], [3, "value", 4, "ngFor", "ngForOf"], [3, "value"], ["value", "Quente"], ["value", "Morno"], ["value", "Frio"], [1, "flex", "items-center", "space-x-2"], ["type", "checkbox", 1, "rounded", "border-gray-300", "text-blue-600", "focus:ring-blue-500", 3, "change", "checked"], [1, "text-sm", "text-gray-700"], [1, "text-center", "py-6"], [1, "fas", "fa-filter", "text-gray-300", "text-3xl", "mb-3"], [1, "text-gray-500", "text-sm"], [1, "kanban-board", "desktop-board"], ["class", "kanban-column", 3, "background-color", 4, "ngFor", "ngForOf"], [1, "kanban-column"], [1, "kanban-column-header"], [1, "flex", "items-center", "justify-between"], [1, "flex", "items-center"], [1, "font-semibold", "text-gray-800"], [1, "ml-2", "bg-gray-200", "text-gray-600", "text-xs", "px-2", "py-1", "rounded-full"], ["class", "ml-2 inline-flex items-center text-xs px-2 py-1 rounded-full bg-yellow-100 text-yellow-800", "title", "Automa\xE7\xF5es ativas nesta fase", 4, "ngIf"], ["cdkDropList", "", 1, "kanban-cards", 3, "cdkDropListDropped", "id", "cdkDropListData", "cdkDropListConnectedTo"], ["class", "bg-white rounded-lg shadow-sm border border-gray-200 hover:shadow-md transition-all duration-200 cursor-pointer mb-3 p-4 border-l-4", "cdkDrag", "", 3, "class", "cdkDragDisabled", "cdkDragData", "cdkDragStarted", "cdkDragEnded", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "text-center py-6 text-gray-400", 4, "ngIf"], ["title", "Automa\xE7\xF5es ativas nesta fase", 1, "ml-2", "inline-flex", "items-center", "text-xs", "px-2", "py-1", "rounded-full", "bg-yellow-100", "text-yellow-800"], [1, "fas", "fa-bolt", "mr-1"], ["cdkDrag", "", 1, "bg-white", "rounded-lg", "shadow-sm", "border", "border-gray-200", "hover:shadow-md", "transition-all", "duration-200", "cursor-pointer", "mb-3", "p-4", "border-l-4", 3, "cdkDragStarted", "cdkDragEnded", "click", "cdkDragDisabled", "cdkDragData"], [1, "flex", "items-start", "justify-between", "mb-3"], [1, "flex-1", "min-w-0"], [1, "font-semibold", "text-gray-900", "text-sm", "truncate", "mb-1"], ["class", "text-xs text-gray-500", 4, "ngIf"], [1, "space-y-2", "mb-3"], ["class", "text-xs", 4, "ngFor", "ngForOf"], ["class", "mb-3", 4, "ngIf"], [1, "flex", "items-center", "gap-3", "text-xs", "text-gray-500"], ["class", "flex items-center", 4, "ngIf"], [1, "flex", "items-center", "text-xs", "text-gray-500"], [1, "far", "fa-calendar-alt", "w-3", "h-3", "mr-1"], ["class", "mt-2 pt-2 border-t border-gray-100", 4, "ngIf"], [1, "text-xs", "text-gray-500"], [1, "text-xs"], [1, "font-medium", "text-gray-600", "mb-0.5"], [1, "text-gray-900", "truncate"], [1, "mb-3"], [1, "flex", "items-center", "text-xs", "font-medium"], [1, "fas", "fa-clock", "w-3", "h-3", "mr-1"], [1, "w-2", "h-2", "rounded-full", "mr-1", 3, "ngClass"], [1, "far", "fa-comment", "mr-1"], [1, "fas", "fa-paperclip", "mr-1"], [1, "mt-2", "pt-2", "border-t", "border-gray-100"], [1, "text-xs", "text-gray-600", "line-clamp-2"], [1, "text-center", "py-6", "text-gray-400"], [1, "fas", "fa-inbox", "text-2xl", "mb-2"], [1, "text-sm"], [1, "fixed", "left-4", "bottom-4", "z-40", "bg-green-500", "hover:bg-green-600", "text-white", "px-4", "py-3", "rounded-full", "shadow-lg", "flex", "items-center", "gap-2", 3, "click"], [1, "fas", "fa-plus"], [1, "p-4", "md:p-8"], [1, "max-w-4xl", "mx-auto"], [1, "text-2xl", "font-bold", "text-gray-900", "mb-4"], [3, "fieldsChanged", "fields"], [1, "flex", "justify-end", "mt-6"], [1, "px-4", "py-2", "text-white", "rounded-lg", 3, "click"], [1, "text-center", "py-20"], [1, "max-w-md", "mx-auto"], [1, "fas", "fa-columns", "text-6xl", "text-gray-300", "mb-4"], [1, "text-xl", "font-semibold", "text-gray-900", "mb-2"], [1, "text-gray-600"], [1, "flex", "justify-between", "items-center", "mb-6"], [1, "text-2xl", "font-bold", "text-gray-900"], [1, "bg-blue-500", "hover:bg-blue-600", "text-white", "px-4", "py-2", "rounded-lg", "font-medium", "transition-colors", 3, "click"], [1, "fas", "fa-plus", "mr-2"], ["class", "grid gap-4", 4, "ngIf"], ["class", "bg-white rounded-lg shadow p-6", 4, "ngIf"], [1, "grid", "gap-4"], ["class", "bg-white border border-gray-200 rounded-lg p-6 hover:shadow-md transition-shadow", 4, "ngFor", "ngForOf"], [1, "bg-white", "border", "border-gray-200", "rounded-lg", "p-6", "hover:shadow-md", "transition-shadow"], [1, "flex", "items-start", "justify-between"], [1, "flex-1"], [1, "text-lg", "font-semibold", "text-gray-900", "mb-2"], [1, "text-sm", "text-gray-600", "mb-3"], [1, "text-xs", "text-gray-500", "mb-4"], [1, "flex", "items-center", "text-xs", "text-gray-500", "space-x-4"], [1, "far", "fa-calendar-alt", "mr-1"], [1, "flex", "items-center", "space-x-2", "ml-4"], [1, "text-blue-600", "hover:text-blue-800", "px-3", "py-1", "text-sm", "font-medium", 3, "click"], [1, "fas", "fa-edit", "mr-1"], [1, "text-red-600", "hover:text-red-800", "px-3", "py-1", "text-sm", "font-medium", 3, "click"], [1, "fas", "fa-trash", "mr-1"], [1, "bg-white", "rounded-lg", "shadow", "p-6"], [1, "text-center", "py-12", "text-gray-500"], [1, "fas", "fa-envelope", "text-6xl", "mb-4"], [1, "text-xl", "font-semibold", "mb-2"], [1, "bg-green-500", "hover:bg-green-600", "text-white", "px-4", "py-2", "rounded-lg", "font-medium", "transition-colors", 3, "click"], [1, "flex", "items-center", "mb-2"], [1, "text-lg", "font-semibold", "text-gray-900", "mr-3"], [1, "px-2", "py-1", "text-xs", "font-medium", "rounded-full"], [1, "space-y-2", "mb-4"], [1, "text-sm", "text-gray-600"], [1, "fas", "fa-bolt", "mr-2"], [1, "fas", "fa-play", "mr-2"], ["title", "Ver Hist\xF3rico", 1, "text-gray-500", "hover:text-blue-600", "px-3", "py-1", "text-sm", "font-medium", 3, "click"], [1, "fas", "fa-history", "mr-1"], [1, "px-3", "py-1", "text-sm", "font-medium", 3, "click"], [1, "fas", "mr-1"], [1, "fas", "fa-play", "mr-1"], [1, "fas", "fa-cogs", "text-6xl", "mb-4"], [1, "w-full", "mx-auto"], [1, "flex", "items-center", "gap-2"], ["title", "Nova fase", 1, "bg-gray-400", "hover:bg-gray-500", "text-white", "px-4", "py-2", "rounded-lg", "font-medium", "transition-colors", 3, "click"], [1, "fas", "fa-save", "mr-2"], [1, "relative", "w-full"], [1, "flow-scroll"], ["cdkDropList", "", 1, "inline-flex", "items-center", "gap-6", "p-2", "whitespace-nowrap", "min-w-max", "flow-row", "w-max", 3, "cdkDropListDropped", "cdkDropListEntered", "cdkDropListExited", "cdkDropListData"], [4, "ngFor", "ngForOf"], [1, "flow-custombar", "mt-1", 3, "mousedown", "touchstart"], [1, "flow-thumb"], ["class", "mt-4 p-4 border rounded-lg bg-white shadow", 4, "ngIf"], ["cdkDrag", "", 1, "min-w-[300px]", "max-w-[340px]", "flow-phase-card", "cursor-pointer", 3, "cdkDragStarted", "cdkDragEnded", "click"], [1, "px-3", "py-2", "bg-gray-50", "rounded-t-lg", "flex", "items-center", "justify-between"], [1, "font-medium", "text-gray-800", "truncate"], ["class", "p-1 text-gray-400 hover:text-blue-600 transition-colors", "title", "Mover para esquerda", 3, "click", 4, "ngIf"], ["class", "p-1 text-gray-400 hover:text-blue-600 transition-colors", "title", "Mover para direita", 3, "click", 4, "ngIf"], ["cdkDragHandle", "", "title", "Arraste para reordenar", 1, "fas", "fa-grip-vertical", "text-gray-400"], [1, "p-3", "text-sm", "space-y-3"], ["class", "pt-0", 4, "ngIf", "ngIfElse"], [1, "pt-2", "border-t", "border-gray-100", "flex", "items-center", "justify-end", "gap-3", "text-base"], ["title", "Formul\xE1rio da fase", 1, "text-blue-600", "hover:text-blue-700", 3, "click"], [1, "fas", "fa-list-check"], ["title", "Automa\xE7\xF5es da fase", 1, "text-purple-600", "hover:text-purple-700", 3, "click"], [1, "fas", "fa-gears"], ["class", "text-indigo-600 hover:text-indigo-700", "title", "Iniciar conex\xE3o", 3, "click", 4, "ngIf"], ["class", "text-indigo-600 hover:text-indigo-700", "title", "Conectar aqui", 3, "click", 4, "ngIf"], ["title", "Mover para esquerda", 1, "p-1", "text-gray-400", "hover:text-blue-600", "transition-colors", 3, "click"], [1, "fas", "fa-chevron-left", "text-xs"], ["title", "Mover para direita", 1, "p-1", "text-gray-400", "hover:text-blue-600", "transition-colors", 3, "click"], [1, "fas", "fa-chevron-right", "text-xs"], [1, "pt-0"], [1, "text-xs", "text-gray-500", "mb-1"], [1, "space-y-1"], ["class", "flex items-center justify-between text-xs", 4, "ngFor", "ngForOf"], [1, "flex", "items-center", "justify-between", "text-xs"], [1, "truncate"], ["title", "Remover", 1, "text-red-600", "hover:text-red-700", 3, "click"], [1, "fas", "fa-xmark"], [1, "text-xs", "text-gray-400"], ["title", "Iniciar conex\xE3o", 1, "text-indigo-600", "hover:text-indigo-700", 3, "click"], [1, "fas", "fa-circle-dot"], ["title", "Conectar aqui", 1, "text-indigo-600", "hover:text-indigo-700", 3, "click"], [1, "fas", "fa-bullseye"], [1, "mt-4", "p-4", "border", "rounded-lg", "bg-white", "shadow"], [1, "flex", "justify-between", "items-center", "mb-3"], [1, "font-semibold"], [1, "text-gray-600", "hover:text-gray-900", 3, "click"], ["class", "p-3 border rounded", 4, "ngFor", "ngForOf"], [1, "pt-2"], [1, "bg-blue-500", "hover:bg-blue-600", "text-white", "px-3", "py-2", "rounded", "text-sm", 3, "click"], [1, "fas", "fa-plus", "mr-1"], [1, "p-3", "border", "rounded"], [1, "font-medium"], [1, "text-xs", "flex", "items-center", "gap-1"], ["type", "checkbox", 3, "change", "checked"], [1, "text-blue-600", "text-sm", 3, "click"], [1, "text-red-600", "text-sm", 3, "click"], [1, "fixed", "inset-0", "bg-black/50", "flex", "items-center", "justify-center", "z-[60]", 3, "click"], [1, "bg-white", "rounded-xl", "shadow-2xl", "w-full", "max-w-md", "p-6", 3, "click"], [1, "text-lg", "font-bold", "text-gray-900", "mb-2"], [1, "text-sm", "text-gray-600", "mb-6"], [1, "flex", "justify-end", "gap-3"], [1, "px-4", "py-2", "rounded-lg", "border", "border-gray-300", 3, "click"], [1, "px-4", "py-2", "rounded-lg", "bg-red-600", "text-white", 3, "click"], [3, "boardId", "ownerId"], [1, "max-w-6xl", "mx-auto"], [1, "flex", "space-x-2"], [1, "bg-red-500", "hover:bg-red-600", "text-white", "px-4", "py-2", "rounded-lg", "font-medium", "transition-colors", 3, "click"], [1, "fas", "fa-trash", "mr-2"], [1, "bg-white", "rounded-lg", "shadow"], [1, "border-b", "border-gray-200"], [1, "flex", "space-x-8", "px-6"], ["class", "py-4 px-1 border-b-2 font-medium text-sm transition-colors duration-200", 3, "border-blue-500", "text-blue-600", "border-transparent", "text-gray-500", "click", 4, "ngFor", "ngForOf"], ["class", "text-center py-12 text-gray-500", 4, "ngIf"], [1, "fas", "fa-paper-plane", "text-6xl", "mb-4"], ["class", "border border-gray-200 rounded-lg p-4 hover:bg-gray-50 transition-colors", 4, "ngFor", "ngForOf"], [1, "border", "border-gray-200", "rounded-lg", "p-4", "hover:bg-gray-50", "transition-colors"], [1, "w-3", "h-3", "rounded-full"], [1, "font-medium", "text-gray-900"], [1, "px-2", "py-1", "text-xs", "rounded-full"], [1, "mt-2", "flex", "items-center", "space-x-4", "text-sm", "text-gray-500"], [1, "fas", "fa-envelope", "mr-1"], [1, "fas", "fa-clock", "mr-1"], [1, "text-blue-600", "hover:text-blue-800", 3, "click"], [1, "fas", "fa-eye"], ["class", "text-green-600 hover:text-green-800", 3, "click", 4, "ngIf"], [1, "text-red-600", "hover:text-red-800", 3, "click"], [1, "fas", "fa-trash"], [1, "text-green-600", "hover:text-green-800", 3, "click"], [1, "fas", "fa-redo"], [1, "px-2", "py-1", "bg-green-100", "text-green-800", "text-xs", "font-medium", "rounded"], [1, "fas", "fa-check-circle", "mr-1"], [1, "bg-white", "rounded-lg", "shadow", "mb-6"], [1, "p-6", "border-b", "border-gray-200"], [1, "fas", "fa-link", "mr-2", "text-blue-500"], [1, "text-sm", "text-gray-600", "mb-4"], [1, "bg-gray-50", "border", "border-gray-200", "rounded-lg", "p-4"], [1, "flex", "items-center", "justify-between", "mb-2"], [1, "text-sm", "font-medium", "text-gray-700"], [1, "text-blue-600", "hover:text-blue-800", "text-sm", 3, "click"], [1, "fas", "fa-copy", "mr-1"], [1, "bg-blue-50", "text-blue-800", "text-sm", "p-2", "rounded", "border", "block"], [1, "text-md", "font-semibold", "text-gray-900", "mb-2"], [1, "fas", "fa-key", "mr-2", "text-yellow-500"], [1, "bg-gray-100", "px-1", "rounded"], [1, "bg-yellow-50", "text-yellow-800", "text-sm", "p-2", "rounded", "border", "block", "font-mono"], [1, "fas", "fa-code", "mr-2", "text-green-500"], [1, "bg-gray-900", "text-gray-100", "rounded-lg", "p-4", "overflow-x-auto"], [1, "fas", "fa-broadcast-tower", "mr-2", "text-purple-500"], [1, "text-center", "py-8", "text-gray-500"], [1, "fas", "fa-construction", "text-4xl", "mb-3"], [1, "font-semibold", "mb-2"], [1, "bg-blue-50", "border", "border-blue-200", "rounded-lg", "p-6"], [1, "text-lg", "font-semibold", "text-blue-900", "mb-3"], [1, "fas", "fa-book", "mr-2"], [1, "space-y-3", "text-sm", "text-blue-800"], [1, "flex", "items-start", "space-x-3"], [1, "fas", "fa-check-circle", "mt-0.5", "text-blue-600"], [1, "mobile-board"], [1, "p-4", "space-y-3"], [1, "flex", "gap-2", "overflow-x-auto", "pb-2"], [1, "relative", "flex-1", "max-w-xs"], ["type", "text", "placeholder", "Buscar nos cards...", 1, "w-full", "pl-8", "pr-10", "py-2", "border", "border-gray-300", "rounded-full", "text-sm", "focus:ring-2", "focus:ring-blue-500", "focus:border-blue-500", "bg-gray-50", "focus:bg-white", 3, "ngModelChange", "input", "ngModel"], [1, "fas", "fa-search", "absolute", "left-3", "top-1/2", "transform", "-translate-y-1/2", "text-gray-400", "text-xs"], [1, "absolute", "right-2", "top-1/2", "transform", "-translate-y-1/2", "p-1", "rounded-full", "hover:bg-gray-100", "transition-colors", 3, "click"], [1, "fas", "fa-sliders-h", "text-xs"], ["class", "absolute -top-1 -right-1 bg-blue-500 text-white rounded-full w-3 h-3 flex items-center justify-center text-xs", 4, "ngIf"], ["class", "absolute right-8 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600 p-1", 3, "click", 4, "ngIf"], ["class", "px-3 py-2 bg-red-100 text-red-700 rounded-full text-sm hover:bg-red-200 transition-colors flex items-center gap-1", 3, "click", 4, "ngIf"], ["class", "bg-gray-50 rounded-lg p-4 space-y-3 border", 4, "ngIf"], ["class", "mt-2 text-xs text-blue-600 flex items-center gap-1", 4, "ngIf"], ["class", "rounded-2xl border border-gray-200 bg-white", 4, "ngFor", "ngForOf"], [1, "mt-4", "space-y-3"], ["class", "bg-white rounded-2xl border border-gray-200 p-4 shadow-sm", 4, "ngFor", "ngForOf"], [1, "fixed", "bottom-4", "inset-x-4", "z-40", "md:hidden"], [1, "w-full", "h-12", "bg-blue-600", "hover:bg-blue-700", "text-white", "rounded-2xl", "font-semibold", "shadow-lg", "flex", "items-center", "justify-center", "gap-2", 3, "click"], [1, "inline-flex", "w-6", "h-6", "items-center", "justify-center", "bg-blue-700/60", "rounded-full"], [1, "fas", "fa-plus", "text-xs"], [1, "absolute", "-top-1", "-right-1", "bg-blue-500", "text-white", "rounded-full", "w-3", "h-3", "flex", "items-center", "justify-center", "text-xs"], [1, "absolute", "right-8", "top-1/2", "transform", "-translate-y-1/2", "text-gray-400", "hover:text-gray-600", "p-1", 3, "click"], [1, "fas", "fa-times", "text-xs"], [1, "px-3", "py-2", "bg-red-100", "text-red-700", "rounded-full", "text-sm", "hover:bg-red-200", "transition-colors", "flex", "items-center", "gap-1", 3, "click"], [1, "bg-gray-50", "rounded-lg", "p-4", "space-y-3", "border"], [1, "text-sm", "font-medium", "text-gray-700", "flex", "items-center", "gap-2"], [1, "fas", "fa-filter", "text-purple-600"], [1, "text-gray-400", "hover:text-gray-600", "p-1", 3, "click"], [1, "grid", "grid-cols-1", "gap-3"], ["class", "flex items-center gap-3", 4, "ngFor", "ngForOf"], ["class", "text-xs text-purple-600 flex items-center gap-1 pt-2 border-t", 4, "ngIf"], [1, "flex", "items-center", "gap-3"], [1, "text-sm", "text-gray-600", "min-w-0", "flex-1"], ["type", "text", "class", "flex-1 px-2 py-1 border border-gray-300 rounded text-sm focus:ring-2 focus:ring-purple-500 focus:border-transparent", 3, "placeholder", "value", "input", 4, "ngIf"], ["type", "number", "class", "flex-1 px-2 py-1 border border-gray-300 rounded text-sm focus:ring-2 focus:ring-purple-500 focus:border-transparent", 3, "placeholder", "value", "input", 4, "ngIf"], ["type", "date", "class", "flex-1 px-2 py-1 border border-gray-300 rounded text-sm focus:ring-2 focus:ring-purple-500 focus:border-transparent", 3, "value", "change", 4, "ngIf"], ["class", "flex items-center gap-2 flex-1", 4, "ngIf"], ["class", "flex-1 px-2 py-1 border border-gray-300 rounded text-sm focus:ring-2 focus:ring-purple-500 focus:border-transparent", 3, "value", "change", 4, "ngIf"], ["class", "p-1 text-red-400 hover:text-red-600 transition-colors", 3, "click", 4, "ngIf"], ["type", "text", 1, "flex-1", "px-2", "py-1", "border", "border-gray-300", "rounded", "text-sm", "focus:ring-2", "focus:ring-purple-500", "focus:border-transparent", 3, "input", "placeholder", "value"], ["type", "number", 1, "flex-1", "px-2", "py-1", "border", "border-gray-300", "rounded", "text-sm", "focus:ring-2", "focus:ring-purple-500", "focus:border-transparent", 3, "input", "placeholder", "value"], ["type", "date", 1, "flex-1", "px-2", "py-1", "border", "border-gray-300", "rounded", "text-sm", "focus:ring-2", "focus:ring-purple-500", "focus:border-transparent", 3, "change", "value"], [1, "flex", "items-center", "gap-2", "flex-1"], ["type", "checkbox", 1, "rounded", "border-gray-300", "text-purple-600", "focus:ring-purple-500", 3, "change", "checked"], [1, "flex-1", "px-2", "py-1", "border", "border-gray-300", "rounded", "text-sm", "focus:ring-2", "focus:ring-purple-500", "focus:border-transparent", 3, "change", "value"], [1, "p-1", "text-red-400", "hover:text-red-600", "transition-colors", 3, "click"], [1, "text-xs", "text-purple-600", "flex", "items-center", "gap-1", "pt-2", "border-t"], [1, "fas", "fa-info-circle"], [1, "mt-2", "text-xs", "text-blue-600", "flex", "items-center", "gap-1"], [1, "fas", "fa-filter"], [1, "bg-blue-100", "text-blue-700", "px-2", "py-0.5", "rounded-full"], [1, "rounded-2xl", "border", "border-gray-200", "bg-white"], [1, "w-full", "px-4", "py-3", "flex", "items-center", "justify-between", 3, "click"], [1, "inline-block", "w-3", "h-3", "rounded-full"], [1, "text-sm", "text-gray-500"], [1, "fas"], ["class", "px-4 pb-4", 4, "ngIf"], [1, "px-4", "pb-4"], [1, "space-y-3"], ["class", "bg-white rounded-xl border border-gray-100 p-4 shadow-sm", 4, "ngFor", "ngForOf"], ["class", "text-center text-gray-400 text-sm py-2", 4, "ngIf"], [1, "bg-white", "rounded-xl", "border", "border-gray-100", "p-4", "shadow-sm"], [1, "text-base", "font-bold", "text-gray-900", "mb-1"], ["class", "text-[13px] text-gray-500 mb-2", 4, "ngIf"], ["class", "text-sm text-gray-700", 4, "ngIf"], [1, "mt-3", "flex", "items-center", "gap-5", "text-xs", "text-gray-500"], [1, "flex", "items-center", "gap-1"], [1, "far", "fa-comment"], [1, "far", "fa-clock", "text-orange-400"], [1, "fas", "fa-history", "text-blue-500"], ["class", "flex items-center gap-1", 4, "ngIf"], [1, "text-[13px]", "text-gray-500", "mb-2"], [1, "uppercase", "tracking-wide", "text-gray-400", "text-[11px]"], [1, "far", "fa-calendar-check", "text-green-500"], [1, "text-center", "text-gray-400", "text-sm", "py-2"], [1, "bg-white", "rounded-2xl", "border", "border-gray-200", "p-4", "shadow-sm"], [3, "closeModalEvent", "saveAutomation", "isVisible", "automation", "phases", "allowedTriggerTypes", "fixedPhaseId", "allowedTransitions", "emailTemplates", "users"]], template: /* @__PURE__ */ __name(function KanbanComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "app-main-layout");
    \u0275\u0275template(1, KanbanComponent_div_1_Template, 2, 0, "div", 3)(2, KanbanComponent_nav_2_Template, 11, 3, "nav", 4)(3, KanbanComponent_div_3_Template, 19, 3, "div", 5)(4, KanbanComponent_div_4_Template, 2, 1, "div", 6)(5, KanbanComponent_button_5_Template, 3, 0, "button", 7)(6, KanbanComponent_div_6_Template, 8, 3, "div", 8)(7, KanbanComponent_div_7_Template, 7, 0, "div", 9)(8, KanbanComponent_div_8_Template, 10, 2, "div", 8)(9, KanbanComponent_div_9_Template, 10, 2, "div", 8)(10, KanbanComponent_div_10_Template, 21, 7, "div", 8)(11, KanbanComponent_div_11_Template, 14, 1, "div", 10)(12, KanbanComponent_div_12_Template, 2, 2, "div", 11)(13, KanbanComponent_div_13_Template, 16, 3, "div", 8)(14, KanbanComponent_div_14_Template, 11, 0, "div", 10)(15, KanbanComponent_div_15_Template, 104, 5, "div", 8)(16, KanbanComponent_div_16_Template, 23, 18, "div", 12);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(17, "app-lead-modal", 13);
    \u0275\u0275listener("leadCreated", /* @__PURE__ */ __name(function KanbanComponent_Template_app_lead_modal_leadCreated_17_listener() {
      return ctx.onLeadCreated();
    }, "KanbanComponent_Template_app_lead_modal_leadCreated_17_listener"))("leadUpdated", /* @__PURE__ */ __name(function KanbanComponent_Template_app_lead_modal_leadUpdated_17_listener() {
      return ctx.onLeadUpdated();
    }, "KanbanComponent_Template_app_lead_modal_leadUpdated_17_listener"))("closeModal", /* @__PURE__ */ __name(function KanbanComponent_Template_app_lead_modal_closeModal_17_listener() {
      return ctx.onLeadUpdated();
    }, "KanbanComponent_Template_app_lead_modal_closeModal_17_listener"));
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(18, "app-column-modal", 14);
    \u0275\u0275listener("columnCreated", /* @__PURE__ */ __name(function KanbanComponent_Template_app_column_modal_columnCreated_18_listener() {
      return ctx.onColumnCreated();
    }, "KanbanComponent_Template_app_column_modal_columnCreated_18_listener"))("columnUpdated", /* @__PURE__ */ __name(function KanbanComponent_Template_app_column_modal_columnUpdated_18_listener() {
      return ctx.onColumnUpdated();
    }, "KanbanComponent_Template_app_column_modal_columnUpdated_18_listener"))("columnDeleted", /* @__PURE__ */ __name(function KanbanComponent_Template_app_column_modal_columnDeleted_18_listener() {
      return ctx.onColumnDeleted();
    }, "KanbanComponent_Template_app_column_modal_columnDeleted_18_listener"))("closeModal", /* @__PURE__ */ __name(function KanbanComponent_Template_app_column_modal_closeModal_18_listener() {
      return ctx.onColumnUpdated();
    }, "KanbanComponent_Template_app_column_modal_closeModal_18_listener"));
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(19, "app-phase-form-modal", 15);
    \u0275\u0275listener("formConfigSaved", /* @__PURE__ */ __name(function KanbanComponent_Template_app_phase_form_modal_formConfigSaved_19_listener() {
      return ctx.onPhaseFormConfigSaved();
    }, "KanbanComponent_Template_app_phase_form_modal_formConfigSaved_19_listener"))("closeModal", /* @__PURE__ */ __name(function KanbanComponent_Template_app_phase_form_modal_closeModal_19_listener() {
      return ctx.onPhaseFormConfigSaved();
    }, "KanbanComponent_Template_app_phase_form_modal_closeModal_19_listener"));
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(20, "app-lead-detail-modal", 16);
    \u0275\u0275listener("leadUpdated", /* @__PURE__ */ __name(function KanbanComponent_Template_app_lead_detail_modal_leadUpdated_20_listener() {
      return ctx.onLeadUpdated();
    }, "KanbanComponent_Template_app_lead_detail_modal_leadUpdated_20_listener"))("leadDeleted", /* @__PURE__ */ __name(function KanbanComponent_Template_app_lead_detail_modal_leadDeleted_20_listener() {
      return ctx.onLeadDeleted();
    }, "KanbanComponent_Template_app_lead_detail_modal_leadDeleted_20_listener"))("closeModal", /* @__PURE__ */ __name(function KanbanComponent_Template_app_lead_detail_modal_closeModal_20_listener() {
      return ctx.onLeadUpdated();
    }, "KanbanComponent_Template_app_lead_detail_modal_closeModal_20_listener"));
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(21, "app-template-modal", 17);
    \u0275\u0275listener("templateSaved", /* @__PURE__ */ __name(function KanbanComponent_Template_app_template_modal_templateSaved_21_listener() {
      return ctx.onTemplateSaved();
    }, "KanbanComponent_Template_app_template_modal_templateSaved_21_listener"))("closeModal", /* @__PURE__ */ __name(function KanbanComponent_Template_app_template_modal_closeModal_21_listener() {
      return ctx.onTemplateSaved();
    }, "KanbanComponent_Template_app_template_modal_closeModal_21_listener"));
    \u0275\u0275elementEnd();
    \u0275\u0275template(22, KanbanComponent_app_automation_modal_22_Template, 1, 9, "app-automation-modal", 18);
    \u0275\u0275elementStart(23, "app-automation-history-modal", 19);
    \u0275\u0275listener("closeModalEvent", /* @__PURE__ */ __name(function KanbanComponent_Template_app_automation_history_modal_closeModalEvent_23_listener() {
      return ctx.onCloseHistoryModal();
    }, "KanbanComponent_Template_app_automation_history_modal_closeModalEvent_23_listener"));
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.isLoading);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx.isLoading);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.showAdvancedFilters && ctx.activeTab === "kanban");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx.isLoading && ctx.activeTab === "kanban");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx.isLoading && ctx.activeTab === "kanban");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx.isLoading && ctx.activeTab === "initial-form");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx.isLoading && ctx.activeTab === "kanban" && ctx.columns.length === 0);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx.isLoading && ctx.activeTab === "templates");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx.isLoading && ctx.activeTab === "automations");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx.isLoading && ctx.activeTab === "flow");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.showAutomationDeleteConfirm);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx.isLoading && ctx.activeTab === "reports");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx.isLoading && ctx.activeTab === "outbox");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.showOutboxDeleteConfirm);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx.isLoading && ctx.activeTab === "api");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx.isLoading && ctx.activeTab === "kanban");
    \u0275\u0275advance();
    \u0275\u0275property("ownerId", ctx.ownerId)("boardId", ctx.boardId)("columns", ctx.columns);
    \u0275\u0275advance();
    \u0275\u0275property("ownerId", ctx.ownerId)("boardId", ctx.boardId)("columns", ctx.columns);
    \u0275\u0275advance();
    \u0275\u0275property("ownerId", ctx.ownerId)("boardId", ctx.boardId);
    \u0275\u0275advance();
    \u0275\u0275property("ownerId", ctx.ownerId)("boardId", ctx.boardId)("columns", ctx.columns)("users", ctx.users);
    \u0275\u0275advance();
    \u0275\u0275property("ownerId", ctx.ownerId)("boardId", ctx.boardId);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.showAutomationModal);
    \u0275\u0275advance();
    \u0275\u0275property("isVisible", ctx.showHistoryModal)("automationId", (ctx.selectedAutomationForHistory == null ? null : ctx.selectedAutomationForHistory.id) || "")("automationName", (ctx.selectedAutomationForHistory == null ? null : ctx.selectedAutomationForHistory.name) || "")("ownerId", ctx.ownerId)("boardId", ctx.boardId)("leads", ctx.leads);
  }
}, "KanbanComponent_Template"), dependencies: [CommonModule, NgClass, NgForOf, NgIf, FormsModule, NgSelectOption, \u0275NgSelectMultipleOption, DefaultValueAccessor, CheckboxControlValueAccessor, NgControlStatus, NgModel, DragDropModule, CdkDropList, CdkDrag, CdkDragHandle, LeadModalComponent, ColumnModalComponent, PhaseFormModalComponent, LeadDetailModalComponent, TemplateModalComponent, AutomationModal, AutomationHistoryModal, MainLayoutComponent, VisualFormBuilderComponent, ReportsComponent], styles: ['@charset "UTF-8";\n\n\n\n.kanban-board[_ngcontent-%COMP%] {\n  display: flex;\n  flex-direction: row;\n  gap: 12px;\n  padding: 12px;\n  overflow-x: auto;\n  min-height: calc(100vh - 80px);\n  scroll-snap-type: x mandatory;\n  position: relative;\n  justify-content: flex-start;\n  align-items: stretch;\n}\n.mobile-board[_ngcontent-%COMP%] {\n  display: none;\n}\n.kanban-column[_ngcontent-%COMP%] {\n  flex: 0 0 340px;\n  min-width: 340px;\n  max-width: 380px;\n  background-color: #f8fafc;\n  border-radius: 12px;\n  display: flex;\n  flex-direction: column;\n  transition: opacity 0.2s ease-in-out;\n  scroll-snap-align: start;\n}\n.kanban-column-header[_ngcontent-%COMP%] {\n  padding: 10px 14px;\n  font-weight: 600;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  border-top-width: 4px;\n  border-top-style: solid;\n  border-top-left-radius: 12px;\n  border-top-right-radius: 12px;\n  transition: background-color 0.3s;\n}\n.kanban-cards[_ngcontent-%COMP%] {\n  flex-grow: 1;\n  padding: 6px 10px 8px;\n  overflow-y: auto;\n  min-height: calc(100vh - 220px);\n}\n.kanban-card[_ngcontent-%COMP%] {\n  background-color: white;\n  border-radius: 8px;\n  padding: 8px;\n  margin-bottom: 10px;\n  cursor: pointer;\n  box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);\n  transition: box-shadow 0.2s, transform 0.2s;\n  border-left: 5px solid transparent;\n  position: relative;\n}\n.kanban-card[_ngcontent-%COMP%]:hover {\n  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);\n  transform: translateY(-1px);\n}\n.card-avatar[_ngcontent-%COMP%] {\n  position: absolute;\n  bottom: 8px;\n  right: 8px;\n  width: 28px;\n  height: 28px;\n  background-color: #94a3b8;\n  color: white;\n  border-radius: 50%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-weight: bold;\n  font-size: 12px;\n  border: 2px solid white;\n}\n.line-clamp-2[_ngcontent-%COMP%] {\n  display: -webkit-box;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n  overflow: hidden;\n}\n.flow-scroll[_ngcontent-%COMP%] {\n  overflow-x: auto;\n  overflow-y: hidden;\n  padding-bottom: 8px;\n  min-height: 1px;\n  border-bottom: 0;\n  -ms-overflow-style: none;\n  scrollbar-width: none;\n}\n.flow-scroll[_ngcontent-%COMP%]::-webkit-scrollbar {\n  height: 0px;\n  background: transparent;\n}\n.flow-row[_ngcontent-%COMP%] {\n  min-width: calc(100% + 2px);\n}\n.flow-scroll[_ngcontent-%COMP%]::-webkit-scrollbar {\n  height: 10px;\n}\n.flow-scroll[_ngcontent-%COMP%]::-webkit-scrollbar-track {\n  background: #e5e7eb;\n  border-radius: 8px;\n}\n.flow-scroll[_ngcontent-%COMP%]::-webkit-scrollbar-thumb {\n  background: #cbd5e1;\n  border-radius: 8px;\n}\n.flow-phase-card[_ngcontent-%COMP%] {\n  background: #ffffff;\n  border: 1px solid #e5e7eb;\n  border-top-width: 4px;\n  border-top-color: var(--phase-color, #94a3b8);\n  border-radius: 12px;\n  transition: box-shadow 0.2s ease, transform 0.1s ease;\n  box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.02);\n}\n.flow-custombar[_ngcontent-%COMP%] {\n  height: 8px;\n  background: #e5e7eb;\n  border-radius: 6px;\n  position: relative;\n  margin: 6px 12px 0 12px;\n  cursor: pointer;\n}\n.flow-thumb[_ngcontent-%COMP%] {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  background: #9ca3af;\n  border-radius: 6px;\n}\n.flow-phase-card[_ngcontent-%COMP%]:hover {\n  box-shadow: 0 6px 20px -10px rgba(0, 0, 0, 0.25);\n  transform: translateY(-1px);\n}\n.cdk-drag-preview[_ngcontent-%COMP%] {\n  box-sizing: border-box;\n  border-radius: 8px;\n  box-shadow:\n    0 5px 5px -3px rgba(0, 0, 0, 0.2),\n    0 8px 10px 1px rgba(0, 0, 0, 0.14),\n    0 3px 14px 2px rgba(0, 0, 0, 0.12);\n}\n.cdk-drag-placeholder[_ngcontent-%COMP%] {\n  opacity: 0;\n}\n.cdk-drag-animating[_ngcontent-%COMP%] {\n  transition: transform 250ms cubic-bezier(0, 0, 0.2, 1);\n}\n.cdk-drop-list-dragging[_ngcontent-%COMP%]   .kanban-card[_ngcontent-%COMP%]:not(.cdk-drag-placeholder) {\n  transition: transform 250ms cubic-bezier(0, 0, 0.2, 1);\n}\n@media (max-width: 768px) {\n  .desktop-board[_ngcontent-%COMP%] {\n    display: none;\n  }\n  .mobile-board[_ngcontent-%COMP%] {\n    display: block;\n  }\n  .kanban-board[_ngcontent-%COMP%] {\n    gap: 8px;\n    padding: 8px;\n  }\n  .kanban-column[_ngcontent-%COMP%] {\n    min-width: 260px;\n    max-width: 320px;\n  }\n  .kanban-card[_ngcontent-%COMP%] {\n    padding: 8px;\n  }\n}\n@media (max-width: 480px) {\n  .desktop-board[_ngcontent-%COMP%] {\n    display: none;\n  }\n  .mobile-board[_ngcontent-%COMP%] {\n    display: block;\n  }\n  .kanban-board[_ngcontent-%COMP%] {\n    gap: 6px;\n    padding: 6px;\n  }\n  .kanban-column[_ngcontent-%COMP%] {\n    min-width: 240px;\n    max-width: 280px;\n  }\n  .kanban-card[_ngcontent-%COMP%] {\n    padding: 8px;\n  }\n}\n/*# sourceMappingURL=kanban.component.css.map */'] }));
var KanbanComponent = _KanbanComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(KanbanComponent, [{
    type: Component,
    args: [{ selector: "app-kanban", standalone: true, imports: [CommonModule, FormsModule, DragDropModule, LeadModalComponent, ColumnModalComponent, PhaseFormModalComponent, LeadDetailModalComponent, TemplateModalComponent, AutomationModal, AutomationHistoryModal, MainLayoutComponent, VisualFormBuilderComponent, ReportsComponent], template: `<app-main-layout>

  <!-- Loading State -->
  <div *ngIf="isLoading" class="flex justify-center items-center py-20">
    <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500"></div>
  </div>

  <!-- Tabs Navigation with Search -->
  <nav *ngIf="!isLoading" class="bg-white px-4 md:px-8 border-b border-gray-200 sticky top-0 z-30">
    <div class="flex justify-between items-center">
      <!-- Left side: Back Button and Search -->
      <div class="flex items-center space-x-4">
        <div class="flex items-center space-x-3">
          <!-- Back Button -->
          <button 
            (click)="goToDashboard()"
            class="text-gray-500 hover:text-gray-700 p-1 rounded hover:bg-gray-100 transition-colors">
            <i class="fas fa-arrow-left"></i>
          </button>
          
          <!-- Search Field - Compact -->
          <div class="relative" *ngIf="activeTab === 'kanban'">
            <input 
              type="text" 
              [(ngModel)]="filterQuery"
              (ngModelChange)="onFilterQueryChange($event)"
              placeholder="Pesquisar..."
              class="w-64 pl-8 pr-10 py-1.5 text-sm border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent">
            <i class="fas fa-search absolute left-2.5 top-1/2 transform -translate-y-1/2 text-gray-400 text-xs"></i>
            
            <!-- Filter Button Inside Search -->
            <button 
              (click)="toggleAdvancedFilters()"
              class="absolute right-2 top-1/2 transform -translate-y-1/2 p-1 hover:bg-gray-100 rounded transition-colors"
              [class.text-blue-600]="showAdvancedFilters"
              [class.bg-blue-50]="showAdvancedFilters">
              <i class="fas fa-filter text-xs"></i>
              <span *ngIf="hasActiveFilters()" class="absolute -top-1 -right-1 bg-blue-500 text-white text-xs rounded-full w-3 h-3 flex items-center justify-center" style="font-size: 8px;">
                {{ getDynamicFilterCount() + (filterOnlyMine ? 1 : 0) }}
              </span>
            </button>
          </div>
        </div>
      </div>

      <!-- Center: Tab Navigation -->
      <div class="hidden md:flex space-x-8">
        <button
          *ngFor="let tab of tabs"
          (click)="switchTab(tab.id)"
          class="py-4 px-1 border-b-2 font-medium text-sm transition-colors duration-200"
          [class.border-blue-500]="activeTab === tab.id"
          [class.text-blue-600]="activeTab === tab.id"
          [class.border-transparent]="activeTab !== tab.id"
          [class.text-gray-500]="activeTab !== tab.id"
          [class.hover:text-gray-700]="activeTab !== tab.id">
          <i class="fas {{ tab.icon }} mr-2"></i>
          {{ tab.name }}
        </button>
      </div>

      <!-- Right side: Clear Filters Button -->
      <div class="hidden md:flex items-center space-x-2">
        <button 
          *ngIf="hasActiveFilters() && activeTab === 'kanban'"
          (click)="clearFilters()"
          class="px-2 py-1 bg-red-100 hover:bg-red-200 text-red-700 border border-red-300 rounded text-xs transition-colors">
          <i class="fas fa-times mr-1"></i>
          Limpar
        </button>
      </div>
    </div>
  </nav>

  <!-- Advanced Filters Modal -->
  <div *ngIf="showAdvancedFilters && activeTab === 'kanban'" 
       class="fixed top-20 left-4 w-full max-w-lg bg-white rounded-xl shadow-xl border border-gray-200 z-[9999]">
    <div class="p-6">
      <div class="flex items-center justify-between mb-4">
        <h3 class="text-lg font-semibold text-gray-900">Filtros Avan\xE7ados</h3>
        <button 
          (click)="toggleAdvancedFilters()"
          class="text-gray-400 hover:text-gray-600">
          <i class="fas fa-times"></i>
        </button>
      </div>
      
      <!-- Quick Filter: Show Only Mine -->
      <div class="mb-6 p-3 bg-gray-50 rounded-lg">
        <label class="flex items-center space-x-2 cursor-pointer">
          <input 
            type="checkbox" 
            [(ngModel)]="filterOnlyMine"
            (ngModelChange)="toggleOnlyMine()"
            class="rounded border-gray-300 text-blue-600 focus:ring-blue-500">
          <span class="text-sm text-gray-700 font-medium">Mostrar apenas meus registros</span>
        </label>
      </div>
      
      <!-- Dynamic Filter Fields -->
      <div *ngIf="availableFilterFields.length > 0" class="space-y-4">
        <h4 class="text-sm font-medium text-gray-700 mb-3">Filtros Din\xE2micos</h4>
        
        <div *ngFor="let field of availableFilterFields" class="space-y-2">
          <label class="block text-sm font-medium text-gray-700">
            {{ field.label }}
          </label>
          
          <!-- Text/Email/Tel/Number Fields -->
          <input 
            *ngIf="field.type === 'text' || field.type === 'email' || field.type === 'tel' || field.type === 'number' || field.type === 'cnpj' || field.type === 'cpf'"
            [type]="field.type === 'number' ? 'number' : 'text'"
            [value]="dynamicFilters[field.name] || ''"
            (input)="setDynamicFilter(field.name, $any($event.target).value)"
            [placeholder]="'Filtrar por ' + field.label.toLowerCase()"
            class="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent">
          
          <!-- Date Fields -->
          <input 
            *ngIf="field.type === 'date'"
            type="date"
            [value]="dynamicFilters[field.name] || ''"
            (input)="setDynamicFilter(field.name, $any($event.target).value)"
            class="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent">
          
          <!-- Select/Radio Fields -->
          <select 
            *ngIf="field.type === 'select' || field.type === 'radio'"
            [value]="dynamicFilters[field.name] || ''"
            (change)="setDynamicFilter(field.name, $any($event.target).value)"
            class="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent">
            <option value="">Todos</option>
            <option *ngFor="let option of getFieldOptions(field)" [value]="option">
              {{ option }}
            </option>
          </select>
          
          <!-- Temperatura Field -->
          <select 
            *ngIf="field.type === 'temperatura'"
            [value]="dynamicFilters[field.name] || ''"
            (change)="setDynamicFilter(field.name, $any($event.target).value)"
            class="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent">
            <option value="">Todas as temperaturas</option>
            <option value="Quente">\u{1F525} Quente</option>
            <option value="Morno">\u{1F321}\uFE0F Morno</option>
            <option value="Frio">\u2744\uFE0F Frio</option>
          </select>
          
          <!-- Checkbox Fields -->
          <div *ngIf="field.type === 'checkbox'" class="flex items-center space-x-2">
            <input 
              type="checkbox"
              [checked]="dynamicFilters[field.name] === true"
              (change)="setDynamicFilter(field.name, $any($event.target).checked)"
              class="rounded border-gray-300 text-blue-600 focus:ring-blue-500">
            <span class="text-sm text-gray-700">Apenas marcados</span>
          </div>
        </div>
      </div>
      
      <!-- No Fields Available -->
      <div *ngIf="availableFilterFields.length === 0" class="text-center py-6">
        <i class="fas fa-filter text-gray-300 text-3xl mb-3"></i>
        <p class="text-gray-500 text-sm">
          Nenhum campo configurado para filtros.<br>
          Configure campos com "Mostrar em filtros" ativado no formul\xE1rio.
        </p>
      </div>
      
      <!-- Action Buttons -->
      <div class="flex justify-end space-x-3 mt-6 pt-4 border-t border-gray-200">
        <button 
          (click)="clearFilters()"
          class="px-4 py-2 text-gray-600 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors">
          Limpar
        </button>
        <button 
          (click)="toggleAdvancedFilters()"
          class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition-colors">
          Aplicar
        </button>
      </div>
    </div>
  </div>

  <!-- Desktop Kanban Board Tab -->
  <div *ngIf="!isLoading && activeTab === 'kanban'" class="kanban-board desktop-board">
    <div 
      *ngFor="let column of columns" 
      class="kanban-column"
      [style.background-color]="'#e2e8f0'">
      
      <!-- Column Header -->
      <div 
        class="kanban-column-header"
        [style.border-top-color]="getColumnBorderColor(column)">
        <div class="flex items-center justify-between">
          <div class="flex items-center">
            <h3 class="font-semibold text-gray-800">{{ column.name }}</h3>
            <span class="ml-2 bg-gray-200 text-gray-600 text-xs px-2 py-1 rounded-full">
              {{ getLeadsForColumn(column.id!).length }}
            </span>
            <span *ngIf="getAutomationCount(column.id!) > 0" class="ml-2 inline-flex items-center text-xs px-2 py-1 rounded-full bg-yellow-100 text-yellow-800" title="Automa\xE7\xF5es ativas nesta fase">
              <i class="fas fa-bolt mr-1"></i>{{ getAutomationCount(column.id!) }}
            </span>
          </div>
          
          
        </div>
      </div>

      <!-- Cards Container -->
      <div 
        class="kanban-cards"
        cdkDropList
        [id]="'column-' + column.id"
        [cdkDropListData]="displayedLeadsByColumn[column.id!] || []"
        [cdkDropListConnectedTo]="getColumnConnectedTo()"
        (cdkDropListDropped)="onLeadDrop($event)">
        
        <div 
          *ngFor="let lead of (displayedLeadsByColumn[column.id!] || []); trackBy: trackByLeadId" 
          class="bg-white rounded-lg shadow-sm border border-gray-200 hover:shadow-md transition-all duration-200 cursor-pointer mb-3 p-4 border-l-4"
          [class]="getSlaStatus(lead).borderClass || getLeadPriorityClass(lead)"
          cdkDrag
          [cdkDragDisabled]="!cardMoveEnabled"
          [cdkDragData]="lead.id"
          (cdkDragStarted)="onLeadDragStarted()"
          (cdkDragEnded)="onLeadDragEnded()"
          (click)="onCardClick(lead, $event)">
          
          <!-- Card Header -->
          <div class="flex items-start justify-between mb-3">
            <div class="flex-1 min-w-0">
              <h4 class="font-semibold text-gray-900 text-sm truncate mb-1">
                {{ getCompanyName(lead) }}
              </h4>
              <div *ngIf="getCnpj(lead)" class="text-xs text-gray-500">
                CNPJ: {{ getCnpj(lead) }}
              </div>
            </div>
            <!-- Removido badge fixa de temperatura (passar\xE1 a exibir via showInCard como \xEDcone) -->
          </div>

          <!-- Campos configurados para exibir no card -->
          <div class="space-y-2 mb-3">
            <div *ngFor="let item of getCardFieldsForLead(lead)" class="text-xs">
              <!-- Outros campos: exibir normal (temperatura vai para o rodap\xE9) -->
              <div *ngIf="item.type !== 'temperatura'">
                <div class="font-medium text-gray-600 mb-0.5">{{ item.label }}</div>
                <div class="text-gray-900 truncate">{{ item.value }}</div>
              </div>
            </div>
          </div>

          <!-- SLA Status -->
          <div *ngIf="getSlaStatus(lead).text" class="mb-3">
            <div class="flex items-center text-xs font-medium"
                 [class]="getSlaStatus(lead).colorClass">
              <i class="fas fa-clock w-3 h-3 mr-1"></i>
              <span>{{ getSlaStatus(lead).text }}</span>
            </div>
          </div>

          <!-- Temperatura (sempre vis\xEDvel se existir) -->
          <div *ngIf="getTemperatureGlobalItem(lead) as temp" class="mb-3">
            <div class="flex items-center text-xs font-medium">
              <span [ngClass]="{
                'bg-red-500': temp.value === 'Quente',
                'bg-yellow-500': temp.value === 'Morno', 
                'bg-blue-500': temp.value === 'Frio'
              }" class="w-2 h-2 rounded-full mr-1"></span>
              <span>{{ temp.value }}</span>
            </div>
          </div>

          <!-- Card Footer -->
          <div class="flex items-center justify-between">
            <div class="flex items-center gap-3 text-xs text-gray-500">
              <!-- Coment\xE1rios count -->
              <div class="flex items-center" *ngIf="lead.historyCommentsCount as c"><i class="far fa-comment mr-1"></i><span>{{ c || 0 }}</span></div>
              <!-- Anexos count -->
              <div class="flex items-center" *ngIf="lead.attachmentsCount as a"><i class="fas fa-paperclip mr-1"></i><span>{{ a || 0 }}</span></div>
            </div>
            <div class="flex items-center text-xs text-gray-500">
              <i class="far fa-calendar-alt w-3 h-3 mr-1"></i>
              <span>{{ formatDateTime(lead.createdAt) }}</span>
            </div>
          </div>

          <!-- Description/Notes Preview -->
          <div *ngIf="lead.fields?.['description']" class="mt-2 pt-2 border-t border-gray-100">
            <p class="text-xs text-gray-600 line-clamp-2">
              {{ lead.fields['description'] }}
            </p>
          </div>
        </div>

        <!-- Empty State -->
        <div *ngIf="getLeadsForColumn(column.id!).length === 0" 
             class="text-center py-6 text-gray-400">
          <i class="fas fa-inbox text-2xl mb-2"></i>
          <p class="text-sm">Nenhum registro nesta fase</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Bot\xE3o flutuante \xFAnico: Novo registro -->
  <button 
    *ngIf="!isLoading && activeTab === 'kanban'"
    (click)="showCreateLeadModal()"
    class="fixed left-4 bottom-4 z-40 bg-green-500 hover:bg-green-600 text-white px-4 py-3 rounded-full shadow-lg flex items-center gap-2">
    <i class="fas fa-plus"></i>
    Novo registro
  </button>

  <!-- Initial Form Tab -->
  <div *ngIf="!isLoading && activeTab === 'initial-form'" class="p-4 md:p-8">
    <div class="max-w-4xl mx-auto">
      <h2 class="text-2xl font-bold text-gray-900 mb-4">Formul\xE1rio inicial do quadro</h2>

      <app-visual-form-builder
        [fields]="initialFormFields"
        (fieldsChanged)="onInitialFieldsChanged($event)">
      </app-visual-form-builder>

      <div class="flex justify-end mt-6">
        <button class="px-4 py-2 text-white rounded-lg" [style.background-color]="getPrimaryColor()" (click)="saveInitialForm()">
          Salvar
        </button>
      </div>
    </div>
  </div>

  <!-- Configura\xE7\xE3o de formul\xE1rio da fase removida daqui; usar \xEDcone na pr\xF3pria coluna -->

  <!-- Empty State - No Columns -->
  <div *ngIf="!isLoading && activeTab === 'kanban' && columns.length === 0" class="text-center py-20">
    <div class="max-w-md mx-auto">
      <i class="fas fa-columns text-6xl text-gray-300 mb-4"></i>
      <h3 class="text-xl font-semibold text-gray-900 mb-2">Nenhuma coluna encontrada</h3>
      <p class="text-gray-600">
        Este quadro ainda n\xE3o possui colunas configuradas.
      </p>
    </div>
  </div>

  <!-- Templates Tab -->
  <div *ngIf="!isLoading && activeTab === 'templates'" class="p-4 md:p-8">
    <div class="max-w-4xl mx-auto">
      <div class="flex justify-between items-center mb-6">
        <h2 class="text-2xl font-bold text-gray-900">Templates de Email</h2>
        <button (click)="createTemplate()" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg font-medium transition-colors">
          <i class="fas fa-plus mr-2"></i>
          Novo Template
        </button>
      </div>
      
      <!-- Lista de Templates -->
      <div *ngIf="emailTemplates.length > 0" class="grid gap-4">
        <div 
          *ngFor="let template of emailTemplates" 
          class="bg-white border border-gray-200 rounded-lg p-6 hover:shadow-md transition-shadow">
          <div class="flex items-start justify-between">
            <div class="flex-1">
              <h3 class="text-lg font-semibold text-gray-900 mb-2">
                {{ template.name || 'Template sem nome' }}
              </h3>
              <p class="text-sm text-gray-600 mb-3">
                <strong>Assunto:</strong> {{ template.subject || 'Sem assunto' }}
              </p>
              <p class="text-xs text-gray-500 mb-4">
                <strong>Para:</strong> {{ template.recipients || 'N\xE3o especificado' }}
              </p>
              <div class="flex items-center text-xs text-gray-500 space-x-4">
                <span>
                  <i class="far fa-calendar-alt mr-1"></i>
                  Criado em {{ formatDate(template.createdAt) }}
                </span>
                <span *ngIf="template.updatedAt">
                  <i class="fas fa-edit mr-1"></i>
                  Atualizado em {{ formatDate(template.updatedAt) }}
                </span>
              </div>
            </div>
            
            <div class="flex items-center space-x-2 ml-4">
              <button 
                (click)="editTemplate(template)"
                class="text-blue-600 hover:text-blue-800 px-3 py-1 text-sm font-medium">
                <i class="fas fa-edit mr-1"></i>
                Editar
              </button>
              <button 
                (click)="deleteTemplate(template)"
                class="text-red-600 hover:text-red-800 px-3 py-1 text-sm font-medium">
                <i class="fas fa-trash mr-1"></i>
                Excluir
              </button>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Empty State -->
      <div *ngIf="emailTemplates.length === 0" class="bg-white rounded-lg shadow p-6">
        <div class="text-center py-12 text-gray-500">
          <i class="fas fa-envelope text-6xl mb-4"></i>
          <h3 class="text-xl font-semibold mb-2">Nenhum template encontrado</h3>
          <p>Crie templates personalizados para automa\xE7\xF5es de email</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Automations Tab -->
  <div *ngIf="!isLoading && activeTab === 'automations'" class="p-4 md:p-8">
    <div class="max-w-4xl mx-auto">
      <div class="flex justify-between items-center mb-6">
        <h2 class="text-2xl font-bold text-gray-900">Automa\xE7\xF5es</h2>
        <button (click)="createAutomation($event)" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-lg font-medium transition-colors">
          <i class="fas fa-plus mr-2"></i>
          Nova Automa\xE7\xE3o
        </button>
      </div>
      
      <!-- Lista de Automa\xE7\xF5es -->
      <div *ngIf="getValidAutomations().length > 0" class="grid gap-4">
        <div 
          *ngFor="let automation of getValidAutomations()" 
          class="bg-white border border-gray-200 rounded-lg p-6 hover:shadow-md transition-shadow">
          <div class="flex items-start justify-between">
            <div class="flex-1">
              <div class="flex items-center mb-2">
                <h3 class="text-lg font-semibold text-gray-900 mr-3">
                  {{ automation.name }}
                </h3>
                <span 
                  class="px-2 py-1 text-xs font-medium rounded-full"
                  [class.bg-green-100]="automation.active"
                  [class.text-green-800]="automation.active"
                  [class.bg-red-100]="!automation.active"
                  [class.text-red-800]="!automation.active">
                  {{ automation.active ? 'Ativa' : 'Inativa' }}
                </span>
              </div>
              
              <div class="space-y-2 mb-4">
                <p class="text-sm text-gray-600">
                  <i class="fas fa-bolt mr-2"></i>
                  <strong>Gatilho:</strong> {{ getTriggerDescription(automation.trigger) }}
                </p>
                <p class="text-sm text-gray-600">
                  <i class="fas fa-play mr-2"></i>
                  <strong>A\xE7\xF5es:</strong> {{ getActionsCount(automation.actions) }} a\xE7\xE3o(\xF5es) configurada(s)
                </p>
              </div>
              
              <div class="flex items-center text-xs text-gray-500 space-x-4">
                <span>
                  <i class="far fa-calendar-alt mr-1"></i>
                  Criada em {{ formatDate(automation.createdAt) }}
                </span>
                <span *ngIf="automation.lastExecuted">
                  <i class="fas fa-play mr-1"></i>
                  \xDAltima execu\xE7\xE3o: {{ formatDate(automation.lastExecuted) }}
                </span>
              </div>
            </div>
            
            <div class="flex items-center space-x-2 ml-4">
              <button 
                (click)="showAutomationHistory(automation, $event)"
                class="text-gray-500 hover:text-blue-600 px-3 py-1 text-sm font-medium"
                title="Ver Hist\xF3rico">
                <i class="fas fa-history mr-1"></i>
                Hist\xF3rico
              </button>
              <button 
                (click)="editAutomation(automation, $event)"
                class="text-blue-600 hover:text-blue-800 px-3 py-1 text-sm font-medium">
                <i class="fas fa-edit mr-1"></i>
                Editar
              </button>
              <button 
                (click)="toggleAutomation(automation)"
                class="px-3 py-1 text-sm font-medium"
                [class.text-red-600]="automation.active"
                [class.hover:text-red-800]="automation.active"
                [class.text-green-600]="!automation.active"
                [class.hover:text-green-800]="!automation.active">
                <i class="fas mr-1" [class.fa-pause]="automation.active" [class.fa-play]="!automation.active"></i>
                {{ automation.active ? 'Pausar' : 'Ativar' }}
              </button>
              <button 
                (click)="openDeleteAutomationConfirm(automation, $event)"
                class="text-red-600 hover:text-red-800 px-3 py-1 text-sm font-medium">
                <i class="fas fa-trash mr-1"></i>
                Excluir
              </button>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Empty State -->
      <div *ngIf="getValidAutomations().length === 0" class="bg-white rounded-lg shadow p-6">
        <div class="text-center py-12 text-gray-500">
          <i class="fas fa-cogs text-6xl mb-4"></i>
          <h3 class="text-xl font-semibold mb-2">Nenhuma automa\xE7\xE3o encontrada</h3>
          <p>Configure automa\xE7\xF5es para disparar a\xE7\xF5es quando leads mudarem de fase</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Flow Tab - Novo Editor Simplificado -->
  <div *ngIf="!isLoading && activeTab === 'flow'" class="p-4 md:p-8">
    <div class="w-full mx-auto">
      <div class="flex justify-between items-center mb-6">
        <h2 class="text-2xl font-bold text-gray-900">Fluxo de Transi\xE7\xF5es</h2>
        <div class="flex items-center gap-2">
          <button (click)="showCreateColumnModal()" class="bg-gray-400 hover:bg-gray-500 text-white px-4 py-2 rounded-lg font-medium transition-colors" title="Nova fase">
            <i class="fas fa-plus mr-2"></i>
            Nova Fase
          </button>
          <button (click)="saveFlowConfig()" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg font-medium transition-colors">
            <i class="fas fa-save mr-2"></i>
            Salvar Fluxo
          </button>
        </div>
      </div>

      <!-- Lista horizontal de fases com reordena\xE7\xE3o -->
      <div class="relative w-full">
        <div #flowScroller class="flow-scroll">
          <div cdkDropList [cdkDropListData]="flowOrder" (cdkDropListDropped)="onFlowReorder($event)" (cdkDropListEntered)="onDragEntered()" (cdkDropListExited)="onDragExited()" class="inline-flex items-center gap-6 p-2 whitespace-nowrap min-w-max flow-row w-max">
          <ng-container *ngFor="let phaseId of flowOrder; let i = index">
          <!-- Phase card -->
          <div cdkDrag (cdkDragStarted)="onDragStarted(phaseId)" (cdkDragEnded)="onDragEnded(phaseId)" class="min-w-[300px] max-w-[340px] flow-phase-card cursor-pointer" [attr.id]="'phase-'+phaseId" [style.--phase-color]="getColumnById(phaseId)?.color || '#94a3b8'" (click)="onPhaseCardClick(phaseId, $event)">
            <div class="px-3 py-2 bg-gray-50 rounded-t-lg flex items-center justify-between">
              <div class="font-medium text-gray-800 truncate">{{ getColumnById(phaseId)?.name }}</div>
              <div class="flex items-center gap-2">
                <button 
                  *ngIf="i > 0" 
                  (click)="movePhaseUp(i, $event)" 
                  class="p-1 text-gray-400 hover:text-blue-600 transition-colors"
                  title="Mover para esquerda">
                  <i class="fas fa-chevron-left text-xs"></i>
                </button>
                <button 
                  *ngIf="i < flowOrder.length - 1" 
                  (click)="movePhaseDown(i, $event)" 
                  class="p-1 text-gray-400 hover:text-blue-600 transition-colors"
                  title="Mover para direita">
                  <i class="fas fa-chevron-right text-xs"></i>
                </button>
                <i class="fas fa-grip-vertical text-gray-400" cdkDragHandle title="Arraste para reordenar"></i>
              </div>
            </div>
            <div class="p-3 text-sm space-y-3">
              <div *ngIf="hasOutgoingConnections(phaseId); else noConnections" class="pt-0">
                <div class="text-xs text-gray-500 mb-1">Conex\xF5es:</div>
                <div class="space-y-1">
                  <div *ngFor="let e of getOutgoingConnections(phaseId)" class="flex items-center justify-between text-xs">
                    <span class="truncate">{{ getEdgeArrow(e) }} {{ getColumnById(e.toId)?.name || e.toId }}</span>
                    <button class="text-red-600 hover:text-red-700" (click)="removeEdge(e); $event.stopPropagation()" title="Remover">
                      <i class="fas fa-xmark"></i>
                    </button>
                  </div>
                </div>
              </div>
              <ng-template #noConnections>
                <div class="text-xs text-gray-400">Sem conex\xF5es para esta fase</div>
              </ng-template>

              <!-- Footer action row: form, automations, connection -->
              <div class="pt-2 border-t border-gray-100 flex items-center justify-end gap-3 text-base">
                <button class="text-blue-600 hover:text-blue-700" title="Formul\xE1rio da fase" (click)="showColumnForm(getColumnById(phaseId)!); $event.stopPropagation()">
                  <i class="fas fa-list-check"></i>
                </button>
                <button class="text-purple-600 hover:text-purple-700" title="Automa\xE7\xF5es da fase" (click)="openPhaseAutomations(phaseId); $event.stopPropagation()">
                  <i class="fas fa-gears"></i>
                </button>
                <button *ngIf="!pendingFromId" class="text-indigo-600 hover:text-indigo-700" title="Iniciar conex\xE3o" (click)="beginEdge(phaseId); $event.stopPropagation()">
                  <i class="fas fa-circle-dot"></i>
                </button>
                <button *ngIf="pendingFromId && pendingFromId!==phaseId" class="text-indigo-600 hover:text-indigo-700" title="Conectar aqui" (click)="completeEdge(phaseId); $event.stopPropagation()">
                  <i class="fas fa-bullseye"></i>
                </button>
              </div>
            </div>
          </div>

          <!-- Connector removed -->
          </ng-container>
        </div>
        </div>
        <!-- custom persistent scrollbar outside the scroller -->
        <div class="flow-custombar mt-1" #flowCustomBar (mousedown)="onFlowBarPointerDown($event)" (touchstart)="onFlowBarTouchStart($event)">
          <div class="flow-thumb" [style.width.%]="flowThumbPercent" [style.left.%]="flowThumbLeftPercent"></div>
        </div>
      </div>

      <!-- Automations drawer inside Flow -->
      <div *ngIf="selectedPhaseIdForAutomations" class="mt-4 p-4 border rounded-lg bg-white shadow">
        <div class="flex justify-between items-center mb-3">
          <div class="font-semibold">Automa\xE7\xF5es da fase: {{ getColumnById(selectedPhaseIdForAutomations!)?.name }}</div>
          <button class="text-gray-600 hover:text-gray-900" (click)="closePhaseAutomations()"><i class="fas fa-times"></i></button>
        </div>
        <div class="space-y-2">
          <div *ngFor="let a of getAutomationsForPhase(selectedPhaseIdForAutomations!)" class="p-3 border rounded">
            <div class="flex justify-between items-center">
              <div>
                <div class="font-medium">{{ a.name || 'Automa\xE7\xE3o sem nome' }}</div>
                <div class="text-xs text-gray-500">Trigger: {{ getTriggerDescription(a) }}</div>
              </div>
              <div class="flex items-center gap-2">
                <label class="text-xs flex items-center gap-1">
                  <input type="checkbox" [checked]="a.active" (change)="toggleAutomation(a)" /> Ativa
                </label>
                <button class="text-blue-600 text-sm" (click)="editAutomation(a)">Editar</button>
                <button class="text-red-600 text-sm" (click)="openDeleteAutomationConfirm(a, $event)">Excluir</button>
              </div>
            </div>
          </div>
          <div class="pt-2">
            <button class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-2 rounded text-sm" (click)="createAutomationForPhase(selectedPhaseIdForAutomations!)">
              <i class="fas fa-plus mr-1"></i> Nova automa\xE7\xE3o nesta fase
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal de confirma\xE7\xE3o de exclus\xE3o de automa\xE7\xE3o -->
  <div *ngIf="showAutomationDeleteConfirm" class="fixed inset-0 bg-black/50 flex items-center justify-center z-[60]" (click)="cancelDeleteAutomation()">
    <div class="bg-white rounded-xl shadow-2xl w-full max-w-md p-6" (click)="$event.stopPropagation()">
      <h3 class="text-lg font-bold text-gray-900 mb-2">Excluir automa\xE7\xE3o</h3>
      <p class="text-sm text-gray-600 mb-6">Tem certeza que deseja excluir a automa\xE7\xE3o
        <strong>{{ automationPendingDelete?.name || 'sem nome' }}</strong>? Esta a\xE7\xE3o n\xE3o pode ser desfeita.</p>
      <div class="flex justify-end gap-3">
        <button class="px-4 py-2 rounded-lg border border-gray-300" (click)="cancelDeleteAutomation()">Cancelar</button>
        <button class="px-4 py-2 rounded-lg bg-red-600 text-white" (click)="confirmDeleteAutomation()">Excluir</button>
      </div>
    </div>
  </div>

  <!-- Reports Tab -->
  <div *ngIf="!isLoading && activeTab === 'reports'">
    <app-reports 
      [boardId]="boardId" 
      [ownerId]="ownerId">
    </app-reports>
  </div>

  <!-- Outbox/Caixa de Sa\xEDda Tab -->
  <div *ngIf="!isLoading && activeTab === 'outbox'" class="p-4 md:p-8">
    <div class="max-w-6xl mx-auto">
      <div class="flex justify-between items-center mb-6">
        <h2 class="text-2xl font-bold text-gray-900">Caixa de Sa\xEDda</h2>
        <div class="flex space-x-2">
          <button 
            (click)="clearOutbox()"
            class="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg font-medium transition-colors">
            <i class="fas fa-trash mr-2"></i>
            Limpar
          </button>
        </div>
      </div>
      
      <div class="bg-white rounded-lg shadow">
        <!-- Tabs de status de email -->
        <div class="border-b border-gray-200">
          <nav class="flex space-x-8 px-6">
            <button 
              *ngFor="let status of emailStatuses"
              (click)="activeEmailStatus = status.id"
              class="py-4 px-1 border-b-2 font-medium text-sm transition-colors duration-200"
              [class.border-blue-500]="activeEmailStatus === status.id"
              [class.text-blue-600]="activeEmailStatus === status.id"
              [class.border-transparent]="activeEmailStatus !== status.id"
              [class.text-gray-500]="activeEmailStatus !== status.id">
              {{ status.name }}
              <span class="ml-2 bg-gray-200 text-gray-600 text-xs px-2 py-1 rounded-full">
                {{ status.count }}
              </span>
            </button>
          </nav>
        </div>

        <!-- Lista de emails -->
        <div class="p-6">
          <div *ngIf="getFilteredEmails().length === 0" class="text-center py-12 text-gray-500">
            <i class="fas fa-paper-plane text-6xl mb-4"></i>
            <h3 class="text-xl font-semibold mb-2">Nenhum email encontrado</h3>
            <p>Emails enviados aparecer\xE3o aqui</p>
          </div>

          <div *ngIf="getFilteredEmails().length > 0" class="space-y-4">
            <div 
              *ngFor="let email of getFilteredEmails()" 
              class="border border-gray-200 rounded-lg p-4 hover:bg-gray-50 transition-colors">
              <div class="flex items-center justify-between">
                <div class="flex-1">
                  <div class="flex items-center space-x-3">
                    <div 
                      class="w-3 h-3 rounded-full"
                      [class.bg-yellow-400]="!email.delivery || email.delivery.state === 'PENDING'"
                      [class.bg-green-400]="email.delivery?.state === 'SUCCESS'"
                      [class.bg-red-400]="email.delivery?.state === 'ERROR'">
                    </div>
                    <h4 class="font-medium text-gray-900">{{ email.subject || 'Sem assunto' }}</h4>
                    <span 
                      class="px-2 py-1 text-xs rounded-full"
                      [class.bg-yellow-100]="!email.delivery || email.delivery.state === 'PENDING'"
                      [class.text-yellow-800]="!email.delivery || email.delivery.state === 'PENDING'"
                      [class.bg-green-100]="email.delivery?.state === 'SUCCESS'"
                      [class.text-green-800]="email.delivery?.state === 'SUCCESS'"
                      [class.bg-red-100]="email.delivery?.state === 'ERROR'"
                      [class.text-red-800]="email.delivery?.state === 'ERROR'">
                      {{ getEmailStatusLabel(email) }}
                    </span>
                  </div>
                  <div class="mt-2 flex items-center space-x-4 text-sm text-gray-500">
                    <span><i class="fas fa-envelope mr-1"></i>Para: {{ email.to }}</span>
                    <span><i class="fas fa-clock mr-1"></i>{{ formatDateTime(getEmailDisplayDate(email)) }}</span>
                  </div>
                </div>
                <div class="flex items-center space-x-2">
                  <button 
                    (click)="viewEmail(email)"
                    class="text-blue-600 hover:text-blue-800">
                    <i class="fas fa-eye"></i>
                  </button>
                  <button 
                    *ngIf="email.delivery?.state === 'ERROR' || !email.delivery"
                    (click)="retryEmail(email)"
                    class="text-green-600 hover:text-green-800">
                    <i class="fas fa-redo"></i>
                  </button>
                  <button 
                    (click)="openOutboxDeleteConfirm(email, $event)"
                    class="text-red-600 hover:text-red-800">
                    <i class="fas fa-trash"></i>
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal de confirma\xE7\xE3o de exclus\xE3o da mensagem (Outbox) -->
  <div *ngIf="showOutboxDeleteConfirm" class="fixed inset-0 bg-black/50 flex items-center justify-center z-[60]" (click)="cancelOutboxDelete()">
    <div class="bg-white rounded-xl shadow-2xl w-full max-w-md p-6" (click)="$event.stopPropagation()">
      <h3 class="text-lg font-bold text-gray-900 mb-2">Excluir mensagem</h3>
      <p class="text-sm text-gray-600 mb-6">Tem certeza que deseja excluir esta mensagem da Caixa de Sa\xEDda? Esta a\xE7\xE3o n\xE3o pode ser desfeita.</p>
      <div class="flex justify-end gap-3">
        <button class="px-4 py-2 rounded-lg border border-gray-300" (click)="cancelOutboxDelete()">Cancelar</button>
        <button class="px-4 py-2 rounded-lg bg-red-600 text-white" (click)="confirmOutboxDelete()">Excluir</button>
      </div>
    </div>
  </div>

  <!-- API Tab -->
  <div *ngIf="!isLoading && activeTab === 'api'" class="p-4 md:p-8">
    <div class="max-w-4xl mx-auto">
      <div class="flex justify-between items-center mb-6">
        <h2 class="text-2xl font-bold text-gray-900">Configura\xE7\xE3o da API</h2>
        <div class="flex items-center space-x-2">
          <span class="text-sm text-gray-600">Status:</span>
          <span class="px-2 py-1 bg-green-100 text-green-800 text-xs font-medium rounded">
            <i class="fas fa-check-circle mr-1"></i>Ativa
          </span>
        </div>
      </div>
      
      <!-- Endpoint -->
      <div class="bg-white rounded-lg shadow mb-6">
        <div class="p-6 border-b border-gray-200">
          <h3 class="text-lg font-semibold text-gray-900 mb-2">
            <i class="fas fa-link mr-2 text-blue-500"></i>Endpoint para Novos Leads
          </h3>
          <p class="text-sm text-gray-600 mb-4">
            Use este endpoint para enviar novos leads diretamente para o seu kanban via API REST.
          </p>
          
          <div class="bg-gray-50 border border-gray-200 rounded-lg p-4">
            <div class="flex items-center justify-between mb-2">
              <span class="text-sm font-medium text-gray-700">URL do Endpoint:</span>
              <button 
                (click)="copyToClipboard(apiEndpoint)"
                class="text-blue-600 hover:text-blue-800 text-sm">
                <i class="fas fa-copy mr-1"></i>Copiar
              </button>
            </div>
            <code class="bg-blue-50 text-blue-800 text-sm p-2 rounded border block">
              {{ apiEndpoint }}
            </code>
          </div>
        </div>
        
        <!-- Token de Autentica\xE7\xE3o -->
        <div class="p-6 border-b border-gray-200">
          <h4 class="text-md font-semibold text-gray-900 mb-2">
            <i class="fas fa-key mr-2 text-yellow-500"></i>Token de Autentica\xE7\xE3o
          </h4>
          <p class="text-sm text-gray-600 mb-3">
            Inclua este token no header <code class="bg-gray-100 px-1 rounded">Authorization</code> de suas requisi\xE7\xF5es.
          </p>
          
          <div class="bg-gray-50 border border-gray-200 rounded-lg p-4">
            <div class="flex items-center justify-between mb-2">
              <span class="text-sm font-medium text-gray-700">Bearer Token:</span>
              <button 
                (click)="copyToClipboard(apiToken)"
                class="text-blue-600 hover:text-blue-800 text-sm">
                <i class="fas fa-copy mr-1"></i>Copiar
              </button>
            </div>
            <code class="bg-yellow-50 text-yellow-800 text-sm p-2 rounded border block font-mono">
              {{ apiToken }}
            </code>
          </div>
        </div>
        
        <!-- Exemplo de Requisi\xE7\xE3o -->
        <div class="p-6">
          <h4 class="text-md font-semibold text-gray-900 mb-2">
            <i class="fas fa-code mr-2 text-green-500"></i>Exemplo de Requisi\xE7\xE3o
          </h4>
          <p class="text-sm text-gray-600 mb-3">
            Exemplo de como enviar um novo lead via POST request:
          </p>
          
          <div class="bg-gray-900 text-gray-100 rounded-lg p-4 overflow-x-auto">
            <pre class="text-sm"><code>POST {{ apiEndpoint }}
Content-Type: application/json
Authorization: Bearer {{ apiToken }}

{{ apiExampleJson }}</code></pre>
          </div>
        </div>
      </div>
      
      <!-- Webhooks -->
      <div class="bg-white rounded-lg shadow mb-6">
        <div class="p-6 border-b border-gray-200">
          <h3 class="text-lg font-semibold text-gray-900 mb-2">
            <i class="fas fa-broadcast-tower mr-2 text-purple-500"></i>Webhooks (Em breve)
          </h3>
          <p class="text-sm text-gray-600">
            Receba notifica\xE7\xF5es quando leads mudarem de fase, forem criados ou atualizados.
          </p>
        </div>
        
        <div class="p-6">
          <div class="text-center py-8 text-gray-500">
            <i class="fas fa-construction text-4xl mb-3"></i>
            <h4 class="font-semibold mb-2">Funcionalidade em Desenvolvimento</h4>
            <p class="text-sm">Webhooks estar\xE3o dispon\xEDveis em breve para integra\xE7\xE3o avan\xE7ada.</p>
          </div>
        </div>
      </div>
      
      <!-- Documenta\xE7\xE3o -->
      <div class="bg-blue-50 border border-blue-200 rounded-lg p-6">
        <h3 class="text-lg font-semibold text-blue-900 mb-3">
          <i class="fas fa-book mr-2"></i>Documenta\xE7\xE3o da API
        </h3>
        <div class="space-y-3 text-sm text-blue-800">
          <div class="flex items-start space-x-3">
            <i class="fas fa-check-circle mt-0.5 text-blue-600"></i>
            <div>
              <strong>M\xE9todo:</strong> POST para criar novos leads
            </div>
          </div>
          <div class="flex items-start space-x-3">
            <i class="fas fa-check-circle mt-0.5 text-blue-600"></i>
            <div>
              <strong>Content-Type:</strong> application/json obrigat\xF3rio
            </div>
          </div>
          <div class="flex items-start space-x-3">
            <i class="fas fa-check-circle mt-0.5 text-blue-600"></i>
            <div>
              <strong>Autentica\xE7\xE3o:</strong> Bearer token no header Authorization
            </div>
          </div>
          <div class="flex items-start space-x-3">
            <i class="fas fa-check-circle mt-0.5 text-blue-600"></i>
            <div>
              <strong>Campos obrigat\xF3rios:</strong> companyName, contactName, contactEmail
            </div>
          </div>
          <div class="flex items-start space-x-3">
            <i class="fas fa-check-circle mt-0.5 text-blue-600"></i>
            <div>
              <strong>Resposta de sucesso:</strong> Status 201 com dados do lead criado
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Mobile board: stages list + cards feed -->
  <div *ngIf="!isLoading && activeTab === 'kanban'" class="mobile-board">
    <div class="p-4 space-y-3">
      <!-- Mobile filters -->
      <div class="relative">
        <div class="flex gap-2 overflow-x-auto pb-2">
          <div class="relative flex-1 max-w-xs">
            <input
              type="text"
              placeholder="Buscar nos cards..."
              [(ngModel)]="filterQuery"
              (input)="applyFilters()"
              class="w-full pl-8 pr-10 py-2 border border-gray-300 rounded-full text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-gray-50 focus:bg-white"
              [class.border-blue-300]="filterQuery"
              [class.bg-white]="filterQuery">
            
            <i class="fas fa-search absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 text-xs"></i>
            
            <!-- Bot\xE3o de filtros no mobile -->
            <button 
              (click)="showAdvancedFilters = !showAdvancedFilters"
              class="absolute right-2 top-1/2 transform -translate-y-1/2 p-1 rounded-full hover:bg-gray-100 transition-colors"
              [class.bg-blue-50]="hasActiveFilters() || showAdvancedFilters"
              [class.text-blue-600]="hasActiveFilters() || showAdvancedFilters"
              [class.text-gray-400]="!hasActiveFilters() && !showAdvancedFilters">
              <i class="fas fa-sliders-h text-xs"></i>
              <span *ngIf="getActiveDynamicFiltersCount() > 0 || filterOnlyMine" 
                    class="absolute -top-1 -right-1 bg-blue-500 text-white rounded-full w-3 h-3 flex items-center justify-center text-xs">
                {{ (filterOnlyMine ? 1 : 0) + getActiveDynamicFiltersCount() }}
              </span>
            </button>
            
            <button 
              *ngIf="filterQuery"
              (click)="filterQuery = ''; applyFilters()"
              class="absolute right-8 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600 p-1">
              <i class="fas fa-times text-xs"></i>
            </button>
          </div>
          
          <button *ngIf="hasActiveFilters()" 
                  (click)="clearFilters()" 
                  class="px-3 py-2 bg-red-100 text-red-700 rounded-full text-sm hover:bg-red-200 transition-colors flex items-center gap-1">
            <i class="fas fa-times"></i>
          Limpar
        </button>
      </div>
      
      <!-- Filtros Avan\xE7ados (Campos Din\xE2micos) -->
      <div *ngIf="showAdvancedFilters && availableFilterFields.length > 0" 
           class="bg-gray-50 rounded-lg p-4 space-y-3 border">
        <div class="flex items-center justify-between">
          <h4 class="text-sm font-medium text-gray-700 flex items-center gap-2">
            <i class="fas fa-filter text-purple-600"></i>
            Filtros por Campos
          </h4>
          <button (click)="showAdvancedFilters = false" 
                  class="text-gray-400 hover:text-gray-600 p-1">
            <i class="fas fa-times"></i>
          </button>
        </div>
        
        <div class="grid grid-cols-1 gap-3">
          <div *ngFor="let field of availableFilterFields" 
               class="flex items-center gap-3">
            <label class="text-sm text-gray-600 min-w-0 flex-1">
              {{ field.label }}
            </label>
            
            <!-- Campo de texto/email/tel -->
            <input *ngIf="field.type === 'text' || field.type === 'email' || field.type === 'tel'"
                   type="text"
                   [placeholder]="'Filtrar por ' + field.label.toLowerCase()"
                   [value]="getDynamicFilterValue(field.name)"
                   (input)="setDynamicFilter(field.name, $event.target.value)"
                   class="flex-1 px-2 py-1 border border-gray-300 rounded text-sm focus:ring-2 focus:ring-purple-500 focus:border-transparent">
            
            <!-- Campo de n\xFAmero -->
            <input *ngIf="field.type === 'number'"
                   type="number"
                   [placeholder]="'Filtrar por ' + field.label.toLowerCase()"
                   [value]="getDynamicFilterValue(field.name)"
                   (input)="setDynamicFilter(field.name, $event.target.value)"
                   class="flex-1 px-2 py-1 border border-gray-300 rounded text-sm focus:ring-2 focus:ring-purple-500 focus:border-transparent">
            
            <!-- Campo de data -->
            <input *ngIf="field.type === 'date'"
                   type="date"
                   [value]="getDynamicFilterValue(field.name)"
                   (change)="setDynamicFilter(field.name, $event.target.value)"
                   class="flex-1 px-2 py-1 border border-gray-300 rounded text-sm focus:ring-2 focus:ring-purple-500 focus:border-transparent">
            
            <!-- Checkbox -->
            <label *ngIf="field.type === 'checkbox'" 
                   class="flex items-center gap-2 flex-1">
              <input type="checkbox"
                     [checked]="getDynamicFilterValue(field.name)"
                     (change)="setDynamicFilter(field.name, $event.target.checked)"
                     class="rounded border-gray-300 text-purple-600 focus:ring-purple-500">
              <span class="text-sm text-gray-600">Apenas marcados</span>
            </label>
            
            <!-- Select/Radio/Temperatura (dropdown com op\xE7\xF5es) -->
            <select *ngIf="field.type === 'select' || field.type === 'radio' || field.type === 'temperatura'"
                    [value]="getDynamicFilterValue(field.name)"
                    (change)="onDynamicFilterChange(field.name, $event)"
                    class="flex-1 px-2 py-1 border border-gray-300 rounded text-sm focus:ring-2 focus:ring-purple-500 focus:border-transparent">
              <option value="">Todos</option>
              <option *ngFor="let option of getFieldOptions(field)" [value]="option">
                {{ option }}
              </option>
            </select>
            
            <!-- Bot\xE3o para remover filtro espec\xEDfico -->
            <button *ngIf="getDynamicFilterValue(field.name)"
                    (click)="removeDynamicFilter(field.name)"
                    class="p-1 text-red-400 hover:text-red-600 transition-colors">
              <i class="fas fa-times text-xs"></i>
            </button>
          </div>
        </div>
        
        <div *ngIf="getActiveDynamicFiltersCount() > 0" 
             class="text-xs text-purple-600 flex items-center gap-1 pt-2 border-t">
          <i class="fas fa-info-circle"></i>
          <span>{{ getActiveDynamicFiltersCount() }} filtro(s) ativo(s) por campos</span>
        </div>
      </div>
      
      <!-- Filter status indicator -->
      <div *ngIf="hasActiveFilters()" class="mt-2 text-xs text-blue-600 flex items-center gap-1">
        <i class="fas fa-filter"></i>
        <span>Filtros ativos</span>
        <span class="bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full">
          {{ (filterQuery ? 1 : 0) + (filterOnlyMine ? 1 : 0) + getActiveDynamicFiltersCount() }}
        </span>
      </div>

      <!-- Stages as accordion list -->
      <div class="space-y-2">
        <div *ngFor="let column of columns" class="rounded-2xl border border-gray-200 bg-white">
          <button (click)="toggleMobileColumn(column.id!)" class="w-full px-4 py-3 flex items-center justify-between">
            <div class="flex items-center gap-3">
              <span class="inline-block w-3 h-3 rounded-full" [style.background-color]="column.color || '#22c55e'"></span>
              <div class="font-semibold text-gray-800">{{ column.name }}</div>
            </div>
            <div class="flex items-center gap-2">
              <span class="text-sm text-gray-500">{{ getLeadsForColumn(column.id!).length }}</span>
              <i class="fas" [class.fa-chevron-down]="!isMobileColumnOpen(column.id!)" [class.fa-chevron-up]="isMobileColumnOpen(column.id!)"></i>
            </div>
          </button>
          <div *ngIf="isMobileColumnOpen(column.id!)" class="px-4 pb-4">
            <div class="space-y-3">
              <div *ngFor="let lead of getLeadsForColumn(column.id!)" class="bg-white rounded-xl border border-gray-100 p-4 shadow-sm">
                <div class="text-base font-bold text-gray-900 mb-1">{{ lead.fields['companyName'] || 'Sem t\xEDtulo' }}</div>
                <div class="text-[13px] text-gray-500 mb-2" *ngIf="getLeadResponsibleName(lead)">
                  {{ getLeadResponsibleName(lead) }}
                </div>
                <div class="text-sm text-gray-700" *ngIf="lead.fields?.['contactName']">
                  <span class="uppercase tracking-wide text-gray-400 text-[11px]">NOME DO CONTATO</span><br>
                  {{ lead.fields['contactName'] }}
                </div>
                <div class="mt-3 flex items-center gap-5 text-xs text-gray-500">
                  <div class="flex items-center gap-1"><i class="far fa-comment"></i> 1</div>
                  <div class="flex items-center gap-1"><i class="far fa-clock text-orange-400"></i> {{ getDaysSince(lead.createdAt) }}d</div>
                  <div class="flex items-center gap-1"><i class="fas fa-history text-blue-500"></i> {{ getDaysSince(lead.movedToCurrentColumnAt) }}d</div>
                  <div class="flex items-center gap-1" *ngIf="getLeadDueDateLabel(lead)"><i class="far fa-calendar-check text-green-500"></i> {{ getLeadDueDateLabel(lead) }}</div>
                </div>
              </div>
              <div *ngIf="getLeadsForColumn(column.id!).length === 0" class="text-center text-gray-400 text-sm py-2">Nenhum registro nesta fase</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Cards feed (pipefy-like) -->
      <div class="mt-4 space-y-3">
        <div *ngFor="let lead of leads" class="bg-white rounded-2xl border border-gray-200 p-4 shadow-sm">
          <div class="text-base font-bold text-gray-900 mb-1">{{ lead.fields['companyName'] || 'Sem t\xEDtulo' }}</div>
          <div class="text-[13px] text-gray-500 mb-2" *ngIf="getLeadResponsibleName(lead)">
            {{ getLeadResponsibleName(lead) }}
          </div>
          <div class="text-sm text-gray-700" *ngIf="lead.fields?.['contactName']">
            <span class="uppercase tracking-wide text-gray-400 text-[11px]">NOME DO CONTATO</span><br>
            {{ lead.fields['contactName'] }}
          </div>
          <div class="mt-3 flex items-center gap-5 text-xs text-gray-500">
            <div class="flex items-center gap-1"><i class="far fa-comment"></i> 1</div>
            <div class="flex items-center gap-1"><i class="far fa-clock text-orange-400"></i> {{ getDaysSince(lead.createdAt) }}d</div>
            <div class="flex items-center gap-1"><i class="fas fa-history text-blue-500"></i> {{ getDaysSince(lead.movedToCurrentColumnAt) }}d</div>
            <div class="flex items-center gap-1" *ngIf="getLeadDueDateLabel(lead)"><i class="far fa-calendar-check text-green-500"></i> {{ getLeadDueDateLabel(lead) }}</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Sticky bottom action -->
    <div class="fixed bottom-4 inset-x-4 z-40 md:hidden">
      <button (click)="showCreateLeadModal()" class="w-full h-12 bg-blue-600 hover:bg-blue-700 text-white rounded-2xl font-semibold shadow-lg flex items-center justify-center gap-2">
        <span class="inline-flex w-6 h-6 items-center justify-center bg-blue-700/60 rounded-full"><i class="fas fa-plus text-xs"></i></span>
        Novo lead
      </button>
    </div>
  </div> <!-- closes mobile-board -->
  </div>
</app-main-layout>

<!-- Modal de Lead -->
<app-lead-modal 
  [ownerId]="ownerId"
  [boardId]="boardId"
  [columns]="columns"
  (leadCreated)="onLeadCreated()"
  (leadUpdated)="onLeadUpdated()"
  (closeModal)="onLeadUpdated()">
</app-lead-modal>

<!-- Modal de Coluna -->
<app-column-modal 
  [ownerId]="ownerId"
  [boardId]="boardId"
  [columns]="columns"
  (columnCreated)="onColumnCreated()"
  (columnUpdated)="onColumnUpdated()"
  (columnDeleted)="onColumnDeleted()"
  (closeModal)="onColumnUpdated()">
</app-column-modal>

<!-- Modal de Formul\xE1rio da Fase -->
<app-phase-form-modal 
  [ownerId]="ownerId"
  [boardId]="boardId"
  (formConfigSaved)="onPhaseFormConfigSaved()"
  (closeModal)="onPhaseFormConfigSaved()">
</app-phase-form-modal>

<!-- Modal de Detalhes do Lead -->
<app-lead-detail-modal 
  [ownerId]="ownerId"
  [boardId]="boardId"
  [columns]="columns"
  [users]="users"
  (leadUpdated)="onLeadUpdated()"
  (leadDeleted)="onLeadDeleted()"
  (closeModal)="onLeadUpdated()">
</app-lead-detail-modal>

<!-- Modal de Template -->
<app-template-modal 
  [ownerId]="ownerId"
  [boardId]="boardId"
  (templateSaved)="onTemplateSaved()"
  (closeModal)="onTemplateSaved()">
</app-template-modal>

<!-- Modal de Automa\xE7\xE3o -->
<app-automation-modal
  *ngIf="showAutomationModal"
  [isVisible]="showAutomationModal"
  [automation]="selectedAutomation"
  [phases]="columns"
  [allowedTriggerTypes]="selectedPhaseIdForAutomations ? getAllowedTriggerTypesForPhase(selectedPhaseIdForAutomations) : null"
  [fixedPhaseId]="selectedPhaseIdForAutomations || null"
  [allowedTransitions]="flowConfig.allowed || {}"
  [emailTemplates]="emailTemplates"
  [users]="users"
  (closeModalEvent)="onCloseAutomationModal()"
  (saveAutomation)="onSaveAutomation($event)">
</app-automation-modal>

<!-- Modal de Hist\xF3rico de Automa\xE7\xE3o -->
<app-automation-history-modal
  [isVisible]="showHistoryModal"
  [automationId]="selectedAutomationForHistory?.id || ''"
  [automationName]="selectedAutomationForHistory?.name || ''"
  [ownerId]="ownerId"
  [boardId]="boardId"
  [leads]="leads"
  (closeModalEvent)="onCloseHistoryModal()">
</app-automation-history-modal>  `, styles: ['@charset "UTF-8";\n\n/* src/app/components/kanban/kanban.component.scss */\n.kanban-board {\n  display: flex;\n  flex-direction: row;\n  gap: 12px;\n  padding: 12px;\n  overflow-x: auto;\n  min-height: calc(100vh - 80px);\n  scroll-snap-type: x mandatory;\n  position: relative;\n  justify-content: flex-start;\n  align-items: stretch;\n}\n.mobile-board {\n  display: none;\n}\n.kanban-column {\n  flex: 0 0 340px;\n  min-width: 340px;\n  max-width: 380px;\n  background-color: #f8fafc;\n  border-radius: 12px;\n  display: flex;\n  flex-direction: column;\n  transition: opacity 0.2s ease-in-out;\n  scroll-snap-align: start;\n}\n.kanban-column-header {\n  padding: 10px 14px;\n  font-weight: 600;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  border-top-width: 4px;\n  border-top-style: solid;\n  border-top-left-radius: 12px;\n  border-top-right-radius: 12px;\n  transition: background-color 0.3s;\n}\n.kanban-cards {\n  flex-grow: 1;\n  padding: 6px 10px 8px;\n  overflow-y: auto;\n  min-height: calc(100vh - 220px);\n}\n.kanban-card {\n  background-color: white;\n  border-radius: 8px;\n  padding: 8px;\n  margin-bottom: 10px;\n  cursor: pointer;\n  box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);\n  transition: box-shadow 0.2s, transform 0.2s;\n  border-left: 5px solid transparent;\n  position: relative;\n}\n.kanban-card:hover {\n  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);\n  transform: translateY(-1px);\n}\n.card-avatar {\n  position: absolute;\n  bottom: 8px;\n  right: 8px;\n  width: 28px;\n  height: 28px;\n  background-color: #94a3b8;\n  color: white;\n  border-radius: 50%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-weight: bold;\n  font-size: 12px;\n  border: 2px solid white;\n}\n.line-clamp-2 {\n  display: -webkit-box;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n  overflow: hidden;\n}\n.flow-scroll {\n  overflow-x: auto;\n  overflow-y: hidden;\n  padding-bottom: 8px;\n  min-height: 1px;\n  border-bottom: 0;\n  -ms-overflow-style: none;\n  scrollbar-width: none;\n}\n.flow-scroll::-webkit-scrollbar {\n  height: 0px;\n  background: transparent;\n}\n.flow-row {\n  min-width: calc(100% + 2px);\n}\n.flow-scroll::-webkit-scrollbar {\n  height: 10px;\n}\n.flow-scroll::-webkit-scrollbar-track {\n  background: #e5e7eb;\n  border-radius: 8px;\n}\n.flow-scroll::-webkit-scrollbar-thumb {\n  background: #cbd5e1;\n  border-radius: 8px;\n}\n.flow-phase-card {\n  background: #ffffff;\n  border: 1px solid #e5e7eb;\n  border-top-width: 4px;\n  border-top-color: var(--phase-color, #94a3b8);\n  border-radius: 12px;\n  transition: box-shadow 0.2s ease, transform 0.1s ease;\n  box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.02);\n}\n.flow-custombar {\n  height: 8px;\n  background: #e5e7eb;\n  border-radius: 6px;\n  position: relative;\n  margin: 6px 12px 0 12px;\n  cursor: pointer;\n}\n.flow-thumb {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  background: #9ca3af;\n  border-radius: 6px;\n}\n.flow-phase-card:hover {\n  box-shadow: 0 6px 20px -10px rgba(0, 0, 0, 0.25);\n  transform: translateY(-1px);\n}\n.cdk-drag-preview {\n  box-sizing: border-box;\n  border-radius: 8px;\n  box-shadow:\n    0 5px 5px -3px rgba(0, 0, 0, 0.2),\n    0 8px 10px 1px rgba(0, 0, 0, 0.14),\n    0 3px 14px 2px rgba(0, 0, 0, 0.12);\n}\n.cdk-drag-placeholder {\n  opacity: 0;\n}\n.cdk-drag-animating {\n  transition: transform 250ms cubic-bezier(0, 0, 0.2, 1);\n}\n.cdk-drop-list-dragging .kanban-card:not(.cdk-drag-placeholder) {\n  transition: transform 250ms cubic-bezier(0, 0, 0.2, 1);\n}\n@media (max-width: 768px) {\n  .desktop-board {\n    display: none;\n  }\n  .mobile-board {\n    display: block;\n  }\n  .kanban-board {\n    gap: 8px;\n    padding: 8px;\n  }\n  .kanban-column {\n    min-width: 260px;\n    max-width: 320px;\n  }\n  .kanban-card {\n    padding: 8px;\n  }\n}\n@media (max-width: 480px) {\n  .desktop-board {\n    display: none;\n  }\n  .mobile-board {\n    display: block;\n  }\n  .kanban-board {\n    gap: 6px;\n    padding: 6px;\n  }\n  .kanban-column {\n    min-width: 240px;\n    max-width: 280px;\n  }\n  .kanban-card {\n    padding: 8px;\n  }\n}\n/*# sourceMappingURL=kanban.component.css.map */\n'] }]
  }], null, { leadModal: [{
    type: ViewChild,
    args: [LeadModalComponent]
  }], columnModal: [{
    type: ViewChild,
    args: [ColumnModalComponent]
  }], phaseFormModal: [{
    type: ViewChild,
    args: [PhaseFormModalComponent]
  }], leadDetailModal: [{
    type: ViewChild,
    args: [LeadDetailModalComponent]
  }], templateModal: [{
    type: ViewChild,
    args: [TemplateModalComponent]
  }], automationModal: [{
    type: ViewChild,
    args: [AutomationModal]
  }], flowScrollerRef: [{
    type: ViewChild,
    args: ["flowScroller"]
  }], onWindowMouseUpForCards: [{
    type: HostListener,
    args: ["window:mouseup"]
  }], onWindowTouchEndForCards: [{
    type: HostListener,
    args: ["window:touchend"]
  }], onWindowResizeFlow: [{
    type: HostListener,
    args: ["window:resize"]
  }], onWindowMouseUp: [{
    type: HostListener,
    args: ["window:mouseup", ["$event"]]
  }], onWindowTouchEnd: [{
    type: HostListener,
    args: ["window:touchend", ["$event"]]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(KanbanComponent, { className: "KanbanComponent", filePath: "src/app/components/kanban/kanban.component.ts", lineNumber: 32 });
})();
export {
  KanbanComponent
};
//# sourceMappingURL=chunk-MRU4DIBL.js.map
